# Comparing `tmp/pieces_os_client-1.2.7.tar.gz` & `tmp/pieces_os_client-2.0.0.post1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pieces_os_client-1.2.7.tar", max compression
+gzip compressed data, was "pieces_os_client-2.0.0.post1.tar", max compression
```

## Comparing `pieces_os_client-1.2.7.tar` & `pieces_os_client-2.0.0.post1.tar`

### file list

```diff
@@ -1,482 +1,504 @@
--rw-r--r--   0        0        0     1067 2024-02-12 09:13:15.697562 pieces_os_client-1.2.7/LICENSE
--rw-r--r--   0        0        0      742 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/pyproject.toml
--rw-r--r--   0        0        0    36044 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/__init__.py
--rw-r--r--   0        0        0     3913 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/__init__.py
--rw-r--r--   0        0        0    22626 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/activities_api.py
--rw-r--r--   0        0        0    23362 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/activity_api.py
--rw-r--r--   0        0        0    13418 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/allocation_api.py
--rw-r--r--   0        0        0    39480 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/allocations_api.py
--rw-r--r--   0        0        0     7888 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/analyses_api.py
--rw-r--r--   0        0        0    29535 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/anchor_api.py
--rw-r--r--   0        0        0    23119 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/anchor_point_api.py
--rw-r--r--   0        0        0    21662 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/anchor_points_api.py
--rw-r--r--   0        0        0    28357 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/anchors_api.py
--rw-r--r--   0        0        0    20841 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/annotation_api.py
--rw-r--r--   0        0        0    20359 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/annotations_api.py
--rw-r--r--   0        0        0     7294 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/application_api.py
--rw-r--r--   0        0        0    65770 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/applications_api.py
--rw-r--r--   0        0        0    94655 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/asset_api.py
--rw-r--r--   0        0        0   109587 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/assets_api.py
--rw-r--r--   0        0        0    40792 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/auth0_api.py
--rw-r--r--   0        0        0    12751 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/backup_api.py
--rw-r--r--   0        0        0     8673 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/classification_api.py
--rw-r--r--   0        0        0     6719 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/code_analyses_api.py
--rw-r--r--   0        0        0    44176 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/connector_api.py
--rw-r--r--   0        0        0   100737 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/conversation_api.py
--rw-r--r--   0        0        0    36417 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/conversation_message_api.py
--rw-r--r--   0        0        0    21585 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/conversation_messages_api.py
--rw-r--r--   0        0        0    39850 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/conversations_api.py
--rw-r--r--   0        0        0    13025 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/database_api.py
--rw-r--r--   0        0        0    35278 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/discovery_api.py
--rw-r--r--   0        0        0    13873 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/distribution_api.py
--rw-r--r--   0        0        0    19687 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/distributions_api.py
--rw-r--r--   0        0        0    22555 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/external_provider_api.py
--rw-r--r--   0        0        0    37992 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/format_api.py
--rw-r--r--   0        0        0    14897 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/formats_api.py
--rw-r--r--   0        0        0     9396 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/github_api.py
--rw-r--r--   0        0        0    20187 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/hint_api.py
--rw-r--r--   0        0        0    18825 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/hints_api.py
--rw-r--r--   0        0        0     7858 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/image_analyses_api.py
--rw-r--r--   0        0        0    19639 2024-02-12 09:13:15.725562 pieces_os_client-1.2.7/src/pieces_os_client/api/linkify_api.py
--rw-r--r--   0        0        0     8072 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/mac_os_api.py
--rw-r--r--   0        0        0     9184 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/machine_learning_api.py
--rw-r--r--   0        0        0    12369 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/metrics_api.py
--rw-r--r--   0        0        0    44203 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/model_api.py
--rw-r--r--   0        0        0    32108 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/models_api.py
--rw-r--r--   0        0        0     7116 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/notifications_api.py
--rw-r--r--   0        0        0     7826 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/ocr_analyses_api.py
--rw-r--r--   0        0        0     8167 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/open_ai_api.py
--rw-r--r--   0        0        0    43119 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/os_api.py
--rw-r--r--   0        0        0    22359 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/person_api.py
--rw-r--r--   0        0        0    28144 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/persons_api.py
--rw-r--r--   0        0        0     7121 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/piece_api.py
--rw-r--r--   0        0        0    32943 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/pkce_api.py
--rw-r--r--   0        0        0    46837 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/qgpt_api.py
--rw-r--r--   0        0        0     7466 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/relationship_api.py
--rw-r--r--   0        0        0     6685 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/relationships_api.py
--rw-r--r--   0        0        0    23226 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/search_api.py
--rw-r--r--   0        0        0    20438 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/sensitive_api.py
--rw-r--r--   0        0        0    19365 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/sensitives_api.py
--rw-r--r--   0        0        0    22356 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/share_api.py
--rw-r--r--   0        0        0    28383 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/shares_api.py
--rw-r--r--   0        0        0    47652 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/tag_api.py
--rw-r--r--   0        0        0    27335 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/tags_api.py
--rw-r--r--   0        0        0     7682 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/ultra_suite_api.py
--rw-r--r--   0        0        0    42861 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/user_api.py
--rw-r--r--   0        0        0    25356 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/users_api.py
--rw-r--r--   0        0        0    62004 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/website_api.py
--rw-r--r--   0        0        0    27857 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/websites_api.py
--rw-r--r--   0        0        0    12117 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api/well_known_api.py
--rw-r--r--   0        0        0    30327 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api_client.py
--rw-r--r--   0        0        0      852 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/api_response.py
--rw-r--r--   0        0        0    16484 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/configuration.py
--rw-r--r--   0        0        0     5423 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/exceptions.py
--rw-r--r--   0        0        0    34989 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/__init__.py
--rw-r--r--   0        0        0      736 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/access_enum.py
--rw-r--r--   0        0        0     3230 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/accessor.py
--rw-r--r--   0        0        0     2794 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/accessors.py
--rw-r--r--   0        0        0     2836 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/activities.py
--rw-r--r--   0        0        0     6656 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/activity.py
--rw-r--r--   0        0        0     3026 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/aesthetics.py
--rw-r--r--   0        0        0     4385 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/allocation_cloud.py
--rw-r--r--   0        0        0     2497 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/allocation_cloud_status.py
--rw-r--r--   0        0        0     2704 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/allocation_cloud_url.py
--rw-r--r--   0        0        0     3498 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/allocation_cloud_urls.py
--rw-r--r--   0        0        0      936 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/allocation_status_enum.py
--rw-r--r--   0        0        0     2839 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/allocations.py
--rw-r--r--   0        0        0     2786 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/analyses.py
--rw-r--r--   0        0        0     3470 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/analysis.py
--rw-r--r--   0        0        0     3642 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/analytics_tracked_adoption_event_identifier_description_pairs.py
--rw-r--r--   0        0        0     5801 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/anchor.py
--rw-r--r--   0        0        0     4558 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/anchor_point.py
--rw-r--r--   0        0        0     3424 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/anchor_points.py
--rw-r--r--   0        0        0      851 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/anchor_type_enum.py
--rw-r--r--   0        0        0     3358 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/anchors.py
--rw-r--r--   0        0        0     7510 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/annotation.py
--rw-r--r--   0        0        0     1081 2024-02-12 09:13:15.729562 pieces_os_client-1.2.7/src/pieces_os_client/models/annotation_type_enum.py
--rw-r--r--   0        0        0     3409 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/annotations.py
--rw-r--r--   0        0        0     4132 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/application.py
--rw-r--r--   0        0        0     1854 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/application_name_enum.py
--rw-r--r--   0        0        0     2862 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/applications.py
--rw-r--r--   0        0        0    10768 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/asset.py
--rw-r--r--   0        0        0     5178 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/asset_filter.py
--rw-r--r--   0        0        0     3133 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/asset_filter_phrase.py
--rw-r--r--   0        0        0     2539 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/asset_filter_phrase_options.py
--rw-r--r--   0        0        0     3283 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/asset_filter_timestamp.py
--rw-r--r--   0        0        0     3117 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/asset_filters.py
--rw-r--r--   0        0        0     2953 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/asset_reclassification.py
--rw-r--r--   0        0        0     2815 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/asset_search_space.py
--rw-r--r--   0        0        0     3452 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/assets.py
--rw-r--r--   0        0        0     3512 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/assets_search_with_filters_input.py
--rw-r--r--   0        0        0     2807 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/assets_search_with_filters_output.py
--rw-r--r--   0        0        0     4441 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/auth0.py
--rw-r--r--   0        0        0     3343 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_identity.py
--rw-r--r--   0        0        0     2722 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_open_ai_user_metadata.py
--rw-r--r--   0        0        0     2260 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_redirects.py
--rw-r--r--   0        0        0     5257 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_user.py
--rw-r--r--   0        0        0     2119 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_user_allocation_metadata.py
--rw-r--r--   0        0        0     3954 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_user_metadata.py
--rw-r--r--   0        0        0     3064 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/available_formats.py
--rw-r--r--   0        0        0     2571 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/byte_descriptor.py
--rw-r--r--   0        0        0      863 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/capabilities_enum.py
--rw-r--r--   0        0        0     3667 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/challenged_pkce.py
--rw-r--r--   0        0        0     2489 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/checked_os_update.py
--rw-r--r--   0        0        0     3067 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/classification.py
--rw-r--r--   0        0        0     1012 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/classification_generic_enum.py
--rw-r--r--   0        0        0      961 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/classification_rendering_enum.py
--rw-r--r--   0        0        0    13762 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/classification_specific_enum.py
--rw-r--r--   0        0        0     2835 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/code_analyses.py
--rw-r--r--   0        0        0     3990 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/code_analysis.py
--rw-r--r--   0        0        0     3724 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/context.py
--rw-r--r--   0        0        0     7938 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/conversation.py
--rw-r--r--   0        0        0     2951 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_grounding.py
--rw-r--r--   0        0        0     6128 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_message.py
--rw-r--r--   0        0        0      932 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_message_sentiment_enum.py
--rw-r--r--   0        0        0     3534 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_messages.py
--rw-r--r--   0        0        0     2924 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_summarize_input.py
--rw-r--r--   0        0        0     3350 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_summarize_output.py
--rw-r--r--   0        0        0      797 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_type_enum.py
--rw-r--r--   0        0        0     3444 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/conversations.py
--rw-r--r--   0        0        0     2978 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/conversations_create_from_asset_output.py
--rw-r--r--   0        0        0     2853 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/created_external_provider_api_key.py
--rw-r--r--   0        0        0     2871 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/deleted_external_provider_api_key.py
--rw-r--r--   0        0        0     4042 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_asset.py
--rw-r--r--   0        0        0     3412 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_assets.py
--rw-r--r--   0        0        0     3087 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_html_webpage.py
--rw-r--r--   0        0        0     3177 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_html_webpages.py
--rw-r--r--   0        0        0     2666 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_related_tag.py
--rw-r--r--   0        0        0     3057 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_related_tags.py
--rw-r--r--   0        0        0     2919 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_sensitive.py
--rw-r--r--   0        0        0     3038 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_sensitives.py
--rw-r--r--   0        0        0     4743 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/distribution.py
--rw-r--r--   0        0        0     2886 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/distributions.py
--rw-r--r--   0        0        0     2280 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/edges.py
--rw-r--r--   0        0        0     2412 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/embedded_model_schema.py
--rw-r--r--   0        0        0      930 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/embedded_model_schema_semantic_version_enum.py
--rw-r--r--   0        0        0     3399 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/embedding.py
--rw-r--r--   0        0        0     2340 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/embeddings.py
--rw-r--r--   0        0        0     2575 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/existent_metadata.py
--rw-r--r--   0        0        0     3335 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/existing_metadata.py
--rw-r--r--   0        0        0     2881 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/exported_asset.py
--rw-r--r--   0        0        0     6093 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/exported_database.py
--rw-r--r--   0        0        0     2598 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/exported_database_format.py
--rw-r--r--   0        0        0     2964 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/exported_database_formats.py
--rw-r--r--   0        0        0     1614 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/external_ml_provider_enum.py
--rw-r--r--   0        0        0     4975 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/external_provider.py
--rw-r--r--   0        0        0     6145 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/external_provider_profile_data.py
--rw-r--r--   0        0        0     1186 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/external_provider_type_enum.py
--rw-r--r--   0        0        0     2891 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/external_providers.py
--rw-r--r--   0        0        0     1093 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/externally_sourced_enum.py
--rw-r--r--   0        0        0     3143 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/file_format.py
--rw-r--r--   0        0        0     2768 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/file_metadata.py
--rw-r--r--   0        0        0     2522 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/file_picker_input.py
--rw-r--r--   0        0        0      785 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/filter_operation_type_enum.py
--rw-r--r--   0        0        0     3021 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_activities.py
--rw-r--r--   0        0        0     6227 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_activity.py
--rw-r--r--   0        0        0     3435 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_analysis.py
--rw-r--r--   0        0        0     6354 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_anchor.py
--rw-r--r--   0        0        0     4946 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_anchor_point.py
--rw-r--r--   0        0        0     3692 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_anchor_points.py
--rw-r--r--   0        0        0     3601 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_anchors.py
--rw-r--r--   0        0        0     7809 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_annotation.py
--rw-r--r--   0        0        0     3757 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_annotations.py
--rw-r--r--   0        0        0    12163 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_asset.py
--rw-r--r--   0        0        0     3946 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_assets.py
--rw-r--r--   0        0        0     8672 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_conversation.py
--rw-r--r--   0        0        0     6557 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_conversation_message.py
--rw-r--r--   0        0        0     3856 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_conversation_messages.py
--rw-r--r--   0        0        0     3732 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_conversations.py
--rw-r--r--   0        0        0     4440 2024-02-12 09:13:15.733562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_distribution.py
--rw-r--r--   0        0        0     2955 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_distributions.py
--rw-r--r--   0        0        0     9326 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_format.py
--rw-r--r--   0        0        0     3230 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_formats.py
--rw-r--r--   0        0        0     5476 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_hint.py
--rw-r--r--   0        0        0     3610 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_hints.py
--rw-r--r--   0        0        0     3049 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_image_analysis.py
--rw-r--r--   0        0        0     3773 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_ocr_analysis.py
--rw-r--r--   0        0        0     8836 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_person.py
--rw-r--r--   0        0        0     3711 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_persons.py
--rw-r--r--   0        0        0     2649 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_preview.py
--rw-r--r--   0        0        0     6155 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_sensitive.py
--rw-r--r--   0        0        0     3494 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_sensitives.py
--rw-r--r--   0        0        0     5788 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_share.py
--rw-r--r--   0        0        0     3406 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_shares.py
--rw-r--r--   0        0        0     6347 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_tag.py
--rw-r--r--   0        0        0     3657 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_tags.py
--rw-r--r--   0        0        0     3014 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_user_profile.py
--rw-r--r--   0        0        0     6536 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_website.py
--rw-r--r--   0        0        0     3680 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_websites.py
--rw-r--r--   0        0        0     2334 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/font.py
--rw-r--r--   0        0        0     8669 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/format.py
--rw-r--r--   0        0        0     2995 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/format_metric.py
--rw-r--r--   0        0        0     2974 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/format_reclassification.py
--rw-r--r--   0        0        0     2854 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/formats.py
--rw-r--r--   0        0        0     2851 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/formats_metrics.py
--rw-r--r--   0        0        0     3634 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/fragment_format.py
--rw-r--r--   0        0        0     2508 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/fragment_metadata.py
--rw-r--r--   0        0        0     2708 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/git_hub_distribution.py
--rw-r--r--   0        0        0     4630 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/git_hub_gist_distribution.py
--rw-r--r--   0        0        0     3084 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_image_descriptive_statistics.py
--rw-r--r--   0        0        0     2817 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_image_processing.py
--rw-r--r--   0        0        0     2871 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_image_statistics.py
--rw-r--r--   0        0        0     3688 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_machine_learning_processing_event.py
--rw-r--r--   0        0        0     3502 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_ocr_descriptive_statistics.py
--rw-r--r--   0        0        0     2106 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_ocr_descriptive_statistics_confidence.py
--rw-r--r--   0        0        0     2793 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_ocr_processing.py
--rw-r--r--   0        0        0     2847 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_ocr_statistics.py
--rw-r--r--   0        0        0     2417 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_svg_statistics.py
--rw-r--r--   0        0        0     2571 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/grouped_timestamp.py
--rw-r--r--   0        0        0     2659 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/health.py
--rw-r--r--   0        0        0     5022 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/hint.py
--rw-r--r--   0        0        0      810 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/hint_type_enum.py
--rw-r--r--   0        0        0     3334 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/hints.py
--rw-r--r--   0        0        0     2847 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/image_analyses.py
--rw-r--r--   0        0        0     3084 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/image_analysis.py
--rw-r--r--   0        0        0     3077 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/interacted_asset.py
--rw-r--r--   0        0        0     2850 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/interacted_asset_interactions.py
--rw-r--r--   0        0        0     2966 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/interacted_assets.py
--rw-r--r--   0        0        0     4241 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/linkify.py
--rw-r--r--   0        0        0     3590 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/linkify_multiple.py
--rw-r--r--   0        0        0     2775 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/mailgun_distribution.py
--rw-r--r--   0        0        0     2603 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/mailgun_metadata.py
--rw-r--r--   0        0        0     1286 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/mechanism_enum.py
--rw-r--r--   0        0        0     6998 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/model.py
--rw-r--r--   0        0        0     2374 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/model_delete_cache_input.py
--rw-r--r--   0        0        0     2765 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/model_delete_cache_output.py
--rw-r--r--   0        0        0     3233 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/model_download_progress.py
--rw-r--r--   0        0        0      972 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/model_download_progress_status_enum.py
--rw-r--r--   0        0        0     3277 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/model_foundation_enum.py
--rw-r--r--   0        0        0     3387 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/model_max_tokens.py
--rw-r--r--   0        0        0      829 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/model_type_enum.py
--rw-r--r--   0        0        0     1741 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/model_usage_enum.py
--rw-r--r--   0        0        0     2806 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/models.py
--rw-r--r--   0        0        0     2843 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/node.py
--rw-r--r--   0        0        0      844 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/node_type_enum.py
--rw-r--r--   0        0        0     2658 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/notification.py
--rw-r--r--   0        0        0     3345 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/o_auth_account.py
--rw-r--r--   0        0        0     2604 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/o_auth_group.py
--rw-r--r--   0        0        0     3218 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/o_auth_token.py
--rw-r--r--   0        0        0     2823 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/ocr_analyses.py
--rw-r--r--   0        0        0     3642 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/ocr_analysis.py
--rw-r--r--   0        0        0     2468 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/open_ai_models_list_input.py
--rw-r--r--   0        0        0     2767 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/open_ai_models_list_output.py
--rw-r--r--   0        0        0     2445 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/ordered_metrics.py
--rw-r--r--   0        0        0     2529 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/os_health.py
--rw-r--r--   0        0        0     8327 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/person.py
--rw-r--r--   0        0        0     3104 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/person_access.py
--rw-r--r--   0        0        0      935 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/person_access_scoped_enum.py
--rw-r--r--   0        0        0     3791 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/person_basic_type.py
--rw-r--r--   0        0        0     3808 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/person_model.py
--rw-r--r--   0        0        0     3329 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/person_type.py
--rw-r--r--   0        0        0     3441 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/persons.py
--rw-r--r--   0        0        0     4583 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/pkce.py
--rw-r--r--   0        0        0      924 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/platform_enum.py
--rw-r--r--   0        0        0     3051 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/precreated_external_provider_api_key.py
--rw-r--r--   0        0        0     2827 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/predeleted_external_provider_api_key.py
--rw-r--r--   0        0        0     3101 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/preupdated_external_provider_api_key.py
--rw-r--r--   0        0        0     3179 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/preview.py
--rw-r--r--   0        0        0      957 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/privacy_enum.py
--rw-r--r--   0        0        0     2782 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/pseudo_assets.py
--rw-r--r--   0        0        0     2637 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_agent_related_routes.py
--rw-r--r--   0        0        0     2930 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_agent_routes.py
--rw-r--r--   0        0        0     2916 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_conversation.py
--rw-r--r--   0        0        0     3091 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_conversation_message.py
--rw-r--r--   0        0        0      882 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_conversation_message_role_enum.py
--rw-r--r--   0        0        0     3305 2024-02-12 09:13:15.737562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_hints_input.py
--rw-r--r--   0        0        0     3504 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_persons_related_input.py
--rw-r--r--   0        0        0     3203 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_persons_related_output.py
--rw-r--r--   0        0        0     2701 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_question_answer.py
--rw-r--r--   0        0        0     2951 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_question_answers.py
--rw-r--r--   0        0        0     3791 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_question_input.py
--rw-r--r--   0        0        0     2900 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_question_output.py
--rw-r--r--   0        0        0     5574 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_relevance_input.py
--rw-r--r--   0        0        0     2870 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_relevance_input_options.py
--rw-r--r--   0        0        0     3607 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_relevance_output.py
--rw-r--r--   0        0        0     3274 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_reprompt_input.py
--rw-r--r--   0        0        0     2393 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_reprompt_output.py
--rw-r--r--   0        0        0      959 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_stream_enum.py
--rw-r--r--   0        0        0     3652 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_stream_input.py
--rw-r--r--   0        0        0     4751 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_stream_output.py
--rw-r--r--   0        0        0     3616 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/reaction.py
--rw-r--r--   0        0        0     2933 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/recipients.py
--rw-r--r--   0        0        0     2883 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_activity.py
--rw-r--r--   0        0        0     2922 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_anchor.py
--rw-r--r--   0        0        0     2923 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_anchor_point.py
--rw-r--r--   0        0        0     2974 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_annotation.py
--rw-r--r--   0        0        0     2999 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_asset.py
--rw-r--r--   0        0        0     2980 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_conversation.py
--rw-r--r--   0        0        0     3119 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_conversation_message.py
--rw-r--r--   0        0        0     2852 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_distribution.py
--rw-r--r--   0        0        0     3049 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_format.py
--rw-r--r--   0        0        0     2896 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_hint.py
--rw-r--r--   0        0        0     2700 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_model.py
--rw-r--r--   0        0        0     2893 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_person.py
--rw-r--r--   0        0        0     3056 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_sensitive.py
--rw-r--r--   0        0        0     2914 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_share.py
--rw-r--r--   0        0        0     2854 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_tag.py
--rw-r--r--   0        0        0     2874 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_user.py
--rw-r--r--   0        0        0     2870 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_website.py
--rw-r--r--   0        0        0     4485 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/relationship.py
--rw-r--r--   0        0        0     2376 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/relationships.py
--rw-r--r--   0        0        0     3551 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/relevant_qgpt_seed.py
--rw-r--r--   0        0        0     2926 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/relevant_qgpt_seeds.py
--rw-r--r--   0        0        0     2657 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/resulted_pkce.py
--rw-r--r--   0        0        0     2840 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/returned_user_profile.py
--rw-r--r--   0        0        0     2446 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/reuse_reaction.py
--rw-r--r--   0        0        0     3327 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/reuse_suggestion.py
--rw-r--r--   0        0        0     3149 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/revoked_pkce.py
--rw-r--r--   0        0        0      792 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/role.py
--rw-r--r--   0        0        0     2812 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/save_suggestion.py
--rw-r--r--   0        0        0     3148 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/score.py
--rw-r--r--   0        0        0     3374 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/searched_asset.py
--rw-r--r--   0        0        0     3310 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/searched_assets.py
--rw-r--r--   0        0        0      931 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/searched_match_enum.py
--rw-r--r--   0        0        0     2982 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seed.py
--rw-r--r--   0        0        0     3013 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_accessor.py
--rw-r--r--   0        0        0     4715 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_activity.py
--rw-r--r--   0        0        0     3752 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_anchor.py
--rw-r--r--   0        0        0     2955 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_anchor_point.py
--rw-r--r--   0        0        0     3954 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_annotation.py
--rw-r--r--   0        0        0     5296 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset.py
--rw-r--r--   0        0        0     2966 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_enrichment.py
--rw-r--r--   0        0        0     6957 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_metadata.py
--rw-r--r--   0        0        0     3956 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_sensitive.py
--rw-r--r--   0        0        0     2921 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_tag.py
--rw-r--r--   0        0        0     2402 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_tags.py
--rw-r--r--   0        0        0     2800 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_website.py
--rw-r--r--   0        0        0     3271 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_assets_recommendation.py
--rw-r--r--   0        0        0     3117 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_classification.py
--rw-r--r--   0        0        0     3247 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_connector_asset.py
--rw-r--r--   0        0        0     2870 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_connector_connection.py
--rw-r--r--   0        0        0     2828 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_connector_creation.py
--rw-r--r--   0        0        0     7381 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_connector_tracking.py
--rw-r--r--   0        0        0     6515 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_conversation.py
--rw-r--r--   0        0        0     4662 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_conversation_message.py
--rw-r--r--   0        0        0     3766 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_asset.py
--rw-r--r--   0        0        0     3772 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_assets.py
--rw-r--r--   0        0        0     2628 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_html_webpage.py
--rw-r--r--   0        0        0     3238 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_html_webpages.py
--rw-r--r--   0        0        0     3226 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_related_tag.py
--rw-r--r--   0        0        0     3228 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_related_tags.py
--rw-r--r--   0        0        0     3968 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_sensitive.py
--rw-r--r--   0        0        0     3141 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_sensitives.py
--rw-r--r--   0        0        0     3289 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_distribution.py
--rw-r--r--   0        0        0     2993 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_distributions.py
--rw-r--r--   0        0        0     2096 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_external_provider.py
--rw-r--r--   0        0        0     3835 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_file.py
--rw-r--r--   0        0        0     3996 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_format.py
--rw-r--r--   0        0        0     3634 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_fragment.py
--rw-r--r--   0        0        0     2781 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_git_hub_distribution.py
--rw-r--r--   0        0        0     3325 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_git_hub_gist_distribution.py
--rw-r--r--   0        0        0     3142 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_github_gists_import.py
--rw-r--r--   0        0        0     3029 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_hint.py
--rw-r--r--   0        0        0     2944 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_mac_os_asset.py
--rw-r--r--   0        0        0     6632 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_model.py
--rw-r--r--   0        0        0     2892 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_models.py
--rw-r--r--   0        0        0     4608 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_person.py
--rw-r--r--   0        0        0     8008 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_pkce.py
--rw-r--r--   0        0        0     2919 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_pkceadditionalparameters.py
--rw-r--r--   0        0        0     2827 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_score.py
--rw-r--r--   0        0        0    10938 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_score_increment.py
--rw-r--r--   0        0        0     3931 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_sensitive.py
--rw-r--r--   0        0        0     3950 2024-02-12 09:13:15.741562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_share.py
--rw-r--r--   0        0        0     3324 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tag.py
--rw-r--r--   0        0        0     3114 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_adoption_event.py
--rw-r--r--   0        0        0     3597 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_application.py
--rw-r--r--   0        0        0     4327 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_asset_event.py
--rw-r--r--   0        0        0     3844 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_assets_event.py
--rw-r--r--   0        0        0     2506 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_assets_event_metadata.py
--rw-r--r--   0        0        0     4444 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_conversation_event.py
--rw-r--r--   0        0        0     4251 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_format_event.py
--rw-r--r--   0        0        0     3601 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_interaction_event.py
--rw-r--r--   0        0        0     3162 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_interaction_event_identifier_description_pairs.py
--rw-r--r--   0        0        0     3526 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_keyboard_event.py
--rw-r--r--   0        0        0     3156 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_keyboard_event_identifier_description_pairs.py
--rw-r--r--   0        0        0     3386 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_machine_learning_event.py
--rw-r--r--   0        0        0     3126 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_session_event.py
--rw-r--r--   0        0        0     3397 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_ultra_suite_asset.py
--rw-r--r--   0        0        0     2361 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_user.py
--rw-r--r--   0        0        0     3529 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_website.py
--rw-r--r--   0        0        0     2796 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/seeds.py
--rw-r--r--   0        0        0     3192 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/segmented_technical_language.py
--rw-r--r--   0        0        0     3454 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/segmented_technical_language_fragment.py
--rw-r--r--   0        0        0     5663 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/sensitive.py
--rw-r--r--   0        0        0     1167 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/sensitive_category_enum.py
--rw-r--r--   0        0        0     2909 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/sensitive_metadata.py
--rw-r--r--   0        0        0      877 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/sensitive_severity_enum.py
--rw-r--r--   0        0        0     3229 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/sensitives.py
--rw-r--r--   0        0        0     2712 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/session.py
--rw-r--r--   0        0        0     5766 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/share.py
--rw-r--r--   0        0        0     3240 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/shares.py
--rw-r--r--   0        0        0     2144 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/space.py
--rw-r--r--   0        0        0     3085 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/streamed_identifier.py
--rw-r--r--   0        0        0     3115 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/streamed_identifiers.py
--rw-r--r--   0        0        0     4445 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/suggestion.py
--rw-r--r--   0        0        0     3106 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/suggestion_target.py
--rw-r--r--   0        0        0     2271 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/system_execution_cpu_information.py
--rw-r--r--   0        0        0     2687 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/system_execution_information.py
--rw-r--r--   0        0        0     6075 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tag.py
--rw-r--r--   0        0        0      841 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tag_category_enum.py
--rw-r--r--   0        0        0     3344 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tags.py
--rw-r--r--   0        0        0     2746 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/text_location.py
--rw-r--r--   0        0        0     3129 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/text_match.py
--rw-r--r--   0        0        0     2348 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/theme.py
--rw-r--r--   0        0        0     2441 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_directory_analytics.py
--rw-r--r--   0        0        0     2401 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_file_analytics.py
--rw-r--r--   0        0        0     4399 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_classification.py
--rw-r--r--   0        0        0     3168 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_classification_metadata.py
--rw-r--r--   0        0        0     3190 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_description.py
--rw-r--r--   0        0        0     3404 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_descriptive_statistics.py
--rw-r--r--   0        0        0     3472 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_reclassification.py
--rw-r--r--   0        0        0     3195 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_reclassification_updates.py
--rw-r--r--   0        0        0     2884 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_statistics.py
--rw-r--r--   0        0        0     2473 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_suggested_reuse.py
--rw-r--r--   0        0        0     3330 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_suggested_save.py
--rw-r--r--   0        0        0     2741 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_tagify.py
--rw-r--r--   0        0        0     4083 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_processing.py
--rw-r--r--   0        0        0     2449 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_repository_analytics.py
--rw-r--r--   0        0        0     5307 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_snippet_analytics.py
--rw-r--r--   0        0        0     3315 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_snippet_suggested_interactions.py
--rw-r--r--   0        0        0     4174 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_snippet_tagify_code.py
--rw-r--r--   0        0        0     2116 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_directed_discovery_filter.py
--rw-r--r--   0        0        0     1022 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_directed_discovery_filter_enum.py
--rw-r--r--   0        0        0     2646 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_directed_discovery_filters.py
--rw-r--r--   0        0        0     2807 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_machine_learning_processing_event.py
--rw-r--r--   0        0        0     3828 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tokenized_pkce.py
--rw-r--r--   0        0        0     3292 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_application.py
--rw-r--r--   0        0        0     3269 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_application_install.py
--rw-r--r--   0        0        0     3553 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_application_update.py
--rw-r--r--   0        0        0     3455 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_creation_metadata.py
--rw-r--r--   0        0        0     2887 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_creation_metadata_clipboard.py
--rw-r--r--   0        0        0     2561 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_creation_metadata_file.py
--rw-r--r--   0        0        0     3285 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_format_reclassification_metadata.py
--rw-r--r--   0        0        0    22869 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_identifier_description_pairs.py
--rw-r--r--   0        0        0     7805 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_metadata.py
--rw-r--r--   0        0        0     2661 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_rename_metadata.py
--rw-r--r--   0        0        0     3093 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_assets_event_identifier_description_pairs.py
--rw-r--r--   0        0        0     3221 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_assets_event_search_metadata.py
--rw-r--r--   0        0        0     3233 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_assets_event_search_metadata_results.py
--rw-r--r--   0        0        0     7444 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_conversation_event_identifier_description_pairs.py
--rw-r--r--   0        0        0     2935 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_conversation_event_metadata.py
--rw-r--r--   0        0        0     2710 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_conversation_event_rename_metadata.py
--rw-r--r--   0        0        0     3310 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_format.py
--rw-r--r--   0        0        0     4129 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_format_event.py
--rw-r--r--   0        0        0     8270 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_format_event_identifier_description_pairs.py
--rw-r--r--   0        0        0     2519 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_format_event_metadata.py
--rw-r--r--   0        0        0     2995 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_interaction_event.py
--rw-r--r--   0        0        0     2833 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_keyboard_event.py
--rw-r--r--   0        0        0    10678 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_session_event_identifier_description_pairs.py
--rw-r--r--   0        0        0     3395 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_user_profile.py
--rw-r--r--   0        0        0     3295 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/transferable_bytes.py
--rw-r--r--   0        0        0     2972 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/transferable_string.py
--rw-r--r--   0        0        0     2361 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/unchecked_os_update.py
--rw-r--r--   0        0        0     2593 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/unsegmented_technical_language.py
--rw-r--r--   0        0        0     2915 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/updated_external_provider_api_key.py
--rw-r--r--   0        0        0     1302 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/updating_status_enum.py
--rw-r--r--   0        0        0     5603 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/user_profile.py
--rw-r--r--   0        0        0     2863 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/users.py
--rw-r--r--   0        0        0     5892 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/website.py
--rw-r--r--   0        0        0     3399 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/models/websites.py
--rw-r--r--   0        0        0        0 2024-02-12 09:13:15.745562 pieces_os_client-1.2.7/src/pieces_os_client/py.typed
--rw-r--r--   0        0        0    12923 2024-02-12 09:13:15.749562 pieces_os_client-1.2.7/src/pieces_os_client/rest.py
--rw-r--r--   0        0        0     1010 1970-01-01 00:00:00.000000 pieces_os_client-1.2.7/PKG-INFO
+-rw-r--r--   0        0        0     1067 2024-02-16 16:06:29.988772 pieces_os_client-2.0.0.post1/LICENSE
+-rw-r--r--   0        0        0    12041 2024-02-16 16:06:29.988772 pieces_os_client-2.0.0.post1/README.md
+-rw-r--r--   0        0        0      776 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/pyproject.toml
+-rw-r--r--   0        0        0    38257 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/__init__.py
+-rw-r--r--   0        0        0     3913 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/__init__.py
+-rw-r--r--   0        0        0    36007 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/activities_api.py
+-rw-r--r--   0        0        0    36993 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/activity_api.py
+-rw-r--r--   0        0        0    21456 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/allocation_api.py
+-rw-r--r--   0        0        0    63976 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/allocations_api.py
+-rw-r--r--   0        0        0    12199 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/analyses_api.py
+-rw-r--r--   0        0        0    47342 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/anchor_api.py
+-rw-r--r--   0        0        0    36735 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/anchor_point_api.py
+-rw-r--r--   0        0        0    34506 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/anchor_points_api.py
+-rw-r--r--   0        0        0    45684 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/anchors_api.py
+-rw-r--r--   0        0        0    33427 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/annotation_api.py
+-rw-r--r--   0        0        0    32649 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/annotations_api.py
+-rw-r--r--   0        0        0    11338 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/application_api.py
+-rw-r--r--   0        0        0   126317 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/applications_api.py
+-rw-r--r--   0        0        0   152850 2024-02-16 16:06:30.008772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/asset_api.py
+-rw-r--r--   0        0        0   175852 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/assets_api.py
+-rw-r--r--   0        0        0    63374 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/auth0_api.py
+-rw-r--r--   0        0        0    21058 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/backup_api.py
+-rw-r--r--   0        0        0    13396 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/classification_api.py
+-rw-r--r--   0        0        0    10502 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/code_analyses_api.py
+-rw-r--r--   0        0        0    71381 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/connector_api.py
+-rw-r--r--   0        0        0   162857 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/conversation_api.py
+-rw-r--r--   0        0        0    58602 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/conversation_message_api.py
+-rw-r--r--   0        0        0    34429 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/conversation_messages_api.py
+-rw-r--r--   0        0        0    64190 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/conversations_api.py
+-rw-r--r--   0        0        0    21126 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/database_api.py
+-rw-r--r--   0        0        0    55339 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/discovery_api.py
+-rw-r--r--   0        0        0    22010 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/distribution_api.py
+-rw-r--r--   0        0        0    31608 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/distributions_api.py
+-rw-r--r--   0        0        0    35690 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/external_provider_api.py
+-rw-r--r--   0        0        0    60605 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/format_api.py
+-rw-r--r--   0        0        0    23408 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/formats_api.py
+-rw-r--r--   0        0        0    14504 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/github_api.py
+-rw-r--r--   0        0        0    32572 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/hint_api.py
+-rw-r--r--   0        0        0    30519 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/hints_api.py
+-rw-r--r--   0        0        0    12117 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/image_analyses_api.py
+-rw-r--r--   0        0        0    31988 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/linkify_api.py
+-rw-r--r--   0        0        0    12392 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/mac_os_api.py
+-rw-r--r--   0        0        0    25675 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/machine_learning_api.py
+-rw-r--r--   0        0        0    19741 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/metrics_api.py
+-rw-r--r--   0        0        0    71669 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/model_api.py
+-rw-r--r--   0        0        0    52226 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/models_api.py
+-rw-r--r--   0        0        0    11235 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/notifications_api.py
+-rw-r--r--   0        0        0    12082 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/ocr_analyses_api.py
+-rw-r--r--   0        0        0    12658 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/open_ai_api.py
+-rw-r--r--   0        0        0    80066 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/os_api.py
+-rw-r--r--   0        0        0    35735 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/person_api.py
+-rw-r--r--   0        0        0    45396 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/persons_api.py
+-rw-r--r--   0        0        0    11082 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/piece_api.py
+-rw-r--r--   0        0        0    53387 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/pkce_api.py
+-rw-r--r--   0        0        0    75135 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/qgpt_api.py
+-rw-r--r--   0        0        0    11438 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/relationship_api.py
+-rw-r--r--   0        0        0    10449 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/relationships_api.py
+-rw-r--r--   0        0        0    36842 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/search_api.py
+-rw-r--r--   0        0        0    32925 2024-02-16 16:06:30.012772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/sensitive_api.py
+-rw-r--r--   0        0        0    31233 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/sensitives_api.py
+-rw-r--r--   0        0        0    35709 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/share_api.py
+-rw-r--r--   0        0        0    45282 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/shares_api.py
+-rw-r--r--   0        0        0    77727 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/tag_api.py
+-rw-r--r--   0        0        0    44097 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/tags_api.py
+-rw-r--r--   0        0        0    11842 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/ultra_suite_api.py
+-rw-r--r--   0        0        0    70312 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/user_api.py
+-rw-r--r--   0        0        0    40843 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/users_api.py
+-rw-r--r--   0        0        0   100991 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/website_api.py
+-rw-r--r--   0        0        0    44762 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/websites_api.py
+-rw-r--r--   0        0        0    19448 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api/well_known_api.py
+-rw-r--r--   0        0        0    25801 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api_client.py
+-rw-r--r--   0        0        0      652 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/api_response.py
+-rw-r--r--   0        0        0    16582 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/configuration.py
+-rw-r--r--   0        0        0     5970 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/exceptions.py
+-rw-r--r--   0        0        0    33830 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/__init__.py
+-rw-r--r--   0        0        0      743 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/access_enum.py
+-rw-r--r--   0        0        0     3786 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/accessor.py
+-rw-r--r--   0        0        0     3365 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/accessors.py
+-rw-r--r--   0        0        0     3389 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/activities.py
+-rw-r--r--   0        0        0     7150 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/activity.py
+-rw-r--r--   0        0        0     3580 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/aesthetics.py
+-rw-r--r--   0        0        0     4916 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocation_cloud.py
+-rw-r--r--   0        0        0     3042 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocation_cloud_status.py
+-rw-r--r--   0        0        0     3242 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocation_cloud_url.py
+-rw-r--r--   0        0        0     4012 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocation_cloud_urls.py
+-rw-r--r--   0        0        0      923 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocation_status_enum.py
+-rw-r--r--   0        0        0     3402 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocations.py
+-rw-r--r--   0        0        0     3361 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/analyses.py
+-rw-r--r--   0        0        0     4008 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/analysis.py
+-rw-r--r--   0        0        0     4092 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/analytics_tracked_adoption_event_identifier_description_pairs.py
+-rw-r--r--   0        0        0     6322 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/anchor.py
+-rw-r--r--   0        0        0     5079 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/anchor_point.py
+-rw-r--r--   0        0        0     3967 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/anchor_points.py
+-rw-r--r--   0        0        0      850 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/anchor_type_enum.py
+-rw-r--r--   0        0        0     3921 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/anchors.py
+-rw-r--r--   0        0        0     8001 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/annotation.py
+-rw-r--r--   0        0        0     1072 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/annotation_type_enum.py
+-rw-r--r--   0        0        0     3956 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/annotations.py
+-rw-r--r--   0        0        0     4661 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/application.py
+-rw-r--r--   0        0        0     2143 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/application_name_enum.py
+-rw-r--r--   0        0        0     3407 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/applications.py
+-rw-r--r--   0        0        0    11403 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset.py
+-rw-r--r--   0        0        0     5536 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_filter.py
+-rw-r--r--   0        0        0     3703 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_filter_phrase.py
+-rw-r--r--   0        0        0     3085 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_filter_phrase_options.py
+-rw-r--r--   0        0        0     3827 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_filter_timestamp.py
+-rw-r--r--   0        0        0     3660 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_filters.py
+-rw-r--r--   0        0        0     3467 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_reclassification.py
+-rw-r--r--   0        0        0     3362 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_search_space.py
+-rw-r--r--   0        0        0     4019 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/assets.py
+-rw-r--r--   0        0        0     4042 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/assets_search_with_filters_input.py
+-rw-r--r--   0        0        0     3302 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/assets_search_with_filters_output.py
+-rw-r--r--   0        0        0     5003 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0.py
+-rw-r--r--   0        0        0     3950 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_identity.py
+-rw-r--r--   0        0        0     3258 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_open_ai_user_metadata.py
+-rw-r--r--   0        0        0     2848 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_redirects.py
+-rw-r--r--   0        0        0     5882 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_user.py
+-rw-r--r--   0        0        0     2623 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_user_allocation_metadata.py
+-rw-r--r--   0        0        0     4517 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_user_metadata.py
+-rw-r--r--   0        0        0     3593 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/available_formats.py
+-rw-r--r--   0        0        0     3117 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/byte_descriptor.py
+-rw-r--r--   0        0        0      858 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/capabilities_enum.py
+-rw-r--r--   0        0        0     4231 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/challenged_pkce.py
+-rw-r--r--   0        0        0     3044 2024-02-16 16:06:30.016772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/checked_os_update.py
+-rw-r--r--   0        0        0     3613 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/classification.py
+-rw-r--r--   0        0        0      989 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/classification_generic_enum.py
+-rw-r--r--   0        0        0      934 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/classification_rendering_enum.py
+-rw-r--r--   0        0        0    13767 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/classification_specific_enum.py
+-rw-r--r--   0        0        0     3394 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/code_analyses.py
+-rw-r--r--   0        0        0     4506 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/code_analysis.py
+-rw-r--r--   0        0        0     4281 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/context.py
+-rw-r--r--   0        0        0     9031 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation.py
+-rw-r--r--   0        0        0     3508 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_grounding.py
+-rw-r--r--   0        0        0     6583 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_message.py
+-rw-r--r--   0        0        0      895 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_message_sentiment_enum.py
+-rw-r--r--   0        0        0     4045 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_messages.py
+-rw-r--r--   0        0        0     3444 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_summarize_input.py
+-rw-r--r--   0        0        0     3836 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_summarize_output.py
+-rw-r--r--   0        0        0      784 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_type_enum.py
+-rw-r--r--   0        0        0     3983 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversations.py
+-rw-r--r--   0        0        0     3453 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversations_create_from_asset_output.py
+-rw-r--r--   0        0        0     3348 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/created_external_provider_api_key.py
+-rw-r--r--   0        0        0     3366 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/deleted_external_provider_api_key.py
+-rw-r--r--   0        0        0     3248 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/detected_external_application.py
+-rw-r--r--   0        0        0     3974 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/detected_external_applications.py
+-rw-r--r--   0        0        0     4594 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_asset.py
+-rw-r--r--   0        0        0     3944 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_assets.py
+-rw-r--r--   0        0        0     3601 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_html_webpage.py
+-rw-r--r--   0        0        0     3669 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_html_webpages.py
+-rw-r--r--   0        0        0     3211 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_related_tag.py
+-rw-r--r--   0        0        0     3567 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_related_tags.py
+-rw-r--r--   0        0        0     3441 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_sensitive.py
+-rw-r--r--   0        0        0     3538 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_sensitives.py
+-rw-r--r--   0        0        0     5247 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/distribution.py
+-rw-r--r--   0        0        0     3427 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/distributions.py
+-rw-r--r--   0        0        0     2860 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/edges.py
+-rw-r--r--   0        0        0     2963 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/embedded_model_schema.py
+-rw-r--r--   0        0        0      881 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/embedded_model_schema_semantic_version_enum.py
+-rw-r--r--   0        0        0     3913 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/embedding.py
+-rw-r--r--   0        0        0     2900 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/embeddings.py
+-rw-r--r--   0        0        0     3126 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/existent_metadata.py
+-rw-r--r--   0        0        0     3891 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/existing_metadata.py
+-rw-r--r--   0        0        0     3430 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/exported_asset.py
+-rw-r--r--   0        0        0     6415 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/exported_database.py
+-rw-r--r--   0        0        0     3124 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/exported_database_format.py
+-rw-r--r--   0        0        0     3479 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/exported_database_formats.py
+-rw-r--r--   0        0        0     1597 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/external_ml_provider_enum.py
+-rw-r--r--   0        0        0     5521 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/external_provider.py
+-rw-r--r--   0        0        0     6665 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/external_provider_profile_data.py
+-rw-r--r--   0        0        0     1165 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/external_provider_type_enum.py
+-rw-r--r--   0        0        0     3430 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/external_providers.py
+-rw-r--r--   0        0        0     1078 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/externally_sourced_enum.py
+-rw-r--r--   0        0        0     3723 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/file_format.py
+-rw-r--r--   0        0        0     3364 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/file_metadata.py
+-rw-r--r--   0        0        0     3079 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/file_picker_input.py
+-rw-r--r--   0        0        0      766 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/filter_operation_type_enum.py
+-rw-r--r--   0        0        0     3540 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_activities.py
+-rw-r--r--   0        0        0     6336 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_activity.py
+-rw-r--r--   0        0        0     3951 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_analysis.py
+-rw-r--r--   0        0        0     6448 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_anchor.py
+-rw-r--r--   0        0        0     5210 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_anchor_point.py
+-rw-r--r--   0        0        0     4118 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_anchor_points.py
+-rw-r--r--   0        0        0     4067 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_anchors.py
+-rw-r--r--   0        0        0     7752 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_annotation.py
+-rw-r--r--   0        0        0     4173 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_annotations.py
+-rw-r--r--   0        0        0    11806 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_asset.py
+-rw-r--r--   0        0        0     4424 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_assets.py
+-rw-r--r--   0        0        0     9177 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_conversation.py
+-rw-r--r--   0        0        0     6579 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_conversation_message.py
+-rw-r--r--   0        0        0     4227 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_conversation_messages.py
+-rw-r--r--   0        0        0     4140 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_conversations.py
+-rw-r--r--   0        0        0     4934 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_distribution.py
+-rw-r--r--   0        0        0     3474 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_distributions.py
+-rw-r--r--   0        0        0     9149 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_format.py
+-rw-r--r--   0        0        0     3747 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_formats.py
+-rw-r--r--   0        0        0     5706 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_hint.py
+-rw-r--r--   0        0        0     4079 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_hints.py
+-rw-r--r--   0        0        0     3585 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_image_analysis.py
+-rw-r--r--   0        0        0     4184 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_ocr_analysis.py
+-rw-r--r--   0        0        0     8755 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_person.py
+-rw-r--r--   0        0        0     4163 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_persons.py
+-rw-r--r--   0        0        0     3216 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_preview.py
+-rw-r--r--   0        0        0     6229 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_sensitive.py
+-rw-r--r--   0        0        0     3939 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_sensitives.py
+-rw-r--r--   0        0        0     5965 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_share.py
+-rw-r--r--   0        0        0     3887 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_shares.py
+-rw-r--r--   0        0        0     6439 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_tag.py
+-rw-r--r--   0        0        0     4130 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_tags.py
+-rw-r--r--   0        0        0     3557 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_user_profile.py
+-rw-r--r--   0        0        0     6598 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_website.py
+-rw-r--r--   0        0        0     4128 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_websites.py
+-rw-r--r--   0        0        0     2933 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/font.py
+-rw-r--r--   0        0        0     8504 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/format.py
+-rw-r--r--   0        0        0     3526 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/format_metric.py
+-rw-r--r--   0        0        0     3484 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/format_reclassification.py
+-rw-r--r--   0        0        0     3419 2024-02-16 16:06:30.020772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/formats.py
+-rw-r--r--   0        0        0     3388 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/formats_metrics.py
+-rw-r--r--   0        0        0     4194 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/fragment_format.py
+-rw-r--r--   0        0        0     3072 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/fragment_metadata.py
+-rw-r--r--   0        0        0     3274 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/git_hub_distribution.py
+-rw-r--r--   0        0        0     5103 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/git_hub_gist_distribution.py
+-rw-r--r--   0        0        0     3494 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_image_descriptive_statistics.py
+-rw-r--r--   0        0        0     3359 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_image_processing.py
+-rw-r--r--   0        0        0     3413 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_image_statistics.py
+-rw-r--r--   0        0        0     4162 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_machine_learning_processing_event.py
+-rw-r--r--   0        0        0     3903 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_ocr_descriptive_statistics.py
+-rw-r--r--   0        0        0     2573 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_ocr_descriptive_statistics_confidence.py
+-rw-r--r--   0        0        0     3343 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_ocr_processing.py
+-rw-r--r--   0        0        0     3397 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_ocr_statistics.py
+-rw-r--r--   0        0        0     2971 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_svg_statistics.py
+-rw-r--r--   0        0        0     3123 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/grouped_timestamp.py
+-rw-r--r--   0        0        0     3246 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/health.py
+-rw-r--r--   0        0        0     5553 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/hint.py
+-rw-r--r--   0        0        0      813 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/hint_type_enum.py
+-rw-r--r--   0        0        0     3905 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/hints.py
+-rw-r--r--   0        0        0     3402 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/image_analyses.py
+-rw-r--r--   0        0        0     3650 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/image_analysis.py
+-rw-r--r--   0        0        0     3708 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/interacted_asset.py
+-rw-r--r--   0        0        0     3454 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/interacted_asset_interactions.py
+-rw-r--r--   0        0        0     3495 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/interacted_assets.py
+-rw-r--r--   0        0        0     4802 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/linkify.py
+-rw-r--r--   0        0        0     4131 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/linkify_multiple.py
+-rw-r--r--   0        0        0     3310 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/mailgun_distribution.py
+-rw-r--r--   0        0        0     3165 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/mailgun_metadata.py
+-rw-r--r--   0        0        0     1287 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/mechanism_enum.py
+-rw-r--r--   0        0        0     7606 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model.py
+-rw-r--r--   0        0        0     2918 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_delete_cache_input.py
+-rw-r--r--   0        0        0     3288 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_delete_cache_output.py
+-rw-r--r--   0        0        0     3789 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_download_progress.py
+-rw-r--r--   0        0        0      937 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_download_progress_status_enum.py
+-rw-r--r--   0        0        0     3353 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_foundation_enum.py
+-rw-r--r--   0        0        0     3958 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_max_tokens.py
+-rw-r--r--   0        0        0      830 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_type_enum.py
+-rw-r--r--   0        0        0     1740 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_usage_enum.py
+-rw-r--r--   0        0        0     3375 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/models.py
+-rw-r--r--   0        0        0     3424 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/node.py
+-rw-r--r--   0        0        0      847 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/node_type_enum.py
+-rw-r--r--   0        0        0     3225 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/notification.py
+-rw-r--r--   0        0        0     4064 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/o_auth_account.py
+-rw-r--r--   0        0        0     3184 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/o_auth_group.py
+-rw-r--r--   0        0        0     3779 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/o_auth_token.py
+-rw-r--r--   0        0        0     3386 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/ocr_analyses.py
+-rw-r--r--   0        0        0     4089 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/ocr_analysis.py
+-rw-r--r--   0        0        0     3481 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/onboarded_persona_details.py
+-rw-r--r--   0        0        0     2999 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/open_ai_models_list_input.py
+-rw-r--r--   0        0        0     3290 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/open_ai_models_list_output.py
+-rw-r--r--   0        0        0     2986 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/ordered_metrics.py
+-rw-r--r--   0        0        0     3193 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_cpu_hardware_information.py
+-rw-r--r--   0        0        0     3195 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_dependencies_information.py
+-rw-r--r--   0        0        0     3214 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_gpu_hardware_capabilities_information.py
+-rw-r--r--   0        0        0     3751 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_gpu_hardware_information.py
+-rw-r--r--   0        0        0     3786 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_hardware_information.py
+-rw-r--r--   0        0        0     4229 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_information_returnable.py
+-rw-r--r--   0        0        0     3115 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_health.py
+-rw-r--r--   0        0        0     8861 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/person.py
+-rw-r--r--   0        0        0     3680 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/person_access.py
+-rw-r--r--   0        0        0      918 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/person_access_scoped_enum.py
+-rw-r--r--   0        0        0     4395 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/person_basic_type.py
+-rw-r--r--   0        0        0     4330 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/person_model.py
+-rw-r--r--   0        0        0     3909 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/person_type.py
+-rw-r--r--   0        0        0     4004 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/persons.py
+-rw-r--r--   0        0        0     5171 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/pkce.py
+-rw-r--r--   0        0        0      927 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/platform_enum.py
+-rw-r--r--   0        0        0     3550 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/precreated_external_provider_api_key.py
+-rw-r--r--   0        0        0     3322 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/predeleted_external_provider_api_key.py
+-rw-r--r--   0        0        0     3327 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/preonboarded_persona_details.py
+-rw-r--r--   0        0        0     3592 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/preupdated_external_provider_api_key.py
+-rw-r--r--   0        0        0     3758 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/preview.py
+-rw-r--r--   0        0        0      962 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/privacy_enum.py
+-rw-r--r--   0        0        0     3358 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/pseudo_assets.py
+-rw-r--r--   0        0        0     3185 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_agent_related_routes.py
+-rw-r--r--   0        0        0     3494 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_agent_routes.py
+-rw-r--r--   0        0        0     3472 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation.py
+-rw-r--r--   0        0        0     3584 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_message.py
+-rw-r--r--   0        0        0      847 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_message_role_enum.py
+-rw-r--r--   0        0        0     5573 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_pipeline.py
+-rw-r--r--   0        0        0     3154 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_pipeline_for_contextualized_code_dialog.py
+-rw-r--r--   0        0        0     3141 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_pipeline_for_contextualized_code_generation.py
+-rw-r--r--   0        0        0     3105 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_pipeline_for_generalized_code_dialog.py
+-rw-r--r--   0        0        0     3872 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_hints_input.py
+-rw-r--r--   0        0        0     4048 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_persons_related_input.py
+-rw-r--r--   0        0        0     3720 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_persons_related_output.py
+-rw-r--r--   0        0        0     4192 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_prompt_pipeline.py
+-rw-r--r--   0        0        0     3239 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_question_answer.py
+-rw-r--r--   0        0        0     3468 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_question_answers.py
+-rw-r--r--   0        0        0     4764 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_question_input.py
+-rw-r--r--   0        0        0     3439 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_question_output.py
+-rw-r--r--   0        0        0     6115 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_relevance_input.py
+-rw-r--r--   0        0        0     3851 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_relevance_input_options.py
+-rw-r--r--   0        0        0     4138 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_relevance_output.py
+-rw-r--r--   0        0        0     4243 2024-02-16 16:06:30.024772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_reprompt_input.py
+-rw-r--r--   0        0        0     2950 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_reprompt_output.py
+-rw-r--r--   0        0        0      958 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_stream_enum.py
+-rw-r--r--   0        0        0     4236 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_stream_input.py
+-rw-r--r--   0        0        0     5331 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_stream_output.py
+-rw-r--r--   0        0        0     5754 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline.py
+-rw-r--r--   0        0        0     3122 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline_for_code_commentation.py
+-rw-r--r--   0        0        0     3513 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline_for_code_completion.py
+-rw-r--r--   0        0        0     3118 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline_for_code_explanation.py
+-rw-r--r--   0        0        0     3305 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline_for_code_fix.py
+-rw-r--r--   0        0        0     3367 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline_for_code_modification.py
+-rw-r--r--   0        0        0     4186 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/reaction.py
+-rw-r--r--   0        0        0     3486 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/recipients.py
+-rw-r--r--   0        0        0     3458 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_activity.py
+-rw-r--r--   0        0        0     3491 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_anchor.py
+-rw-r--r--   0        0        0     3486 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_anchor_point.py
+-rw-r--r--   0        0        0     3527 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_annotation.py
+-rw-r--r--   0        0        0     3572 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_asset.py
+-rw-r--r--   0        0        0     3525 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_conversation.py
+-rw-r--r--   0        0        0     3589 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_conversation_message.py
+-rw-r--r--   0        0        0     3375 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_distribution.py
+-rw-r--r--   0        0        0     3626 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_format.py
+-rw-r--r--   0        0        0     3473 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_hint.py
+-rw-r--r--   0        0        0     3255 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_model.py
+-rw-r--r--   0        0        0     3462 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_person.py
+-rw-r--r--   0        0        0     3613 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_sensitive.py
+-rw-r--r--   0        0        0     3487 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_share.py
+-rw-r--r--   0        0        0     3435 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_tag.py
+-rw-r--r--   0        0        0     3429 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_user.py
+-rw-r--r--   0        0        0     3449 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_website.py
+-rw-r--r--   0        0        0     4980 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/relationship.py
+-rw-r--r--   0        0        0     2924 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/relationships.py
+-rw-r--r--   0        0        0     4115 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/relevant_qgpt_seed.py
+-rw-r--r--   0        0        0     3451 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/relevant_qgpt_seeds.py
+-rw-r--r--   0        0        0     3227 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/resulted_pkce.py
+-rw-r--r--   0        0        0     3388 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/returned_user_profile.py
+-rw-r--r--   0        0        0     3009 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/reuse_reaction.py
+-rw-r--r--   0        0        0     3873 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/reuse_suggestion.py
+-rw-r--r--   0        0        0     3723 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/revoked_pkce.py
+-rw-r--r--   0        0        0      811 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/role.py
+-rw-r--r--   0        0        0     3379 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/save_suggestion.py
+-rw-r--r--   0        0        0     3746 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/score.py
+-rw-r--r--   0        0        0     3910 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/searched_asset.py
+-rw-r--r--   0        0        0     3837 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/searched_assets.py
+-rw-r--r--   0        0        0      924 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/searched_match_enum.py
+-rw-r--r--   0        0        0     3594 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seed.py
+-rw-r--r--   0        0        0     3571 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_accessor.py
+-rw-r--r--   0        0        0     5230 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_activity.py
+-rw-r--r--   0        0        0     4306 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_anchor.py
+-rw-r--r--   0        0        0     3498 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_anchor_point.py
+-rw-r--r--   0        0        0     4496 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_annotation.py
+-rw-r--r--   0        0        0     6017 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset.py
+-rw-r--r--   0        0        0     3510 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_enrichment.py
+-rw-r--r--   0        0        0     7461 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_metadata.py
+-rw-r--r--   0        0        0     4443 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_sensitive.py
+-rw-r--r--   0        0        0     3488 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_tag.py
+-rw-r--r--   0        0        0     2942 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_tags.py
+-rw-r--r--   0        0        0     3330 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_website.py
+-rw-r--r--   0        0        0     3761 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_assets_recommendation.py
+-rw-r--r--   0        0        0     3665 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_classification.py
+-rw-r--r--   0        0        0     3774 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_connector_asset.py
+-rw-r--r--   0        0        0     3381 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_connector_connection.py
+-rw-r--r--   0        0        0     3360 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_connector_creation.py
+-rw-r--r--   0        0        0     7402 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_connector_tracking.py
+-rw-r--r--   0        0        0     7632 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_conversation.py
+-rw-r--r--   0        0        0     5148 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_conversation_message.py
+-rw-r--r--   0        0        0     4290 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_asset.py
+-rw-r--r--   0        0        0     4268 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_assets.py
+-rw-r--r--   0        0        0     3144 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_html_webpage.py
+-rw-r--r--   0        0        0     3720 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_html_webpages.py
+-rw-r--r--   0        0        0     3740 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_related_tag.py
+-rw-r--r--   0        0        0     3714 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_related_tags.py
+-rw-r--r--   0        0        0     4466 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_sensitive.py
+-rw-r--r--   0        0        0     3623 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_sensitives.py
+-rw-r--r--   0        0        0     3837 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_distribution.py
+-rw-r--r--   0        0        0     3510 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_distributions.py
+-rw-r--r--   0        0        0     2633 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_external_provider.py
+-rw-r--r--   0        0        0     4411 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_file.py
+-rw-r--r--   0        0        0     4564 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_format.py
+-rw-r--r--   0        0        0     4194 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_fragment.py
+-rw-r--r--   0        0        0     3323 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_git_hub_distribution.py
+-rw-r--r--   0        0        0     3848 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_git_hub_gist_distribution.py
+-rw-r--r--   0        0        0     3681 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_github_gists_import.py
+-rw-r--r--   0        0        0     3629 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_hint.py
+-rw-r--r--   0        0        0     3499 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_mac_os_asset.py
+-rw-r--r--   0        0        0     7213 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_model.py
+-rw-r--r--   0        0        0     3437 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_models.py
+-rw-r--r--   0        0        0     5141 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_person.py
+-rw-r--r--   0        0        0     8659 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_pkce.py
+-rw-r--r--   0        0        0     3455 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_pkceadditionalparameters.py
+-rw-r--r--   0        0        0     3411 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_score.py
+-rw-r--r--   0        0        0    11418 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_score_increment.py
+-rw-r--r--   0        0        0     4425 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_sensitive.py
+-rw-r--r--   0        0        0     4507 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_share.py
+-rw-r--r--   0        0        0     3927 2024-02-16 16:06:30.028772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tag.py
+-rw-r--r--   0        0        0     3648 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_adoption_event.py
+-rw-r--r--   0        0        0     4105 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_application.py
+-rw-r--r--   0        0        0     4679 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_asset_event.py
+-rw-r--r--   0        0        0     4220 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_assets_event.py
+-rw-r--r--   0        0        0     3056 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_assets_event_metadata.py
+-rw-r--r--   0        0        0     4690 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_conversation_event.py
+-rw-r--r--   0        0        0     4599 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_format_event.py
+-rw-r--r--   0        0        0     4104 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_interaction_event.py
+-rw-r--r--   0        0        0     3601 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_interaction_event_identifier_description_pairs.py
+-rw-r--r--   0        0        0     4010 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_keyboard_event.py
+-rw-r--r--   0        0        0     3607 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_keyboard_event_identifier_description_pairs.py
+-rw-r--r--   0        0        0     3888 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_machine_learning_event.py
+-rw-r--r--   0        0        0     3637 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_session_event.py
+-rw-r--r--   0        0        0     3932 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_ultra_suite_asset.py
+-rw-r--r--   0        0        0     2918 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_user.py
+-rw-r--r--   0        0        0     4119 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_website.py
+-rw-r--r--   0        0        0     3369 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeds.py
+-rw-r--r--   0        0        0     3681 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/segmented_technical_language.py
+-rw-r--r--   0        0        0     3916 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/segmented_technical_language_fragment.py
+-rw-r--r--   0        0        0     6109 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/sensitive.py
+-rw-r--r--   0        0        0     1152 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/sensitive_category_enum.py
+-rw-r--r--   0        0        0     3473 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/sensitive_metadata.py
+-rw-r--r--   0        0        0      862 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/sensitive_severity_enum.py
+-rw-r--r--   0        0        0     3778 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/sensitives.py
+-rw-r--r--   0        0        0     3286 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/session.py
+-rw-r--r--   0        0        0     6312 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/share.py
+-rw-r--r--   0        0        0     3813 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/shares.py
+-rw-r--r--   0        0        0     2768 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/space.py
+-rw-r--r--   0        0        0     3641 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/streamed_identifier.py
+-rw-r--r--   0        0        0     3632 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/streamed_identifiers.py
+-rw-r--r--   0        0        0     4959 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/suggestion.py
+-rw-r--r--   0        0        0     3648 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/suggestion_target.py
+-rw-r--r--   0        0        0     2791 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/system_execution_cpu_information.py
+-rw-r--r--   0        0        0     3165 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/system_execution_information.py
+-rw-r--r--   0        0        0     6624 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tag.py
+-rw-r--r--   0        0        0      838 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tag_category_enum.py
+-rw-r--r--   0        0        0     3919 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tags.py
+-rw-r--r--   0        0        0     3311 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/text_location.py
+-rw-r--r--   0        0        0     3700 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/text_match.py
+-rw-r--r--   0        0        0     2943 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/theme.py
+-rw-r--r--   0        0        0     2983 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_directory_analytics.py
+-rw-r--r--   0        0        0     2963 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_file_analytics.py
+-rw-r--r--   0        0        0     4828 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_classification.py
+-rw-r--r--   0        0        0     3654 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_classification_metadata.py
+-rw-r--r--   0        0        0     3726 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_description.py
+-rw-r--r--   0        0        0     3787 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_descriptive_statistics.py
+-rw-r--r--   0        0        0     3910 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_reclassification.py
+-rw-r--r--   0        0        0     3651 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_reclassification_updates.py
+-rw-r--r--   0        0        0     3422 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_statistics.py
+-rw-r--r--   0        0        0     2999 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_suggested_reuse.py
+-rw-r--r--   0        0        0     3805 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_suggested_save.py
+-rw-r--r--   0        0        0     3295 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_tagify.py
+-rw-r--r--   0        0        0     4641 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_processing.py
+-rw-r--r--   0        0        0     2987 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_repository_analytics.py
+-rw-r--r--   0        0        0     5833 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_snippet_analytics.py
+-rw-r--r--   0        0        0     3809 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_snippet_suggested_interactions.py
+-rw-r--r--   0        0        0     4656 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_snippet_tagify_code.py
+-rw-r--r--   0        0        0     2637 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_directed_discovery_filter.py
+-rw-r--r--   0        0        0      989 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_directed_discovery_filter_enum.py
+-rw-r--r--   0        0        0     3139 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_directed_discovery_filters.py
+-rw-r--r--   0        0        0     3313 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_machine_learning_processing_event.py
+-rw-r--r--   0        0        0     4404 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tokenized_pkce.py
+-rw-r--r--   0        0        0     3819 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_application.py
+-rw-r--r--   0        0        0     3776 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_application_install.py
+-rw-r--r--   0        0        0     4060 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_application_update.py
+-rw-r--r--   0        0        0     3943 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_creation_metadata.py
+-rw-r--r--   0        0        0     3363 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_creation_metadata_clipboard.py
+-rw-r--r--   0        0        0     3065 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_creation_metadata_file.py
+-rw-r--r--   0        0        0     3717 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_format_reclassification_metadata.py
+-rw-r--r--   0        0        0    23903 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_identifier_description_pairs.py
+-rw-r--r--   0        0        0     7750 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_metadata.py
+-rw-r--r--   0        0        0     3139 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_rename_metadata.py
+-rw-r--r--   0        0        0     3570 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_assets_event_identifier_description_pairs.py
+-rw-r--r--   0        0        0     3700 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_assets_event_search_metadata.py
+-rw-r--r--   0        0        0     3703 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_assets_event_search_metadata_results.py
+-rw-r--r--   0        0        0     8011 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_conversation_event_identifier_description_pairs.py
+-rw-r--r--   0        0        0     3431 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_conversation_event_metadata.py
+-rw-r--r--   0        0        0     3160 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_conversation_event_rename_metadata.py
+-rw-r--r--   0        0        0     3820 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_format.py
+-rw-r--r--   0        0        0     4656 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_format_event.py
+-rw-r--r--   0        0        0     8918 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_format_event_identifier_description_pairs.py
+-rw-r--r--   0        0        0     3053 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_format_event_metadata.py
+-rw-r--r--   0        0        0     3534 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_interaction_event.py
+-rw-r--r--   0        0        0     3353 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_keyboard_event.py
+-rw-r--r--   0        0        0    11360 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_session_event_identifier_description_pairs.py
+-rw-r--r--   0        0        0     3961 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_user_profile.py
+-rw-r--r--   0        0        0     3856 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/transferable_bytes.py
+-rw-r--r--   0        0        0     3556 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/transferable_string.py
+-rw-r--r--   0        0        0     2921 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/unchecked_os_update.py
+-rw-r--r--   0        0        0     3096 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/unsegmented_technical_language.py
+-rw-r--r--   0        0        0     3410 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/updated_external_provider_api_key.py
+-rw-r--r--   0        0        0     1293 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/updating_status_enum.py
+-rw-r--r--   0        0        0     6161 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/user_profile.py
+-rw-r--r--   0        0        0     3449 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/users.py
+-rw-r--r--   0        0        0     6425 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/website.py
+-rw-r--r--   0        0        0     3958 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/models/websites.py
+-rw-r--r--   0        0        0        0 2024-02-16 16:06:30.032772 pieces_os_client-2.0.0.post1/src/pieces_os_client/py.typed
+-rw-r--r--   0        0        0     9232 2024-02-16 16:06:30.036772 pieces_os_client-2.0.0.post1/src/pieces_os_client/rest.py
+-rw-r--r--   0        0        0    13099 1970-01-01 00:00:00.000000 pieces_os_client-2.0.0.post1/PKG-INFO
```

### Comparing `pieces_os_client-1.2.7/LICENSE` & `pieces_os_client-2.0.0.post1/LICENSE`

 * *Files identical despite different names*

### Comparing `pieces_os_client-1.2.7/pyproject.toml` & `pieces_os_client-2.0.0.post1/pyproject.toml`

 * *Files 15% similar despite different names*

```diff
@@ -1,47 +1,49 @@
 00000000: 5b74 6f6f 6c2e 706f 6574 7279 5d0d 0a20  [tool.poetry].. 
 00000010: 206e 616d 6520 3d20 2270 6965 6365 735f   name = "pieces_
 00000020: 6f73 5f63 6c69 656e 7422 0d0a 2020 7665  os_client"..  ve
-00000030: 7273 696f 6e20 3d20 2231 2e32 2e37 220d  rsion = "1.2.7".
-00000040: 0a20 2064 6573 6372 6970 7469 6f6e 203d  .  description =
-00000050: 2022 4120 706f 7765 7266 756c 2063 6f64   "A powerful cod
-00000060: 6520 656e 6769 6e65 2070 6163 6b61 6765  e engine package
-00000070: 2066 6f72 2077 7269 7469 6e67 2061 7070   for writing app
-00000080: 6c69 6361 7469 6f6e 7320 6f6e 2074 6f70  lications on top
-00000090: 206f 6620 5069 6563 6573 204f 5322 0d0a   of Pieces OS"..
-000000a0: 2020 6175 7468 6f72 7320 3d20 5b0d 0a20    authors = [.. 
-000000b0: 2020 2022 5069 6563 6573 203c 6465 7665     "Pieces <deve
-000000c0: 6c6f 706d 656e 7440 7069 6563 6573 2e61  lopment@pieces.a
-000000d0: 7070 3e22 0d0a 2020 5d0d 0a20 206c 6963  pp>"..  ]..  lic
-000000e0: 656e 7365 203d 2022 4d49 5422 0d0a 0d0a  ense = "MIT"....
-000000f0: 5b74 6f6f 6c2e 706f 6574 7279 2e64 6570  [tool.poetry.dep
-00000100: 656e 6465 6e63 6965 735d 0d0a 2020 7079  endencies]..  py
-00000110: 7468 6f6e 203d 2022 3e3d 332e 3822 0d0a  thon = ">=3.8"..
-00000120: 7079 6461 6e74 6963 203d 2022 312e 3130  pydantic = "1.10
-00000130: 2e31 3322 0d0a 6165 6e75 6d20 3d20 225e  .13"..aenum = "^
-00000140: 332e 312e 3135 220d 0a70 7974 686f 6e2d  3.1.15"..python-
-00000150: 6461 7465 7574 696c 203d 2022 5e32 2e38  dateutil = "^2.8
-00000160: 2e32 220d 0a75 726c 6c69 6233 203d 2022  .2"..urllib3 = "
-00000170: 5e32 2e32 2e30 220d 0a0d 0a5b 746f 6f6c  ^2.2.0"....[tool
-00000180: 2e70 6f65 7472 792e 7572 6c73 5d0d 0a20  .poetry.urls].. 
-00000190: 2068 6f6d 6570 6167 6520 3d20 2268 7474   homepage = "htt
-000001a0: 7073 3a2f 2f67 6974 6875 622e 636f 6d2f  ps://github.com/
-000001b0: 7069 6563 6573 2d61 7070 2f70 6965 6365  pieces-app/piece
-000001c0: 732d 6f73 2d63 6c69 656e 742d 7364 6b2d  s-os-client-sdk-
-000001d0: 666f 722d 7079 7468 6f6e 220d 0a20 2072  for-python"..  r
-000001e0: 6570 6f73 6974 6f72 7920 3d20 2268 7474  epository = "htt
-000001f0: 7073 3a2f 2f67 6974 6875 622e 636f 6d2f  ps://github.com/
-00000200: 7069 6563 6573 2d61 7070 2f70 6965 6365  pieces-app/piece
-00000210: 732d 6f73 2d63 6c69 656e 742d 7364 6b2d  s-os-client-sdk-
-00000220: 666f 722d 7079 7468 6f6e 220d 0a20 2069  for-python"..  i
-00000230: 7373 7565 7320 3d20 2268 7474 7073 3a2f  ssues = "https:/
-00000240: 2f67 6974 6875 622e 636f 6d2f 7069 6563  /github.com/piec
-00000250: 6573 2d61 7070 2f70 6965 6365 732d 6f73  es-app/pieces-os
-00000260: 2d63 6c69 656e 742d 7364 6b2d 666f 722d  -client-sdk-for-
-00000270: 7079 7468 6f6e 2f69 7373 7565 7322 0d0a  python/issues"..
-00000280: 0d0a 5b62 7569 6c64 2d73 7973 7465 6d5d  ..[build-system]
-00000290: 0d0a 2020 7265 7175 6972 6573 203d 205b  ..  requires = [
-000002a0: 2270 6f65 7472 792d 636f 7265 3e3d 312e  "poetry-core>=1.
-000002b0: 302e 3022 5d0d 0a20 2062 7569 6c64 2d62  0.0"]..  build-b
-000002c0: 6163 6b65 6e64 203d 2022 706f 6574 7279  ackend = "poetry
-000002d0: 2e63 6f72 652e 6d61 736f 6e72 792e 6170  .core.masonry.ap
-000002e0: 6922 0d0a 0d0a                           i"....
+00000030: 7273 696f 6e20 3d20 2232 2e30 2e30 2d31  rsion = "2.0.0-1
+00000040: 220d 0a20 2064 6573 6372 6970 7469 6f6e  "..  description
+00000050: 203d 2022 4120 706f 7765 7266 756c 2063   = "A powerful c
+00000060: 6f64 6520 656e 6769 6e65 2070 6163 6b61  ode engine packa
+00000070: 6765 2066 6f72 2077 7269 7469 6e67 2061  ge for writing a
+00000080: 7070 6c69 6361 7469 6f6e 7320 6f6e 2074  pplications on t
+00000090: 6f70 206f 6620 5069 6563 6573 204f 5322  op of Pieces OS"
+000000a0: 0d0a 2020 6175 7468 6f72 7320 3d20 5b0d  ..  authors = [.
+000000b0: 0a20 2020 2022 5069 6563 6573 203c 6465  .    "Pieces <de
+000000c0: 7665 6c6f 706d 656e 7440 7069 6563 6573  velopment@pieces
+000000d0: 2e61 7070 3e22 0d0a 2020 5d0d 0a20 206c  .app>"..  ]..  l
+000000e0: 6963 656e 7365 203d 2022 4d49 5422 0d0a  icense = "MIT"..
+000000f0: 2020 7265 6164 6d65 203d 2022 5245 4144    readme = "READ
+00000100: 4d45 2e6d 6422 0d0a 0d0a 5b74 6f6f 6c2e  ME.md"....[tool.
+00000110: 706f 6574 7279 2e64 6570 656e 6465 6e63  poetry.dependenc
+00000120: 6965 735d 0d0a 2020 7079 7468 6f6e 203d  ies]..  python =
+00000130: 2022 3e3d 332e 3822 0d0a 2020 7079 6461   ">=3.8"..  pyda
+00000140: 6e74 6963 203d 2022 312e 3130 2e31 3322  ntic = "1.10.13"
+00000150: 0d0a 2020 6165 6e75 6d20 3d20 225e 332e  ..  aenum = "^3.
+00000160: 312e 3135 220d 0a20 2070 7974 686f 6e2d  1.15"..  python-
+00000170: 6461 7465 7574 696c 203d 2022 5e32 2e38  dateutil = "^2.8
+00000180: 2e32 220d 0a20 2075 726c 6c69 6233 203d  .2"..  urllib3 =
+00000190: 2022 5e32 2e32 2e30 220d 0a0d 0a5b 746f   "^2.2.0"....[to
+000001a0: 6f6c 2e70 6f65 7472 792e 7572 6c73 5d0d  ol.poetry.urls].
+000001b0: 0a20 2068 6f6d 6570 6167 6520 3d20 2268  .  homepage = "h
+000001c0: 7474 7073 3a2f 2f67 6974 6875 622e 636f  ttps://github.co
+000001d0: 6d2f 7069 6563 6573 2d61 7070 2f70 6965  m/pieces-app/pie
+000001e0: 6365 732d 6f73 2d63 6c69 656e 742d 7364  ces-os-client-sd
+000001f0: 6b2d 666f 722d 7079 7468 6f6e 220d 0a20  k-for-python".. 
+00000200: 2072 6570 6f73 6974 6f72 7920 3d20 2268   repository = "h
+00000210: 7474 7073 3a2f 2f67 6974 6875 622e 636f  ttps://github.co
+00000220: 6d2f 7069 6563 6573 2d61 7070 2f70 6965  m/pieces-app/pie
+00000230: 6365 732d 6f73 2d63 6c69 656e 742d 7364  ces-os-client-sd
+00000240: 6b2d 666f 722d 7079 7468 6f6e 220d 0a20  k-for-python".. 
+00000250: 2069 7373 7565 7320 3d20 2268 7474 7073   issues = "https
+00000260: 3a2f 2f67 6974 6875 622e 636f 6d2f 7069  ://github.com/pi
+00000270: 6563 6573 2d61 7070 2f70 6965 6365 732d  eces-app/pieces-
+00000280: 6f73 2d63 6c69 656e 742d 7364 6b2d 666f  os-client-sdk-fo
+00000290: 722d 7079 7468 6f6e 2f69 7373 7565 7322  r-python/issues"
+000002a0: 0d0a 0d0a 5b62 7569 6c64 2d73 7973 7465  ....[build-syste
+000002b0: 6d5d 0d0a 2020 7265 7175 6972 6573 203d  m]..  requires =
+000002c0: 205b 2270 6f65 7472 792d 636f 7265 3e3d   ["poetry-core>=
+000002d0: 312e 302e 3022 5d0d 0a20 2062 7569 6c64  1.0.0"]..  build
+000002e0: 2d62 6163 6b65 6e64 203d 2022 706f 6574  -backend = "poet
+000002f0: 7279 2e63 6f72 652e 6d61 736f 6e72 792e  ry.core.masonry.
+00000300: 6170 6922 0d0a 0d0a                      api"....
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/__init__.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -160,14 +160,16 @@
 from pieces_os_client.models.conversation_summarize_input import ConversationSummarizeInput
 from pieces_os_client.models.conversation_summarize_output import ConversationSummarizeOutput
 from pieces_os_client.models.conversation_type_enum import ConversationTypeEnum
 from pieces_os_client.models.conversations import Conversations
 from pieces_os_client.models.conversations_create_from_asset_output import ConversationsCreateFromAssetOutput
 from pieces_os_client.models.created_external_provider_api_key import CreatedExternalProviderApiKey
 from pieces_os_client.models.deleted_external_provider_api_key import DeletedExternalProviderApiKey
+from pieces_os_client.models.detected_external_application import DetectedExternalApplication
+from pieces_os_client.models.detected_external_applications import DetectedExternalApplications
 from pieces_os_client.models.discovered_asset import DiscoveredAsset
 from pieces_os_client.models.discovered_assets import DiscoveredAssets
 from pieces_os_client.models.discovered_html_webpage import DiscoveredHtmlWebpage
 from pieces_os_client.models.discovered_html_webpages import DiscoveredHtmlWebpages
 from pieces_os_client.models.discovered_related_tag import DiscoveredRelatedTag
 from pieces_os_client.models.discovered_related_tags import DiscoveredRelatedTags
 from pieces_os_client.models.discovered_sensitive import DiscoveredSensitive
@@ -278,53 +280,72 @@
 from pieces_os_client.models.node_type_enum import NodeTypeEnum
 from pieces_os_client.models.notification import Notification
 from pieces_os_client.models.o_auth_account import OAuthAccount
 from pieces_os_client.models.o_auth_group import OAuthGroup
 from pieces_os_client.models.o_auth_token import OAuthToken
 from pieces_os_client.models.ocr_analyses import OCRAnalyses
 from pieces_os_client.models.ocr_analysis import OCRAnalysis
+from pieces_os_client.models.os_device_cpu_hardware_information import OSDeviceCPUHardwareInformation
+from pieces_os_client.models.os_device_dependencies_information import OSDeviceDependenciesInformation
+from pieces_os_client.models.os_device_gpu_hardware_capabilities_information import OSDeviceGPUHardwareCapabilitiesInformation
+from pieces_os_client.models.os_device_gpu_hardware_information import OSDeviceGPUHardwareInformation
+from pieces_os_client.models.os_device_hardware_information import OSDeviceHardwareInformation
+from pieces_os_client.models.os_device_information_returnable import OSDeviceInformationReturnable
 from pieces_os_client.models.os_health import OSHealth
+from pieces_os_client.models.onboarded_persona_details import OnboardedPersonaDetails
 from pieces_os_client.models.open_ai_models_list_input import OpenAIModelsListInput
 from pieces_os_client.models.open_ai_models_list_output import OpenAIModelsListOutput
 from pieces_os_client.models.ordered_metrics import OrderedMetrics
 from pieces_os_client.models.pkce import PKCE
 from pieces_os_client.models.person import Person
 from pieces_os_client.models.person_access import PersonAccess
 from pieces_os_client.models.person_access_scoped_enum import PersonAccessScopedEnum
 from pieces_os_client.models.person_basic_type import PersonBasicType
 from pieces_os_client.models.person_model import PersonModel
 from pieces_os_client.models.person_type import PersonType
 from pieces_os_client.models.persons import Persons
 from pieces_os_client.models.platform_enum import PlatformEnum
 from pieces_os_client.models.precreated_external_provider_api_key import PrecreatedExternalProviderApiKey
 from pieces_os_client.models.predeleted_external_provider_api_key import PredeletedExternalProviderApiKey
+from pieces_os_client.models.preonboarded_persona_details import PreonboardedPersonaDetails
 from pieces_os_client.models.preupdated_external_provider_api_key import PreupdatedExternalProviderApiKey
 from pieces_os_client.models.preview import Preview
 from pieces_os_client.models.privacy_enum import PrivacyEnum
 from pieces_os_client.models.pseudo_assets import PseudoAssets
 from pieces_os_client.models.qgpt_agent_related_routes import QGPTAgentRelatedRoutes
 from pieces_os_client.models.qgpt_agent_routes import QGPTAgentRoutes
 from pieces_os_client.models.qgpt_conversation import QGPTConversation
 from pieces_os_client.models.qgpt_conversation_message import QGPTConversationMessage
 from pieces_os_client.models.qgpt_conversation_message_role_enum import QGPTConversationMessageRoleEnum
+from pieces_os_client.models.qgpt_conversation_pipeline import QGPTConversationPipeline
+from pieces_os_client.models.qgpt_conversation_pipeline_for_contextualized_code_dialog import QGPTConversationPipelineForContextualizedCodeDialog
+from pieces_os_client.models.qgpt_conversation_pipeline_for_contextualized_code_generation import QGPTConversationPipelineForContextualizedCodeGeneration
+from pieces_os_client.models.qgpt_conversation_pipeline_for_generalized_code_dialog import QGPTConversationPipelineForGeneralizedCodeDialog
 from pieces_os_client.models.qgpt_hints_input import QGPTHintsInput
 from pieces_os_client.models.qgpt_persons_related_input import QGPTPersonsRelatedInput
 from pieces_os_client.models.qgpt_persons_related_output import QGPTPersonsRelatedOutput
+from pieces_os_client.models.qgpt_prompt_pipeline import QGPTPromptPipeline
 from pieces_os_client.models.qgpt_question_answer import QGPTQuestionAnswer
 from pieces_os_client.models.qgpt_question_answers import QGPTQuestionAnswers
 from pieces_os_client.models.qgpt_question_input import QGPTQuestionInput
 from pieces_os_client.models.qgpt_question_output import QGPTQuestionOutput
 from pieces_os_client.models.qgpt_relevance_input import QGPTRelevanceInput
 from pieces_os_client.models.qgpt_relevance_input_options import QGPTRelevanceInputOptions
 from pieces_os_client.models.qgpt_relevance_output import QGPTRelevanceOutput
 from pieces_os_client.models.qgpt_reprompt_input import QGPTRepromptInput
 from pieces_os_client.models.qgpt_reprompt_output import QGPTRepromptOutput
 from pieces_os_client.models.qgpt_stream_enum import QGPTStreamEnum
 from pieces_os_client.models.qgpt_stream_input import QGPTStreamInput
 from pieces_os_client.models.qgpt_stream_output import QGPTStreamOutput
+from pieces_os_client.models.qgpt_task_pipeline import QGPTTaskPipeline
+from pieces_os_client.models.qgpt_task_pipeline_for_code_commentation import QGPTTaskPipelineForCodeCommentation
+from pieces_os_client.models.qgpt_task_pipeline_for_code_completion import QGPTTaskPipelineForCodeCompletion
+from pieces_os_client.models.qgpt_task_pipeline_for_code_explanation import QGPTTaskPipelineForCodeExplanation
+from pieces_os_client.models.qgpt_task_pipeline_for_code_fix import QGPTTaskPipelineForCodeFix
+from pieces_os_client.models.qgpt_task_pipeline_for_code_modification import QGPTTaskPipelineForCodeModification
 from pieces_os_client.models.reaction import Reaction
 from pieces_os_client.models.recipients import Recipients
 from pieces_os_client.models.referenced_activity import ReferencedActivity
 from pieces_os_client.models.referenced_anchor import ReferencedAnchor
 from pieces_os_client.models.referenced_anchor_point import ReferencedAnchorPoint
 from pieces_os_client.models.referenced_annotation import ReferencedAnnotation
 from pieces_os_client.models.referenced_asset import ReferencedAsset
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/api/__init__.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/api/__init__.py`

 * *Files identical despite different names*

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/api/allocation_api.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/api/open_ai_api.py`

 * *Files 22% similar despite different names*

```diff
@@ -8,329 +8,308 @@
     The version of the OpenAPI document: 1.0
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import re  # noqa: F401
-import io
 import warnings
-
-from pydantic import validate_arguments, ValidationError
-
-from pydantic import StrictStr
+from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
+from typing import Any, Dict, List, Optional, Tuple, Union
+from typing_extensions import Annotated
 
 from typing import Optional
+from pieces_os_client.models.open_ai_models_list_input import OpenAIModelsListInput
+from pieces_os_client.models.open_ai_models_list_output import OpenAIModelsListOutput
 
-from pieces_os_client.models.allocation_cloud import AllocationCloud
-
-from pieces_os_client.api_client import ApiClient
+from pieces_os_client.api_client import ApiClient, RequestSerialized
 from pieces_os_client.api_response import ApiResponse
-from pieces_os_client.exceptions import (  # noqa: F401
-    ApiTypeError,
-    ApiValueError
-)
+from pieces_os_client.rest import RESTResponseType
 
 
-class AllocationApi:
+class OpenAIApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None) -> None:
         if api_client is None:
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
-    @validate_arguments
-    def allocation_snapshot(self, allocation : StrictStr, **kwargs) -> AllocationCloud:  # noqa: E501
-        """/allocation/{allocation} [GET]  # noqa: E501
-
-        This will get a snapshot of a specific allocation.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.allocation_snapshot(allocation, async_req=True)
-        >>> result = thread.get()
-
-        :param allocation: (required)
-        :type allocation: str
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: AllocationCloud
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the allocation_snapshot_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.allocation_snapshot_with_http_info(allocation, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def allocation_snapshot_with_http_info(self, allocation : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
-        """/allocation/{allocation} [GET]  # noqa: E501
-
-        This will get a snapshot of a specific allocation.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.allocation_snapshot_with_http_info(allocation, async_req=True)
-        >>> result = thread.get()
-
-        :param allocation: (required)
-        :type allocation: str
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+    @validate_call
+    def open_ai_models_list(
+        self,
+        open_ai_models_list_input: Optional[OpenAIModelsListInput] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> OpenAIModelsListOutput:
+        """/open_ai/models/list [POST]
+
+        This will get a list of all of your Models from OpenAI w/ you user.auth0.openAI.apiKey.  if the user is unauthenticated or if the openAI key doesnt exist or if it is invalid we will return a 401.  Requires internet as this will ping out to OpenAI's server to get the models.
+
+        :param open_ai_models_list_input:
+        :type open_ai_models_list_input: OpenAIModelsListInput
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(AllocationCloud, status_code(int), headers(HTTPHeaderDict))
-        """
-
-        _params = locals()
+        """ # noqa: E501
 
-        _all_params = [
-            'allocation'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _param = self._open_ai_models_list_serialize(
+            open_ai_models_list_input=open_ai_models_list_input,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
         )
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method allocation_snapshot" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "OpenAIModelsListOutput",
+            '401': "str",
+            '500': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
 
-        _collection_formats = {}
 
-        # process the path parameters
-        _path_params = {}
-        if _params['allocation']:
-            _path_params['allocation'] = _params['allocation']
+    @validate_call
+    def open_ai_models_list_with_http_info(
+        self,
+        open_ai_models_list_input: Optional[OpenAIModelsListInput] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[OpenAIModelsListOutput]:
+        """/open_ai/models/list [POST]
 
+        This will get a list of all of your Models from OpenAI w/ you user.auth0.openAI.apiKey.  if the user is unauthenticated or if the openAI key doesnt exist or if it is invalid we will return a 401.  Requires internet as this will ping out to OpenAI's server to get the models.
 
-        # process the query parameters
-        _query_params = []
-        # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
-        # process the form parameters
-        _form_params = []
-        _files = {}
-        # process the body parameter
-        _body_params = None
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        :param open_ai_models_list_input:
+        :type open_ai_models_list_input: OpenAIModelsListInput
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
 
-        # authentication setting
-        _auth_settings = []  # noqa: E501
+        _param = self._open_ai_models_list_serialize(
+            open_ai_models_list_input=open_ai_models_list_input,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        _response_types_map = {
-            '200': "AllocationCloud",
-            '410': "str",
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "OpenAIModelsListOutput",
+            '401': "str",
+            '500': "str",
         }
-
-        return self.api_client.call_api(
-            '/allocation/{allocation}', 'GET',
-            _path_params,
-            _query_params,
-            _header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
             response_types_map=_response_types_map,
-            auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
-            collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+        )
 
-    @validate_arguments
-    def allocation_update(self, allocation_cloud : Optional[AllocationCloud] = None, **kwargs) -> AllocationCloud:  # noqa: E501
-        """/allocation/update [POST]  # noqa: E501
-
-        This will update a specific allocation.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.allocation_update(allocation_cloud, async_req=True)
-        >>> result = thread.get()
-
-        :param allocation_cloud:
-        :type allocation_cloud: AllocationCloud
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: AllocationCloud
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the allocation_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.allocation_update_with_http_info(allocation_cloud, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def allocation_update_with_http_info(self, allocation_cloud : Optional[AllocationCloud] = None, **kwargs) -> ApiResponse:  # noqa: E501
-        """/allocation/update [POST]  # noqa: E501
-
-        This will update a specific allocation.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.allocation_update_with_http_info(allocation_cloud, async_req=True)
-        >>> result = thread.get()
-
-        :param allocation_cloud:
-        :type allocation_cloud: AllocationCloud
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+    @validate_call
+    def open_ai_models_list_without_preload_content(
+        self,
+        open_ai_models_list_input: Optional[OpenAIModelsListInput] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """/open_ai/models/list [POST]
+
+        This will get a list of all of your Models from OpenAI w/ you user.auth0.openAI.apiKey.  if the user is unauthenticated or if the openAI key doesnt exist or if it is invalid we will return a 401.  Requires internet as this will ping out to OpenAI's server to get the models.
+
+        :param open_ai_models_list_input:
+        :type open_ai_models_list_input: OpenAIModelsListInput
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(AllocationCloud, status_code(int), headers(HTTPHeaderDict))
-        """
+        """ # noqa: E501
 
-        _params = locals()
+        _param = self._open_ai_models_list_serialize(
+            open_ai_models_list_input=open_ai_models_list_input,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        _all_params = [
-            'allocation_cloud'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "OpenAIModelsListOutput",
+            '401': "str",
+            '500': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
         )
+        return response_data.response
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method allocation_update" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
 
-        _collection_formats = {}
+    def _open_ai_models_list_serialize(
+        self,
+        open_ai_models_list_input,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
 
-        # process the path parameters
-        _path_params = {}
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
 
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, str] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
         # process the query parameters
-        _query_params = []
         # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
-        _form_params = []
-        _files = {}
         # process the body parameter
-        _body_params = None
-        if _params['allocation_cloud'] is not None:
-            _body_params = _params['allocation_cloud']
+        if open_ai_models_list_input is not None:
+            _body_params = open_ai_models_list_input
+
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+            [
+                'application/json'
+            ]
+        )
 
         # set the HTTP header `Content-Type`
-        _content_types_list = _params.get('_content_type',
-            self.api_client.select_header_content_type(
-                ['application/json']))
-        if _content_types_list:
-                _header_params['Content-Type'] = _content_types_list
+        if _content_type:
+            _header_params['Content-Type'] = _content_type
+        else:
+            _default_content_type = (
+                self.api_client.select_header_content_type(
+                    [
+                        'application/json'
+                    ]
+                )
+            )
+            if _default_content_type is not None:
+                _header_params['Content-Type'] = _default_content_type
 
         # authentication setting
-        _auth_settings = []  # noqa: E501
-
-        _response_types_map = {
-            '200': "AllocationCloud",
-            '500': "str",
-            '504': "str",
-        }
+        _auth_settings: List[str] = [
+        ]
 
-        return self.api_client.call_api(
-            '/allocation/update', 'POST',
-            _path_params,
-            _query_params,
-            _header_params,
+        return self.api_client.param_serialize(
+            method='POST',
+            resource_path='/open_ai/models/list',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
-            response_types_map=_response_types_map,
             auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/api/application_api.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_conversation.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,183 +9,153 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
+import pprint
 import re  # noqa: F401
-import io
-import warnings
-
-from pydantic import validate_arguments, ValidationError
-
-from typing import Optional
+import json
 
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.application import Application
+from pieces_os_client.models.conversation_type_enum import ConversationTypeEnum
+from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.flattened_assets import FlattenedAssets
+from pieces_os_client.models.flattened_websites import FlattenedWebsites
+from pieces_os_client.models.qgpt_prompt_pipeline import QGPTPromptPipeline
+from pieces_os_client.models.referenced_model import ReferencedModel
+from pieces_os_client.models.seeded_anchor import SeededAnchor
+from pieces_os_client.models.seeded_annotation import SeededAnnotation
+from pieces_os_client.models.seeded_conversation_message import SeededConversationMessage
+from typing import Optional, Set
+from typing_extensions import Self
 
-from pieces_os_client.api_client import ApiClient
-from pieces_os_client.api_response import ApiResponse
-from pieces_os_client.exceptions import (  # noqa: F401
-    ApiTypeError,
-    ApiValueError
-)
-
-
-class ApplicationApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
+class SeededConversation(BaseModel):
     """
-
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-    @validate_arguments
-    def application_update(self, application : Optional[Application] = None, **kwargs) -> Application:  # noqa: E501
-        """/application/update [GET]  # noqa: E501
-
-        This is an endpoint for updating an application.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.application_update(application, async_req=True)
-        >>> result = thread.get()
-
-        :param application:
-        :type application: Application
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: Application
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the application_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.application_update_with_http_info(application, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def application_update_with_http_info(self, application : Optional[Application] = None, **kwargs) -> ApiResponse:  # noqa: E501
-        """/application/update [GET]  # noqa: E501
-
-        This is an endpoint for updating an application.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.application_update_with_http_info(application, async_req=True)
-        >>> result = thread.get()
-
-        :param application:
-        :type application: Application
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
-        :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
+    This is a pre-Conversation object.  This will hold together a conversation. Ie allthe message within a conversation.  All the additional properties on here used on here like(anchors/assets) are used for context that will seed the conversation.  model is a calculated property, and will be the model of the last message sent if applicable.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    name: Optional[StrictStr] = Field(default=None, description="This is a name that is customized.")
+    favorited: Optional[StrictBool] = None
+    application: Optional[Application] = None
+    annotations: Optional[List[SeededAnnotation]] = None
+    messages: Optional[List[SeededConversationMessage]] = None
+    model: Optional[ReferencedModel] = None
+    assets: Optional[FlattenedAssets] = None
+    websites: Optional[FlattenedWebsites] = None
+    anchors: Optional[List[SeededAnchor]] = None
+    type: ConversationTypeEnum
+    pipeline: Optional[QGPTPromptPipeline] = None
+    demo: Optional[StrictBool] = Field(default=None, description="This will let us know if this conversation was generated as a 'demo' conversation")
+    __properties: ClassVar[List[str]] = ["schema", "name", "favorited", "application", "annotations", "messages", "model", "assets", "websites", "anchors", "type", "pipeline", "demo"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
+
+    def to_str(self) -> str:
+        """Returns the string representation of the model using alias"""
+        return pprint.pformat(self.model_dump(by_alias=True))
+
+    def to_json(self) -> str:
+        """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+        return json.dumps(self.to_dict())
+
+    @classmethod
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededConversation from a JSON string"""
+        return cls.from_dict(json.loads(json_str))
+
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
         """
+        excluded_fields: Set[str] = set([
+        ])
 
-        _params = locals()
-
-        _all_params = [
-            'application'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
         )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of application
+        if self.application:
+            _dict['application'] = self.application.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in annotations (list)
+        _items = []
+        if self.annotations:
+            for _item in self.annotations:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['annotations'] = _items
+        # override the default output from pydantic by calling `to_dict()` of each item in messages (list)
+        _items = []
+        if self.messages:
+            for _item in self.messages:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['messages'] = _items
+        # override the default output from pydantic by calling `to_dict()` of model
+        if self.model:
+            _dict['model'] = self.model.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of assets
+        if self.assets:
+            _dict['assets'] = self.assets.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of websites
+        if self.websites:
+            _dict['websites'] = self.websites.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in anchors (list)
+        _items = []
+        if self.anchors:
+            for _item in self.anchors:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['anchors'] = _items
+        # override the default output from pydantic by calling `to_dict()` of pipeline
+        if self.pipeline:
+            _dict['pipeline'] = self.pipeline.to_dict()
+        return _dict
+
+    @classmethod
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededConversation from a dict"""
+        if obj is None:
+            return None
+
+        if not isinstance(obj, dict):
+            return cls.model_validate(obj)
+
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "name": obj.get("name"),
+            "favorited": obj.get("favorited"),
+            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "annotations": [SeededAnnotation.from_dict(_item) for _item in obj["annotations"]] if obj.get("annotations") is not None else None,
+            "messages": [SeededConversationMessage.from_dict(_item) for _item in obj["messages"]] if obj.get("messages") is not None else None,
+            "model": ReferencedModel.from_dict(obj["model"]) if obj.get("model") is not None else None,
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "websites": FlattenedWebsites.from_dict(obj["websites"]) if obj.get("websites") is not None else None,
+            "anchors": [SeededAnchor.from_dict(_item) for _item in obj["anchors"]] if obj.get("anchors") is not None else None,
+            "type": obj.get("type"),
+            "pipeline": QGPTPromptPipeline.from_dict(obj["pipeline"]) if obj.get("pipeline") is not None else None,
+            "demo": obj.get("demo")
+        })
+        return _obj
+
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method application_update" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
-
-        _collection_formats = {}
-
-        # process the path parameters
-        _path_params = {}
-
-        # process the query parameters
-        _query_params = []
-        # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
-        # process the form parameters
-        _form_params = []
-        _files = {}
-        # process the body parameter
-        _body_params = None
-        if _params['application'] is not None:
-            _body_params = _params['application']
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
-        # set the HTTP header `Content-Type`
-        _content_types_list = _params.get('_content_type',
-            self.api_client.select_header_content_type(
-                ['application/json']))
-        if _content_types_list:
-                _header_params['Content-Type'] = _content_types_list
-
-        # authentication setting
-        _auth_settings = []  # noqa: E501
-
-        _response_types_map = {
-            '200': "Application",
-        }
-
-        return self.api_client.call_api(
-            '/application/update', 'POST',
-            _path_params,
-            _query_params,
-            _header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            response_types_map=_response_types_map,
-            auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
-            collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/api/applications_api.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/api/auth0_api.py`

 * *Files 22% similar despite different names*

```diff
@@ -8,1462 +8,1347 @@
     The version of the OpenAPI document: 1.0
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import re  # noqa: F401
-import io
 import warnings
-
-from pydantic import validate_arguments, ValidationError
-
+from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import Field, StrictStr, constr, validator
 
-from typing import Optional
-
-from pieces_os_client.models.application import Application
-from pieces_os_client.models.applications import Applications
-from pieces_os_client.models.seeded_tracked_interaction_event import SeededTrackedInteractionEvent
-from pieces_os_client.models.seeded_tracked_keyboard_event import SeededTrackedKeyboardEvent
-from pieces_os_client.models.session import Session
-from pieces_os_client.models.tracked_application_install import TrackedApplicationInstall
-from pieces_os_client.models.tracked_application_update import TrackedApplicationUpdate
-from pieces_os_client.models.tracked_interaction_event import TrackedInteractionEvent
-from pieces_os_client.models.tracked_keyboard_event import TrackedKeyboardEvent
+from pydantic import Field, StrictStr, field_validator
+from typing import List, Optional
+from typing_extensions import Annotated
+from pieces_os_client.models.auth0_user import Auth0User
+from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.o_auth_token import OAuthToken
+from pieces_os_client.models.resulted_pkce import ResultedPKCE
 
-from pieces_os_client.api_client import ApiClient
+from pieces_os_client.api_client import ApiClient, RequestSerialized
 from pieces_os_client.api_response import ApiResponse
-from pieces_os_client.exceptions import (  # noqa: F401
-    ApiTypeError,
-    ApiValueError
-)
+from pieces_os_client.rest import RESTResponseType
 
 
-class ApplicationsApi:
+class Auth0Api:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None) -> None:
         if api_client is None:
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
-    @validate_arguments
-    def applications_register(self, application : Annotated[Optional[Application], Field(description="This will accept a application.")] = None, **kwargs) -> Application:  # noqa: E501
-        """/applications/register [POST]  # noqa: E501
-
-        This will register a connected applicaiton.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_register(application, async_req=True)
-        >>> result = thread.get()
-
-        :param application: This will accept a application.
-        :type application: Application
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: Application
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the applications_register_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.applications_register_with_http_info(application, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def applications_register_with_http_info(self, application : Annotated[Optional[Application], Field(description="This will accept a application.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
-        """/applications/register [POST]  # noqa: E501
-
-        This will register a connected applicaiton.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_register_with_http_info(application, async_req=True)
-        >>> result = thread.get()
-
-        :param application: This will accept a application.
-        :type application: Application
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+    @validate_call
+    def auth0_logout(
+        self,
+        client_id: Annotated[Optional[StrictStr], Field(description="The client ID of the Auth0 Instance")] = None,
+        return_to: Annotated[Optional[StrictStr], Field(description="The URL that the logout endpoint will return to")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> str:
+        """https://auth.pieces.services/v2/logout [GET]
+
+        https://auth0.com/docs/api/authentication#logout
+
+        :param client_id: The client ID of the Auth0 Instance
+        :type client_id: str
+        :param return_to: The URL that the logout endpoint will return to
+        :type return_to: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
-        """
+        """ # noqa: E501
 
-        _params = locals()
-
-        _all_params = [
-            'application'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _param = self._auth0_logout_serialize(
+            client_id=client_id,
+            return_to=return_to,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
         )
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method applications_register" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
-
-        _collection_formats = {}
-
-        # process the path parameters
-        _path_params = {}
-
-        # process the query parameters
-        _query_params = []
-        # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
-        # process the form parameters
-        _form_params = []
-        _files = {}
-        # process the body parameter
-        _body_params = None
-        if _params['application'] is not None:
-            _body_params = _params['application']
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
 
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
 
-        # set the HTTP header `Content-Type`
-        _content_types_list = _params.get('_content_type',
-            self.api_client.select_header_content_type(
-                ['application/json']))
-        if _content_types_list:
-                _header_params['Content-Type'] = _content_types_list
+    @validate_call
+    def auth0_logout_with_http_info(
+        self,
+        client_id: Annotated[Optional[StrictStr], Field(description="The client ID of the Auth0 Instance")] = None,
+        return_to: Annotated[Optional[StrictStr], Field(description="The URL that the logout endpoint will return to")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[str]:
+        """https://auth.pieces.services/v2/logout [GET]
+
+        https://auth0.com/docs/api/authentication#logout
+
+        :param client_id: The client ID of the Auth0 Instance
+        :type client_id: str
+        :param return_to: The URL that the logout endpoint will return to
+        :type return_to: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
 
-        # authentication setting
-        _auth_settings = []  # noqa: E501
+        _param = self._auth0_logout_serialize(
+            client_id=client_id,
+            return_to=return_to,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        _response_types_map = {
-            '200': "Application",
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "str",
         }
-
-        return self.api_client.call_api(
-            '/applications/register', 'POST',
-            _path_params,
-            _query_params,
-            _header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
             response_types_map=_response_types_map,
-            auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
-            collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+        )
 
-    @validate_arguments
-    def applications_session_close(self, body : Annotated[Optional[constr(strict=True, max_length=36, min_length=36)], Field(description="This will accept a required session uuid.")] = None, **kwargs) -> Session:  # noqa: E501
-        """/applications/session/close [POST]  # noqa: E501
-
-        This will close your opened session! Going to want to accept a session uuid here.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_session_close(body, async_req=True)
-        >>> result = thread.get()
-
-        :param body: This will accept a required session uuid.
-        :type body: str
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: Session
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the applications_session_close_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.applications_session_close_with_http_info(body, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def applications_session_close_with_http_info(self, body : Annotated[Optional[constr(strict=True, max_length=36, min_length=36)], Field(description="This will accept a required session uuid.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
-        """/applications/session/close [POST]  # noqa: E501
-
-        This will close your opened session! Going to want to accept a session uuid here.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_session_close_with_http_info(body, async_req=True)
-        >>> result = thread.get()
-
-        :param body: This will accept a required session uuid.
-        :type body: str
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+    @validate_call
+    def auth0_logout_without_preload_content(
+        self,
+        client_id: Annotated[Optional[StrictStr], Field(description="The client ID of the Auth0 Instance")] = None,
+        return_to: Annotated[Optional[StrictStr], Field(description="The URL that the logout endpoint will return to")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """https://auth.pieces.services/v2/logout [GET]
+
+        https://auth0.com/docs/api/authentication#logout
+
+        :param client_id: The client ID of the Auth0 Instance
+        :type client_id: str
+        :param return_to: The URL that the logout endpoint will return to
+        :type return_to: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(Session, status_code(int), headers(HTTPHeaderDict))
-        """
+        """ # noqa: E501
 
-        _params = locals()
+        _param = self._auth0_logout_serialize(
+            client_id=client_id,
+            return_to=return_to,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        _all_params = [
-            'body'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
         )
+        return response_data.response
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method applications_session_close" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
 
-        _collection_formats = {}
+    def _auth0_logout_serialize(
+        self,
+        client_id,
+        return_to,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
 
-        # process the path parameters
-        _path_params = {}
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, str] = {}
+        _body_params: Optional[bytes] = None
 
+        # process the path parameters
         # process the query parameters
-        _query_params = []
+        if client_id is not None:
+            
+            _query_params.append(('client_id', client_id))
+            
+        if return_to is not None:
+            
+            _query_params.append(('returnTo', return_to))
+            
         # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
-        _form_params = []
-        _files = {}
         # process the body parameter
-        _body_params = None
-        if _params['body'] is not None:
-            _body_params = _params['body']
+
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+            [
+                'text/html'
+            ]
+        )
 
-        # set the HTTP header `Content-Type`
-        _content_types_list = _params.get('_content_type',
-            self.api_client.select_header_content_type(
-                ['application/json']))
-        if _content_types_list:
-                _header_params['Content-Type'] = _content_types_list
 
         # authentication setting
-        _auth_settings = []  # noqa: E501
-
-        _response_types_map = {
-            '200': "Session",
-        }
+        _auth_settings: List[str] = [
+        ]
 
-        return self.api_client.call_api(
-            '/applications/session/close', 'POST',
-            _path_params,
-            _query_params,
-            _header_params,
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/v2/logout',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
-            response_types_map=_response_types_map,
             auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+            _host=_host,
+            _request_auth=_request_auth
+        )
 
-    @validate_arguments
-    def applications_session_open(self, **kwargs) -> Session:  # noqa: E501
-        """/applications/session/open [POST]  # noqa: E501
-
-        This will open a new session. A session is when someone is using the pieces application.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_session_open(async_req=True)
-        >>> result = thread.get()
-
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: Session
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the applications_session_open_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.applications_session_open_with_http_info(**kwargs)  # noqa: E501
-
-    @validate_arguments
-    def applications_session_open_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
-        """/applications/session/open [POST]  # noqa: E501
-
-        This will open a new session. A session is when someone is using the pieces application.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_session_open_with_http_info(async_req=True)
-        >>> result = thread.get()
-
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+
+
+    @validate_call
+    def authorize_auth0(
+        self,
+        audience: Annotated[StrictStr, Field(description=" The unique identifier of the target API you want to access.")],
+        scope: Annotated[List[StrictStr], Field(description="The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OpenID Connect (OIDC) scopes about users, such as profile and email, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, read:contacts). Include offline_access to get a Refresh Token.")],
+        response_type: Annotated[StrictStr, Field(description="Indicates to Auth0 which OAuth 2.0 Flow you want to perform. Use code for Authorization Code Grant (PKCE) Flow.")],
+        client_id: Annotated[StrictStr, Field(description="Your application's Client ID.")],
+        code_challenge_method: Annotated[StrictStr, Field(description="Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged.")],
+        code_challenge: Annotated[StrictStr, Field(description="Generated challenge from the code_verifier.")],
+        response_mode: StrictStr,
+        state: Annotated[Optional[StrictStr], Field(description="An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.")] = None,
+        redirect_uri: Annotated[Optional[StrictStr], Field(description="The URL to which Auth0 will redirect the browser after authorization has been granted by the user.")] = None,
+        connection: Annotated[Optional[StrictStr], Field(description="The name of the connection configured to your application.")] = None,
+        prompt: Annotated[Optional[StrictStr], Field(description="To initiate a silent authentication request, use prompt=none (see Remarks for more info).")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ResultedPKCE:
+        """https://auth.pieces.services/authorize [GET]
+
+        An endpoint that is used locally authenticate via a PKCE Flow.  Example https://auth.pieces.services /authorize?audience=https%3A%2F%2Fpieces.us.auth0.com%2Fapi%2Fv2%2F&scope=email+profile+offline_access+openid&response_type=code&client_id=9sW4Pa1LEjX67l6VO14u0207NLYeXnu1&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fpkce%2Fresponse%2Fcode&code_challenge_method=S256&code_challenge=yxRssZxdfBpMigRmDxAety1QU72Bd5WnDUbtlsCZOnk&response_mode=form_post&state=4bd0b9a389b4b229602346c33913b4c3c199628a90011ab3a901302ab62b3832
+
+        :param audience:  The unique identifier of the target API you want to access. (required)
+        :type audience: str
+        :param scope: The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OpenID Connect (OIDC) scopes about users, such as profile and email, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, read:contacts). Include offline_access to get a Refresh Token. (required)
+        :type scope: List[str]
+        :param response_type: Indicates to Auth0 which OAuth 2.0 Flow you want to perform. Use code for Authorization Code Grant (PKCE) Flow. (required)
+        :type response_type: str
+        :param client_id: Your application's Client ID. (required)
+        :type client_id: str
+        :param code_challenge_method: Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged. (required)
+        :type code_challenge_method: str
+        :param code_challenge: Generated challenge from the code_verifier. (required)
+        :type code_challenge: str
+        :param response_mode: (required)
+        :type response_mode: str
+        :param state: An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.
+        :type state: str
+        :param redirect_uri: The URL to which Auth0 will redirect the browser after authorization has been granted by the user.
+        :type redirect_uri: str
+        :param connection: The name of the connection configured to your application.
+        :type connection: str
+        :param prompt: To initiate a silent authentication request, use prompt=none (see Remarks for more info).
+        :type prompt: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(Session, status_code(int), headers(HTTPHeaderDict))
-        """
-
-        _params = locals()
+        """ # noqa: E501
 
-        _all_params = [
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _param = self._authorize_auth0_serialize(
+            audience=audience,
+            scope=scope,
+            response_type=response_type,
+            client_id=client_id,
+            code_challenge_method=code_challenge_method,
+            code_challenge=code_challenge,
+            response_mode=response_mode,
+            state=state,
+            redirect_uri=redirect_uri,
+            connection=connection,
+            prompt=prompt,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
         )
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method applications_session_open" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
-
-        _collection_formats = {}
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "ResultedPKCE",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
 
-        # process the path parameters
-        _path_params = {}
 
-        # process the query parameters
-        _query_params = []
-        # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
-        # process the form parameters
-        _form_params = []
-        _files = {}
-        # process the body parameter
-        _body_params = None
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+    @validate_call
+    def authorize_auth0_with_http_info(
+        self,
+        audience: Annotated[StrictStr, Field(description=" The unique identifier of the target API you want to access.")],
+        scope: Annotated[List[StrictStr], Field(description="The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OpenID Connect (OIDC) scopes about users, such as profile and email, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, read:contacts). Include offline_access to get a Refresh Token.")],
+        response_type: Annotated[StrictStr, Field(description="Indicates to Auth0 which OAuth 2.0 Flow you want to perform. Use code for Authorization Code Grant (PKCE) Flow.")],
+        client_id: Annotated[StrictStr, Field(description="Your application's Client ID.")],
+        code_challenge_method: Annotated[StrictStr, Field(description="Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged.")],
+        code_challenge: Annotated[StrictStr, Field(description="Generated challenge from the code_verifier.")],
+        response_mode: StrictStr,
+        state: Annotated[Optional[StrictStr], Field(description="An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.")] = None,
+        redirect_uri: Annotated[Optional[StrictStr], Field(description="The URL to which Auth0 will redirect the browser after authorization has been granted by the user.")] = None,
+        connection: Annotated[Optional[StrictStr], Field(description="The name of the connection configured to your application.")] = None,
+        prompt: Annotated[Optional[StrictStr], Field(description="To initiate a silent authentication request, use prompt=none (see Remarks for more info).")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[ResultedPKCE]:
+        """https://auth.pieces.services/authorize [GET]
+
+        An endpoint that is used locally authenticate via a PKCE Flow.  Example https://auth.pieces.services /authorize?audience=https%3A%2F%2Fpieces.us.auth0.com%2Fapi%2Fv2%2F&scope=email+profile+offline_access+openid&response_type=code&client_id=9sW4Pa1LEjX67l6VO14u0207NLYeXnu1&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fpkce%2Fresponse%2Fcode&code_challenge_method=S256&code_challenge=yxRssZxdfBpMigRmDxAety1QU72Bd5WnDUbtlsCZOnk&response_mode=form_post&state=4bd0b9a389b4b229602346c33913b4c3c199628a90011ab3a901302ab62b3832
+
+        :param audience:  The unique identifier of the target API you want to access. (required)
+        :type audience: str
+        :param scope: The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OpenID Connect (OIDC) scopes about users, such as profile and email, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, read:contacts). Include offline_access to get a Refresh Token. (required)
+        :type scope: List[str]
+        :param response_type: Indicates to Auth0 which OAuth 2.0 Flow you want to perform. Use code for Authorization Code Grant (PKCE) Flow. (required)
+        :type response_type: str
+        :param client_id: Your application's Client ID. (required)
+        :type client_id: str
+        :param code_challenge_method: Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged. (required)
+        :type code_challenge_method: str
+        :param code_challenge: Generated challenge from the code_verifier. (required)
+        :type code_challenge: str
+        :param response_mode: (required)
+        :type response_mode: str
+        :param state: An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.
+        :type state: str
+        :param redirect_uri: The URL to which Auth0 will redirect the browser after authorization has been granted by the user.
+        :type redirect_uri: str
+        :param connection: The name of the connection configured to your application.
+        :type connection: str
+        :param prompt: To initiate a silent authentication request, use prompt=none (see Remarks for more info).
+        :type prompt: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
 
-        # authentication setting
-        _auth_settings = []  # noqa: E501
+        _param = self._authorize_auth0_serialize(
+            audience=audience,
+            scope=scope,
+            response_type=response_type,
+            client_id=client_id,
+            code_challenge_method=code_challenge_method,
+            code_challenge=code_challenge,
+            response_mode=response_mode,
+            state=state,
+            redirect_uri=redirect_uri,
+            connection=connection,
+            prompt=prompt,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        _response_types_map = {
-            '200': "Session",
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "ResultedPKCE",
         }
-
-        return self.api_client.call_api(
-            '/applications/session/open', 'POST',
-            _path_params,
-            _query_params,
-            _header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
             response_types_map=_response_types_map,
-            auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
-            collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+        )
 
-    @validate_arguments
-    def applications_session_snapshot(self, session : Annotated[StrictStr, Field(..., description="This is a uuid that points to a session.")], **kwargs) -> Session:  # noqa: E501
-        """/applications/sessions/{session} [GET]  # noqa: E501
-
-        This is an endpoint to get a snapshot of a specific session.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_session_snapshot(session, async_req=True)
-        >>> result = thread.get()
-
-        :param session: This is a uuid that points to a session. (required)
-        :type session: str
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: Session
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the applications_session_snapshot_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.applications_session_snapshot_with_http_info(session, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def applications_session_snapshot_with_http_info(self, session : Annotated[StrictStr, Field(..., description="This is a uuid that points to a session.")], **kwargs) -> ApiResponse:  # noqa: E501
-        """/applications/sessions/{session} [GET]  # noqa: E501
-
-        This is an endpoint to get a snapshot of a specific session.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_session_snapshot_with_http_info(session, async_req=True)
-        >>> result = thread.get()
-
-        :param session: This is a uuid that points to a session. (required)
-        :type session: str
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+    @validate_call
+    def authorize_auth0_without_preload_content(
+        self,
+        audience: Annotated[StrictStr, Field(description=" The unique identifier of the target API you want to access.")],
+        scope: Annotated[List[StrictStr], Field(description="The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OpenID Connect (OIDC) scopes about users, such as profile and email, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, read:contacts). Include offline_access to get a Refresh Token.")],
+        response_type: Annotated[StrictStr, Field(description="Indicates to Auth0 which OAuth 2.0 Flow you want to perform. Use code for Authorization Code Grant (PKCE) Flow.")],
+        client_id: Annotated[StrictStr, Field(description="Your application's Client ID.")],
+        code_challenge_method: Annotated[StrictStr, Field(description="Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged.")],
+        code_challenge: Annotated[StrictStr, Field(description="Generated challenge from the code_verifier.")],
+        response_mode: StrictStr,
+        state: Annotated[Optional[StrictStr], Field(description="An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.")] = None,
+        redirect_uri: Annotated[Optional[StrictStr], Field(description="The URL to which Auth0 will redirect the browser after authorization has been granted by the user.")] = None,
+        connection: Annotated[Optional[StrictStr], Field(description="The name of the connection configured to your application.")] = None,
+        prompt: Annotated[Optional[StrictStr], Field(description="To initiate a silent authentication request, use prompt=none (see Remarks for more info).")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """https://auth.pieces.services/authorize [GET]
+
+        An endpoint that is used locally authenticate via a PKCE Flow.  Example https://auth.pieces.services /authorize?audience=https%3A%2F%2Fpieces.us.auth0.com%2Fapi%2Fv2%2F&scope=email+profile+offline_access+openid&response_type=code&client_id=9sW4Pa1LEjX67l6VO14u0207NLYeXnu1&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fpkce%2Fresponse%2Fcode&code_challenge_method=S256&code_challenge=yxRssZxdfBpMigRmDxAety1QU72Bd5WnDUbtlsCZOnk&response_mode=form_post&state=4bd0b9a389b4b229602346c33913b4c3c199628a90011ab3a901302ab62b3832
+
+        :param audience:  The unique identifier of the target API you want to access. (required)
+        :type audience: str
+        :param scope: The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OpenID Connect (OIDC) scopes about users, such as profile and email, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, read:contacts). Include offline_access to get a Refresh Token. (required)
+        :type scope: List[str]
+        :param response_type: Indicates to Auth0 which OAuth 2.0 Flow you want to perform. Use code for Authorization Code Grant (PKCE) Flow. (required)
+        :type response_type: str
+        :param client_id: Your application's Client ID. (required)
+        :type client_id: str
+        :param code_challenge_method: Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged. (required)
+        :type code_challenge_method: str
+        :param code_challenge: Generated challenge from the code_verifier. (required)
+        :type code_challenge: str
+        :param response_mode: (required)
+        :type response_mode: str
+        :param state: An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.
+        :type state: str
+        :param redirect_uri: The URL to which Auth0 will redirect the browser after authorization has been granted by the user.
+        :type redirect_uri: str
+        :param connection: The name of the connection configured to your application.
+        :type connection: str
+        :param prompt: To initiate a silent authentication request, use prompt=none (see Remarks for more info).
+        :type prompt: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(Session, status_code(int), headers(HTTPHeaderDict))
-        """
+        """ # noqa: E501
 
-        _params = locals()
+        _param = self._authorize_auth0_serialize(
+            audience=audience,
+            scope=scope,
+            response_type=response_type,
+            client_id=client_id,
+            code_challenge_method=code_challenge_method,
+            code_challenge=code_challenge,
+            response_mode=response_mode,
+            state=state,
+            redirect_uri=redirect_uri,
+            connection=connection,
+            prompt=prompt,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        _all_params = [
-            'session'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "ResultedPKCE",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
         )
+        return response_data.response
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method applications_session_snapshot" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
 
-        _collection_formats = {}
+    def _authorize_auth0_serialize(
+        self,
+        audience,
+        scope,
+        response_type,
+        client_id,
+        code_challenge_method,
+        code_challenge,
+        response_mode,
+        state,
+        redirect_uri,
+        connection,
+        prompt,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
 
-        # process the path parameters
-        _path_params = {}
-        if _params['session']:
-            _path_params['session'] = _params['session']
+        _host = None
 
+        _collection_formats: Dict[str, str] = {
+            'scope': 'ssv',
+        }
 
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, str] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
         # process the query parameters
-        _query_params = []
+        if audience is not None:
+            
+            _query_params.append(('audience', audience))
+            
+        if scope is not None:
+            
+            _query_params.append(('scope', scope))
+            
+        if response_type is not None:
+            
+            _query_params.append(('response_type', response_type))
+            
+        if client_id is not None:
+            
+            _query_params.append(('client_id', client_id))
+            
+        if state is not None:
+            
+            _query_params.append(('state', state))
+            
+        if redirect_uri is not None:
+            
+            _query_params.append(('redirect_uri', redirect_uri))
+            
+        if code_challenge_method is not None:
+            
+            _query_params.append(('code_challenge_method', code_challenge_method))
+            
+        if code_challenge is not None:
+            
+            _query_params.append(('code_challenge', code_challenge))
+            
+        if connection is not None:
+            
+            _query_params.append(('connection', connection))
+            
+        if prompt is not None:
+            
+            _query_params.append(('prompt', prompt))
+            
+        if response_mode is not None:
+            
+            _query_params.append(('response_mode', response_mode))
+            
         # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
-        _form_params = []
-        _files = {}
         # process the body parameter
-        _body_params = None
+
+
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+            [
+                'application/x-www-form-urlencoded'
+            ]
+        )
 
-        # authentication setting
-        _auth_settings = []  # noqa: E501
 
-        _response_types_map = {
-            '200': "Session",
-        }
+        # authentication setting
+        _auth_settings: List[str] = [
+        ]
 
-        return self.api_client.call_api(
-            '/applications/sessions/{session}', 'GET',
-            _path_params,
-            _query_params,
-            _header_params,
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/authorize',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
-            response_types_map=_response_types_map,
             auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+            _host=_host,
+            _request_auth=_request_auth
+        )
 
-    @validate_arguments
-    def applications_snapshot(self, **kwargs) -> Applications:  # noqa: E501
-        """/applications [GET]  # noqa: E501
-
-          # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_snapshot(async_req=True)
-        >>> result = thread.get()
-
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: Applications
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the applications_snapshot_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.applications_snapshot_with_http_info(**kwargs)  # noqa: E501
-
-    @validate_arguments
-    def applications_snapshot_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
-        """/applications [GET]  # noqa: E501
-
-          # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_snapshot_with_http_info(async_req=True)
-        >>> result = thread.get()
-
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+
+
+    @validate_call
+    def exchange_for_auth0_token(
+        self,
+        grant_type: Annotated[StrictStr, Field(description="Denotes the flow you are using. For Authorization Code, use authorization_code or refresh_token.")],
+        client_id: Annotated[StrictStr, Field(description="Your application's Client ID.")],
+        code: Annotated[StrictStr, Field(description="The Authorization Code received from the initial /authorize call.")],
+        redirect_uri: Annotated[StrictStr, Field(description="This is required only if it was set at the GET /authorize endpoint. The values must match.")],
+        code_verifier: Annotated[StrictStr, Field(description="Cryptographically random key that was used to generate the code_challenge passed to /authorize.")],
+        var_schema: Optional[EmbeddedModelSchema] = None,
+        audience: Annotated[Optional[StrictStr], Field(description="The audience domain: i.e. https://pieces.us.auth0.com")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> OAuthToken:
+        """https://auth.pieces.services/oauth/token [POST]
+
+        An endpoint to generate a OAuth Token for an authentication flow. 
+
+        :param grant_type: Denotes the flow you are using. For Authorization Code, use authorization_code or refresh_token. (required)
+        :type grant_type: str
+        :param client_id: Your application's Client ID. (required)
+        :type client_id: str
+        :param code: The Authorization Code received from the initial /authorize call. (required)
+        :type code: str
+        :param redirect_uri: This is required only if it was set at the GET /authorize endpoint. The values must match. (required)
+        :type redirect_uri: str
+        :param code_verifier: Cryptographically random key that was used to generate the code_challenge passed to /authorize. (required)
+        :type code_verifier: str
+        :param var_schema:
+        :type var_schema: EmbeddedModelSchema
+        :param audience: The audience domain: i.e. https://pieces.us.auth0.com
+        :type audience: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(Applications, status_code(int), headers(HTTPHeaderDict))
-        """
-
-        _params = locals()
+        """ # noqa: E501
 
-        _all_params = [
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _param = self._exchange_for_auth0_token_serialize(
+            grant_type=grant_type,
+            client_id=client_id,
+            code=code,
+            redirect_uri=redirect_uri,
+            code_verifier=code_verifier,
+            var_schema=var_schema,
+            audience=audience,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
         )
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method applications_snapshot" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
-
-        _collection_formats = {}
-
-        # process the path parameters
-        _path_params = {}
-
-        # process the query parameters
-        _query_params = []
-        # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
-        # process the form parameters
-        _form_params = []
-        _files = {}
-        # process the body parameter
-        _body_params = None
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
-        # authentication setting
-        _auth_settings = []  # noqa: E501
-
-        _response_types_map = {
-            '200': "Applications",
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "OAuthToken",
         }
-
-        return self.api_client.call_api(
-            '/applications', 'GET',
-            _path_params,
-            _query_params,
-            _header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
             response_types_map=_response_types_map,
-            auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
-            collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+        ).data
 
-    @validate_arguments
-    def applications_specific_application_snapshot(self, application : Annotated[StrictStr, Field(..., description="This is a uuid that represents an application")], **kwargs) -> Application:  # noqa: E501
-        """/applications/{application} [GET]  # noqa: E501
-
-        This will retrieve snapshot of a single application.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_specific_application_snapshot(application, async_req=True)
-        >>> result = thread.get()
-
-        :param application: This is a uuid that represents an application (required)
-        :type application: str
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: Application
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the applications_specific_application_snapshot_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.applications_specific_application_snapshot_with_http_info(application, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def applications_specific_application_snapshot_with_http_info(self, application : Annotated[StrictStr, Field(..., description="This is a uuid that represents an application")], **kwargs) -> ApiResponse:  # noqa: E501
-        """/applications/{application} [GET]  # noqa: E501
-
-        This will retrieve snapshot of a single application.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_specific_application_snapshot_with_http_info(application, async_req=True)
-        >>> result = thread.get()
-
-        :param application: This is a uuid that represents an application (required)
-        :type application: str
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+    @validate_call
+    def exchange_for_auth0_token_with_http_info(
+        self,
+        grant_type: Annotated[StrictStr, Field(description="Denotes the flow you are using. For Authorization Code, use authorization_code or refresh_token.")],
+        client_id: Annotated[StrictStr, Field(description="Your application's Client ID.")],
+        code: Annotated[StrictStr, Field(description="The Authorization Code received from the initial /authorize call.")],
+        redirect_uri: Annotated[StrictStr, Field(description="This is required only if it was set at the GET /authorize endpoint. The values must match.")],
+        code_verifier: Annotated[StrictStr, Field(description="Cryptographically random key that was used to generate the code_challenge passed to /authorize.")],
+        var_schema: Optional[EmbeddedModelSchema] = None,
+        audience: Annotated[Optional[StrictStr], Field(description="The audience domain: i.e. https://pieces.us.auth0.com")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[OAuthToken]:
+        """https://auth.pieces.services/oauth/token [POST]
+
+        An endpoint to generate a OAuth Token for an authentication flow. 
+
+        :param grant_type: Denotes the flow you are using. For Authorization Code, use authorization_code or refresh_token. (required)
+        :type grant_type: str
+        :param client_id: Your application's Client ID. (required)
+        :type client_id: str
+        :param code: The Authorization Code received from the initial /authorize call. (required)
+        :type code: str
+        :param redirect_uri: This is required only if it was set at the GET /authorize endpoint. The values must match. (required)
+        :type redirect_uri: str
+        :param code_verifier: Cryptographically random key that was used to generate the code_challenge passed to /authorize. (required)
+        :type code_verifier: str
+        :param var_schema:
+        :type var_schema: EmbeddedModelSchema
+        :param audience: The audience domain: i.e. https://pieces.us.auth0.com
+        :type audience: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
-        """
-
-        _params = locals()
+        """ # noqa: E501
 
-        _all_params = [
-            'application'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _param = self._exchange_for_auth0_token_serialize(
+            grant_type=grant_type,
+            client_id=client_id,
+            code=code,
+            redirect_uri=redirect_uri,
+            code_verifier=code_verifier,
+            var_schema=var_schema,
+            audience=audience,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
         )
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method applications_specific_application_snapshot" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
-
-        _collection_formats = {}
-
-        # process the path parameters
-        _path_params = {}
-        if _params['application']:
-            _path_params['application'] = _params['application']
-
-
-        # process the query parameters
-        _query_params = []
-        # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
-        # process the form parameters
-        _form_params = []
-        _files = {}
-        # process the body parameter
-        _body_params = None
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
-        # authentication setting
-        _auth_settings = []  # noqa: E501
-
-        _response_types_map = {
-            '200': "Application",
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "OAuthToken",
         }
-
-        return self.api_client.call_api(
-            '/applications/{application}', 'GET',
-            _path_params,
-            _query_params,
-            _header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
             response_types_map=_response_types_map,
-            auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
-            collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+        )
 
-    @validate_arguments
-    def applications_usage_engagement_interaction(self, seeded_tracked_interaction_event : Optional[SeededTrackedInteractionEvent] = None, **kwargs) -> TrackedInteractionEvent:  # noqa: E501
-        """/applications/usage/engagement/interaction [POST] Scoped to Apps  # noqa: E501
-
-        This is an analytics endpoint that will enable us to know when a user engages something via an interaction(ie click/tap).  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_usage_engagement_interaction(seeded_tracked_interaction_event, async_req=True)
-        >>> result = thread.get()
-
-        :param seeded_tracked_interaction_event: 
-        :type seeded_tracked_interaction_event: SeededTrackedInteractionEvent
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: TrackedInteractionEvent
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the applications_usage_engagement_interaction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.applications_usage_engagement_interaction_with_http_info(seeded_tracked_interaction_event, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def applications_usage_engagement_interaction_with_http_info(self, seeded_tracked_interaction_event : Optional[SeededTrackedInteractionEvent] = None, **kwargs) -> ApiResponse:  # noqa: E501
-        """/applications/usage/engagement/interaction [POST] Scoped to Apps  # noqa: E501
-
-        This is an analytics endpoint that will enable us to know when a user engages something via an interaction(ie click/tap).  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_usage_engagement_interaction_with_http_info(seeded_tracked_interaction_event, async_req=True)
-        >>> result = thread.get()
-
-        :param seeded_tracked_interaction_event: 
-        :type seeded_tracked_interaction_event: SeededTrackedInteractionEvent
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+    @validate_call
+    def exchange_for_auth0_token_without_preload_content(
+        self,
+        grant_type: Annotated[StrictStr, Field(description="Denotes the flow you are using. For Authorization Code, use authorization_code or refresh_token.")],
+        client_id: Annotated[StrictStr, Field(description="Your application's Client ID.")],
+        code: Annotated[StrictStr, Field(description="The Authorization Code received from the initial /authorize call.")],
+        redirect_uri: Annotated[StrictStr, Field(description="This is required only if it was set at the GET /authorize endpoint. The values must match.")],
+        code_verifier: Annotated[StrictStr, Field(description="Cryptographically random key that was used to generate the code_challenge passed to /authorize.")],
+        var_schema: Optional[EmbeddedModelSchema] = None,
+        audience: Annotated[Optional[StrictStr], Field(description="The audience domain: i.e. https://pieces.us.auth0.com")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """https://auth.pieces.services/oauth/token [POST]
+
+        An endpoint to generate a OAuth Token for an authentication flow. 
+
+        :param grant_type: Denotes the flow you are using. For Authorization Code, use authorization_code or refresh_token. (required)
+        :type grant_type: str
+        :param client_id: Your application's Client ID. (required)
+        :type client_id: str
+        :param code: The Authorization Code received from the initial /authorize call. (required)
+        :type code: str
+        :param redirect_uri: This is required only if it was set at the GET /authorize endpoint. The values must match. (required)
+        :type redirect_uri: str
+        :param code_verifier: Cryptographically random key that was used to generate the code_challenge passed to /authorize. (required)
+        :type code_verifier: str
+        :param var_schema:
+        :type var_schema: EmbeddedModelSchema
+        :param audience: The audience domain: i.e. https://pieces.us.auth0.com
+        :type audience: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(TrackedInteractionEvent, status_code(int), headers(HTTPHeaderDict))
-        """
+        """ # noqa: E501
 
-        _params = locals()
+        _param = self._exchange_for_auth0_token_serialize(
+            grant_type=grant_type,
+            client_id=client_id,
+            code=code,
+            redirect_uri=redirect_uri,
+            code_verifier=code_verifier,
+            var_schema=var_schema,
+            audience=audience,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        _all_params = [
-            'seeded_tracked_interaction_event'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "OAuthToken",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
         )
+        return response_data.response
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method applications_usage_engagement_interaction" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
 
-        _collection_formats = {}
+    def _exchange_for_auth0_token_serialize(
+        self,
+        grant_type,
+        client_id,
+        code,
+        redirect_uri,
+        code_verifier,
+        var_schema,
+        audience,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
 
-        # process the path parameters
-        _path_params = {}
+        _host = None
 
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, str] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
         # process the query parameters
-        _query_params = []
         # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
-        _form_params = []
-        _files = {}
+        if var_schema is not None:
+            _form_params.append(('schema', var_schema))
+        if grant_type is not None:
+            _form_params.append(('grant_type', grant_type))
+        if client_id is not None:
+            _form_params.append(('client_id', client_id))
+        if code is not None:
+            _form_params.append(('code', code))
+        if redirect_uri is not None:
+            _form_params.append(('redirect_uri', redirect_uri))
+        if code_verifier is not None:
+            _form_params.append(('code_verifier', code_verifier))
+        if audience is not None:
+            _form_params.append(('audience', audience))
         # process the body parameter
-        _body_params = None
-        if _params['seeded_tracked_interaction_event'] is not None:
-            _body_params = _params['seeded_tracked_interaction_event']
+
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+            [
+                'application/json'
+            ]
+        )
 
         # set the HTTP header `Content-Type`
-        _content_types_list = _params.get('_content_type',
-            self.api_client.select_header_content_type(
-                ['application/json']))
-        if _content_types_list:
-                _header_params['Content-Type'] = _content_types_list
+        if _content_type:
+            _header_params['Content-Type'] = _content_type
+        else:
+            _default_content_type = (
+                self.api_client.select_header_content_type(
+                    [
+                        'application/x-www-form-urlencoded'
+                    ]
+                )
+            )
+            if _default_content_type is not None:
+                _header_params['Content-Type'] = _default_content_type
 
         # authentication setting
-        _auth_settings = []  # noqa: E501
-
-        _response_types_map = {
-            '200': "TrackedInteractionEvent",
-        }
+        _auth_settings: List[str] = [
+        ]
 
-        return self.api_client.call_api(
-            '/applications/usage/engagement/interaction', 'POST',
-            _path_params,
-            _query_params,
-            _header_params,
+        return self.api_client.param_serialize(
+            method='POST',
+            resource_path='/oauth/token',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
-            response_types_map=_response_types_map,
             auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def get_auth0_user_info(
+        self,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> Auth0User:
+        """https://auth.pieces.services/userinfo [GET]
+
+        Get the users info from the Auth0 API
 
-    @validate_arguments
-    def applications_usage_engagement_keyboard(self, seeded_tracked_keyboard_event : Optional[SeededTrackedKeyboardEvent] = None, **kwargs) -> TrackedKeyboardEvent:  # noqa: E501
-        """/applications/usage/engagement/keyboard [POST] Scoped to Apps  # noqa: E501
-
-        This is an analytics endpoint that will enable us to know when a user uses a keyboard short cut for any sort of engagement.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_usage_engagement_keyboard(seeded_tracked_keyboard_event, async_req=True)
-        >>> result = thread.get()
-
-        :param seeded_tracked_keyboard_event: 
-        :type seeded_tracked_keyboard_event: SeededTrackedKeyboardEvent
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: TrackedKeyboardEvent
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the applications_usage_engagement_keyboard_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.applications_usage_engagement_keyboard_with_http_info(seeded_tracked_keyboard_event, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def applications_usage_engagement_keyboard_with_http_info(self, seeded_tracked_keyboard_event : Optional[SeededTrackedKeyboardEvent] = None, **kwargs) -> ApiResponse:  # noqa: E501
-        """/applications/usage/engagement/keyboard [POST] Scoped to Apps  # noqa: E501
-
-        This is an analytics endpoint that will enable us to know when a user uses a keyboard short cut for any sort of engagement.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_usage_engagement_keyboard_with_http_info(seeded_tracked_keyboard_event, async_req=True)
-        >>> result = thread.get()
-
-        :param seeded_tracked_keyboard_event: 
-        :type seeded_tracked_keyboard_event: SeededTrackedKeyboardEvent
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(TrackedKeyboardEvent, status_code(int), headers(HTTPHeaderDict))
-        """
-
-        _params = locals()
+        """ # noqa: E501
 
-        _all_params = [
-            'seeded_tracked_keyboard_event'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _param = self._get_auth0_user_info_serialize(
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
         )
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method applications_usage_engagement_keyboard" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
-
-        _collection_formats = {}
-
-        # process the path parameters
-        _path_params = {}
-
-        # process the query parameters
-        _query_params = []
-        # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
-        # process the form parameters
-        _form_params = []
-        _files = {}
-        # process the body parameter
-        _body_params = None
-        if _params['seeded_tracked_keyboard_event'] is not None:
-            _body_params = _params['seeded_tracked_keyboard_event']
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
-        # set the HTTP header `Content-Type`
-        _content_types_list = _params.get('_content_type',
-            self.api_client.select_header_content_type(
-                ['application/json']))
-        if _content_types_list:
-                _header_params['Content-Type'] = _content_types_list
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "Auth0User",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
 
-        # authentication setting
-        _auth_settings = []  # noqa: E501
 
-        _response_types_map = {
-            '200': "TrackedKeyboardEvent",
-        }
+    @validate_call
+    def get_auth0_user_info_with_http_info(
+        self,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[Auth0User]:
+        """https://auth.pieces.services/userinfo [GET]
 
-        return self.api_client.call_api(
-            '/applications/usage/engagement/keyboard', 'POST',
-            _path_params,
-            _query_params,
-            _header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            response_types_map=_response_types_map,
-            auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
-            collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+        Get the users info from the Auth0 API
 
-    @validate_arguments
-    def applications_usage_installation(self, tracked_application_install : Optional[TrackedApplicationInstall] = None, **kwargs) -> None:  # noqa: E501
-        """/applications/usage/installation [POST]  # noqa: E501
-
-        This is an analytics endpoint that will enable us to know when a user has installed a version of Pieces  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_usage_installation(tracked_application_install, async_req=True)
-        >>> result = thread.get()
-
-        :param tracked_application_install: 
-        :type tracked_application_install: TrackedApplicationInstall
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: None
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the applications_usage_installation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.applications_usage_installation_with_http_info(tracked_application_install, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def applications_usage_installation_with_http_info(self, tracked_application_install : Optional[TrackedApplicationInstall] = None, **kwargs) -> ApiResponse:  # noqa: E501
-        """/applications/usage/installation [POST]  # noqa: E501
-
-        This is an analytics endpoint that will enable us to know when a user has installed a version of Pieces  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.applications_usage_installation_with_http_info(tracked_application_install, async_req=True)
-        >>> result = thread.get()
-
-        :param tracked_application_install: 
-        :type tracked_application_install: TrackedApplicationInstall
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: None
-        """
-
-        _params = locals()
+        """ # noqa: E501
 
-        _all_params = [
-            'tracked_application_install'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _param = self._get_auth0_user_info_serialize(
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
         )
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method applications_usage_installation" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
-
-        _collection_formats = {}
-
-        # process the path parameters
-        _path_params = {}
-
-        # process the query parameters
-        _query_params = []
-        # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
-        # process the form parameters
-        _form_params = []
-        _files = {}
-        # process the body parameter
-        _body_params = None
-        if _params['tracked_application_install'] is not None:
-            _body_params = _params['tracked_application_install']
-
-        # set the HTTP header `Content-Type`
-        _content_types_list = _params.get('_content_type',
-            self.api_client.select_header_content_type(
-                ['application/json']))
-        if _content_types_list:
-                _header_params['Content-Type'] = _content_types_list
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "Auth0User",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
 
-        # authentication setting
-        _auth_settings = []  # noqa: E501
 
-        _response_types_map = {}
+    @validate_call
+    def get_auth0_user_info_without_preload_content(
+        self,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """https://auth.pieces.services/userinfo [GET]
 
-        return self.api_client.call_api(
-            '/applications/usage/installation', 'POST',
-            _path_params,
-            _query_params,
-            _header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            response_types_map=_response_types_map,
-            auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
-            collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+        Get the users info from the Auth0 API
 
-    @validate_arguments
-    def post_applications_usage_updated(self, tracked_application_update : Annotated[Optional[TrackedApplicationUpdate], Field(description="Sending over the previous application version, the current version, and the user.")] = None, **kwargs) -> None:  # noqa: E501
-        """/applications/usage/updated [POST]  # noqa: E501
-
-        This is an endpoint to determine when an application has been updated   # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.post_applications_usage_updated(tracked_application_update, async_req=True)
-        >>> result = thread.get()
-
-        :param tracked_application_update: Sending over the previous application version, the current version, and the user.
-        :type tracked_application_update: TrackedApplicationUpdate
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: None
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the post_applications_usage_updated_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.post_applications_usage_updated_with_http_info(tracked_application_update, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def post_applications_usage_updated_with_http_info(self, tracked_application_update : Annotated[Optional[TrackedApplicationUpdate], Field(description="Sending over the previous application version, the current version, and the user.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
-        """/applications/usage/updated [POST]  # noqa: E501
-
-        This is an endpoint to determine when an application has been updated   # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.post_applications_usage_updated_with_http_info(tracked_application_update, async_req=True)
-        >>> result = thread.get()
-
-        :param tracked_application_update: Sending over the previous application version, the current version, and the user.
-        :type tracked_application_update: TrackedApplicationUpdate
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: None
-        """
+        """ # noqa: E501
 
-        _params = locals()
+        _param = self._get_auth0_user_info_serialize(
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        _all_params = [
-            'tracked_application_update'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "Auth0User",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
         )
+        return response_data.response
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method post_applications_usage_updated" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
 
-        _collection_formats = {}
+    def _get_auth0_user_info_serialize(
+        self,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
 
-        # process the path parameters
-        _path_params = {}
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
 
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, str] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
         # process the query parameters
-        _query_params = []
         # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
-        _form_params = []
-        _files = {}
         # process the body parameter
-        _body_params = None
-        if _params['tracked_application_update'] is not None:
-            _body_params = _params['tracked_application_update']
 
-        # set the HTTP header `Content-Type`
-        _content_types_list = _params.get('_content_type',
-            self.api_client.select_header_content_type(
-                ['application/json']))
-        if _content_types_list:
-                _header_params['Content-Type'] = _content_types_list
 
-        # authentication setting
-        _auth_settings = []  # noqa: E501
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
 
-        _response_types_map = {}
+        # authentication setting
+        _auth_settings: List[str] = [
+            'auth0', 
+            'auth0', 
+            'auth0'
+        ]
 
-        return self.api_client.call_api(
-            '/applications/usage/updated', 'POST',
-            _path_params,
-            _query_params,
-            _header_params,
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/userinfo',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
-            response_types_map=_response_types_map,
             auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/api/distribution_api.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/api/image_analyses_api.py`

 * *Files 26% similar despite different names*

```diff
@@ -8,330 +8,295 @@
     The version of the OpenAPI document: 1.0
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import re  # noqa: F401
-import io
 import warnings
-
-from pydantic import validate_arguments, ValidationError
-
+from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import Field, StrictStr
 
+from pydantic import Field, StrictBool
 from typing import Optional
+from typing_extensions import Annotated
+from pieces_os_client.models.image_analyses import ImageAnalyses
 
-from pieces_os_client.models.distribution import Distribution
-
-from pieces_os_client.api_client import ApiClient
+from pieces_os_client.api_client import ApiClient, RequestSerialized
 from pieces_os_client.api_response import ApiResponse
-from pieces_os_client.exceptions import (  # noqa: F401
-    ApiTypeError,
-    ApiValueError
-)
+from pieces_os_client.rest import RESTResponseType
 
 
-class DistributionApi:
+class ImageAnalysesApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None) -> None:
         if api_client is None:
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
-    @validate_arguments
-    def distribution_update(self, distribution : Optional[Distribution] = None, **kwargs) -> Distribution:  # noqa: E501
-        """/distribution/update [POST]  # noqa: E501
-
-        This will update a specific Distribution.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.distribution_update(distribution, async_req=True)
-        >>> result = thread.get()
-
-        :param distribution:
-        :type distribution: Distribution
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: Distribution
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the distribution_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.distribution_update_with_http_info(distribution, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def distribution_update_with_http_info(self, distribution : Optional[Distribution] = None, **kwargs) -> ApiResponse:  # noqa: E501
-        """/distribution/update [POST]  # noqa: E501
-
-        This will update a specific Distribution.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.distribution_update_with_http_info(distribution, async_req=True)
-        >>> result = thread.get()
-
-        :param distribution:
-        :type distribution: Distribution
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+    @validate_call
+    def image_analyses_snapshot(
+        self,
+        transferables: Annotated[Optional[StrictBool], Field(description="This is a boolean that will decided if we are want to return the transferable data (default) or not(performance enhancement)")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ImageAnalyses:
+        """Your GET endpoint
+
+        This will get a snapshot of all of your code analyses, a code analysis is attached to an image analysis.
+
+        :param transferables: This is a boolean that will decided if we are want to return the transferable data (default) or not(performance enhancement)
+        :type transferables: bool
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(Distribution, status_code(int), headers(HTTPHeaderDict))
-        """
+        """ # noqa: E501
 
-        _params = locals()
-
-        _all_params = [
-            'distribution'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _param = self._image_analyses_snapshot_serialize(
+            transferables=transferables,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
         )
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method distribution_update" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "ImageAnalyses",
+            '500': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
 
-        _collection_formats = {}
 
-        # process the path parameters
-        _path_params = {}
-
-        # process the query parameters
-        _query_params = []
-        # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
-        # process the form parameters
-        _form_params = []
-        _files = {}
-        # process the body parameter
-        _body_params = None
-        if _params['distribution'] is not None:
-            _body_params = _params['distribution']
+    @validate_call
+    def image_analyses_snapshot_with_http_info(
+        self,
+        transferables: Annotated[Optional[StrictBool], Field(description="This is a boolean that will decided if we are want to return the transferable data (default) or not(performance enhancement)")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[ImageAnalyses]:
+        """Your GET endpoint
 
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        This will get a snapshot of all of your code analyses, a code analysis is attached to an image analysis.
 
-        # set the HTTP header `Content-Type`
-        _content_types_list = _params.get('_content_type',
-            self.api_client.select_header_content_type(
-                ['application/json']))
-        if _content_types_list:
-                _header_params['Content-Type'] = _content_types_list
+        :param transferables: This is a boolean that will decided if we are want to return the transferable data (default) or not(performance enhancement)
+        :type transferables: bool
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
 
-        # authentication setting
-        _auth_settings = []  # noqa: E501
+        _param = self._image_analyses_snapshot_serialize(
+            transferables=transferables,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        _response_types_map = {
-            '200': "Distribution",
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "ImageAnalyses",
             '500': "str",
         }
-
-        return self.api_client.call_api(
-            '/distribution/update', 'POST',
-            _path_params,
-            _query_params,
-            _header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
             response_types_map=_response_types_map,
-            auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
-            collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+        )
 
-    @validate_arguments
-    def distributions_specific_distribution_snapshot(self, distribution : Annotated[StrictStr, Field(..., description="This is the uuid of a specific distribution.")], **kwargs) -> Distribution:  # noqa: E501
-        """/distribution/{distribution} [GET]  # noqa: E501
-
-        This will get a specific snapshot of a distribution.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.distributions_specific_distribution_snapshot(distribution, async_req=True)
-        >>> result = thread.get()
-
-        :param distribution: This is the uuid of a specific distribution. (required)
-        :type distribution: str
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _request_timeout: timeout setting for this request.
-               If one number provided, it will be total request
-               timeout. It can also be a pair (tuple) of
-               (connection, read) timeouts.
-        :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: Distribution
-        """
-        kwargs['_return_http_data_only'] = True
-        if '_preload_content' in kwargs:
-            message = "Error! Please call the distributions_specific_distribution_snapshot_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
-            raise ValueError(message)
-        return self.distributions_specific_distribution_snapshot_with_http_info(distribution, **kwargs)  # noqa: E501
-
-    @validate_arguments
-    def distributions_specific_distribution_snapshot_with_http_info(self, distribution : Annotated[StrictStr, Field(..., description="This is the uuid of a specific distribution.")], **kwargs) -> ApiResponse:  # noqa: E501
-        """/distribution/{distribution} [GET]  # noqa: E501
-
-        This will get a specific snapshot of a distribution.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-
-        >>> thread = api.distributions_specific_distribution_snapshot_with_http_info(distribution, async_req=True)
-        >>> result = thread.get()
-
-        :param distribution: This is the uuid of a specific distribution. (required)
-        :type distribution: str
-        :param async_req: Whether to execute the request asynchronously.
-        :type async_req: bool, optional
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :type _preload_content: bool, optional
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :type _return_http_data_only: bool, optional
+
+    @validate_call
+    def image_analyses_snapshot_without_preload_content(
+        self,
+        transferables: Annotated[Optional[StrictBool], Field(description="This is a boolean that will decided if we are want to return the transferable data (default) or not(performance enhancement)")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Your GET endpoint
+
+        This will get a snapshot of all of your code analyses, a code analysis is attached to an image analysis.
+
+        :param transferables: This is a boolean that will decided if we are want to return the transferable data (default) or not(performance enhancement)
+        :type transferables: bool
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
         :type _request_auth: dict, optional
-        :type _content_type: string, optional: force content-type for the request
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
         :return: Returns the result object.
-                 If the method is called asynchronously,
-                 returns the request thread.
-        :rtype: tuple(Distribution, status_code(int), headers(HTTPHeaderDict))
-        """
+        """ # noqa: E501
 
-        _params = locals()
+        _param = self._image_analyses_snapshot_serialize(
+            transferables=transferables,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        _all_params = [
-            'distribution'
-        ]
-        _all_params.extend(
-            [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers'
-            ]
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "ImageAnalyses",
+            '500': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
         )
+        return response_data.response
 
-        # validate the arguments
-        for _key, _val in _params['kwargs'].items():
-            if _key not in _all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method distributions_specific_distribution_snapshot" % _key
-                )
-            _params[_key] = _val
-        del _params['kwargs']
 
-        _collection_formats = {}
+    def _image_analyses_snapshot_serialize(
+        self,
+        transferables,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
 
-        # process the path parameters
-        _path_params = {}
-        if _params['distribution']:
-            _path_params['distribution'] = _params['distribution']
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
 
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, str] = {}
+        _body_params: Optional[bytes] = None
 
+        # process the path parameters
         # process the query parameters
-        _query_params = []
+        if transferables is not None:
+            
+            _query_params.append(('transferables', transferables))
+            
         # process the header parameters
-        _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
-        _form_params = []
-        _files = {}
         # process the body parameter
-        _body_params = None
+
+
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+            [
+                'application/json'
+            ]
+        )
 
-        # authentication setting
-        _auth_settings = []  # noqa: E501
 
-        _response_types_map = {
-            '200': "Distribution",
-            '410': "str",
-            '500': "str",
-        }
+        # authentication setting
+        _auth_settings: List[str] = [
+        ]
 
-        return self.api_client.call_api(
-            '/distribution/{distribution}', 'GET',
-            _path_params,
-            _query_params,
-            _header_params,
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/image_analyses',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
-            response_types_map=_response_types_map,
             auth_settings=_auth_settings,
-            async_req=_params.get('async_req'),
-            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=_params.get('_preload_content', True),
-            _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
-            _request_auth=_params.get('_request_auth'))
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/api_client.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/api_client.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,32 +9,41 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
-import atexit
 import datetime
 from dateutil.parser import parse
+from enum import Enum
 import json
 import mimetypes
-from multiprocessing.pool import ThreadPool
 import os
 import re
 import tempfile
 
 from urllib.parse import quote
+from typing import Tuple, Optional, List, Dict
 
 from pieces_os_client.configuration import Configuration
-from pieces_os_client.api_response import ApiResponse
+from pieces_os_client.api_response import ApiResponse, T as ApiResponseT
 import pieces_os_client.models
 from pieces_os_client import rest
-from pieces_os_client.exceptions import ApiValueError, ApiException
+from pieces_os_client.exceptions import (
+    ApiValueError,
+    ApiException,
+    BadRequestException,
+    UnauthorizedException,
+    ForbiddenException,
+    NotFoundException,
+    ServiceException
+)
 
+RequestSerialized = Tuple[str, str, Dict[str, str], Optional[str], List[str]]
 
 class ApiClient:
     """Generic API client for OpenAPI client library builds.
 
     OpenAPI generic API client. This client handles the client-
     server communication, and is invariant across implementations. Specifics of
     the methods and models for each application are generated from the OpenAPI
@@ -42,16 +51,14 @@
 
     :param configuration: .Configuration object for this client
     :param header_name: a header to pass when making calls to the API.
     :param header_value: a header value to pass when making calls to
         the API.
     :param cookie: a cookie to include in the header when making calls
         to the API
-    :param pool_threads: The number of threads to use for async requests
-        to the API. More threads means more concurrent API requests.
     """
 
     PRIMITIVE_TYPES = (float, bool, bytes, str, int)
     NATIVE_TYPES_MAPPING = {
         'int': int,
         'long': int, # TODO remove as only py3 is supported?
         'float': float,
@@ -59,54 +66,40 @@
         'bool': bool,
         'date': datetime.date,
         'datetime': datetime.datetime,
         'object': object,
     }
     _pool = None
 
-    def __init__(self, configuration=None, header_name=None, header_value=None,
-                 cookie=None, pool_threads=1) -> None:
+    def __init__(
+        self,
+        configuration=None,
+        header_name=None,
+        header_value=None,
+        cookie=None
+    ) -> None:
         # use default configuration if none is provided
         if configuration is None:
             configuration = Configuration.get_default()
         self.configuration = configuration
-        self.pool_threads = pool_threads
 
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
         self.user_agent = 'OpenAPI-Generator/1.0.0/python'
         self.client_side_validation = configuration.client_side_validation
 
     def __enter__(self):
         return self
 
     def __exit__(self, exc_type, exc_value, traceback):
-        self.close()
-
-    def close(self):
-        if self._pool:
-            self._pool.close()
-            self._pool.join()
-            self._pool = None
-            if hasattr(atexit, 'unregister'):
-                atexit.unregister(self.close)
-
-    @property
-    def pool(self):
-        """Create thread pool on first request
-         avoids instantiating unused threadpool for blocking clients.
-        """
-        if self._pool is None:
-            atexit.register(self.close)
-            self._pool = ThreadPool(self.pool_threads)
-        return self._pool
+        pass
 
     @property
     def user_agent(self):
         """User agent for this API client"""
         return self.default_headers['User-Agent']
 
     @user_agent.setter
@@ -139,59 +132,98 @@
 
         It stores default ApiClient.
 
         :param default: object of ApiClient.
         """
         cls._default = default
 
-    def __call_api(
-            self, resource_path, method, path_params=None,
-            query_params=None, header_params=None, body=None, post_params=None,
-            files=None, response_types_map=None, auth_settings=None,
-            _return_http_data_only=None, collection_formats=None,
-            _preload_content=True, _request_timeout=None, _host=None,
-            _request_auth=None):
+    def param_serialize(
+        self,
+        method,
+        resource_path,
+        path_params=None,
+        query_params=None,
+        header_params=None,
+        body=None,
+        post_params=None,
+        files=None, auth_settings=None,
+        collection_formats=None,
+        _host=None,
+        _request_auth=None
+    ) -> RequestSerialized:
+
+        """Builds the HTTP request params needed by the request.
+        :param method: Method to call.
+        :param resource_path: Path to method endpoint.
+        :param path_params: Path parameters in the url.
+        :param query_params: Query parameters in the url.
+        :param header_params: Header parameters to be
+            placed in the request header.
+        :param body: Request body.
+        :param post_params dict: Request post form parameters,
+            for `application/x-www-form-urlencoded`, `multipart/form-data`.
+        :param auth_settings list: Auth Settings names for the request.
+        :param files dict: key -> filename, value -> filepath,
+            for `multipart/form-data`.
+        :param collection_formats: dict of collection formats for path, query,
+            header, and post parameters.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :return: tuple of form (path, http_method, query_params, header_params,
+            body, post_params, files)
+        """
 
         config = self.configuration
 
         # header parameters
         header_params = header_params or {}
         header_params.update(self.default_headers)
         if self.cookie:
             header_params['Cookie'] = self.cookie
         if header_params:
             header_params = self.sanitize_for_serialization(header_params)
-            header_params = dict(self.parameters_to_tuples(header_params,
-                                                           collection_formats))
+            header_params = dict(
+                self.parameters_to_tuples(header_params,collection_formats)
+            )
 
         # path parameters
         if path_params:
             path_params = self.sanitize_for_serialization(path_params)
-            path_params = self.parameters_to_tuples(path_params,
-                                                    collection_formats)
+            path_params = self.parameters_to_tuples(
+                path_params,
+                collection_formats
+            )
             for k, v in path_params:
                 # specified safe chars, encode everything
                 resource_path = resource_path.replace(
                     '{%s}' % k,
                     quote(str(v), safe=config.safe_chars_for_path_param)
                 )
 
         # post parameters
         if post_params or files:
             post_params = post_params if post_params else []
             post_params = self.sanitize_for_serialization(post_params)
-            post_params = self.parameters_to_tuples(post_params,
-                                                    collection_formats)
+            post_params = self.parameters_to_tuples(
+                post_params,
+                collection_formats
+            )
             post_params.extend(self.files_parameters(files))
 
         # auth setting
         self.update_params_for_auth(
-            header_params, query_params, auth_settings,
-            resource_path, method, body,
-            request_auth=_request_auth)
+            header_params,
+            query_params,
+            auth_settings,
+            resource_path,
+            method,
+            body,
+            request_auth=_request_auth
+        )
 
         # body
         if body:
             body = self.sanitize_for_serialization(body)
 
         # request url
         if _host is None:
@@ -199,67 +231,107 @@
         else:
             # use server/host defined in path or operation instead
             url = _host + resource_path
 
         # query parameters
         if query_params:
             query_params = self.sanitize_for_serialization(query_params)
-            url_query = self.parameters_to_url_query(query_params,
-                                                     collection_formats)
+            url_query = self.parameters_to_url_query(
+                query_params,
+                collection_formats
+            )
             url += "?" + url_query
 
+        return method, url, header_params, body, post_params
+
+
+    def call_api(
+        self,
+        method,
+        url,
+        header_params=None,
+        body=None,
+        post_params=None,
+        _request_timeout=None
+    ) -> rest.RESTResponse:
+        """Makes the HTTP request (synchronous)
+        :param method: Method to call.
+        :param url: Path to method endpoint.
+        :param header_params: Header parameters to be
+            placed in the request header.
+        :param body: Request body.
+        :param post_params dict: Request post form parameters,
+            for `application/x-www-form-urlencoded`, `multipart/form-data`.
+        :param _request_timeout: timeout setting for this request.
+        :return: RESTResponse
+        """
+
         try:
             # perform request and return response
-            response_data = self.request(
+            response_data = self.rest_client.request(
                 method, url,
-                query_params=query_params,
                 headers=header_params,
-                post_params=post_params, body=body,
-                _preload_content=_preload_content,
-                _request_timeout=_request_timeout)
+                body=body, post_params=post_params,
+                _request_timeout=_request_timeout
+            )
+
         except ApiException as e:
-            if e.body:
-                e.body = e.body.decode('utf-8')
             raise e
 
-        self.last_response = response_data
+        return response_data
 
-        return_data = None # assuming derialization is not needed
-        # data needs deserialization or returns HTTP data (deserialized) only
-        if _preload_content or _return_http_data_only:
-          response_type = response_types_map.get(str(response_data.status), None)
-          if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
-              # if not found, look for '1XX', '2XX', etc.
-              response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)
-
-          if response_type == "bytearray":
-              response_data.data = response_data.data
-          else:
-              match = None
-              content_type = response_data.getheader('content-type')
-              if content_type is not None:
-                  match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
-              encoding = match.group(1) if match else "utf-8"
-              response_data.data = response_data.data.decode(encoding)
-
-          # deserialize response data
-          if response_type == "bytearray":
-              return_data = response_data.data
-          elif response_type:
-              return_data = self.deserialize(response_data, response_type)
-          else:
-              return_data = None
+    def response_deserialize(
+        self,
+        response_data: rest.RESTResponse,
+        response_types_map: Optional[Dict[str, ApiResponseT]]=None
+    ) -> ApiResponse[ApiResponseT]:
+        """Deserializes response into an object.
+        :param response_data: RESTResponse object to be deserialized.
+        :param response_types_map: dict of response types.
+        :return: ApiResponse
+        """
+
+        msg = "RESTResponse.read() must be called before passing it to response_deserialize()"
+        assert response_data.data is not None, msg
+
+        response_type = response_types_map.get(str(response_data.status), None)
+        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
+            # if not found, look for '1XX', '2XX', etc.
+            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)
+
+        # deserialize response data
+        response_text = None
+        return_data = None
+        try:
+            if response_type == "bytearray":
+                return_data = response_data.data
+            elif response_type == "file":
+                return_data = self.__deserialize_file(response_data)
+            elif response_type is not None:
+                match = None
+                content_type = response_data.getheader('content-type')
+                if content_type is not None:
+                    match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
+                encoding = match.group(1) if match else "utf-8"
+                response_text = response_data.data.decode(encoding)
+                return_data = self.deserialize(response_text, response_type)
+        finally:
+            if not 200 <= response_data.status <= 299:
+                raise ApiException.from_response(
+                    http_resp=response_data,
+                    body=response_text,
+                    data=return_data,
+                )
 
-        if _return_http_data_only:
-            return return_data
-        else:
-            return ApiResponse(status_code = response_data.status,
-                           data = return_data,
-                           headers = response_data.getheaders(),
-                           raw_data = response_data.data)
+        return ApiResponse(
+            status_code = response_data.status,
+            data = return_data,
+            headers = response_data.getheaders(),
+            raw_data = response_data.data
+        )
 
     def sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
 
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
@@ -272,54 +344,54 @@
         :return: The serialized form of data.
         """
         if obj is None:
             return None
         elif isinstance(obj, self.PRIMITIVE_TYPES):
             return obj
         elif isinstance(obj, list):
-            return [self.sanitize_for_serialization(sub_obj)
-                    for sub_obj in obj]
+            return [
+                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
+            ]
         elif isinstance(obj, tuple):
-            return tuple(self.sanitize_for_serialization(sub_obj)
-                         for sub_obj in obj)
+            return tuple(
+                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
+            )
         elif isinstance(obj, (datetime.datetime, datetime.date)):
             return obj.isoformat()
 
-        if isinstance(obj, dict):
+        elif isinstance(obj, dict):
             obj_dict = obj
         else:
             # Convert model obj to dict except
             # attributes `openapi_types`, `attribute_map`
             # and attributes which value is not None.
             # Convert attribute name to json key in
             # model definition for request.
             obj_dict = obj.to_dict()
 
-        return {key: self.sanitize_for_serialization(val)
-                for key, val in obj_dict.items()}
+        return {
+            key: self.sanitize_for_serialization(val)
+            for key, val in obj_dict.items()
+        }
 
-    def deserialize(self, response, response_type):
+    def deserialize(self, response_text, response_type):
         """Deserializes response into an object.
 
         :param response: RESTResponse object to be deserialized.
         :param response_type: class literal for
             deserialized object, or string of class name.
 
         :return: deserialized object.
         """
-        # handle file downloading
-        # save response body into a tmp file and return the instance
-        if response_type == "file":
-            return self.__deserialize_file(response)
 
         # fetch data from response object
         try:
-            data = json.loads(response.data)
+            data = json.loads(response_text)
         except ValueError:
-            data = response.data
+            data = response_text
 
         return self.__deserialize(data, response_type)
 
     def __deserialize(self, data, klass):
         """Deserializes dict, list, str into an object.
 
         :param data: dict, list or str.
@@ -328,20 +400,24 @@
         :return: object.
         """
         if data is None:
             return None
 
         if isinstance(klass, str):
             if klass.startswith('List['):
-                sub_kls = re.match(r'List\[(.*)]', klass).group(1)
+                m = re.match(r'List\[(.*)]', klass)
+                assert m is not None, "Malformed List type definition"
+                sub_kls = m.group(1)
                 return [self.__deserialize(sub_data, sub_kls)
                         for sub_data in data]
 
             if klass.startswith('Dict['):
-                sub_kls = re.match(r'Dict\[([^,]*), (.*)]', klass).group(2)
+                m = re.match(r'Dict\[([^,]*), (.*)]', klass)
+                assert m is not None, "Malformed Dict type definition"
+                sub_kls = m.group(2)
                 return {k: self.__deserialize(v, sub_kls)
                         for k, v in data.items()}
 
             # convert str to class
             if klass in self.NATIVE_TYPES_MAPPING:
                 klass = self.NATIVE_TYPES_MAPPING[klass]
             else:
@@ -351,157 +427,30 @@
             return self.__deserialize_primitive(data, klass)
         elif klass == object:
             return self.__deserialize_object(data)
         elif klass == datetime.date:
             return self.__deserialize_date(data)
         elif klass == datetime.datetime:
             return self.__deserialize_datetime(data)
+        elif issubclass(klass, Enum):
+            return self.__deserialize_enum(data, klass)
         else:
             return self.__deserialize_model(data, klass)
 
-    def call_api(self, resource_path, method,
-                 path_params=None, query_params=None, header_params=None,
-                 body=None, post_params=None, files=None,
-                 response_types_map=None, auth_settings=None,
-                 async_req=None, _return_http_data_only=None,
-                 collection_formats=None, _preload_content=True,
-                 _request_timeout=None, _host=None, _request_auth=None):
-        """Makes the HTTP request (synchronous) and returns deserialized data.
-
-        To make an async_req request, set the async_req parameter.
-
-        :param resource_path: Path to method endpoint.
-        :param method: Method to call.
-        :param path_params: Path parameters in the url.
-        :param query_params: Query parameters in the url.
-        :param header_params: Header parameters to be
-            placed in the request header.
-        :param body: Request body.
-        :param post_params dict: Request post form parameters,
-            for `application/x-www-form-urlencoded`, `multipart/form-data`.
-        :param auth_settings list: Auth Settings names for the request.
-        :param response: Response data type.
-        :param files dict: key -> filename, value -> filepath,
-            for `multipart/form-data`.
-        :param async_req bool: execute request asynchronously
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :param collection_formats: dict of collection formats for path, query,
-            header, and post parameters.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
-        :type _request_token: dict, optional
-        :return:
-            If async_req parameter is True,
-            the request will be called asynchronously.
-            The method will return the request thread.
-            If parameter async_req is False or missing,
-            then the method will return the response directly.
-        """
-        if not async_req:
-            return self.__call_api(resource_path, method,
-                                   path_params, query_params, header_params,
-                                   body, post_params, files,
-                                   response_types_map, auth_settings,
-                                   _return_http_data_only, collection_formats,
-                                   _preload_content, _request_timeout, _host,
-                                   _request_auth)
-
-        return self.pool.apply_async(self.__call_api, (resource_path,
-                                                       method, path_params,
-                                                       query_params,
-                                                       header_params, body,
-                                                       post_params, files,
-                                                       response_types_map,
-                                                       auth_settings,
-                                                       _return_http_data_only,
-                                                       collection_formats,
-                                                       _preload_content,
-                                                       _request_timeout,
-                                                       _host, _request_auth))
-
-    def request(self, method, url, query_params=None, headers=None,
-                post_params=None, body=None, _preload_content=True,
-                _request_timeout=None):
-        """Makes the HTTP request using RESTClient."""
-        if method == "GET":
-            return self.rest_client.get_request(url,
-                                        query_params=query_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        headers=headers)
-        elif method == "HEAD":
-            return self.rest_client.head_request(url,
-                                         query_params=query_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         headers=headers)
-        elif method == "OPTIONS":
-            return self.rest_client.options_request(url,
-                                            query_params=query_params,
-                                            headers=headers,
-                                            _preload_content=_preload_content,
-                                            _request_timeout=_request_timeout)
-        elif method == "POST":
-            return self.rest_client.post_request(url,
-                                         query_params=query_params,
-                                         headers=headers,
-                                         post_params=post_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         body=body)
-        elif method == "PUT":
-            return self.rest_client.put_request(url,
-                                        query_params=query_params,
-                                        headers=headers,
-                                        post_params=post_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        body=body)
-        elif method == "PATCH":
-            return self.rest_client.patch_request(url,
-                                          query_params=query_params,
-                                          headers=headers,
-                                          post_params=post_params,
-                                          _preload_content=_preload_content,
-                                          _request_timeout=_request_timeout,
-                                          body=body)
-        elif method == "DELETE":
-            return self.rest_client.delete_request(url,
-                                           query_params=query_params,
-                                           headers=headers,
-                                           _preload_content=_preload_content,
-                                           _request_timeout=_request_timeout,
-                                           body=body)
-        else:
-            raise ApiValueError(
-                "http method must be `GET`, `HEAD`, `OPTIONS`,"
-                " `POST`, `PATCH`, `PUT` or `DELETE`."
-            )
-
     def parameters_to_tuples(self, params, collection_formats):
         """Get parameters as list of tuples, formatting collections.
 
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: Parameters as list of tuples, collections formatted
         """
-        new_params = []
+        new_params: List[Tuple[str, str]] = []
         if collection_formats is None:
             collection_formats = {}
-        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
+        for k, v in params.items() if isinstance(params, dict) else params:
             if k in collection_formats:
                 collection_format = collection_formats[k]
                 if collection_format == 'multi':
                     new_params.extend((k, value) for value in v)
                 else:
                     if collection_format == 'ssv':
                         delimiter = ' '
@@ -520,44 +469,45 @@
     def parameters_to_url_query(self, params, collection_formats):
         """Get parameters as list of tuples, formatting collections.
 
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: URL query string (e.g. a=Hello%20World&b=123)
         """
-        new_params = []
+        new_params: List[Tuple[str, str]] = []
         if collection_formats is None:
             collection_formats = {}
-        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
-            if isinstance(v, (int, float)):
-                v = str(v)
+        for k, v in params.items() if isinstance(params, dict) else params:
             if isinstance(v, bool):
                 v = str(v).lower()
+            if isinstance(v, (int, float)):
+                v = str(v)
             if isinstance(v, dict):
                 v = json.dumps(v)
 
             if k in collection_formats:
                 collection_format = collection_formats[k]
                 if collection_format == 'multi':
-                    new_params.extend((k, value) for value in v)
+                    new_params.extend((k, str(value)) for value in v)
                 else:
                     if collection_format == 'ssv':
                         delimiter = ' '
                     elif collection_format == 'tsv':
                         delimiter = '\t'
                     elif collection_format == 'pipes':
                         delimiter = '|'
                     else:  # csv is the default
                         delimiter = ','
                     new_params.append(
-                        (k, delimiter.join(quote(str(value)) for value in v)))
+                        (k, delimiter.join(quote(str(value)) for value in v))
+                    )
             else:
                 new_params.append((k, quote(str(v))))
 
-        return "&".join(["=".join(item) for item in new_params])
+        return "&".join(["=".join(map(str, item)) for item in new_params])
 
     def files_parameters(self, files=None):
         """Builds form parameters.
 
         :param files: File parameters.
         :return: Form parameters with files.
         """
@@ -568,29 +518,32 @@
                 if not v:
                     continue
                 file_names = v if type(v) is list else [v]
                 for n in file_names:
                     with open(n, 'rb') as f:
                         filename = os.path.basename(f.name)
                         filedata = f.read()
-                        mimetype = (mimetypes.guess_type(filename)[0] or
-                                    'application/octet-stream')
+                        mimetype = (
+                            mimetypes.guess_type(filename)[0]
+                            or 'application/octet-stream'
+                        )
                         params.append(
-                            tuple([k, tuple([filename, filedata, mimetype])]))
+                            tuple([k, tuple([filename, filedata, mimetype])])
+                        )
 
         return params
 
-    def select_header_accept(self, accepts):
+    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
         """Returns `Accept` based on an array of accepts provided.
 
         :param accepts: List of headers.
         :return: Accept (e.g. application/json).
         """
         if not accepts:
-            return
+            return None
 
         for accept in accepts:
             if re.search('json', accept, re.IGNORECASE):
                 return accept
 
         return accepts[0]
 
@@ -605,17 +558,24 @@
 
         for content_type in content_types:
             if re.search('json', content_type, re.IGNORECASE):
                 return content_type
 
         return content_types[0]
 
-    def update_params_for_auth(self, headers, queries, auth_settings,
-                               resource_path, method, body,
-                               request_auth=None):
+    def update_params_for_auth(
+        self,
+        headers,
+        queries,
+        auth_settings,
+        resource_path,
+        method,
+        body,
+        request_auth=None
+    ) -> None:
         """Updates header and query params based on authentication setting.
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :param auth_settings: Authentication setting identifiers list.
         :resource_path: A string representation of the HTTP request resource path.
         :method: A string representation of the HTTP request method.
@@ -624,29 +584,44 @@
         :param request_auth: if set, the provided settings will
                              override the token in the configuration.
         """
         if not auth_settings:
             return
 
         if request_auth:
-            self._apply_auth_params(headers, queries,
-                                    resource_path, method, body,
-                                    request_auth)
-            return
-
-        for auth in auth_settings:
-            auth_setting = self.configuration.auth_settings().get(auth)
-            if auth_setting:
-                self._apply_auth_params(headers, queries,
-                                        resource_path, method, body,
-                                        auth_setting)
-
-    def _apply_auth_params(self, headers, queries,
-                           resource_path, method, body,
-                           auth_setting):
+            self._apply_auth_params(
+                headers,
+                queries,
+                resource_path,
+                method,
+                body,
+                request_auth
+            )
+        else:
+            for auth in auth_settings:
+                auth_setting = self.configuration.auth_settings().get(auth)
+                if auth_setting:
+                    self._apply_auth_params(
+                        headers,
+                        queries,
+                        resource_path,
+                        method,
+                        body,
+                        auth_setting
+                    )
+
+    def _apply_auth_params(
+        self,
+        headers,
+        queries,
+        resource_path,
+        method,
+        body,
+        auth_setting
+    ) -> None:
         """Updates the request parameters based on a single auth_setting
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :resource_path: A string representation of the HTTP request resource path.
         :method: A string representation of the HTTP request method.
         :body: A object representing the body of the HTTP request.
@@ -667,25 +642,32 @@
 
     def __deserialize_file(self, response):
         """Deserializes body to file
 
         Saves response body into a file in a temporary folder,
         using the filename from the `Content-Disposition` header if provided.
 
+        handle file downloading
+        save response body into a tmp file and return the instance
+
         :param response:  RESTResponse.
         :return: file path.
         """
         fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
         os.close(fd)
         os.remove(path)
 
         content_disposition = response.getheader("Content-Disposition")
         if content_disposition:
-            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
-                                 content_disposition).group(1)
+            m = re.search(
+                r'filename=[\'"]?([^\'"\s]+)[\'"]?',
+                content_disposition
+            )
+            assert m is not None, "Unexpected 'content-disposition' header value"
+            filename = m.group(1)
             path = os.path.join(os.path.dirname(path), filename)
 
         with open(path, "wb") as f:
             f.write(response.data)
 
         return path
 
@@ -744,14 +726,32 @@
                 status=0,
                 reason=(
                     "Failed to parse `{0}` as datetime object"
                     .format(string)
                 )
             )
 
+    def __deserialize_enum(self, data, klass):
+        """Deserializes primitive type to enum.
+
+        :param data: primitive type.
+        :param klass: class literal.
+        :return: enum value.
+        """
+        try:
+            return klass(data)
+        except ValueError:
+            raise rest.ApiException(
+                status=0,
+                reason=(
+                    "Failed to parse `{0}` as `{1}`"
+                    .format(data, klass)
+                )
+            )
+
     def __deserialize_model(self, data, klass):
         """Deserializes list or dict to model.
 
         :param data: dict, list.
         :param klass: class literal.
         :return: model object.
         """
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/configuration.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/configuration.py`

 * *Files 2% similar despite different names*

```diff
@@ -11,16 +11,18 @@
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
 import copy
 import logging
+from logging import FileHandler
 import multiprocessing
 import sys
+from typing import Optional
 import urllib3
 
 import http.client as httplib
 
 JSON_SCHEMA_VALIDATION_KEYWORDS = {
     'multipleOf', 'maximum', 'exclusiveMaximum',
     'minimum', 'exclusiveMinimum', 'maxLength',
@@ -113,15 +115,15 @@
         self.logger["urllib3_logger"] = logging.getLogger("urllib3")
         self.logger_format = '%(asctime)s %(levelname)s %(message)s'
         """Log format
         """
         self.logger_stream_handler = None
         """Log stream handler
         """
-        self.logger_file_handler = None
+        self.logger_file_handler: Optional[FileHandler] = None
         """Log file handler
         """
         self.logger_file = None
         """Debug file location
         """
         self.debug = False
         """Debug switch
@@ -153,15 +155,15 @@
         """urllib3 connection pool's maximum number of connections saved
            per pool. urllib3 uses 1 connection as default value, but this is
            not the best value when you are making a lot of possibly parallel
            requests to the same host, which is often the case here.
            cpu_count * 5 is used as default value to increase performance.
         """
 
-        self.proxy = None
+        self.proxy: Optional[str] = None
         """Proxy URL
         """
         self.proxy_headers = None
         """Proxy headers
         """
         self.safe_chars_for_path_param = ''
         """Safe chars for path_param
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/exceptions.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/exceptions.py`

 * *Files 24% similar despite different names*

```diff
@@ -8,14 +8,16 @@
     The version of the OpenAPI document: 1.0
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Optional
+from typing_extensions import Self
 
 class OpenApiException(Exception):
     """The base exception class for all OpenAPIExceptions"""
 
 
 class ApiTypeError(OpenApiException, TypeError):
     def __init__(self, msg, path_to_item=None, valid_classes=None,
@@ -98,66 +100,97 @@
         if path_to_item:
             full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
         super(ApiKeyError, self).__init__(full_msg)
 
 
 class ApiException(OpenApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
+    def __init__(
+        self, 
+        status=None, 
+        reason=None, 
+        http_resp=None,
+        *,
+        body: Optional[str] = None,
+        data: Optional[Any] = None,
+    ) -> None:
+        self.status = status
+        self.reason = reason
+        self.body = body
+        self.data = data
+        self.headers = None
+
         if http_resp:
-            self.status = http_resp.status
-            self.reason = http_resp.reason
-            self.body = http_resp.data
+            if self.status is None:
+                self.status = http_resp.status
+            if self.reason is None:
+                self.reason = http_resp.reason
+            if self.body is None:
+                try:
+                    self.body = http_resp.data.decode('utf-8')
+                except Exception:
+                    pass
             self.headers = http_resp.getheaders()
-        else:
-            self.status = status
-            self.reason = reason
-            self.body = None
-            self.headers = None
+
+    @classmethod
+    def from_response(
+        cls, 
+        *, 
+        http_resp, 
+        body: Optional[str], 
+        data: Optional[Any],
+    ) -> Self:
+        if http_resp.status == 400:
+            raise BadRequestException(http_resp=http_resp, body=body, data=data)
+
+        if http_resp.status == 401:
+            raise UnauthorizedException(http_resp=http_resp, body=body, data=data)
+
+        if http_resp.status == 403:
+            raise ForbiddenException(http_resp=http_resp, body=body, data=data)
+
+        if http_resp.status == 404:
+            raise NotFoundException(http_resp=http_resp, body=body, data=data)
+
+        if 500 <= http_resp.status <= 599:
+            raise ServiceException(http_resp=http_resp, body=body, data=data)
+        raise ApiException(http_resp=http_resp, body=body, data=data)
 
     def __str__(self):
         """Custom error messages for exception"""
         error_message = "({0})\n"\
                         "Reason: {1}\n".format(self.status, self.reason)
         if self.headers:
             error_message += "HTTP response headers: {0}\n".format(
                 self.headers)
 
-        if self.body:
-            error_message += "HTTP response body: {0}\n".format(self.body)
+        if self.data or self.body:
+            error_message += "HTTP response body: {0}\n".format(self.data or self.body)
 
         return error_message
 
+
 class BadRequestException(ApiException):
+    pass
 
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(BadRequestException, self).__init__(status, reason, http_resp)
 
 class NotFoundException(ApiException):
-
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(NotFoundException, self).__init__(status, reason, http_resp)
+    pass
 
 
 class UnauthorizedException(ApiException):
-
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(UnauthorizedException, self).__init__(status, reason, http_resp)
+    pass
 
 
 class ForbiddenException(ApiException):
-
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(ForbiddenException, self).__init__(status, reason, http_resp)
+    pass
 
 
 class ServiceException(ApiException):
-
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(ServiceException, self).__init__(status, reason, http_resp)
+    pass
 
 
 def render_path(path_to_item):
     """Returns a string representation of a path"""
     result = ""
     for pth in path_to_item:
         if isinstance(pth, int):
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/__init__.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -25,17 +25,15 @@
 from pieces_os_client.models.allocation_cloud_status import AllocationCloudStatus
 from pieces_os_client.models.allocation_cloud_url import AllocationCloudUrl
 from pieces_os_client.models.allocation_cloud_urls import AllocationCloudUrls
 from pieces_os_client.models.allocation_status_enum import AllocationStatusEnum
 from pieces_os_client.models.allocations import Allocations
 from pieces_os_client.models.analyses import Analyses
 from pieces_os_client.models.analysis import Analysis
-from pieces_os_client.models.analytics_tracked_adoption_event_identifier_description_pairs import (
-    AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs,
-)
+from pieces_os_client.models.analytics_tracked_adoption_event_identifier_description_pairs import AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs
 from pieces_os_client.models.anchor import Anchor
 from pieces_os_client.models.anchor_point import AnchorPoint
 from pieces_os_client.models.anchor_points import AnchorPoints
 from pieces_os_client.models.anchor_type_enum import AnchorTypeEnum
 from pieces_os_client.models.anchors import Anchors
 from pieces_os_client.models.annotation import Annotation
 from pieces_os_client.models.annotation_type_enum import AnnotationTypeEnum
@@ -48,99 +46,73 @@
 from pieces_os_client.models.asset_filter_phrase import AssetFilterPhrase
 from pieces_os_client.models.asset_filter_phrase_options import AssetFilterPhraseOptions
 from pieces_os_client.models.asset_filter_timestamp import AssetFilterTimestamp
 from pieces_os_client.models.asset_filters import AssetFilters
 from pieces_os_client.models.asset_reclassification import AssetReclassification
 from pieces_os_client.models.asset_search_space import AssetSearchSpace
 from pieces_os_client.models.assets import Assets
-from pieces_os_client.models.assets_search_with_filters_input import (
-    AssetsSearchWithFiltersInput,
-)
-from pieces_os_client.models.assets_search_with_filters_output import (
-    AssetsSearchWithFiltersOutput,
-)
+from pieces_os_client.models.assets_search_with_filters_input import AssetsSearchWithFiltersInput
+from pieces_os_client.models.assets_search_with_filters_output import AssetsSearchWithFiltersOutput
 from pieces_os_client.models.auth0 import Auth0
 from pieces_os_client.models.auth0_identity import Auth0Identity
 from pieces_os_client.models.auth0_open_ai_user_metadata import Auth0OpenAIUserMetadata
 from pieces_os_client.models.auth0_redirects import Auth0Redirects
 from pieces_os_client.models.auth0_user import Auth0User
-from pieces_os_client.models.auth0_user_allocation_metadata import (
-    Auth0UserAllocationMetadata,
-)
+from pieces_os_client.models.auth0_user_allocation_metadata import Auth0UserAllocationMetadata
 from pieces_os_client.models.auth0_user_metadata import Auth0UserMetadata
 from pieces_os_client.models.available_formats import AvailableFormats
 from pieces_os_client.models.byte_descriptor import ByteDescriptor
 from pieces_os_client.models.capabilities_enum import CapabilitiesEnum
 from pieces_os_client.models.challenged_pkce import ChallengedPKCE
 from pieces_os_client.models.checked_os_update import CheckedOSUpdate
 from pieces_os_client.models.classification import Classification
-from pieces_os_client.models.classification_generic_enum import (
-    ClassificationGenericEnum,
-)
-from pieces_os_client.models.classification_rendering_enum import (
-    ClassificationRenderingEnum,
-)
-from pieces_os_client.models.classification_specific_enum import (
-    ClassificationSpecificEnum,
-)
+from pieces_os_client.models.classification_generic_enum import ClassificationGenericEnum
+from pieces_os_client.models.classification_rendering_enum import ClassificationRenderingEnum
+from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.code_analyses import CodeAnalyses
 from pieces_os_client.models.code_analysis import CodeAnalysis
 from pieces_os_client.models.context import Context
 from pieces_os_client.models.conversation import Conversation
 from pieces_os_client.models.conversation_grounding import ConversationGrounding
 from pieces_os_client.models.conversation_message import ConversationMessage
-from pieces_os_client.models.conversation_message_sentiment_enum import (
-    ConversationMessageSentimentEnum,
-)
+from pieces_os_client.models.conversation_message_sentiment_enum import ConversationMessageSentimentEnum
 from pieces_os_client.models.conversation_messages import ConversationMessages
-from pieces_os_client.models.conversation_summarize_input import (
-    ConversationSummarizeInput,
-)
-from pieces_os_client.models.conversation_summarize_output import (
-    ConversationSummarizeOutput,
-)
+from pieces_os_client.models.conversation_summarize_input import ConversationSummarizeInput
+from pieces_os_client.models.conversation_summarize_output import ConversationSummarizeOutput
 from pieces_os_client.models.conversation_type_enum import ConversationTypeEnum
 from pieces_os_client.models.conversations import Conversations
-from pieces_os_client.models.conversations_create_from_asset_output import (
-    ConversationsCreateFromAssetOutput,
-)
-from pieces_os_client.models.created_external_provider_api_key import (
-    CreatedExternalProviderApiKey,
-)
-from pieces_os_client.models.deleted_external_provider_api_key import (
-    DeletedExternalProviderApiKey,
-)
+from pieces_os_client.models.conversations_create_from_asset_output import ConversationsCreateFromAssetOutput
+from pieces_os_client.models.created_external_provider_api_key import CreatedExternalProviderApiKey
+from pieces_os_client.models.deleted_external_provider_api_key import DeletedExternalProviderApiKey
+from pieces_os_client.models.detected_external_application import DetectedExternalApplication
+from pieces_os_client.models.detected_external_applications import DetectedExternalApplications
 from pieces_os_client.models.discovered_asset import DiscoveredAsset
 from pieces_os_client.models.discovered_assets import DiscoveredAssets
 from pieces_os_client.models.discovered_html_webpage import DiscoveredHtmlWebpage
 from pieces_os_client.models.discovered_html_webpages import DiscoveredHtmlWebpages
 from pieces_os_client.models.discovered_related_tag import DiscoveredRelatedTag
 from pieces_os_client.models.discovered_related_tags import DiscoveredRelatedTags
 from pieces_os_client.models.discovered_sensitive import DiscoveredSensitive
 from pieces_os_client.models.discovered_sensitives import DiscoveredSensitives
 from pieces_os_client.models.distribution import Distribution
 from pieces_os_client.models.distributions import Distributions
 from pieces_os_client.models.edges import Edges
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.embedded_model_schema_semantic_version_enum import (
-    EmbeddedModelSchemaSemanticVersionEnum,
-)
+from pieces_os_client.models.embedded_model_schema_semantic_version_enum import EmbeddedModelSchemaSemanticVersionEnum
 from pieces_os_client.models.embedding import Embedding
 from pieces_os_client.models.embeddings import Embeddings
 from pieces_os_client.models.existent_metadata import ExistentMetadata
 from pieces_os_client.models.existing_metadata import ExistingMetadata
 from pieces_os_client.models.exported_asset import ExportedAsset
 from pieces_os_client.models.exported_database import ExportedDatabase
 from pieces_os_client.models.exported_database_format import ExportedDatabaseFormat
 from pieces_os_client.models.exported_database_formats import ExportedDatabaseFormats
 from pieces_os_client.models.external_ml_provider_enum import ExternalMLProviderEnum
 from pieces_os_client.models.external_provider import ExternalProvider
-from pieces_os_client.models.external_provider_profile_data import (
-    ExternalProviderProfileData,
-)
+from pieces_os_client.models.external_provider_profile_data import ExternalProviderProfileData
 from pieces_os_client.models.external_provider_type_enum import ExternalProviderTypeEnum
 from pieces_os_client.models.external_providers import ExternalProviders
 from pieces_os_client.models.externally_sourced_enum import ExternallySourcedEnum
 from pieces_os_client.models.file_format import FileFormat
 from pieces_os_client.models.file_metadata import FileMetadata
 from pieces_os_client.models.file_picker_input import FilePickerInput
 from pieces_os_client.models.filter_operation_type_enum import FilterOperationTypeEnum
@@ -152,20 +124,16 @@
 from pieces_os_client.models.flattened_anchor_points import FlattenedAnchorPoints
 from pieces_os_client.models.flattened_anchors import FlattenedAnchors
 from pieces_os_client.models.flattened_annotation import FlattenedAnnotation
 from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
 from pieces_os_client.models.flattened_asset import FlattenedAsset
 from pieces_os_client.models.flattened_assets import FlattenedAssets
 from pieces_os_client.models.flattened_conversation import FlattenedConversation
-from pieces_os_client.models.flattened_conversation_message import (
-    FlattenedConversationMessage,
-)
-from pieces_os_client.models.flattened_conversation_messages import (
-    FlattenedConversationMessages,
-)
+from pieces_os_client.models.flattened_conversation_message import FlattenedConversationMessage
+from pieces_os_client.models.flattened_conversation_messages import FlattenedConversationMessages
 from pieces_os_client.models.flattened_conversations import FlattenedConversations
 from pieces_os_client.models.flattened_distribution import FlattenedDistribution
 from pieces_os_client.models.flattened_distributions import FlattenedDistributions
 from pieces_os_client.models.flattened_format import FlattenedFormat
 from pieces_os_client.models.flattened_formats import FlattenedFormats
 from pieces_os_client.models.flattened_hint import FlattenedHint
 from pieces_os_client.models.flattened_hints import FlattenedHints
@@ -189,128 +157,123 @@
 from pieces_os_client.models.format_reclassification import FormatReclassification
 from pieces_os_client.models.formats import Formats
 from pieces_os_client.models.formats_metrics import FormatsMetrics
 from pieces_os_client.models.fragment_format import FragmentFormat
 from pieces_os_client.models.fragment_metadata import FragmentMetadata
 from pieces_os_client.models.git_hub_distribution import GitHubDistribution
 from pieces_os_client.models.git_hub_gist_distribution import GitHubGistDistribution
-from pieces_os_client.models.graphical_image_descriptive_statistics import (
-    GraphicalImageDescriptiveStatistics,
-)
+from pieces_os_client.models.graphical_image_descriptive_statistics import GraphicalImageDescriptiveStatistics
 from pieces_os_client.models.graphical_image_processing import GraphicalImageProcessing
 from pieces_os_client.models.graphical_image_statistics import GraphicalImageStatistics
-from pieces_os_client.models.graphical_machine_learning_processing_event import (
-    GraphicalMachineLearningProcessingEvent,
-)
-from pieces_os_client.models.graphical_ocr_descriptive_statistics import (
-    GraphicalOCRDescriptiveStatistics,
-)
-from pieces_os_client.models.graphical_ocr_descriptive_statistics_confidence import (
-    GraphicalOCRDescriptiveStatisticsConfidence,
-)
+from pieces_os_client.models.graphical_machine_learning_processing_event import GraphicalMachineLearningProcessingEvent
+from pieces_os_client.models.graphical_ocr_descriptive_statistics import GraphicalOCRDescriptiveStatistics
+from pieces_os_client.models.graphical_ocr_descriptive_statistics_confidence import GraphicalOCRDescriptiveStatisticsConfidence
 from pieces_os_client.models.graphical_ocr_processing import GraphicalOCRProcessing
 from pieces_os_client.models.graphical_ocr_statistics import GraphicalOCRStatistics
 from pieces_os_client.models.graphical_svg_statistics import GraphicalSVGStatistics
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.health import Health
 from pieces_os_client.models.hint import Hint
 from pieces_os_client.models.hint_type_enum import HintTypeEnum
 from pieces_os_client.models.hints import Hints
 from pieces_os_client.models.image_analyses import ImageAnalyses
 from pieces_os_client.models.image_analysis import ImageAnalysis
 from pieces_os_client.models.interacted_asset import InteractedAsset
-from pieces_os_client.models.interacted_asset_interactions import (
-    InteractedAssetInteractions,
-)
+from pieces_os_client.models.interacted_asset_interactions import InteractedAssetInteractions
 from pieces_os_client.models.interacted_assets import InteractedAssets
 from pieces_os_client.models.linkify import Linkify
 from pieces_os_client.models.linkify_multiple import LinkifyMultiple
 from pieces_os_client.models.mailgun_distribution import MailgunDistribution
 from pieces_os_client.models.mailgun_metadata import MailgunMetadata
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.model import Model
 from pieces_os_client.models.model_delete_cache_input import ModelDeleteCacheInput
 from pieces_os_client.models.model_delete_cache_output import ModelDeleteCacheOutput
 from pieces_os_client.models.model_download_progress import ModelDownloadProgress
-from pieces_os_client.models.model_download_progress_status_enum import (
-    ModelDownloadProgressStatusEnum,
-)
+from pieces_os_client.models.model_download_progress_status_enum import ModelDownloadProgressStatusEnum
 from pieces_os_client.models.model_foundation_enum import ModelFoundationEnum
 from pieces_os_client.models.model_max_tokens import ModelMaxTokens
 from pieces_os_client.models.model_type_enum import ModelTypeEnum
 from pieces_os_client.models.model_usage_enum import ModelUsageEnum
 from pieces_os_client.models.models import Models
 from pieces_os_client.models.node import Node
 from pieces_os_client.models.node_type_enum import NodeTypeEnum
 from pieces_os_client.models.notification import Notification
 from pieces_os_client.models.o_auth_account import OAuthAccount
 from pieces_os_client.models.o_auth_group import OAuthGroup
 from pieces_os_client.models.o_auth_token import OAuthToken
 from pieces_os_client.models.ocr_analyses import OCRAnalyses
 from pieces_os_client.models.ocr_analysis import OCRAnalysis
+from pieces_os_client.models.os_device_cpu_hardware_information import OSDeviceCPUHardwareInformation
+from pieces_os_client.models.os_device_dependencies_information import OSDeviceDependenciesInformation
+from pieces_os_client.models.os_device_gpu_hardware_capabilities_information import OSDeviceGPUHardwareCapabilitiesInformation
+from pieces_os_client.models.os_device_gpu_hardware_information import OSDeviceGPUHardwareInformation
+from pieces_os_client.models.os_device_hardware_information import OSDeviceHardwareInformation
+from pieces_os_client.models.os_device_information_returnable import OSDeviceInformationReturnable
 from pieces_os_client.models.os_health import OSHealth
+from pieces_os_client.models.onboarded_persona_details import OnboardedPersonaDetails
 from pieces_os_client.models.open_ai_models_list_input import OpenAIModelsListInput
 from pieces_os_client.models.open_ai_models_list_output import OpenAIModelsListOutput
 from pieces_os_client.models.ordered_metrics import OrderedMetrics
 from pieces_os_client.models.pkce import PKCE
 from pieces_os_client.models.person import Person
 from pieces_os_client.models.person_access import PersonAccess
 from pieces_os_client.models.person_access_scoped_enum import PersonAccessScopedEnum
 from pieces_os_client.models.person_basic_type import PersonBasicType
 from pieces_os_client.models.person_model import PersonModel
 from pieces_os_client.models.person_type import PersonType
 from pieces_os_client.models.persons import Persons
 from pieces_os_client.models.platform_enum import PlatformEnum
-from pieces_os_client.models.precreated_external_provider_api_key import (
-    PrecreatedExternalProviderApiKey,
-)
-from pieces_os_client.models.predeleted_external_provider_api_key import (
-    PredeletedExternalProviderApiKey,
-)
-from pieces_os_client.models.preupdated_external_provider_api_key import (
-    PreupdatedExternalProviderApiKey,
-)
+from pieces_os_client.models.precreated_external_provider_api_key import PrecreatedExternalProviderApiKey
+from pieces_os_client.models.predeleted_external_provider_api_key import PredeletedExternalProviderApiKey
+from pieces_os_client.models.preonboarded_persona_details import PreonboardedPersonaDetails
+from pieces_os_client.models.preupdated_external_provider_api_key import PreupdatedExternalProviderApiKey
 from pieces_os_client.models.preview import Preview
 from pieces_os_client.models.privacy_enum import PrivacyEnum
 from pieces_os_client.models.pseudo_assets import PseudoAssets
 from pieces_os_client.models.qgpt_agent_related_routes import QGPTAgentRelatedRoutes
 from pieces_os_client.models.qgpt_agent_routes import QGPTAgentRoutes
 from pieces_os_client.models.qgpt_conversation import QGPTConversation
 from pieces_os_client.models.qgpt_conversation_message import QGPTConversationMessage
-from pieces_os_client.models.qgpt_conversation_message_role_enum import (
-    QGPTConversationMessageRoleEnum,
-)
+from pieces_os_client.models.qgpt_conversation_message_role_enum import QGPTConversationMessageRoleEnum
+from pieces_os_client.models.qgpt_conversation_pipeline import QGPTConversationPipeline
+from pieces_os_client.models.qgpt_conversation_pipeline_for_contextualized_code_dialog import QGPTConversationPipelineForContextualizedCodeDialog
+from pieces_os_client.models.qgpt_conversation_pipeline_for_contextualized_code_generation import QGPTConversationPipelineForContextualizedCodeGeneration
+from pieces_os_client.models.qgpt_conversation_pipeline_for_generalized_code_dialog import QGPTConversationPipelineForGeneralizedCodeDialog
 from pieces_os_client.models.qgpt_hints_input import QGPTHintsInput
 from pieces_os_client.models.qgpt_persons_related_input import QGPTPersonsRelatedInput
 from pieces_os_client.models.qgpt_persons_related_output import QGPTPersonsRelatedOutput
+from pieces_os_client.models.qgpt_prompt_pipeline import QGPTPromptPipeline
 from pieces_os_client.models.qgpt_question_answer import QGPTQuestionAnswer
 from pieces_os_client.models.qgpt_question_answers import QGPTQuestionAnswers
 from pieces_os_client.models.qgpt_question_input import QGPTQuestionInput
 from pieces_os_client.models.qgpt_question_output import QGPTQuestionOutput
 from pieces_os_client.models.qgpt_relevance_input import QGPTRelevanceInput
-from pieces_os_client.models.qgpt_relevance_input_options import (
-    QGPTRelevanceInputOptions,
-)
+from pieces_os_client.models.qgpt_relevance_input_options import QGPTRelevanceInputOptions
 from pieces_os_client.models.qgpt_relevance_output import QGPTRelevanceOutput
 from pieces_os_client.models.qgpt_reprompt_input import QGPTRepromptInput
 from pieces_os_client.models.qgpt_reprompt_output import QGPTRepromptOutput
 from pieces_os_client.models.qgpt_stream_enum import QGPTStreamEnum
 from pieces_os_client.models.qgpt_stream_input import QGPTStreamInput
 from pieces_os_client.models.qgpt_stream_output import QGPTStreamOutput
+from pieces_os_client.models.qgpt_task_pipeline import QGPTTaskPipeline
+from pieces_os_client.models.qgpt_task_pipeline_for_code_commentation import QGPTTaskPipelineForCodeCommentation
+from pieces_os_client.models.qgpt_task_pipeline_for_code_completion import QGPTTaskPipelineForCodeCompletion
+from pieces_os_client.models.qgpt_task_pipeline_for_code_explanation import QGPTTaskPipelineForCodeExplanation
+from pieces_os_client.models.qgpt_task_pipeline_for_code_fix import QGPTTaskPipelineForCodeFix
+from pieces_os_client.models.qgpt_task_pipeline_for_code_modification import QGPTTaskPipelineForCodeModification
 from pieces_os_client.models.reaction import Reaction
 from pieces_os_client.models.recipients import Recipients
 from pieces_os_client.models.referenced_activity import ReferencedActivity
 from pieces_os_client.models.referenced_anchor import ReferencedAnchor
 from pieces_os_client.models.referenced_anchor_point import ReferencedAnchorPoint
 from pieces_os_client.models.referenced_annotation import ReferencedAnnotation
 from pieces_os_client.models.referenced_asset import ReferencedAsset
 from pieces_os_client.models.referenced_conversation import ReferencedConversation
-from pieces_os_client.models.referenced_conversation_message import (
-    ReferencedConversationMessage,
-)
+from pieces_os_client.models.referenced_conversation_message import ReferencedConversationMessage
 from pieces_os_client.models.referenced_distribution import ReferencedDistribution
 from pieces_os_client.models.referenced_format import ReferencedFormat
 from pieces_os_client.models.referenced_hint import ReferencedHint
 from pieces_os_client.models.referenced_model import ReferencedModel
 from pieces_os_client.models.referenced_person import ReferencedPerson
 from pieces_os_client.models.referenced_sensitive import ReferencedSensitive
 from pieces_os_client.models.referenced_share import ReferencedShare
@@ -341,323 +304,140 @@
 from pieces_os_client.models.seeded_asset import SeededAsset
 from pieces_os_client.models.seeded_asset_enrichment import SeededAssetEnrichment
 from pieces_os_client.models.seeded_asset_metadata import SeededAssetMetadata
 from pieces_os_client.models.seeded_asset_sensitive import SeededAssetSensitive
 from pieces_os_client.models.seeded_asset_tag import SeededAssetTag
 from pieces_os_client.models.seeded_asset_tags import SeededAssetTags
 from pieces_os_client.models.seeded_asset_website import SeededAssetWebsite
-from pieces_os_client.models.seeded_assets_recommendation import (
-    SeededAssetsRecommendation,
-)
+from pieces_os_client.models.seeded_assets_recommendation import SeededAssetsRecommendation
 from pieces_os_client.models.seeded_classification import SeededClassification
 from pieces_os_client.models.seeded_connector_asset import SeededConnectorAsset
-from pieces_os_client.models.seeded_connector_connection import (
-    SeededConnectorConnection,
-)
+from pieces_os_client.models.seeded_connector_connection import SeededConnectorConnection
 from pieces_os_client.models.seeded_connector_creation import SeededConnectorCreation
 from pieces_os_client.models.seeded_connector_tracking import SeededConnectorTracking
 from pieces_os_client.models.seeded_conversation import SeededConversation
-from pieces_os_client.models.seeded_conversation_message import (
-    SeededConversationMessage,
-)
+from pieces_os_client.models.seeded_conversation_message import SeededConversationMessage
 from pieces_os_client.models.seeded_discoverable_asset import SeededDiscoverableAsset
 from pieces_os_client.models.seeded_discoverable_assets import SeededDiscoverableAssets
-from pieces_os_client.models.seeded_discoverable_html_webpage import (
-    SeededDiscoverableHtmlWebpage,
-)
-from pieces_os_client.models.seeded_discoverable_html_webpages import (
-    SeededDiscoverableHtmlWebpages,
-)
-from pieces_os_client.models.seeded_discoverable_related_tag import (
-    SeededDiscoverableRelatedTag,
-)
-from pieces_os_client.models.seeded_discoverable_related_tags import (
-    SeededDiscoverableRelatedTags,
-)
-from pieces_os_client.models.seeded_discoverable_sensitive import (
-    SeededDiscoverableSensitive,
-)
-from pieces_os_client.models.seeded_discoverable_sensitives import (
-    SeededDiscoverableSensitives,
-)
+from pieces_os_client.models.seeded_discoverable_html_webpage import SeededDiscoverableHtmlWebpage
+from pieces_os_client.models.seeded_discoverable_html_webpages import SeededDiscoverableHtmlWebpages
+from pieces_os_client.models.seeded_discoverable_related_tag import SeededDiscoverableRelatedTag
+from pieces_os_client.models.seeded_discoverable_related_tags import SeededDiscoverableRelatedTags
+from pieces_os_client.models.seeded_discoverable_sensitive import SeededDiscoverableSensitive
+from pieces_os_client.models.seeded_discoverable_sensitives import SeededDiscoverableSensitives
 from pieces_os_client.models.seeded_distribution import SeededDistribution
 from pieces_os_client.models.seeded_distributions import SeededDistributions
 from pieces_os_client.models.seeded_external_provider import SeededExternalProvider
 from pieces_os_client.models.seeded_file import SeededFile
 from pieces_os_client.models.seeded_format import SeededFormat
 from pieces_os_client.models.seeded_fragment import SeededFragment
 from pieces_os_client.models.seeded_git_hub_distribution import SeededGitHubDistribution
-from pieces_os_client.models.seeded_git_hub_gist_distribution import (
-    SeededGitHubGistDistribution,
-)
+from pieces_os_client.models.seeded_git_hub_gist_distribution import SeededGitHubGistDistribution
 from pieces_os_client.models.seeded_github_gists_import import SeededGithubGistsImport
 from pieces_os_client.models.seeded_hint import SeededHint
 from pieces_os_client.models.seeded_mac_os_asset import SeededMacOSAsset
 from pieces_os_client.models.seeded_model import SeededModel
 from pieces_os_client.models.seeded_models import SeededModels
 from pieces_os_client.models.seeded_pkce import SeededPKCE
-from pieces_os_client.models.seeded_pkceadditionalparameters import (
-    SeededPKCEADDITIONALPARAMETERS,
-)
+from pieces_os_client.models.seeded_pkceadditionalparameters import SeededPKCEADDITIONALPARAMETERS
 from pieces_os_client.models.seeded_person import SeededPerson
 from pieces_os_client.models.seeded_score import SeededScore
 from pieces_os_client.models.seeded_score_increment import SeededScoreIncrement
 from pieces_os_client.models.seeded_sensitive import SeededSensitive
 from pieces_os_client.models.seeded_share import SeededShare
 from pieces_os_client.models.seeded_tag import SeededTag
-from pieces_os_client.models.seeded_tracked_adoption_event import (
-    SeededTrackedAdoptionEvent,
-)
+from pieces_os_client.models.seeded_tracked_adoption_event import SeededTrackedAdoptionEvent
 from pieces_os_client.models.seeded_tracked_application import SeededTrackedApplication
 from pieces_os_client.models.seeded_tracked_asset_event import SeededTrackedAssetEvent
 from pieces_os_client.models.seeded_tracked_assets_event import SeededTrackedAssetsEvent
-from pieces_os_client.models.seeded_tracked_assets_event_metadata import (
-    SeededTrackedAssetsEventMetadata,
-)
-from pieces_os_client.models.seeded_tracked_conversation_event import (
-    SeededTrackedConversationEvent,
-)
+from pieces_os_client.models.seeded_tracked_assets_event_metadata import SeededTrackedAssetsEventMetadata
+from pieces_os_client.models.seeded_tracked_conversation_event import SeededTrackedConversationEvent
 from pieces_os_client.models.seeded_tracked_format_event import SeededTrackedFormatEvent
-from pieces_os_client.models.seeded_tracked_interaction_event import (
-    SeededTrackedInteractionEvent,
-)
-from pieces_os_client.models.seeded_tracked_interaction_event_identifier_description_pairs import (
-    SeededTrackedInteractionEventIdentifierDescriptionPairs,
-)
-from pieces_os_client.models.seeded_tracked_keyboard_event import (
-    SeededTrackedKeyboardEvent,
-)
-from pieces_os_client.models.seeded_tracked_keyboard_event_identifier_description_pairs import (
-    SeededTrackedKeyboardEventIdentifierDescriptionPairs,
-)
-from pieces_os_client.models.seeded_tracked_machine_learning_event import (
-    SeededTrackedMachineLearningEvent,
-)
-from pieces_os_client.models.seeded_tracked_session_event import (
-    SeededTrackedSessionEvent,
-)
+from pieces_os_client.models.seeded_tracked_interaction_event import SeededTrackedInteractionEvent
+from pieces_os_client.models.seeded_tracked_interaction_event_identifier_description_pairs import SeededTrackedInteractionEventIdentifierDescriptionPairs
+from pieces_os_client.models.seeded_tracked_keyboard_event import SeededTrackedKeyboardEvent
+from pieces_os_client.models.seeded_tracked_keyboard_event_identifier_description_pairs import SeededTrackedKeyboardEventIdentifierDescriptionPairs
+from pieces_os_client.models.seeded_tracked_machine_learning_event import SeededTrackedMachineLearningEvent
+from pieces_os_client.models.seeded_tracked_session_event import SeededTrackedSessionEvent
 from pieces_os_client.models.seeded_ultra_suite_asset import SeededUltraSuiteAsset
 from pieces_os_client.models.seeded_user import SeededUser
 from pieces_os_client.models.seeded_website import SeededWebsite
 from pieces_os_client.models.seeds import Seeds
-from pieces_os_client.models.segmented_technical_language import (
-    SegmentedTechnicalLanguage,
-)
-from pieces_os_client.models.segmented_technical_language_fragment import (
-    SegmentedTechnicalLanguageFragment,
-)
+from pieces_os_client.models.segmented_technical_language import SegmentedTechnicalLanguage
+from pieces_os_client.models.segmented_technical_language_fragment import SegmentedTechnicalLanguageFragment
 from pieces_os_client.models.sensitive import Sensitive
 from pieces_os_client.models.sensitive_category_enum import SensitiveCategoryEnum
 from pieces_os_client.models.sensitive_metadata import SensitiveMetadata
 from pieces_os_client.models.sensitive_severity_enum import SensitiveSeverityEnum
 from pieces_os_client.models.sensitives import Sensitives
 from pieces_os_client.models.session import Session
 from pieces_os_client.models.share import Share
 from pieces_os_client.models.shares import Shares
 from pieces_os_client.models.space import Space
 from pieces_os_client.models.streamed_identifier import StreamedIdentifier
 from pieces_os_client.models.streamed_identifiers import StreamedIdentifiers
 from pieces_os_client.models.suggestion import Suggestion
 from pieces_os_client.models.suggestion_target import SuggestionTarget
-from pieces_os_client.models.system_execution_cpu_information import (
-    SystemExecutionCpuInformation,
-)
-from pieces_os_client.models.system_execution_information import (
-    SystemExecutionInformation,
-)
-from pieces_os_client.models.tlp_code_directory_analytics import (
-    TLPCodeDirectoryAnalytics,
-)
+from pieces_os_client.models.system_execution_cpu_information import SystemExecutionCpuInformation
+from pieces_os_client.models.system_execution_information import SystemExecutionInformation
+from pieces_os_client.models.tlp_code_directory_analytics import TLPCodeDirectoryAnalytics
 from pieces_os_client.models.tlp_code_file_analytics import TLPCodeFileAnalytics
-from pieces_os_client.models.tlp_code_fragment_classification import (
-    TLPCodeFragmentClassification,
-)
-from pieces_os_client.models.tlp_code_fragment_classification_metadata import (
-    TLPCodeFragmentClassificationMetadata,
-)
-from pieces_os_client.models.tlp_code_fragment_description import (
-    TLPCodeFragmentDescription,
-)
-from pieces_os_client.models.tlp_code_fragment_descriptive_statistics import (
-    TLPCodeFragmentDescriptiveStatistics,
-)
-from pieces_os_client.models.tlp_code_fragment_reclassification import (
-    TLPCodeFragmentReclassification,
-)
-from pieces_os_client.models.tlp_code_fragment_reclassification_updates import (
-    TLPCodeFragmentReclassificationUpdates,
-)
-from pieces_os_client.models.tlp_code_fragment_statistics import (
-    TLPCodeFragmentStatistics,
-)
-from pieces_os_client.models.tlp_code_fragment_suggested_reuse import (
-    TLPCodeFragmentSuggestedReuse,
-)
-from pieces_os_client.models.tlp_code_fragment_suggested_save import (
-    TLPCodeFragmentSuggestedSave,
-)
+from pieces_os_client.models.tlp_code_fragment_classification import TLPCodeFragmentClassification
+from pieces_os_client.models.tlp_code_fragment_classification_metadata import TLPCodeFragmentClassificationMetadata
+from pieces_os_client.models.tlp_code_fragment_description import TLPCodeFragmentDescription
+from pieces_os_client.models.tlp_code_fragment_descriptive_statistics import TLPCodeFragmentDescriptiveStatistics
+from pieces_os_client.models.tlp_code_fragment_reclassification import TLPCodeFragmentReclassification
+from pieces_os_client.models.tlp_code_fragment_reclassification_updates import TLPCodeFragmentReclassificationUpdates
+from pieces_os_client.models.tlp_code_fragment_statistics import TLPCodeFragmentStatistics
+from pieces_os_client.models.tlp_code_fragment_suggested_reuse import TLPCodeFragmentSuggestedReuse
+from pieces_os_client.models.tlp_code_fragment_suggested_save import TLPCodeFragmentSuggestedSave
 from pieces_os_client.models.tlp_code_fragment_tagify import TLPCodeFragmentTagify
 from pieces_os_client.models.tlp_code_processing import TLPCodeProcessing
-from pieces_os_client.models.tlp_code_repository_analytics import (
-    TLPCodeRepositoryAnalytics,
-)
+from pieces_os_client.models.tlp_code_repository_analytics import TLPCodeRepositoryAnalytics
 from pieces_os_client.models.tlp_code_snippet_analytics import TLPCodeSnippetAnalytics
-from pieces_os_client.models.tlp_code_snippet_suggested_interactions import (
-    TLPCodeSnippetSuggestedInteractions,
-)
-from pieces_os_client.models.tlp_code_snippet_tagify_code import (
-    TLPCodeSnippetTagifyCode,
-)
-from pieces_os_client.models.tlp_directed_discovery_filter import (
-    TLPDirectedDiscoveryFilter,
-)
-from pieces_os_client.models.tlp_directed_discovery_filter_enum import (
-    TLPDirectedDiscoveryFilterEnum,
-)
-from pieces_os_client.models.tlp_directed_discovery_filters import (
-    TLPDirectedDiscoveryFilters,
-)
-from pieces_os_client.models.tlp_machine_learning_processing_event import (
-    TLPMachineLearningProcessingEvent,
-)
+from pieces_os_client.models.tlp_code_snippet_suggested_interactions import TLPCodeSnippetSuggestedInteractions
+from pieces_os_client.models.tlp_code_snippet_tagify_code import TLPCodeSnippetTagifyCode
+from pieces_os_client.models.tlp_directed_discovery_filter import TLPDirectedDiscoveryFilter
+from pieces_os_client.models.tlp_directed_discovery_filter_enum import TLPDirectedDiscoveryFilterEnum
+from pieces_os_client.models.tlp_directed_discovery_filters import TLPDirectedDiscoveryFilters
+from pieces_os_client.models.tlp_machine_learning_processing_event import TLPMachineLearningProcessingEvent
 from pieces_os_client.models.tag import Tag
 from pieces_os_client.models.tag_category_enum import TagCategoryEnum
 from pieces_os_client.models.tags import Tags
 from pieces_os_client.models.text_location import TextLocation
 from pieces_os_client.models.text_match import TextMatch
 from pieces_os_client.models.theme import Theme
 from pieces_os_client.models.tokenized_pkce import TokenizedPKCE
 from pieces_os_client.models.tracked_application import TrackedApplication
-from pieces_os_client.models.tracked_application_install import (
-    TrackedApplicationInstall,
-)
+from pieces_os_client.models.tracked_application_install import TrackedApplicationInstall
 from pieces_os_client.models.tracked_application_update import TrackedApplicationUpdate
-from pieces_os_client.models.tracked_asset_event_creation_metadata import (
-    TrackedAssetEventCreationMetadata,
-)
-from pieces_os_client.models.tracked_asset_event_creation_metadata_clipboard import (
-    TrackedAssetEventCreationMetadataClipboard,
-)
-from pieces_os_client.models.tracked_asset_event_creation_metadata_file import (
-    TrackedAssetEventCreationMetadataFile,
-)
-from pieces_os_client.models.tracked_asset_event_format_reclassification_metadata import (
-    TrackedAssetEventFormatReclassificationMetadata,
-)
-from pieces_os_client.models.tracked_asset_event_identifier_description_pairs import (
-    TrackedAssetEventIdentifierDescriptionPairs,
-)
-from pieces_os_client.models.tracked_asset_event_metadata import (
-    TrackedAssetEventMetadata,
-)
-from pieces_os_client.models.tracked_asset_event_rename_metadata import (
-    TrackedAssetEventRenameMetadata,
-)
-from pieces_os_client.models.tracked_assets_event_identifier_description_pairs import (
-    TrackedAssetsEventIdentifierDescriptionPairs,
-)
-from pieces_os_client.models.tracked_assets_event_search_metadata import (
-    TrackedAssetsEventSearchMetadata,
-)
-from pieces_os_client.models.tracked_assets_event_search_metadata_results import (
-    TrackedAssetsEventSearchMetadataResults,
-)
-from pieces_os_client.models.tracked_conversation_event_identifier_description_pairs import (
-    TrackedConversationEventIdentifierDescriptionPairs,
-)
-from pieces_os_client.models.tracked_conversation_event_metadata import (
-    TrackedConversationEventMetadata,
-)
-from pieces_os_client.models.tracked_conversation_event_rename_metadata import (
-    TrackedConversationEventRenameMetadata,
-)
+from pieces_os_client.models.tracked_asset_event_creation_metadata import TrackedAssetEventCreationMetadata
+from pieces_os_client.models.tracked_asset_event_creation_metadata_clipboard import TrackedAssetEventCreationMetadataClipboard
+from pieces_os_client.models.tracked_asset_event_creation_metadata_file import TrackedAssetEventCreationMetadataFile
+from pieces_os_client.models.tracked_asset_event_format_reclassification_metadata import TrackedAssetEventFormatReclassificationMetadata
+from pieces_os_client.models.tracked_asset_event_identifier_description_pairs import TrackedAssetEventIdentifierDescriptionPairs
+from pieces_os_client.models.tracked_asset_event_metadata import TrackedAssetEventMetadata
+from pieces_os_client.models.tracked_asset_event_rename_metadata import TrackedAssetEventRenameMetadata
+from pieces_os_client.models.tracked_assets_event_identifier_description_pairs import TrackedAssetsEventIdentifierDescriptionPairs
+from pieces_os_client.models.tracked_assets_event_search_metadata import TrackedAssetsEventSearchMetadata
+from pieces_os_client.models.tracked_assets_event_search_metadata_results import TrackedAssetsEventSearchMetadataResults
+from pieces_os_client.models.tracked_conversation_event_identifier_description_pairs import TrackedConversationEventIdentifierDescriptionPairs
+from pieces_os_client.models.tracked_conversation_event_metadata import TrackedConversationEventMetadata
+from pieces_os_client.models.tracked_conversation_event_rename_metadata import TrackedConversationEventRenameMetadata
 from pieces_os_client.models.tracked_format import TrackedFormat
 from pieces_os_client.models.tracked_format_event import TrackedFormatEvent
-from pieces_os_client.models.tracked_format_event_identifier_description_pairs import (
-    TrackedFormatEventIdentifierDescriptionPairs,
-)
-from pieces_os_client.models.tracked_format_event_metadata import (
-    TrackedFormatEventMetadata,
-)
+from pieces_os_client.models.tracked_format_event_identifier_description_pairs import TrackedFormatEventIdentifierDescriptionPairs
+from pieces_os_client.models.tracked_format_event_metadata import TrackedFormatEventMetadata
 from pieces_os_client.models.tracked_interaction_event import TrackedInteractionEvent
 from pieces_os_client.models.tracked_keyboard_event import TrackedKeyboardEvent
-from pieces_os_client.models.tracked_session_event_identifier_description_pairs import (
-    TrackedSessionEventIdentifierDescriptionPairs,
-)
+from pieces_os_client.models.tracked_session_event_identifier_description_pairs import TrackedSessionEventIdentifierDescriptionPairs
 from pieces_os_client.models.tracked_user_profile import TrackedUserProfile
 from pieces_os_client.models.transferable_bytes import TransferableBytes
 from pieces_os_client.models.transferable_string import TransferableString
 from pieces_os_client.models.unchecked_os_update import UncheckedOSUpdate
-from pieces_os_client.models.unsegmented_technical_language import (
-    UnsegmentedTechnicalLanguage,
-)
-from pieces_os_client.models.updated_external_provider_api_key import (
-    UpdatedExternalProviderApiKey,
-)
+from pieces_os_client.models.unsegmented_technical_language import UnsegmentedTechnicalLanguage
+from pieces_os_client.models.updated_external_provider_api_key import UpdatedExternalProviderApiKey
 from pieces_os_client.models.updating_status_enum import UpdatingStatusEnum
 from pieces_os_client.models.user_profile import UserProfile
 from pieces_os_client.models.users import Users
 from pieces_os_client.models.website import Website
 from pieces_os_client.models.websites import Websites
-
-Analysis.update_forward_refs()
-AssetFilter.update_forward_refs()
-AssetFilters.update_forward_refs()
-ConversationGrounding.update_forward_refs()
-FlattenedActivities.update_forward_refs()
-FlattenedActivity.update_forward_refs()
-FlattenedAnalysis.update_forward_refs()
-FlattenedAnchorPoint.update_forward_refs()
-FlattenedAnchorPoints.update_forward_refs()
-FlattenedAnchor.update_forward_refs()
-FlattenedAnchors.update_forward_refs()
-FlattenedAnnotation.update_forward_refs()
-FlattenedAnnotations.update_forward_refs()
-FlattenedAsset.update_forward_refs()
-FlattenedAssets.update_forward_refs()
-FlattenedConversationMessage.update_forward_refs()
-FlattenedConversationMessages.update_forward_refs()
-FlattenedConversation.update_forward_refs()
-FlattenedConversations.update_forward_refs()
-FlattenedFormat.update_forward_refs()
-FlattenedFormats.update_forward_refs()
-FlattenedHint.update_forward_refs()
-FlattenedHints.update_forward_refs()
-FlattenedImageAnalysis.update_forward_refs()
-FlattenedOCRAnalysis.update_forward_refs()
-FlattenedPerson.update_forward_refs()
-FlattenedPersons.update_forward_refs()
-FlattenedSensitive.update_forward_refs()
-FlattenedSensitives.update_forward_refs()
-FlattenedShare.update_forward_refs()
-FlattenedShares.update_forward_refs()
-FlattenedTag.update_forward_refs()
-FlattenedTags.update_forward_refs()
-FlattenedWebsite.update_forward_refs()
-FlattenedWebsites.update_forward_refs()
-Format.update_forward_refs()
-ImageAnalysis.update_forward_refs()
-OCRAnalysis.update_forward_refs()
-PersonModel.update_forward_refs()
-ReferencedActivity.update_forward_refs()
-ReferencedAnchorPoint.update_forward_refs()
-ReferencedAnchor.update_forward_refs()
-ReferencedAnnotation.update_forward_refs()
-ReferencedAsset.update_forward_refs()
-ReferencedConversationMessage.update_forward_refs()
-ReferencedConversation.update_forward_refs()
-ReferencedFormat.update_forward_refs()
-ReferencedHint.update_forward_refs()
-ReferencedPerson.update_forward_refs()
-ReferencedSensitive.update_forward_refs()
-ReferencedShare.update_forward_refs()
-ReferencedTag.update_forward_refs()
-ReferencedWebsite.update_forward_refs()
-SeededConnectorTracking.update_forward_refs()
-SeededTrackedAssetEvent.update_forward_refs()
-SeededTrackedAssetsEventMetadata.update_forward_refs()
-SeededTrackedAssetsEvent.update_forward_refs()
-SeededTrackedConversationEvent.update_forward_refs()
-SeededTrackedFormatEvent.update_forward_refs()
-TrackedAssetEventMetadata.update_forward_refs()
-TrackedAssetsEventSearchMetadataResults.update_forward_refs()
-TrackedAssetsEventSearchMetadata.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/access_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/searched_match_enum.py`

 * *Files 21% similar despite different names*

```diff
@@ -9,33 +9,37 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class AccessEnum(str, Enum):
+class SearchedMatchEnum(str, Enum):
     """
-    AccessEnum
+    SearchedMatchEnum
     """
 
     """
     allowed enum values
     """
-    PUBLIC = 'PUBLIC'
-    PRIVATE = 'PRIVATE'
+    TITLE = 'TITLE'
+    ANNOTATION = 'ANNOTATION'
+    HINT = 'HINT'
+    CONTENT = 'CONTENT'
+    FUZZY = 'FUZZY'
+    MULTIPLE = 'MULTIPLE'
+    TAGS = 'TAGS'
+    WEBSITES = 'WEBSITES'
+    PERSONS = 'PERSONS'
 
     @classmethod
-    def from_json(cls, json_str: str) -> AccessEnum:
-        """Create an instance of AccessEnum from a JSON string"""
-        return AccessEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of SearchedMatchEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/accessor.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_accessor.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,77 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_user_profile import FlattenedUserProfile
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Accessor(BaseModel):
-    """
-    This is used to determine who has accessed a share. and how many times.  The user here is the user that accessed this Piece.(optional) if undefined then this user was not logged in yet.  # noqa: E501
+class SeededAccessor(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    os: StrictStr = Field(..., description="this is an os id.")
-    share: StrictStr = Field(...)
-    count: StrictInt = Field(..., description="how many times this user accessed this piece.")
+    This is a pre-created accessor that simply takes an os id and an optional user(flattened)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    os: StrictStr = Field(description="this is an os id.")
     user: Optional[FlattenedUserProfile] = None
-    __properties = ["schema", "id", "os", "share", "count", "user"]
+    share: StrictStr = Field(description="this is the share that the asset is apart of.")
+    __properties: ClassVar[List[str]] = ["schema", "os", "user", "share"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Accessor:
-        """Create an instance of Accessor from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededAccessor from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of user
         if self.user:
             _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Accessor:
-        """Create an instance of Accessor from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededAccessor from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Accessor.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Accessor.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id"),
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "os": obj.get("os"),
-            "share": obj.get("share"),
-            "count": obj.get("count"),
-            "user": FlattenedUserProfile.from_dict(obj.get("user")) if obj.get("user") is not None else None
+            "user": FlattenedUserProfile.from_dict(obj["user"]) if obj.get("user") is not None else None,
+            "share": obj.get("share")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/accessors.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/accessors.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.accessor import Accessor
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Accessors(BaseModel):
     """
     Accessors
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Accessor) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Accessor]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Accessors:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Accessors from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Accessors:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Accessors from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Accessors.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Accessors.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Accessor.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Accessor.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/activities.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/activities.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.activity import Activity
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Activities(BaseModel):
     """
-    This is the plural of activity  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Activity) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the plural of activity
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Activity]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Activities:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Activities from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Activities:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Activities from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Activities.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Activities.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Activity.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Activity.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/activity.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/activity.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,68 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.application import Application
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_asset import FlattenedAsset
 from pieces_os_client.models.flattened_format import FlattenedFormat
 from pieces_os_client.models.flattened_user_profile import FlattenedUserProfile
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.seeded_connector_tracking import SeededConnectorTracking
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Activity(BaseModel):
     """
-    consider a rename to Event? That being said if we go with event we need to think about a word to pre/post fix event because it is likely to be a reserved word.  additional documentation: https://www.notion.so/getpieces/Activity-4da8de193733441f85f87b510235fb74   Notes: - user/asset/format are all optional, NOT required that one of these are present. - if mechanism == internal we will not display to the user.  Thoughts around additional properties. - hmm dismissed array here, that is an array of strings, where the string is the userId that dismissed this notification? or we could potentially do it based on the os_ID. -   # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
-    event: SeededConnectorTracking = Field(...)
-    application: Application = Field(...)
+    consider a rename to Event? That being said if we go with event we need to think about a word to pre/post fix event because it is likely to be a reserved word.  additional documentation: https://www.notion.so/getpieces/Activity-4da8de193733441f85f87b510235fb74   Notes: - user/asset/format are all optional, NOT required that one of these are present. - if mechanism == internal we will not display to the user.  Thoughts around additional properties. - hmm dismissed array here, that is an array of strings, where the string is the userId that dismissed this notification? or we could potentially do it based on the os_ID. - 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
+    event: SeededConnectorTracking
+    application: Application
     deleted: Optional[GroupedTimestamp] = None
     asset: Optional[FlattenedAsset] = None
     user: Optional[FlattenedUserProfile] = None
     format: Optional[FlattenedFormat] = None
-    mechanism: MechanismEnum = Field(...)
-    rank: Optional[StrictInt] = Field(None, description="This is the numeric value assigned for this activity event. This number is based off the the type of activity event calcaulated on the server side.DO NOT MODIFY. To see what the value qualilates to, please refer to the function within the common sdk. The number here is based on the fib series. from 0 -> infinity but rn there arnt any value over 8.")
-    __properties = ["schema", "id", "created", "updated", "event", "application", "deleted", "asset", "user", "format", "mechanism", "rank"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    mechanism: MechanismEnum
+    rank: Optional[StrictInt] = Field(default=None, description="This is the numeric value assigned for this activity event. This number is based off the the type of activity event calcaulated on the server side.DO NOT MODIFY. To see what the value qualilates to, please refer to the function within the common sdk. The number here is based on the fib series. from 0 -> infinity but rn there arnt any value over 8.")
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "event", "application", "deleted", "asset", "user", "format", "mechanism", "rank"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Activity:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Activity from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -98,32 +114,32 @@
             _dict['user'] = self.user.to_dict()
         # override the default output from pydantic by calling `to_dict()` of format
         if self.format:
             _dict['format'] = self.format.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Activity:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Activity from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Activity.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Activity.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "event": SeededConnectorTracking.from_dict(obj.get("event")) if obj.get("event") is not None else None,
-            "application": Application.from_dict(obj.get("application")) if obj.get("application") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
-            "asset": FlattenedAsset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "user": FlattenedUserProfile.from_dict(obj.get("user")) if obj.get("user") is not None else None,
-            "format": FlattenedFormat.from_dict(obj.get("format")) if obj.get("format") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "event": SeededConnectorTracking.from_dict(obj["event"]) if obj.get("event") is not None else None,
+            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "asset": FlattenedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "user": FlattenedUserProfile.from_dict(obj["user"]) if obj.get("user") is not None else None,
+            "format": FlattenedFormat.from_dict(obj["format"]) if obj.get("format") is not None else None,
             "mechanism": obj.get("mechanism"),
             "rank": obj.get("rank")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/aesthetics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_models.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,75 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.font import Font
-from pieces_os_client.models.theme import Theme
+from pieces_os_client.models.seeded_model import SeededModel
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Aesthetics(BaseModel):
-    """
-    These are aesthetics properties that will ensure the darkmode + font size and other aesthetics properties persist:)  # noqa: E501
+class SeededModels(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    theme: Theme = Field(...)
-    font: Font = Field(...)
-    __properties = ["schema", "theme", "font"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a Model that will hold an iterable of SeededModels.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[SeededModel]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Aesthetics:
-        """Create an instance of Aesthetics from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededModels from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of theme
-        if self.theme:
-            _dict['theme'] = self.theme.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of font
-        if self.font:
-            _dict['font'] = self.font.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
+        _items = []
+        if self.iterable:
+            for _item in self.iterable:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Aesthetics:
-        """Create an instance of Aesthetics from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededModels from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Aesthetics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Aesthetics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "theme": Theme.from_dict(obj.get("theme")) if obj.get("theme") is not None else None,
-            "font": Font.from_dict(obj.get("font")) if obj.get("font") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [SeededModel.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/allocation_cloud.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocation_cloud.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,61 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.allocation_cloud_status import AllocationCloudStatus
 from pieces_os_client.models.allocation_cloud_urls import AllocationCloudUrls
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AllocationCloud(BaseModel):
     """
-    update && version: will be present only if your cloud was successfully spun up && running.  updated: is the last time this was updated.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="This is a uuid that represents this cloud.(this is the same as the userid)")
-    user: StrictStr = Field(..., description="this is your useruuid.")
-    urls: AllocationCloudUrls = Field(...)
-    status: AllocationCloudStatus = Field(...)
-    project: StrictStr = Field(..., description="This is the project that this is attached to.")
+    update && version: will be present only if your cloud was successfully spun up && running.  updated: is the last time this was updated.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="This is a uuid that represents this cloud.(this is the same as the userid)")
+    user: StrictStr = Field(description="this is your useruuid.")
+    urls: AllocationCloudUrls
+    status: AllocationCloudStatus
+    project: StrictStr = Field(description="This is the project that this is attached to.")
     updated: Optional[GroupedTimestamp] = None
-    version: Optional[StrictStr] = Field(None, description="this is the current version of the server.")
-    region: Optional[StrictStr] = Field(None, description="this is the region where the project is defined.")
-    __properties = ["schema", "id", "user", "urls", "status", "project", "updated", "version", "region"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    version: Optional[StrictStr] = Field(default=None, description="this is the current version of the server.")
+    region: Optional[StrictStr] = Field(default=None, description="this is the region where the project is defined.")
+    __properties: ClassVar[List[str]] = ["schema", "id", "user", "urls", "status", "project", "updated", "version", "region"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AllocationCloud:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AllocationCloud from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of urls
         if self.urls:
             _dict['urls'] = self.urls.to_dict()
         # override the default output from pydantic by calling `to_dict()` of status
@@ -76,29 +92,29 @@
             _dict['status'] = self.status.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
             _dict['updated'] = self.updated.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AllocationCloud:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AllocationCloud from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AllocationCloud.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AllocationCloud.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
             "user": obj.get("user"),
-            "urls": AllocationCloudUrls.from_dict(obj.get("urls")) if obj.get("urls") is not None else None,
-            "status": AllocationCloudStatus.from_dict(obj.get("status")) if obj.get("status") is not None else None,
+            "urls": AllocationCloudUrls.from_dict(obj["urls"]) if obj.get("urls") is not None else None,
+            "status": AllocationCloudStatus.from_dict(obj["status"]) if obj.get("status") is not None else None,
             "project": obj.get("project"),
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
             "version": obj.get("version"),
             "region": obj.get("region")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/allocation_cloud_status.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocation_cloud_status.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,66 +14,82 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.allocation_status_enum import AllocationStatusEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AllocationCloudStatus(BaseModel):
     """
     AllocationCloudStatus
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    cloud: AllocationStatusEnum = Field(...)
-    __properties = ["schema", "cloud"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    cloud: AllocationStatusEnum
+    __properties: ClassVar[List[str]] = ["schema", "cloud"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AllocationCloudStatus:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AllocationCloudStatus from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AllocationCloudStatus:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AllocationCloudStatus from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AllocationCloudStatus.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AllocationCloudStatus.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "cloud": obj.get("cloud")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/allocation_cloud_url.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocation_cloud_url.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,68 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.allocation_status_enum import AllocationStatusEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AllocationCloudUrl(BaseModel):
     """
-    This is one of the 3 possible urls that will route to your cloud :).  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    status: AllocationStatusEnum = Field(...)
-    url: StrictStr = Field(..., description="this is the base url that is used to communicat with your vpc.")
-    __properties = ["schema", "status", "url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is one of the 3 possible urls that will route to your cloud :).
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    status: AllocationStatusEnum
+    url: StrictStr = Field(description="this is the base url that is used to communicat with your vpc.")
+    __properties: ClassVar[List[str]] = ["schema", "status", "url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AllocationCloudUrl:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AllocationCloudUrl from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AllocationCloudUrl:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AllocationCloudUrl from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AllocationCloudUrl.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AllocationCloudUrl.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "status": obj.get("status"),
             "url": obj.get("url")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/allocation_cloud_urls.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocation_cloud_urls.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,54 +14,70 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.allocation_cloud_url import AllocationCloudUrl
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AllocationCloudUrls(BaseModel):
     """
-    you will have at minimum 2 urls,  base: is the default url of your cloud.  id: is the branded url, uuid.pieces.cloud.  (optional) vanity: is the custom branded url, mark.pieces.cloud  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    base: AllocationCloudUrl = Field(...)
-    id: AllocationCloudUrl = Field(...)
+    you will have at minimum 2 urls,  base: is the default url of your cloud.  id: is the branded url, uuid.pieces.cloud.  (optional) vanity: is the custom branded url, mark.pieces.cloud
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    base: AllocationCloudUrl
+    id: AllocationCloudUrl
     vanity: Optional[AllocationCloudUrl] = None
-    __properties = ["schema", "base", "id", "vanity"]
+    __properties: ClassVar[List[str]] = ["schema", "base", "id", "vanity"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AllocationCloudUrls:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AllocationCloudUrls from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of base
         if self.base:
             _dict['base'] = self.base.to_dict()
         # override the default output from pydantic by calling `to_dict()` of id
@@ -69,24 +85,24 @@
             _dict['id'] = self.id.to_dict()
         # override the default output from pydantic by calling `to_dict()` of vanity
         if self.vanity:
             _dict['vanity'] = self.vanity.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AllocationCloudUrls:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AllocationCloudUrls from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AllocationCloudUrls.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AllocationCloudUrls.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "base": AllocationCloudUrl.from_dict(obj.get("base")) if obj.get("base") is not None else None,
-            "id": AllocationCloudUrl.from_dict(obj.get("id")) if obj.get("id") is not None else None,
-            "vanity": AllocationCloudUrl.from_dict(obj.get("vanity")) if obj.get("vanity") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "base": AllocationCloudUrl.from_dict(obj["base"]) if obj.get("base") is not None else None,
+            "id": AllocationCloudUrl.from_dict(obj["id"]) if obj.get("id") is not None else None,
+            "vanity": AllocationCloudUrl.from_dict(obj["vanity"]) if obj.get("vanity") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/allocation_status_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocation_status_enum.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class AllocationStatusEnum(str, Enum):
     """
     This is a Generic status enumeration that will be used for the status of dns and pod or cloud.
     """
 
@@ -33,12 +30,12 @@
     PENDING = 'PENDING'
     RUNNING = 'RUNNING'
     FAILED = 'FAILED'
     SUCCEEDED = 'SUCCEEDED'
     UNKNOWN = 'UNKNOWN'
 
     @classmethod
-    def from_json(cls, json_str: str) -> AllocationStatusEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of AllocationStatusEnum from a JSON string"""
-        return AllocationStatusEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/allocations.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_git_hub_distribution.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
-from pieces_os_client.models.allocation_cloud import AllocationCloud
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.seeded_git_hub_gist_distribution import SeededGitHubGistDistribution
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Allocations(BaseModel):
-    """
-    Allocations
+class SeededGitHubDistribution(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(AllocationCloud) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SeededGitHubDistribution
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    gist: Optional[SeededGitHubGistDistribution] = None
+    __properties: ClassVar[List[str]] = ["schema", "gist"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Allocations:
-        """Create an instance of Allocations from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededGitHubDistribution from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
+        # override the default output from pydantic by calling `to_dict()` of gist
+        if self.gist:
+            _dict['gist'] = self.gist.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Allocations:
-        """Create an instance of Allocations from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededGitHubDistribution from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Allocations.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Allocations.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [AllocationCloud.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "gist": SeededGitHubGistDistribution.from_dict(obj["gist"]) if obj.get("gist") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/analyses.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/analyses.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.analysis import Analysis
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Analyses(BaseModel):
     """
     Analyses
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Analysis) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Analysis]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Analyses:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Analyses from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Analyses:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Analyses from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Analyses.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Analyses.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Analysis.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Analysis.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/analysis.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/ocr_analyses.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,91 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.code_analysis import CodeAnalysis
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.ocr_analysis import OCRAnalysis
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class Analysis(BaseModel):
-    """
-    This the the MlAnalysis Object, that will go on a format.  this will hold all the different analysis models!  ** keep format just a uuid for now **  # noqa: E501
+class OCRAnalyses(BaseModel):
     """
+    OCRAnalyses
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[OCRAnalysis]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    code: Optional[CodeAnalysis] = None
-    id: StrictStr = Field(...)
-    format: StrictStr = Field(
-        ..., description="this is a reference to the format that it belongs too."
-    )
-    image: Optional[ImageAnalysis] = None
-    __properties = ["schema", "code", "id", "format", "image"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Analysis:
-        """Create an instance of Analysis from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OCRAnalyses from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of code
-        if self.code:
-            _dict["code"] = self.code.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of image
-        if self.image:
-            _dict["image"] = self.image.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
+        _items = []
+        if self.iterable:
+            for _item in self.iterable:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Analysis:
-        """Create an instance of Analysis from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OCRAnalyses from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Analysis.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Analysis.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "code": CodeAnalysis.from_dict(obj.get("code"))
-                if obj.get("code") is not None
-                else None,
-                "id": obj.get("id"),
-                "format": obj.get("format"),
-                "image": ImageAnalysis.from_dict(obj.get("image"))
-                if obj.get("image") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [OCRAnalysis.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.image_analysis import ImageAnalysis
-
-# Analysis.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/analytics_tracked_adoption_event_identifier_description_pairs.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/analytics_tracked_adoption_event_identifier_description_pairs.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,87 +14,103 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs(BaseModel):
     """
     AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     adoption_install: Optional[StrictStr] = None
     adoption_uninstall: Optional[StrictStr] = None
-    __properties = ["schema", "adoption_install", "adoption_uninstall"]
+    __properties: ClassVar[List[str]] = ["schema", "adoption_install", "adoption_uninstall"]
 
-    @validator('adoption_install')
+    @field_validator('adoption_install')
     def adoption_install_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('the_user_has_installed_a_pieces_application'):
+        if value not in set(['the_user_has_installed_a_pieces_application']):
             raise ValueError("must be one of enum values ('the_user_has_installed_a_pieces_application')")
         return value
 
-    @validator('adoption_uninstall')
+    @field_validator('adoption_uninstall')
     def adoption_uninstall_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('the_user_has_uninstalled_a_pieces_application'):
+        if value not in set(['the_user_has_uninstalled_a_pieces_application']):
             raise ValueError("must be one of enum values ('the_user_has_uninstalled_a_pieces_application')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "adoption_install": obj.get("adoption_install"),
             "adoption_uninstall": obj.get("adoption_uninstall")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/anchor.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/anchor.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.anchor_type_enum import AnchorTypeEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_anchor_points import FlattenedAnchorPoints
 from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
 from pieces_os_client.models.flattened_assets import FlattenedAssets
 from pieces_os_client.models.flattened_conversations import FlattenedConversations
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Anchor(BaseModel):
     """
     Anchor
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
     name: Optional[StrictStr] = None
-    type: AnchorTypeEnum = Field(...)
+    type: AnchorTypeEnum
     watch: Optional[StrictBool] = None
-    points: FlattenedAnchorPoints = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    points: FlattenedAnchorPoints
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     assets: Optional[FlattenedAssets] = None
     annotations: Optional[FlattenedAnnotations] = None
     conversations: Optional[FlattenedConversations] = None
     score: Optional[Score] = None
-    __properties = ["schema", "id", "name", "type", "watch", "points", "created", "updated", "deleted", "assets", "annotations", "conversations", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "name", "type", "watch", "points", "created", "updated", "deleted", "assets", "annotations", "conversations", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Anchor:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Anchor from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of points
         if self.points:
             _dict['points'] = self.points.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
@@ -99,33 +115,33 @@
             _dict['conversations'] = self.conversations.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Anchor:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Anchor from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Anchor.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Anchor.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
             "name": obj.get("name"),
             "type": obj.get("type"),
             "watch": obj.get("watch"),
-            "points": FlattenedAnchorPoints.from_dict(obj.get("points")) if obj.get("points") is not None else None,
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
-            "assets": FlattenedAssets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "annotations": FlattenedAnnotations.from_dict(obj.get("annotations")) if obj.get("annotations") is not None else None,
-            "conversations": FlattenedConversations.from_dict(obj.get("conversations")) if obj.get("conversations") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "points": FlattenedAnchorPoints.from_dict(obj["points"]) if obj.get("points") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "annotations": FlattenedAnnotations.from_dict(obj["annotations"]) if obj.get("annotations") is not None else None,
+            "conversations": FlattenedConversations.from_dict(obj["conversations"]) if obj.get("conversations") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/anchor_point.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/anchor_point.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,63 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.platform_enum import PlatformEnum
 from pieces_os_client.models.referenced_anchor import ReferencedAnchor
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AnchorPoint(BaseModel):
     """
     AnchorPoint
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
     verified: Optional[StrictBool] = None
-    fullpath: StrictStr = Field(..., description="This is the text of the path.")
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    fullpath: StrictStr = Field(description="This is the text of the path.")
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     platform: Optional[PlatformEnum] = None
-    anchor: ReferencedAnchor = Field(...)
+    anchor: ReferencedAnchor
     score: Optional[Score] = None
-    __properties = ["schema", "id", "verified", "fullpath", "created", "updated", "deleted", "platform", "anchor", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "verified", "fullpath", "created", "updated", "deleted", "platform", "anchor", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AnchorPoint:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AnchorPoint from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -84,30 +100,30 @@
             _dict['anchor'] = self.anchor.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AnchorPoint:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AnchorPoint from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AnchorPoint.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AnchorPoint.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
             "verified": obj.get("verified"),
             "fullpath": obj.get("fullpath"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
             "platform": obj.get("platform"),
-            "anchor": ReferencedAnchor.from_dict(obj.get("anchor")) if obj.get("anchor") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "anchor": ReferencedAnchor.from_dict(obj["anchor"]) if obj.get("anchor") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/anchor_points.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/embeddings.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,81 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List
+from pieces_os_client.models.embedding import Embedding
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
-from pieces_os_client.models.anchor_point import AnchorPoint
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.score import Score
-
-class AnchorPoints(BaseModel):
-    """
-    This is the plural of AnchorPoint.  # noqa: E501
+class Embeddings(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(AnchorPoint) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(None, description="This is a Map<String, int> where the the key is an AnchorPoint id.")
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Embeddings
+    """ # noqa: E501
+    iterable: List[Embedding]
+    __properties: ClassVar[List[str]] = ["iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AnchorPoints:
-        """Create an instance of AnchorPoints from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Embeddings from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AnchorPoints:
-        """Create an instance of AnchorPoints from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Embeddings from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AnchorPoints.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AnchorPoints.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [AnchorPoint.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "indices": obj.get("indices"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+        _obj = cls.model_validate({
+            "iterable": [Embedding.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/anchor_type_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/anchor_type_enum.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,33 +9,30 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class AnchorTypeEnum(str, Enum):
     """
     This is an enum used to differentiate the different between different anchors. Used in the Anchor data model.
     """
 
     """
     allowed enum values
     """
     FILE = 'FILE'
     DIRECTORY = 'DIRECTORY'
 
     @classmethod
-    def from_json(cls, json_str: str) -> AnchorTypeEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of AnchorTypeEnum from a JSON string"""
-        return AnchorTypeEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/anchors.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/users.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,81 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
-from pieces_os_client.models.anchor import Anchor
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.score import Score
+from pieces_os_client.models.user_profile import UserProfile
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Anchors(BaseModel):
-    """
-    This is the plural of Anchor.  # noqa: E501
+class Users(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Anchor) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(None, description="This is a Map<String, int> where the the key is an Anchor id.")
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A base class for a collection of users and some additional meta properties.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: Optional[List[UserProfile]] = None
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Anchors:
-        """Create an instance of Anchors from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Users from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Anchors:
-        """Create an instance of Anchors from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Users from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Anchors.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Anchors.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Anchor.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "indices": obj.get("indices"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [UserProfile.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/annotation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/annotation.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,76 +14,92 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.annotation_type_enum import AnnotationTypeEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_conversation_messages import FlattenedConversationMessages
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.referenced_anchor import ReferencedAnchor
 from pieces_os_client.models.referenced_asset import ReferencedAsset
 from pieces_os_client.models.referenced_conversation import ReferencedConversation
 from pieces_os_client.models.referenced_model import ReferencedModel
 from pieces_os_client.models.referenced_person import ReferencedPerson
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Annotation(BaseModel):
     """
-    An Annotation is the replacement for descriptions, this will enable comments, description, summaries and many more.  person on here is a reference to the description/comment/annotation about a person  NOTE: person here is NOT the creator of the annotaion. but rather the descriptions of the person. NOTE****: if we want to add \"who\" wrote the annotation, we will want to add a new field on here called author && will need to also layer in behavior the enable an author(person) and an asset both being referenced(ensure you check the side effect in the AssetsFacade.delete)  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    An Annotation is the replacement for descriptions, this will enable comments, description, summaries and many more.  person on here is a reference to the description/comment/annotation about a person  NOTE: person here is NOT the creator of the annotaion. but rather the descriptions of the person. NOTE****: if we want to add \"who\" wrote the annotation, we will want to add a new field on here called author && will need to also layer in behavior the enable an author(person) and an asset both being referenced(ensure you check the side effect in the AssetsFacade.delete)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     mechanism: Optional[MechanismEnum] = None
     asset: Optional[ReferencedAsset] = None
     person: Optional[ReferencedPerson] = None
-    type: AnnotationTypeEnum = Field(...)
-    text: StrictStr = Field(..., description="This is the text of the annotation.")
+    type: AnnotationTypeEnum
+    text: StrictStr = Field(description="This is the text of the annotation.")
     model: Optional[ReferencedModel] = None
     pseudo: Optional[StrictBool] = None
     favorited: Optional[StrictBool] = None
     anchor: Optional[ReferencedAnchor] = None
     conversation: Optional[ReferencedConversation] = None
     score: Optional[Score] = None
     messages: Optional[FlattenedConversationMessages] = None
-    __properties = ["schema", "id", "created", "updated", "deleted", "mechanism", "asset", "person", "type", "text", "model", "pseudo", "favorited", "anchor", "conversation", "score", "messages"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "deleted", "mechanism", "asset", "person", "type", "text", "model", "pseudo", "favorited", "anchor", "conversation", "score", "messages"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Annotation:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Annotation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -112,37 +128,37 @@
             _dict['score'] = self.score.to_dict()
         # override the default output from pydantic by calling `to_dict()` of messages
         if self.messages:
             _dict['messages'] = self.messages.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Annotation:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Annotation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Annotation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Annotation.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
             "mechanism": obj.get("mechanism"),
-            "asset": ReferencedAsset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "person": ReferencedPerson.from_dict(obj.get("person")) if obj.get("person") is not None else None,
+            "asset": ReferencedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "person": ReferencedPerson.from_dict(obj["person"]) if obj.get("person") is not None else None,
             "type": obj.get("type"),
             "text": obj.get("text"),
-            "model": ReferencedModel.from_dict(obj.get("model")) if obj.get("model") is not None else None,
+            "model": ReferencedModel.from_dict(obj["model"]) if obj.get("model") is not None else None,
             "pseudo": obj.get("pseudo"),
             "favorited": obj.get("favorited"),
-            "anchor": ReferencedAnchor.from_dict(obj.get("anchor")) if obj.get("anchor") is not None else None,
-            "conversation": ReferencedConversation.from_dict(obj.get("conversation")) if obj.get("conversation") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None,
-            "messages": FlattenedConversationMessages.from_dict(obj.get("messages")) if obj.get("messages") is not None else None
+            "anchor": ReferencedAnchor.from_dict(obj["anchor"]) if obj.get("anchor") is not None else None,
+            "conversation": ReferencedConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None,
+            "messages": FlattenedConversationMessages.from_dict(obj["messages"]) if obj.get("messages") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/annotation_type_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/annotation_type_enum.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class AnnotationTypeEnum(str, Enum):
     """
     This is used to describe a specific type of annotation. NOTE** This is linked to the annotation_type_filter in the parameters folder(if you change an enum here, please adjust the enum there.)
     """
 
@@ -34,12 +31,12 @@
     COMMENT = 'COMMENT'
     DOCUMENTATION = 'DOCUMENTATION'
     SUMMARY = 'SUMMARY'
     EXPLANATION = 'EXPLANATION'
     GIT_COMMIT = 'GIT_COMMIT'
 
     @classmethod
-    def from_json(cls, json_str: str) -> AnnotationTypeEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of AnnotationTypeEnum from a JSON string"""
-        return AnnotationTypeEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/annotations.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/distributions.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,81 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
-from pieces_os_client.models.annotation import Annotation
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.distribution import Distribution
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Annotations(BaseModel):
-    """
-    This is the plural of Annotation  # noqa: E501
+class Distributions(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Annotation) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(None, description="This is a Map<String, int> where the the key is an annotation id.")
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the plural Model of a Distribution.
+    """ # noqa: E501
+    iterable: List[Distribution]
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    __properties: ClassVar[List[str]] = ["iterable", "schema"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Annotations:
-        """Create an instance of Annotations from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Distributions from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict['score'] = self.score.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Annotations:
-        """Create an instance of Annotations from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Distributions from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Annotations.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Annotations.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Annotation.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "indices": obj.get("indices"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+        _obj = cls.model_validate({
+            "iterable": [Distribution.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/application.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/application.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,86 +14,102 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.application_name_enum import ApplicationNameEnum
 from pieces_os_client.models.capabilities_enum import CapabilitiesEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.platform_enum import PlatformEnum
 from pieces_os_client.models.privacy_enum import PrivacyEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Application(BaseModel):
     """
-    A Model to describe what application a format/analytics event originated.  mechanism: This will let us know where this came from. ie.only 2 enums are used here or else throw and error. default mechanism here is MANUAL- meaning that this came from our user Connecting an application. INTERNAL - means that this came from a shareable link  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="The ID of the application at the device level")
-    name: ApplicationNameEnum = Field(...)
-    version: StrictStr = Field(..., description="This is the specific version number 0.0.0")
-    platform: PlatformEnum = Field(...)
-    onboarded: StrictBool = Field(...)
-    privacy: PrivacyEnum = Field(...)
+    A Model to describe what application a format/analytics event originated.  mechanism: This will let us know where this came from. ie.only 2 enums are used here or else throw and error. default mechanism here is MANUAL- meaning that this came from our user Connecting an application. INTERNAL - means that this came from a shareable link
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="The ID of the application at the device level")
+    name: ApplicationNameEnum
+    version: StrictStr = Field(description="This is the specific version number 0.0.0")
+    platform: PlatformEnum
+    onboarded: StrictBool
+    privacy: PrivacyEnum
     capabilities: Optional[CapabilitiesEnum] = None
     mechanism: Optional[MechanismEnum] = None
-    automatic_unload: Optional[StrictBool] = Field(None, alias="automaticUnload", description="This is a proper that will let us know if we will proactivity unload all of your machine learning models.by default this is false.")
-    __properties = ["schema", "id", "name", "version", "platform", "onboarded", "privacy", "capabilities", "mechanism", "automaticUnload"]
+    automatic_unload: Optional[StrictBool] = Field(default=None, description="This is a proper that will let us know if we will proactivity unload all of your machine learning models.by default this is false.", alias="automaticUnload")
+    __properties: ClassVar[List[str]] = ["schema", "id", "name", "version", "platform", "onboarded", "privacy", "capabilities", "mechanism", "automaticUnload"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Application:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Application from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Application:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Application from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Application.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Application.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
             "name": obj.get("name"),
             "version": obj.get("version"),
             "platform": obj.get("platform"),
             "onboarded": obj.get("onboarded"),
             "privacy": obj.get("privacy"),
             "capabilities": obj.get("capabilities"),
             "mechanism": obj.get("mechanism"),
-            "automatic_unload": obj.get("automaticUnload")
+            "automaticUnload": obj.get("automaticUnload")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/application_name_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/application_name_enum.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ApplicationNameEnum(str, Enum):
     """
     This is a running enumeration for the Names of all the Applications that can be Registered
     """
 
@@ -52,15 +49,26 @@
     VISUAL_STUDIO = 'VISUAL_STUDIO'
     MICROSOFT_EDGE = 'MICROSOFT_EDGE'
     BRAVE = 'BRAVE'
     GOOGLE_CHAT = 'GOOGLE_CHAT'
     SLACK = 'SLACK'
     AZURE_DATA_STUDIO = 'AZURE_DATA_STUDIO'
     OPEN_SOURCE = 'OPEN_SOURCE'
+    R_STUDIO = 'R_STUDIO'
+    VIM = 'VIM'
+    NOTION = 'NOTION'
+    GITHUB_DESKTOP = 'GITHUB_DESKTOP'
+    RAYCAST = 'RAYCAST'
+    REPLIT = 'REPLIT'
+    ALFRED = 'ALFRED'
+    FIGMA = 'FIGMA'
+    SKETCH = 'SKETCH'
+    ADOBE_ILLUSTRATOR = 'ADOBE_ILLUSTRATOR'
+    NOTEPAD_PLUS_PLUS = 'NOTEPAD_PLUS_PLUS'
     UNKNOWN = 'UNKNOWN'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ApplicationNameEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ApplicationNameEnum from a JSON string"""
-        return ApplicationNameEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/applications.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/allocations.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
-from pieces_os_client.models.application import Application
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.allocation_cloud import AllocationCloud
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Applications(BaseModel):
-    """
-    A list of all the applications  # noqa: E501
+class Allocations(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Application) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Allocations
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[AllocationCloud]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Applications:
-        """Create an instance of Applications from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Allocations from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Applications:
-        """Create an instance of Applications from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Allocations from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Applications.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Applications.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Application.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [AllocationCloud.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,17 +14,16 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.activities import Activities
 from pieces_os_client.models.anchors import Anchors
 from pieces_os_client.models.annotations import Annotations
 from pieces_os_client.models.conversations import Conversations
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.formats import Formats
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
@@ -34,73 +33,91 @@
 from pieces_os_client.models.preview import Preview
 from pieces_os_client.models.referenced_format import ReferencedFormat
 from pieces_os_client.models.score import Score
 from pieces_os_client.models.sensitives import Sensitives
 from pieces_os_client.models.shares import Shares
 from pieces_os_client.models.tags import Tags
 from pieces_os_client.models.websites import Websites
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Asset(BaseModel):
     """
-    An Asset Model representing data extracted from an Application connecting a group of data containing one or more Formats.  Below formats, preview, and original CAN to be pollinated (DAG Unsafe) because it is a root node and it's child leaf nodes will prevent cycles agressively.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="The globally available UID representing the asset in the Database, both locally and in the cloud.")
+    An Asset Model representing data extracted from an Application connecting a group of data containing one or more Formats.  Below formats, preview, and original CAN to be pollinated (DAG Unsafe) because it is a root node and it's child leaf nodes will prevent cycles agressively.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="The globally available UID representing the asset in the Database, both locally and in the cloud.")
     name: Optional[StrictStr] = None
-    creator: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    creator: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     synced: Optional[GroupedTimestamp] = None
     deleted: Optional[GroupedTimestamp] = None
-    formats: Formats = Field(...)
-    preview: Preview = Field(...)
-    original: ReferencedFormat = Field(...)
+    formats: Formats
+    preview: Preview
+    original: ReferencedFormat
     shares: Optional[Shares] = None
-    mechanism: MechanismEnum = Field(...)
+    mechanism: MechanismEnum
     websites: Optional[Websites] = None
     interacted: Optional[GroupedTimestamp] = None
     tags: Optional[Tags] = None
     sensitives: Optional[Sensitives] = None
     persons: Optional[Persons] = None
-    curated: Optional[StrictBool] = Field(None, description="This is an optional boolean that will flag that this asset came from a currated collection.")
+    curated: Optional[StrictBool] = Field(default=None, description="This is an optional boolean that will flag that this asset came from a currated collection.")
     discovered: Optional[StrictBool] = None
     activities: Optional[Activities] = None
     score: Optional[Score] = None
     favorited: Optional[StrictBool] = None
-    pseudo: Optional[StrictBool] = Field(None, description="This will determine if this is a asset that the user did not explicitly save.")
+    pseudo: Optional[StrictBool] = Field(default=None, description="This will determine if this is a asset that the user did not explicitly save.")
     annotations: Optional[Annotations] = None
     hints: Optional[Hints] = None
     anchors: Optional[Anchors] = None
     conversations: Optional[Conversations] = None
-    __properties = ["schema", "id", "name", "creator", "created", "updated", "synced", "deleted", "formats", "preview", "original", "shares", "mechanism", "websites", "interacted", "tags", "sensitives", "persons", "curated", "discovered", "activities", "score", "favorited", "pseudo", "annotations", "hints", "anchors", "conversations"]
+    demo: Optional[StrictBool] = Field(default=None, description="This will let us know if this asset was generated as a 'demo' snippet")
+    __properties: ClassVar[List[str]] = ["schema", "id", "name", "creator", "created", "updated", "synced", "deleted", "formats", "preview", "original", "shares", "mechanism", "websites", "interacted", "tags", "sensitives", "persons", "curated", "discovered", "activities", "score", "favorited", "pseudo", "annotations", "hints", "anchors", "conversations", "demo"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Asset:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Asset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -156,48 +173,49 @@
             _dict['anchors'] = self.anchors.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversations
         if self.conversations:
             _dict['conversations'] = self.conversations.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Asset:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Asset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Asset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Asset.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
             "name": obj.get("name"),
             "creator": obj.get("creator"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "synced": GroupedTimestamp.from_dict(obj.get("synced")) if obj.get("synced") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
-            "formats": Formats.from_dict(obj.get("formats")) if obj.get("formats") is not None else None,
-            "preview": Preview.from_dict(obj.get("preview")) if obj.get("preview") is not None else None,
-            "original": ReferencedFormat.from_dict(obj.get("original")) if obj.get("original") is not None else None,
-            "shares": Shares.from_dict(obj.get("shares")) if obj.get("shares") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "synced": GroupedTimestamp.from_dict(obj["synced"]) if obj.get("synced") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "formats": Formats.from_dict(obj["formats"]) if obj.get("formats") is not None else None,
+            "preview": Preview.from_dict(obj["preview"]) if obj.get("preview") is not None else None,
+            "original": ReferencedFormat.from_dict(obj["original"]) if obj.get("original") is not None else None,
+            "shares": Shares.from_dict(obj["shares"]) if obj.get("shares") is not None else None,
             "mechanism": obj.get("mechanism"),
-            "websites": Websites.from_dict(obj.get("websites")) if obj.get("websites") is not None else None,
-            "interacted": GroupedTimestamp.from_dict(obj.get("interacted")) if obj.get("interacted") is not None else None,
-            "tags": Tags.from_dict(obj.get("tags")) if obj.get("tags") is not None else None,
-            "sensitives": Sensitives.from_dict(obj.get("sensitives")) if obj.get("sensitives") is not None else None,
-            "persons": Persons.from_dict(obj.get("persons")) if obj.get("persons") is not None else None,
+            "websites": Websites.from_dict(obj["websites"]) if obj.get("websites") is not None else None,
+            "interacted": GroupedTimestamp.from_dict(obj["interacted"]) if obj.get("interacted") is not None else None,
+            "tags": Tags.from_dict(obj["tags"]) if obj.get("tags") is not None else None,
+            "sensitives": Sensitives.from_dict(obj["sensitives"]) if obj.get("sensitives") is not None else None,
+            "persons": Persons.from_dict(obj["persons"]) if obj.get("persons") is not None else None,
             "curated": obj.get("curated"),
             "discovered": obj.get("discovered"),
-            "activities": Activities.from_dict(obj.get("activities")) if obj.get("activities") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None,
+            "activities": Activities.from_dict(obj["activities"]) if obj.get("activities") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None,
             "favorited": obj.get("favorited"),
             "pseudo": obj.get("pseudo"),
-            "annotations": Annotations.from_dict(obj.get("annotations")) if obj.get("annotations") is not None else None,
-            "hints": Hints.from_dict(obj.get("hints")) if obj.get("hints") is not None else None,
-            "anchors": Anchors.from_dict(obj.get("anchors")) if obj.get("anchors") is not None else None,
-            "conversations": Conversations.from_dict(obj.get("conversations")) if obj.get("conversations") is not None else None
+            "annotations": Annotations.from_dict(obj["annotations"]) if obj.get("annotations") is not None else None,
+            "hints": Hints.from_dict(obj["hints"]) if obj.get("hints") is not None else None,
+            "anchors": Anchors.from_dict(obj["anchors"]) if obj.get("anchors") is not None else None,
+            "conversations": Conversations.from_dict(obj["conversations"]) if obj.get("conversations") is not None else None,
+            "demo": obj.get("demo")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/asset_filter.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_filter.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,121 +14,113 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.asset_filter_phrase import AssetFilterPhrase
 from pieces_os_client.models.asset_filter_timestamp import AssetFilterTimestamp
-from pieces_os_client.models.classification_specific_enum import (
-    ClassificationSpecificEnum,
-)
+from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AssetFilter(BaseModel):
     """
-    ** in the future, consider adding an optional bool's called nextAnd, nextOr which will say that the next filter will be  AND behavor or OR behavior.  \"operations\": here is is an optional property to allow or behavior,(we will only allow 1 level deep of or's), if or is not passed in then it is just simply ignored. If or is passed in then we will be or'd together with the top level filter and considered extras. default behavior for operations is and, however yoour can specifiy OR operations as well.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    ** in the future, consider adding an optional bool's called nextAnd, nextOr which will say that the next filter will be  AND behavor or OR behavior.  \"operations\": here is is an optional property to allow or behavior,(we will only allow 1 level deep of or's), if or is not passed in then it is just simply ignored. If or is passed in then we will be or'd together with the top level filter and considered extras. default behavior for operations is and, however yoour can specifiy OR operations as well.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     classification: Optional[ClassificationSpecificEnum] = None
-    tags: Optional[conlist(StrictStr)] = None
-    websites: Optional[conlist(StrictStr)] = None
-    persons: Optional[conlist(StrictStr)] = None
+    tags: Optional[List[StrictStr]] = None
+    websites: Optional[List[StrictStr]] = None
+    persons: Optional[List[StrictStr]] = None
     phrase: Optional[AssetFilterPhrase] = None
     created: Optional[AssetFilterTimestamp] = None
     updated: Optional[AssetFilterTimestamp] = None
     operations: Optional[AssetFilters] = None
-    __properties = [
-        "schema",
-        "classification",
-        "tags",
-        "websites",
-        "persons",
-        "phrase",
-        "created",
-        "updated",
-        "operations",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "classification", "tags", "websites", "persons", "phrase", "created", "updated", "operations"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AssetFilter:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AssetFilter from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of phrase
         if self.phrase:
-            _dict["phrase"] = self.phrase.to_dict()
+            _dict['phrase'] = self.phrase.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of operations
         if self.operations:
-            _dict["operations"] = self.operations.to_dict()
+            _dict['operations'] = self.operations.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AssetFilter:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AssetFilter from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AssetFilter.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AssetFilter.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "classification": obj.get("classification"),
-                "tags": obj.get("tags"),
-                "websites": obj.get("websites"),
-                "persons": obj.get("persons"),
-                "phrase": AssetFilterPhrase.from_dict(obj.get("phrase"))
-                if obj.get("phrase") is not None
-                else None,
-                "created": AssetFilterTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": AssetFilterTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "operations": AssetFilters.from_dict(obj.get("operations"))
-                if obj.get("operations") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "classification": obj.get("classification"),
+            "tags": obj.get("tags"),
+            "websites": obj.get("websites"),
+            "persons": obj.get("persons"),
+            "phrase": AssetFilterPhrase.from_dict(obj["phrase"]) if obj.get("phrase") is not None else None,
+            "created": AssetFilterTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": AssetFilterTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "operations": AssetFilters.from_dict(obj["operations"]) if obj.get("operations") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.asset_filters import AssetFilters
+# TODO: Rewrite to not use raise_errors
+AssetFilter.model_rebuild(raise_errors=False)
 
-# AssetFilter.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/asset_filter_phrase.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_machine_learning_processing_event.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,77 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-from pieces_os_client.models.asset_filter_phrase_options import AssetFilterPhraseOptions
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.tlp_code_processing import TLPCodeProcessing
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AssetFilterPhrase(BaseModel):
-    """
-    AssetFilterPhrase
+class TLPMachineLearningProcessingEvent(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    value: Optional[StrictStr] = None
-    annotation: Optional[StrictBool] = None
-    title: Optional[StrictBool] = None
-    content: Optional[StrictBool] = None
-    options: Optional[AssetFilterPhraseOptions] = None
-    __properties = ["schema", "value", "annotation", "title", "content", "options"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TLPMachineLearningProcessingEvent
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    code: Optional[TLPCodeProcessing] = None
+    __properties: ClassVar[List[str]] = ["schema", "code"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AssetFilterPhrase:
-        """Create an instance of AssetFilterPhrase from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPMachineLearningProcessingEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of options
-        if self.options:
-            _dict['options'] = self.options.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of code
+        if self.code:
+            _dict['code'] = self.code.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AssetFilterPhrase:
-        """Create an instance of AssetFilterPhrase from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPMachineLearningProcessingEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AssetFilterPhrase.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AssetFilterPhrase.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "value": obj.get("value"),
-            "annotation": obj.get("annotation"),
-            "title": obj.get("title"),
-            "content": obj.get("content"),
-            "options": AssetFilterPhraseOptions.from_dict(obj.get("options")) if obj.get("options") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "code": TLPCodeProcessing.from_dict(obj["code"]) if obj.get("code") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/asset_filter_phrase_options.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_filter_phrase_options.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,66 +14,82 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.annotation_type_enum import AnnotationTypeEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AssetFilterPhraseOptions(BaseModel):
     """
     AssetFilterPhraseOptions
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     annotation: Optional[AnnotationTypeEnum] = None
-    __properties = ["schema", "annotation"]
+    __properties: ClassVar[List[str]] = ["schema", "annotation"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AssetFilterPhraseOptions:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AssetFilterPhraseOptions from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AssetFilterPhraseOptions:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AssetFilterPhraseOptions from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AssetFilterPhraseOptions.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AssetFilterPhraseOptions.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "annotation": obj.get("annotation")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/asset_filter_timestamp.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/suggestion_target.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,76 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from pieces_os_client.models.seeded_connector_creation import SeededConnectorCreation
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AssetFilterTimestamp(BaseModel):
-    """
-    if you want a range between you can use from && to.  if you want anything before, use to and NO from.  if you want anything after, use from and NO to.  # noqa: E501
+class SuggestionTarget(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    var_from: Optional[GroupedTimestamp] = Field(None, alias="from")
-    to: Optional[GroupedTimestamp] = None
-    between: Optional[StrictBool] = None
-    __properties = ["schema", "from", "to", "between"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the target that was sent to pieces. This will return the string that represents this coppied || pasted asset. This will also send along the SeededConnectorCreation and will send along the vector that we created based on the seed.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    seed: SeededConnectorCreation
+    vector: StrictInt = Field(description="This is the vector representation of this target that we generated.")
+    __properties: ClassVar[List[str]] = ["schema", "seed", "vector"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AssetFilterTimestamp:
-        """Create an instance of AssetFilterTimestamp from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SuggestionTarget from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of var_from
-        if self.var_from:
-            _dict['from'] = self.var_from.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of to
-        if self.to:
-            _dict['to'] = self.to.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of seed
+        if self.seed:
+            _dict['seed'] = self.seed.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AssetFilterTimestamp:
-        """Create an instance of AssetFilterTimestamp from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SuggestionTarget from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AssetFilterTimestamp.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AssetFilterTimestamp.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "var_from": GroupedTimestamp.from_dict(obj.get("from")) if obj.get("from") is not None else None,
-            "to": GroupedTimestamp.from_dict(obj.get("to")) if obj.get("to") is not None else None,
-            "between": obj.get("between")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "seed": SeededConnectorCreation.from_dict(obj["seed"]) if obj.get("seed") is not None else None,
+            "vector": obj.get("vector")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/asset_filters.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeds.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,86 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.filter_operation_type_enum import FilterOperationTypeEnum
-
+from pieces_os_client.models.seed import Seed
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AssetFilters(BaseModel):
-    """
-    AssetFilters
+class Seeds(BaseModel):
     """
+    This is a plural model for multiple Seed.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Seed]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(AssetFilter) = Field(...)
-    type: Optional[FilterOperationTypeEnum] = None
-    __properties = ["schema", "iterable", "type"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AssetFilters:
-        """Create an instance of AssetFilters from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Seeds from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AssetFilters:
-        """Create an instance of AssetFilters from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Seeds from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AssetFilters.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AssetFilters.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    AssetFilter.from_dict(_item) for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "type": obj.get("type"),
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Seed.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.asset_filter import AssetFilter
-
-# AssetFilters.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/asset_reclassification.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/checked_os_update.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,72 +14,82 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
-from pieces_os_client.models.asset import Asset
-from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.updating_status_enum import UpdatingStatusEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AssetReclassification(BaseModel):
-    """
-    This is a model that will represent the miminum properties required to update the classification of this asset.  # noqa: E501
+class CheckedOSUpdate(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    ext: ClassificationSpecificEnum = Field(...)
-    asset: Asset = Field(...)
-    __properties = ["schema", "ext", "asset"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the returnable for /os/update/check
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    status: UpdatingStatusEnum
+    __properties: ClassVar[List[str]] = ["schema", "status"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AssetReclassification:
-        """Create an instance of AssetReclassification from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of CheckedOSUpdate from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of asset
-        if self.asset:
-            _dict['asset'] = self.asset.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AssetReclassification:
-        """Create an instance of AssetReclassification from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of CheckedOSUpdate from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AssetReclassification.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AssetReclassification.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "ext": obj.get("ext"),
-            "asset": Asset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "status": obj.get("status")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/asset_search_space.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_search_space.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_assets import FlattenedAssets
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AssetSearchSpace(BaseModel):
     """
-    This is provided search spaces, This is a provided assets, TODO in the future we might want to add seeds.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    identifers: FlattenedAssets = Field(...)
-    __properties = ["schema", "identifers"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is provided search spaces, This is a provided assets, TODO in the future we might want to add seeds.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    identifers: FlattenedAssets
+    __properties: ClassVar[List[str]] = ["schema", "identifers"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AssetSearchSpace:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AssetSearchSpace from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of identifers
         if self.identifers:
             _dict['identifers'] = self.identifers.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AssetSearchSpace:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AssetSearchSpace from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AssetSearchSpace.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AssetSearchSpace.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "identifers": FlattenedAssets.from_dict(obj.get("identifers")) if obj.get("identifers") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "identifers": FlattenedAssets.from_dict(obj["identifers"]) if obj.get("identifers") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/assets.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/shares.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,55 +14,70 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
-from pieces_os_client.models.asset import Asset
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
+from pieces_os_client.models.share import Share
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Assets(BaseModel):
-    """
-    A base class for a collection of assets and some additional meta properties. Fully Populated with Formats internally (not just uuid's).  # noqa: E501
+class Shares(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Asset) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(None, description="This is a Map<String, int> where the the key is an asset id.")
+    this is just an iterable of our individual share models.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Share] = Field(description="this is just an iterable of our individual share models.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Assets:
-        """Create an instance of Assets from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Shares from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
@@ -71,24 +86,23 @@
             _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Assets:
-        """Create an instance of Assets from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Shares from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Assets.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Assets.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Asset.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "indices": obj.get("indices"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Share.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/assets_search_with_filters_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_filter_phrase.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,79 +14,93 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
-from pieces_os_client.models.asset_filters import AssetFilters
-from pieces_os_client.models.asset_search_space import AssetSearchSpace
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.asset_filter_phrase_options import AssetFilterPhraseOptions
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AssetsSearchWithFiltersInput(BaseModel):
-    """
-    AssetsSearchWithFiltersInput
+class AssetFilterPhrase(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    query: Optional[StrictStr] = None
-    space: Optional[AssetSearchSpace] = None
-    filters: Optional[AssetFilters] = None
-    casing: Optional[StrictBool] = Field(None, description="This is an optional bool that will let us know, if we want to ignore case or not.(default is to allow casing)ie casing:true.")
-    __properties = ["schema", "query", "space", "filters", "casing"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AssetFilterPhrase
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    value: Optional[StrictStr] = None
+    annotation: Optional[StrictBool] = None
+    title: Optional[StrictBool] = None
+    content: Optional[StrictBool] = None
+    options: Optional[AssetFilterPhraseOptions] = None
+    __properties: ClassVar[List[str]] = ["schema", "value", "annotation", "title", "content", "options"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AssetsSearchWithFiltersInput:
-        """Create an instance of AssetsSearchWithFiltersInput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AssetFilterPhrase from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of space
-        if self.space:
-            _dict['space'] = self.space.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of filters
-        if self.filters:
-            _dict['filters'] = self.filters.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of options
+        if self.options:
+            _dict['options'] = self.options.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AssetsSearchWithFiltersInput:
-        """Create an instance of AssetsSearchWithFiltersInput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AssetFilterPhrase from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AssetsSearchWithFiltersInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AssetsSearchWithFiltersInput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "query": obj.get("query"),
-            "space": AssetSearchSpace.from_dict(obj.get("space")) if obj.get("space") is not None else None,
-            "filters": AssetFilters.from_dict(obj.get("filters")) if obj.get("filters") is not None else None,
-            "casing": obj.get("casing")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "value": obj.get("value"),
+            "annotation": obj.get("annotation"),
+            "title": obj.get("title"),
+            "content": obj.get("content"),
+            "options": AssetFilterPhraseOptions.from_dict(obj["options"]) if obj.get("options") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/assets_search_with_filters_output.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/fragment_metadata.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,69 +14,82 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.searched_assets import SearchedAssets
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AssetsSearchWithFiltersOutput(BaseModel):
-    """
-    output for the /assets/search [POST]   # noqa: E501
+class FragmentMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    results: SearchedAssets = Field(...)
-    __properties = ["schema", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a model for metadata of a file!
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    ext: Optional[ClassificationSpecificEnum] = None
+    __properties: ClassVar[List[str]] = ["schema", "ext"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AssetsSearchWithFiltersOutput:
-        """Create an instance of AssetsSearchWithFiltersOutput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FragmentMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of results
-        if self.results:
-            _dict['results'] = self.results.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AssetsSearchWithFiltersOutput:
-        """Create an instance of AssetsSearchWithFiltersOutput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FragmentMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AssetsSearchWithFiltersOutput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AssetsSearchWithFiltersOutput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "results": SearchedAssets.from_dict(obj.get("results")) if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "ext": obj.get("ext")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/auth0.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,62 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.auth0_identity import Auth0Identity
 from pieces_os_client.models.auth0_redirects import Auth0Redirects
 from pieces_os_client.models.auth0_user import Auth0User
 from pieces_os_client.models.auth0_user_metadata import Auth0UserMetadata
 from pieces_os_client.models.o_auth_group import OAuthGroup
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Auth0(BaseModel):
     """
-    An object representing all of the properties that are available within a Auth0 PKCE Flow  # noqa: E501
-    """
+    An object representing all of the properties that are available within a Auth0 PKCE Flow
+    """ # noqa: E501
     identity: Optional[Auth0Identity] = None
     user: Optional[Auth0User] = None
     metadata: Optional[Auth0UserMetadata] = None
-    domain: StrictStr = Field(..., description="The domain of your Auth 0 Service")
-    client: StrictStr = Field(..., description="The Client ID for your Auth0 Service")
-    audience: StrictStr = Field(..., description="The Server Audience of your Auth0 Service")
-    redirects: Auth0Redirects = Field(...)
-    o_auth: OAuthGroup = Field(..., alias="oAuth")
-    namespace: Optional[StrictStr] = Field(None, description="An optional namespace parameter to add an additional namespace")
-    __properties = ["identity", "user", "metadata", "domain", "client", "audience", "redirects", "oAuth", "namespace"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    domain: StrictStr = Field(description="The domain of your Auth 0 Service")
+    client: StrictStr = Field(description="The Client ID for your Auth0 Service")
+    audience: StrictStr = Field(description="The Server Audience of your Auth0 Service")
+    redirects: Auth0Redirects
+    o_auth: OAuthGroup = Field(alias="oAuth")
+    namespace: Optional[StrictStr] = Field(default=None, description="An optional namespace parameter to add an additional namespace")
+    __properties: ClassVar[List[str]] = ["identity", "user", "metadata", "domain", "client", "audience", "redirects", "oAuth", "namespace"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Auth0:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Auth0 from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of identity
         if self.identity:
             _dict['identity'] = self.identity.to_dict()
         # override the default output from pydantic by calling `to_dict()` of user
         if self.user:
             _dict['user'] = self.user.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
@@ -80,29 +96,29 @@
             _dict['redirects'] = self.redirects.to_dict()
         # override the default output from pydantic by calling `to_dict()` of o_auth
         if self.o_auth:
             _dict['oAuth'] = self.o_auth.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Auth0:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Auth0 from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Auth0.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Auth0.parse_obj({
-            "identity": Auth0Identity.from_dict(obj.get("identity")) if obj.get("identity") is not None else None,
-            "user": Auth0User.from_dict(obj.get("user")) if obj.get("user") is not None else None,
-            "metadata": Auth0UserMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None,
+        _obj = cls.model_validate({
+            "identity": Auth0Identity.from_dict(obj["identity"]) if obj.get("identity") is not None else None,
+            "user": Auth0User.from_dict(obj["user"]) if obj.get("user") is not None else None,
+            "metadata": Auth0UserMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None,
             "domain": obj.get("domain"),
             "client": obj.get("client"),
             "audience": obj.get("audience"),
-            "redirects": Auth0Redirects.from_dict(obj.get("redirects")) if obj.get("redirects") is not None else None,
-            "o_auth": OAuthGroup.from_dict(obj.get("oAuth")) if obj.get("oAuth") is not None else None,
+            "redirects": Auth0Redirects.from_dict(obj["redirects"]) if obj.get("redirects") is not None else None,
+            "oAuth": OAuthGroup.from_dict(obj["oAuth"]) if obj.get("oAuth") is not None else None,
             "namespace": obj.get("namespace")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_identity.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_identity.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,68 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Auth0Identity(BaseModel):
     """
-    Contains info retrieved from the identity provider with which the user originally authenticates. Users may also link their profile to multiple identity providers; those identities will then also appear in this array. The contents of an individual identity provider object varies by provider, but it will typically include the following. Link: [https://auth0.com/docs/rules/user-object-in-rules]  Currently left out: - profile_data: (Object) User information associated with the connection. When profiles are linked, it is populated with the associated user info for secondary accounts.  # noqa: E501
-    """
-    connection: Optional[StrictStr] = Field(None, description="Name of the Auth0 connection used to authenticate the user. ")
-    is_social: Optional[StrictBool] = Field(None, alias="isSocial", description="Indicates whether the connection is a social one. ")
-    provider: Optional[StrictStr] = Field(None, description="mapped from user_id  -> id")
-    user_id: Optional[StrictStr] = Field(None, description="User's unique identifier for this connection/provider.")
+    Contains info retrieved from the identity provider with which the user originally authenticates. Users may also link their profile to multiple identity providers; those identities will then also appear in this array. The contents of an individual identity provider object varies by provider, but it will typically include the following. Link: [https://auth0.com/docs/rules/user-object-in-rules]  Currently left out: - profile_data: (Object) User information associated with the connection. When profiles are linked, it is populated with the associated user info for secondary accounts.
+    """ # noqa: E501
+    connection: Optional[StrictStr] = Field(default=None, description="Name of the Auth0 connection used to authenticate the user. ")
+    is_social: Optional[StrictBool] = Field(default=None, description="Indicates whether the connection is a social one. ", alias="isSocial")
+    provider: Optional[StrictStr] = Field(default=None, description="mapped from user_id  -> id")
+    user_id: Optional[StrictStr] = Field(default=None, description="User's unique identifier for this connection/provider.")
     access_token: Optional[StrictStr] = None
     expires_in: Optional[StrictInt] = None
-    __properties = ["connection", "isSocial", "provider", "user_id", "access_token", "expires_in"]
+    __properties: ClassVar[List[str]] = ["connection", "isSocial", "provider", "user_id", "access_token", "expires_in"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Auth0Identity:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Auth0Identity from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Auth0Identity:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Auth0Identity from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Auth0Identity.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Auth0Identity.parse_obj({
+        _obj = cls.model_validate({
             "connection": obj.get("connection"),
-            "is_social": obj.get("isSocial"),
+            "isSocial": obj.get("isSocial"),
             "provider": obj.get("provider"),
             "user_id": obj.get("user_id"),
             "access_token": obj.get("access_token"),
             "expires_in": obj.get("expires_in")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_open_ai_user_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/formats.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,69 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.format import Format
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Auth0OpenAIUserMetadata(BaseModel):
-    """
-    Only supporting a single api key per user.  # noqa: E501
+class Formats(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    api_key: Optional[StrictStr] = None
-    api_key_name: Optional[StrictStr] = None
-    organization_key: Optional[StrictStr] = None
-    __properties = ["schema", "api_key", "api_key_name", "organization_key"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A base class for a collection of formats and some additional meta properties.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Format]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Auth0OpenAIUserMetadata:
-        """Create an instance of Auth0OpenAIUserMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Formats from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
+        _items = []
+        if self.iterable:
+            for _item in self.iterable:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Auth0OpenAIUserMetadata:
-        """Create an instance of Auth0OpenAIUserMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Formats from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Auth0OpenAIUserMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Auth0OpenAIUserMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "api_key": obj.get("api_key"),
-            "api_key_name": obj.get("api_key_name"),
-            "organization_key": obj.get("organization_key")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Format.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_redirects.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_redirects.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,61 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Auth0Redirects(BaseModel):
     """
-    The redirect URI for you Auth 0 Service  # noqa: E501
-    """
-    authenticated: Optional[StrictStr] = Field(None, description="Where the Auth0 redirects after the user is authorized")
-    unauthenticated: Optional[StrictStr] = Field(None, description="The redirect where a user returns once unauthenticated")
-    __properties = ["authenticated", "unauthenticated"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    The redirect URI for you Auth 0 Service
+    """ # noqa: E501
+    authenticated: Optional[StrictStr] = Field(default=None, description="Where the Auth0 redirects after the user is authorized")
+    unauthenticated: Optional[StrictStr] = Field(default=None, description="The redirect where a user returns once unauthenticated")
+    __properties: ClassVar[List[str]] = ["authenticated", "unauthenticated"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Auth0Redirects:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Auth0Redirects from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Auth0Redirects:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Auth0Redirects from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Auth0Redirects.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Auth0Redirects.parse_obj({
+        _obj = cls.model_validate({
             "authenticated": obj.get("authenticated"),
             "unauthenticated": obj.get("unauthenticated")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_user.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_user.py`

 * *Files 7% similar despite different names*

```diff
@@ -15,102 +15,119 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.auth0_identity import Auth0Identity
 from pieces_os_client.models.auth0_user_metadata import Auth0UserMetadata
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Auth0User(BaseModel):
     """
-      # noqa: E501
-    """
-    name: Optional[StrictStr] = Field(None, description=" User's full name.")
-    picture: Optional[StrictStr] = Field(None, description="mapped from picture.URL pointing to the user's profile picture. ")
+    
+    """ # noqa: E501
+    name: Optional[StrictStr] = Field(default=None, description=" User's full name.")
+    picture: Optional[StrictStr] = Field(default=None, description="mapped from picture.URL pointing to the user's profile picture. ")
     email: Optional[StrictStr] = None
     created_at: Optional[datetime] = None
-    email_verified: Optional[StrictBool] = Field(None, description="Indicates whether the user has verified their email address. Mapped from email_verified -> emailVerified.")
-    family_name: Optional[StrictStr] = Field(None, description="User's family name.")
-    given_name: Optional[StrictStr] = Field(None, description="User's given name. ")
-    identities: Optional[conlist(Auth0Identity)] = Field(None, description="Contains info retrieved from the identity provider with which the user originally authenticates.")
-    nickname: Optional[StrictStr] = Field(None, description="User's nickname. ")
+    email_verified: Optional[StrictBool] = Field(default=None, description="Indicates whether the user has verified their email address. Mapped from email_verified -> emailVerified.")
+    family_name: Optional[StrictStr] = Field(default=None, description="User's family name.")
+    given_name: Optional[StrictStr] = Field(default=None, description="User's given name. ")
+    identities: Optional[List[Auth0Identity]] = Field(default=None, description="Contains info retrieved from the identity provider with which the user originally authenticates.")
+    nickname: Optional[StrictStr] = Field(default=None, description="User's nickname. ")
     updated_at: Optional[datetime] = None
-    username: Optional[StrictStr] = Field(None, description=" (unique) User's username.  ")
+    username: Optional[StrictStr] = Field(default=None, description=" (unique) User's username.  ")
     user_metadata: Optional[Auth0UserMetadata] = None
     locale: Optional[StrictStr] = None
     user_id: Optional[StrictStr] = None
     last_ip: Optional[StrictStr] = None
     last_login: Optional[datetime] = None
     logins_count: Optional[StrictInt] = None
-    blocked_for: Optional[conlist(StrictStr)] = None
-    guardian_authenticators: Optional[conlist(StrictStr)] = None
-    __properties = ["name", "picture", "email", "created_at", "email_verified", "family_name", "given_name", "identities", "nickname", "updated_at", "username", "user_metadata", "locale", "user_id", "last_ip", "last_login", "logins_count", "blocked_for", "guardian_authenticators"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    blocked_for: Optional[List[StrictStr]] = None
+    guardian_authenticators: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["name", "picture", "email", "created_at", "email_verified", "family_name", "given_name", "identities", "nickname", "updated_at", "username", "user_metadata", "locale", "user_id", "last_ip", "last_login", "logins_count", "blocked_for", "guardian_authenticators"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Auth0User:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Auth0User from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in identities (list)
         _items = []
         if self.identities:
             for _item in self.identities:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['identities'] = _items
         # override the default output from pydantic by calling `to_dict()` of user_metadata
         if self.user_metadata:
             _dict['user_metadata'] = self.user_metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Auth0User:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Auth0User from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Auth0User.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Auth0User.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "picture": obj.get("picture"),
             "email": obj.get("email"),
             "created_at": obj.get("created_at"),
             "email_verified": obj.get("email_verified"),
             "family_name": obj.get("family_name"),
             "given_name": obj.get("given_name"),
-            "identities": [Auth0Identity.from_dict(_item) for _item in obj.get("identities")] if obj.get("identities") is not None else None,
+            "identities": [Auth0Identity.from_dict(_item) for _item in obj["identities"]] if obj.get("identities") is not None else None,
             "nickname": obj.get("nickname"),
             "updated_at": obj.get("updated_at"),
             "username": obj.get("username"),
-            "user_metadata": Auth0UserMetadata.from_dict(obj.get("user_metadata")) if obj.get("user_metadata") is not None else None,
+            "user_metadata": Auth0UserMetadata.from_dict(obj["user_metadata"]) if obj.get("user_metadata") is not None else None,
             "locale": obj.get("locale"),
             "user_id": obj.get("user_id"),
             "last_ip": obj.get("last_ip"),
             "last_login": obj.get("last_login"),
             "logins_count": obj.get("logins_count"),
             "blocked_for": obj.get("blocked_for"),
             "guardian_authenticators": obj.get("guardian_authenticators")
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_user_allocation_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_html_webpage.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,61 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Auth0UserAllocationMetadata(BaseModel):
-    """
-    This is specifically for our allocation server metadata.  # noqa: E501
+class SeededDiscoverableHtmlWebpage(BaseModel):
     """
-    project: StrictStr = Field(...)
-    region: StrictStr = Field(...)
-    __properties = ["project", "region"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SeededDiscoverableHtmlWebpage
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    url: StrictStr = Field(description="The route of the page ")
+    page: StrictStr = Field(description="page's html as a string")
+    __properties: ClassVar[List[str]] = ["schema", "url", "page"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Auth0UserAllocationMetadata:
-        """Create an instance of Auth0UserAllocationMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededDiscoverableHtmlWebpage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Auth0UserAllocationMetadata:
-        """Create an instance of Auth0UserAllocationMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededDiscoverableHtmlWebpage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Auth0UserAllocationMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Auth0UserAllocationMetadata.parse_obj({
-            "project": obj.get("project"),
-            "region": obj.get("region")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "url": obj.get("url"),
+            "page": obj.get("page")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/auth0_user_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_user_metadata.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,83 +14,99 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.auth0_open_ai_user_metadata import Auth0OpenAIUserMetadata
 from pieces_os_client.models.auth0_user_allocation_metadata import Auth0UserAllocationMetadata
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Auth0UserMetadata(BaseModel):
     """
-    User Metadata from Auth0  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    global_id: StrictStr = Field(...)
+    User Metadata from Auth0
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    global_id: StrictStr
     cloud_key: Optional[StrictStr] = None
-    stripe_customer_id: Optional[StrictStr] = Field(None, description="A customer ID that is added to the user in the case of payments")
-    vanityname: Optional[StrictStr] = Field(None, description="this is the vanityname of the user.(set from their custom CNAME dns record.) ie mark.pieces.cloud where \"mark\" is the vanityname.")
+    stripe_customer_id: Optional[StrictStr] = Field(default=None, description="A customer ID that is added to the user in the case of payments")
+    vanityname: Optional[StrictStr] = Field(default=None, description="this is the vanityname of the user.(set from their custom CNAME dns record.) ie mark.pieces.cloud where \"mark\" is the vanityname.")
     allocation: Optional[Auth0UserAllocationMetadata] = None
-    open_ai: Optional[Auth0OpenAIUserMetadata] = Field(None, alias="open_AI")
-    __properties = ["schema", "global_id", "cloud_key", "stripe_customer_id", "vanityname", "allocation", "open_AI"]
+    open_ai: Optional[Auth0OpenAIUserMetadata] = Field(default=None, alias="open_AI")
+    __properties: ClassVar[List[str]] = ["schema", "global_id", "cloud_key", "stripe_customer_id", "vanityname", "allocation", "open_AI"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Auth0UserMetadata:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Auth0UserMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of allocation
         if self.allocation:
             _dict['allocation'] = self.allocation.to_dict()
         # override the default output from pydantic by calling `to_dict()` of open_ai
         if self.open_ai:
             _dict['open_AI'] = self.open_ai.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Auth0UserMetadata:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Auth0UserMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Auth0UserMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Auth0UserMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "global_id": obj.get("global_id"),
             "cloud_key": obj.get("cloud_key"),
             "stripe_customer_id": obj.get("stripe_customer_id"),
             "vanityname": obj.get("vanityname"),
-            "allocation": Auth0UserAllocationMetadata.from_dict(obj.get("allocation")) if obj.get("allocation") is not None else None,
-            "open_ai": Auth0OpenAIUserMetadata.from_dict(obj.get("open_AI")) if obj.get("open_AI") is not None else None
+            "allocation": Auth0UserAllocationMetadata.from_dict(obj["allocation"]) if obj.get("allocation") is not None else None,
+            "open_AI": Auth0OpenAIUserMetadata.from_dict(obj["open_AI"]) if obj.get("open_AI") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/available_formats.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/created_external_provider_api_key.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
-from pieces_os_client.models.classification import Classification
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.auth0_user_metadata import Auth0UserMetadata
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AvailableFormats(BaseModel):
-    """
-    This is a specific model here used within the SeededAsset that enables us to return all the available formats on a specific seed that was passed as an input within the '/assets/draft' endpoint  # noqa: E501
+class CreatedExternalProviderApiKey(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Classification) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the outputmodel for /external_provider/api_key/create
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    metadata: Auth0UserMetadata
+    __properties: ClassVar[List[str]] = ["schema", "metadata"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AvailableFormats:
-        """Create an instance of AvailableFormats from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of CreatedExternalProviderApiKey from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
+        # override the default output from pydantic by calling `to_dict()` of metadata
+        if self.metadata:
+            _dict['metadata'] = self.metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AvailableFormats:
-        """Create an instance of AvailableFormats from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of CreatedExternalProviderApiKey from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AvailableFormats.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AvailableFormats.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Classification.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "metadata": Auth0UserMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/byte_descriptor.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/font.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,67 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ByteDescriptor(BaseModel):
-    """
-    This is a nice microclass to help with managing the size of a File or Fragment in a readable way for UI's  # noqa: E501
+class Font(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    value: StrictInt = Field(...)
-    readable: StrictStr = Field(...)
-    __properties = ["schema", "value", "readable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will describe the font that the user sees.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    size: StrictInt
+    __properties: ClassVar[List[str]] = ["schema", "size"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ByteDescriptor:
-        """Create an instance of ByteDescriptor from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Font from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ByteDescriptor:
-        """Create an instance of ByteDescriptor from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Font from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ByteDescriptor.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ByteDescriptor.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "value": obj.get("value"),
-            "readable": obj.get("readable")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "size": obj.get("size")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/capabilities_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_message_sentiment_enum.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,34 +9,31 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class CapabilitiesEnum(str, Enum):
+class ConversationMessageSentimentEnum(str, Enum):
     """
-    This lets us know what capabilites in relation to ml/ cloud infrastructure you are opting into.
+    This will describe the sentiment of a specific message ie if the message was liked/disliked/reported
     """
 
     """
     allowed enum values
     """
-    LOCAL = 'LOCAL'
-    CLOUD = 'CLOUD'
-    BLENDED = 'BLENDED'
+    LIKE = 'LIKE'
+    DISLIKE = 'DISLIKE'
+    REPORT = 'REPORT'
 
     @classmethod
-    def from_json(cls, json_str: str) -> CapabilitiesEnum:
-        """Create an instance of CapabilitiesEnum from a JSON string"""
-        return CapabilitiesEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ConversationMessageSentimentEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/challenged_pkce.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_interaction_event.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,80 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ChallengedPKCE(BaseModel):
-    """
-    A model that Generates A PKCE Challenge Object with the needed requirements.  # noqa: E501
+class TrackedInteractionEvent(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    state: StrictStr = Field(..., description="An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.")
-    nonce: StrictStr = Field(..., description="A local key that is held as the comparator to state, thus they should be the same.")
-    challenge: StrictStr = Field(..., description="Generated challenge from the code_verifier.")
-    method: StrictStr = Field(..., description="Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged.")
-    verifier: StrictStr = Field(..., description="Cryptographically random key that was used to generate the code_challenge passed to /authorize.")
-    __properties = ["schema", "state", "nonce", "challenge", "method", "verifier"]
-
-    @validator('method')
-    def method_validate_enum(cls, value):
-        """Validates the enum"""
-        if value not in ('S256'):
-            raise ValueError("must be one of enum values ('S256')")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a model that will hold relavent information in relation to an interaction(ONLY CLICK/TAP) analytics event(usage). If you want to register an event that relates to an interaction with the key then register a Keyboard Event. 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    description: StrictStr = Field(description="(optional) a description of this button that was clicked. or maybe what it did.")
+    element: Optional[StrictStr] = Field(default=None, description="This is an identifer that will allow the developer to know what unique button/field was interacted with.")
+    __properties: ClassVar[List[str]] = ["schema", "description", "element"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChallengedPKCE:
-        """Create an instance of ChallengedPKCE from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedInteractionEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChallengedPKCE:
-        """Create an instance of ChallengedPKCE from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedInteractionEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChallengedPKCE.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChallengedPKCE.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "state": obj.get("state"),
-            "nonce": obj.get("nonce"),
-            "challenge": obj.get("challenge"),
-            "method": obj.get("method"),
-            "verifier": obj.get("verifier")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "description": obj.get("description"),
+            "element": obj.get("element")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/checked_os_update.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/git_hub_distribution.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,66 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.updating_status_enum import UpdatingStatusEnum
+from pieces_os_client.models.git_hub_gist_distribution import GitHubGistDistribution
+from typing import Optional, Set
+from typing_extensions import Self
 
-class CheckedOSUpdate(BaseModel):
-    """
-    This is the returnable for /os/update/check  # noqa: E501
+class GitHubDistribution(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    status: UpdatingStatusEnum = Field(...)
-    __properties = ["schema", "status"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GitHubDistribution
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    gist: Optional[GitHubGistDistribution] = None
+    __properties: ClassVar[List[str]] = ["schema", "gist"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CheckedOSUpdate:
-        """Create an instance of CheckedOSUpdate from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GitHubDistribution from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of gist
+        if self.gist:
+            _dict['gist'] = self.gist.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CheckedOSUpdate:
-        """Create an instance of CheckedOSUpdate from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GitHubDistribution from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CheckedOSUpdate.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CheckedOSUpdate.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "status": obj.get("status")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "gist": GitHubGistDistribution.from_dict(obj["gist"]) if obj.get("gist") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/classification.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/classification.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,72 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.classification_generic_enum import ClassificationGenericEnum
 from pieces_os_client.models.classification_rendering_enum import ClassificationRenderingEnum
 from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Classification(BaseModel):
     """
-    This is the specific classification of an Asset's Format.(This is on a per format basis b/c an asset could have different formats that are different format representations of the Asset.)  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    generic: ClassificationGenericEnum = Field(...)
-    specific: ClassificationSpecificEnum = Field(...)
+    This is the specific classification of an Asset's Format.(This is on a per format basis b/c an asset could have different formats that are different format representations of the Asset.)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    generic: ClassificationGenericEnum
+    specific: ClassificationSpecificEnum
     rendering: Optional[ClassificationRenderingEnum] = None
-    __properties = ["schema", "generic", "specific", "rendering"]
+    __properties: ClassVar[List[str]] = ["schema", "generic", "specific", "rendering"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Classification:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Classification from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Classification:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Classification from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Classification.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Classification.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "generic": obj.get("generic"),
             "specific": obj.get("specific"),
             "rendering": obj.get("rendering")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/classification_generic_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/classification_generic_enum.py`

 * *Files 15% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ClassificationGenericEnum(str, Enum):
     """
     EXTERNAL_RESOURCE_REFERENCE can be thought of as anything such as URL, URI, UNIX PATH, etc
     """
 
@@ -35,12 +32,12 @@
     IMAGE = 'IMAGE'
     VIDEO = 'VIDEO'
     EXTERNAL_RESOURCE_REFERENCE = 'EXTERNAL_RESOURCE_REFERENCE'
     UNKNOWN = 'UNKNOWN'
     FILE = 'FILE'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ClassificationGenericEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ClassificationGenericEnum from a JSON string"""
-        return ClassificationGenericEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/classification_rendering_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/classification_rendering_enum.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ClassificationRenderingEnum(str, Enum):
     """
     Specifically supported renderings...usually between generic types
     """
 
@@ -31,12 +28,12 @@
     allowed enum values
     """
     HTML = 'HTML'
     TWENTY_FOUR_BIT_ANSI_ESCAPED_SEQUENCES = 'TWENTY_FOUR_BIT_ANSI_ESCAPED_SEQUENCES'
     HIGHLIGHT_JS_HTML = 'HIGHLIGHT_JS_HTML'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ClassificationRenderingEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ClassificationRenderingEnum from a JSON string"""
-        return ClassificationRenderingEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/classification_specific_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/classification_specific_enum.py`

 * *Files 1% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ClassificationSpecificEnum(str, Enum):
     """
     
     """
 
@@ -518,14 +515,16 @@
     SOL = 'sol'
     SV = 'sv'
     ASP = 'asp'
     CFM = 'cfm'
     FS = 'fs'
     FSI = 'fsi'
     FSX = 'fsx'
+    TF = 'tf'
+    VBA = 'vba'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ClassificationSpecificEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ClassificationSpecificEnum from a JSON string"""
-        return ClassificationSpecificEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/code_analyses.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/formats_metrics.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
-from pieces_os_client.models.code_analysis import CodeAnalysis
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.format_metric import FormatMetric
+from typing import Optional, Set
+from typing_extensions import Self
 
-class CodeAnalyses(BaseModel):
-    """
-    CodeAnalyses
+class FormatsMetrics(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(CodeAnalysis) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[FormatMetric]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CodeAnalyses:
-        """Create an instance of CodeAnalyses from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FormatsMetrics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CodeAnalyses:
-        """Create an instance of CodeAnalyses from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FormatsMetrics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CodeAnalyses.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CodeAnalyses.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [CodeAnalysis.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [FormatMetric.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/code_analysis.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/code_analysis.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,88 +14,104 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional, Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.classification_generic_enum import ClassificationGenericEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.model import Model
+from typing import Optional, Set
+from typing_extensions import Self
 
 class CodeAnalysis(BaseModel):
     """
-    This is the ML Analysis object Specific to code.  prediction and similarity are custom types {[string]: number}. ** please dont not modify **  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    tokenized: Optional[conlist(StrictStr)] = None
+    This is the ML Analysis object Specific to code.  prediction and similarity are custom types {[string]: number}. ** please dont not modify **
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    tokenized: Optional[List[StrictStr]] = None
     language: Optional[StrictStr] = None
-    type: ClassificationGenericEnum = Field(...)
+    type: ClassificationGenericEnum
     prediction: Optional[Dict[str, Union[StrictFloat, StrictInt]]] = None
     similarity: Optional[Dict[str, Union[StrictFloat, StrictInt]]] = None
-    top5_colors: Optional[conlist(StrictInt)] = Field(None, alias="top5Colors")
-    top5_sorted: Optional[conlist(StrictStr)] = Field(None, alias="top5Sorted")
-    id: StrictStr = Field(...)
-    analysis: StrictStr = Field(..., description="this is just a reference to the analysis parent object.")
-    model: Model = Field(...)
-    __properties = ["schema", "tokenized", "language", "type", "prediction", "similarity", "top5Colors", "top5Sorted", "id", "analysis", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    top5_colors: Optional[List[StrictInt]] = Field(default=None, alias="top5Colors")
+    top5_sorted: Optional[List[StrictStr]] = Field(default=None, alias="top5Sorted")
+    id: StrictStr
+    analysis: StrictStr = Field(description="this is just a reference to the analysis parent object.")
+    model: Model
+    __properties: ClassVar[List[str]] = ["schema", "tokenized", "language", "type", "prediction", "similarity", "top5Colors", "top5Sorted", "id", "analysis", "model"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CodeAnalysis:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of CodeAnalysis from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of model
         if self.model:
             _dict['model'] = self.model.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CodeAnalysis:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of CodeAnalysis from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CodeAnalysis.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CodeAnalysis.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "tokenized": obj.get("tokenized"),
             "language": obj.get("language"),
             "type": obj.get("type"),
             "prediction": obj.get("prediction"),
             "similarity": obj.get("similarity"),
-            "top5_colors": obj.get("top5Colors"),
-            "top5_sorted": obj.get("top5Sorted"),
+            "top5Colors": obj.get("top5Colors"),
+            "top5Sorted": obj.get("top5Sorted"),
             "id": obj.get("id"),
             "analysis": obj.get("analysis"),
-            "model": Model.from_dict(obj.get("model")) if obj.get("model") is not None else None
+            "model": Model.from_dict(obj["model"]) if obj.get("model") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/context.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/context.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,57 +14,73 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.application import Application
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.health import Health
 from pieces_os_client.models.user_profile import UserProfile
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Context(BaseModel):
     """
-    A Context that is returned from almost all calls to the ContextAPI  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    os: StrictStr = Field(..., description="This is th UUID of the OS that this context is currently connected to. This attempts to be the same as Segment's anonmyousId feild. It is attempted to be set at initial installation at Pieces/.identity/.os")
-    application: Application = Field(...)
-    health: Health = Field(...)
+    A Context that is returned from almost all calls to the ContextAPI
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    os: StrictStr = Field(description="This is th UUID of the OS that this context is currently connected to. This attempts to be the same as Segment's anonmyousId feild. It is attempted to be set at initial installation at Pieces/.identity/.os")
+    application: Application
+    health: Health
     user: Optional[UserProfile] = None
-    __properties = ["schema", "os", "application", "health", "user"]
+    __properties: ClassVar[List[str]] = ["schema", "os", "application", "health", "user"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Context:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Context from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of application
         if self.application:
             _dict['application'] = self.application.to_dict()
         # override the default output from pydantic by calling `to_dict()` of health
@@ -72,25 +88,25 @@
             _dict['health'] = self.health.to_dict()
         # override the default output from pydantic by calling `to_dict()` of user
         if self.user:
             _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Context:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Context from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Context.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Context.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "os": obj.get("os"),
-            "application": Application.from_dict(obj.get("application")) if obj.get("application") is not None else None,
-            "health": Health.from_dict(obj.get("health")) if obj.get("health") is not None else None,
-            "user": UserProfile.from_dict(obj.get("user")) if obj.get("user") is not None else None
+            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "health": Health.from_dict(obj["health"]) if obj.get("health") is not None else None,
+            "user": UserProfile.from_dict(obj["user"]) if obj.get("user") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/conversation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,77 +14,96 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.application import Application
 from pieces_os_client.models.conversation_grounding import ConversationGrounding
 from pieces_os_client.models.conversation_type_enum import ConversationTypeEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_anchors import FlattenedAnchors
 from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
 from pieces_os_client.models.flattened_assets import FlattenedAssets
 from pieces_os_client.models.flattened_conversation_messages import FlattenedConversationMessages
 from pieces_os_client.models.flattened_websites import FlattenedWebsites
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from pieces_os_client.models.qgpt_prompt_pipeline import QGPTPromptPipeline
 from pieces_os_client.models.referenced_model import ReferencedModel
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Conversation(BaseModel):
     """
-    This is a fully referenced Conversation.  This will hold together a conversation. Ie allthe message within a conversation.  All the additional properties on here used on here like(anchors/assets) are used for context that will seed the conversation.  model is a calculated property, and will be the model of the last message sent if applicable.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    name: Optional[StrictStr] = Field(None, description="This is a name that is customized.")
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    This is a fully referenced Conversation.  This will hold together a conversation. Ie allthe message within a conversation.  All the additional properties on here used on here like(anchors/assets) are used for context that will seed the conversation.  model is a calculated property, and will be the model of the last message sent if applicable.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    name: Optional[StrictStr] = Field(default=None, description="This is a name that is customized.")
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     favorited: Optional[StrictBool] = None
     application: Optional[Application] = None
     annotations: Optional[FlattenedAnnotations] = None
-    messages: FlattenedConversationMessages = Field(...)
+    messages: FlattenedConversationMessages
     model: Optional[ReferencedModel] = None
     assets: Optional[FlattenedAssets] = None
     websites: Optional[FlattenedWebsites] = None
     anchors: Optional[FlattenedAnchors] = None
-    type: ConversationTypeEnum = Field(...)
+    type: ConversationTypeEnum
     grounding: Optional[ConversationGrounding] = None
     score: Optional[Score] = None
-    __properties = ["schema", "id", "name", "created", "updated", "deleted", "favorited", "application", "annotations", "messages", "model", "assets", "websites", "anchors", "type", "grounding", "score"]
+    pipeline: Optional[QGPTPromptPipeline] = None
+    demo: Optional[StrictBool] = Field(default=None, description="This will let us know if this conversation was generated as a 'demo' conversation")
+    __properties: ClassVar[List[str]] = ["schema", "id", "name", "created", "updated", "deleted", "favorited", "application", "annotations", "messages", "model", "assets", "websites", "anchors", "type", "grounding", "score", "pipeline", "demo"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Conversation:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Conversation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -116,40 +135,45 @@
             _dict['anchors'] = self.anchors.to_dict()
         # override the default output from pydantic by calling `to_dict()` of grounding
         if self.grounding:
             _dict['grounding'] = self.grounding.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of pipeline
+        if self.pipeline:
+            _dict['pipeline'] = self.pipeline.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Conversation:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Conversation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Conversation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Conversation.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
             "name": obj.get("name"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
             "favorited": obj.get("favorited"),
-            "application": Application.from_dict(obj.get("application")) if obj.get("application") is not None else None,
-            "annotations": FlattenedAnnotations.from_dict(obj.get("annotations")) if obj.get("annotations") is not None else None,
-            "messages": FlattenedConversationMessages.from_dict(obj.get("messages")) if obj.get("messages") is not None else None,
-            "model": ReferencedModel.from_dict(obj.get("model")) if obj.get("model") is not None else None,
-            "assets": FlattenedAssets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "websites": FlattenedWebsites.from_dict(obj.get("websites")) if obj.get("websites") is not None else None,
-            "anchors": FlattenedAnchors.from_dict(obj.get("anchors")) if obj.get("anchors") is not None else None,
+            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "annotations": FlattenedAnnotations.from_dict(obj["annotations"]) if obj.get("annotations") is not None else None,
+            "messages": FlattenedConversationMessages.from_dict(obj["messages"]) if obj.get("messages") is not None else None,
+            "model": ReferencedModel.from_dict(obj["model"]) if obj.get("model") is not None else None,
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "websites": FlattenedWebsites.from_dict(obj["websites"]) if obj.get("websites") is not None else None,
+            "anchors": FlattenedAnchors.from_dict(obj["anchors"]) if obj.get("anchors") is not None else None,
             "type": obj.get("type"),
-            "grounding": ConversationGrounding.from_dict(obj.get("grounding")) if obj.get("grounding") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "grounding": ConversationGrounding.from_dict(obj["grounding"]) if obj.get("grounding") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None,
+            "pipeline": QGPTPromptPipeline.from_dict(obj["pipeline"]) if obj.get("pipeline") is not None else None,
+            "demo": obj.get("demo")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_grounding.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_connector_connection.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,79 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.seeded_tracked_application import SeededTrackedApplication
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ConversationGrounding(BaseModel):
-    """
-    This is the context used for grounding the ml models with reguard to a conversation.  # noqa: E501
+class SeededConnectorConnection(BaseModel):
     """
+    A model that is passed to the context API at bootup
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    application: SeededTrackedApplication
+    __properties: ClassVar[List[str]] = ["schema", "application"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    messages: Optional[FlattenedConversationMessages] = None
-    __properties = ["schema", "messages"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConversationGrounding:
-        """Create an instance of ConversationGrounding from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededConnectorConnection from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of messages
-        if self.messages:
-            _dict["messages"] = self.messages.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of application
+        if self.application:
+            _dict['application'] = self.application.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConversationGrounding:
-        """Create an instance of ConversationGrounding from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededConnectorConnection from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConversationGrounding.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConversationGrounding.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "messages": FlattenedConversationMessages.from_dict(obj.get("messages"))
-                if obj.get("messages") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "application": SeededTrackedApplication.from_dict(obj["application"]) if obj.get("application") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_conversation_messages import (
-    FlattenedConversationMessages,
-)
-
-# ConversationGrounding.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_message.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_message.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.conversation_message_sentiment_enum import ConversationMessageSentimentEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
 from pieces_os_client.models.fragment_format import FragmentFormat
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.model import Model
 from pieces_os_client.models.qgpt_conversation_message_role_enum import QGPTConversationMessageRoleEnum
 from pieces_os_client.models.referenced_conversation import ReferencedConversation
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ConversationMessage(BaseModel):
     """
-    This is a fully referenced ConversationMessage.  This has the minimum amount of properties to keep this light weight  (will consider additional properties in the future like people/tags/links xyz)  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    This is a fully referenced ConversationMessage.  This has the minimum amount of properties to keep this light weight  (will consider additional properties in the future like people/tags/links xyz)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     model: Optional[Model] = None
     fragment: Optional[FragmentFormat] = None
-    conversation: ReferencedConversation = Field(...)
+    conversation: ReferencedConversation
     sentiment: Optional[ConversationMessageSentimentEnum] = None
-    role: QGPTConversationMessageRoleEnum = Field(...)
+    role: QGPTConversationMessageRoleEnum
     score: Optional[Score] = None
     annotations: Optional[FlattenedAnnotations] = None
-    __properties = ["schema", "id", "created", "updated", "deleted", "model", "fragment", "conversation", "sentiment", "role", "score", "annotations"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "deleted", "model", "fragment", "conversation", "sentiment", "role", "score", "annotations"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConversationMessage:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ConversationMessage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -99,32 +115,32 @@
             _dict['score'] = self.score.to_dict()
         # override the default output from pydantic by calling `to_dict()` of annotations
         if self.annotations:
             _dict['annotations'] = self.annotations.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConversationMessage:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ConversationMessage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConversationMessage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConversationMessage.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
-            "model": Model.from_dict(obj.get("model")) if obj.get("model") is not None else None,
-            "fragment": FragmentFormat.from_dict(obj.get("fragment")) if obj.get("fragment") is not None else None,
-            "conversation": ReferencedConversation.from_dict(obj.get("conversation")) if obj.get("conversation") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "model": Model.from_dict(obj["model"]) if obj.get("model") is not None else None,
+            "fragment": FragmentFormat.from_dict(obj["fragment"]) if obj.get("fragment") is not None else None,
+            "conversation": ReferencedConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
             "sentiment": obj.get("sentiment"),
             "role": obj.get("role"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None,
-            "annotations": FlattenedAnnotations.from_dict(obj.get("annotations")) if obj.get("annotations") is not None else None
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None,
+            "annotations": FlattenedAnnotations.from_dict(obj["annotations"]) if obj.get("annotations") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_message_sentiment_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/filter_operation_type_enum.py`

 * *Files 21% similar despite different names*

```diff
@@ -9,34 +9,30 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class ConversationMessageSentimentEnum(str, Enum):
+class FilterOperationTypeEnum(str, Enum):
     """
-    This will describe the sentiment of a specific message ie if the message was liked/disliked/reported
+    FilterOperationTypeEnum
     """
 
     """
     allowed enum values
     """
-    LIKE = 'LIKE'
-    DISLIKE = 'DISLIKE'
-    REPORT = 'REPORT'
+    AND = 'AND'
+    OR = 'OR'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConversationMessageSentimentEnum:
-        """Create an instance of ConversationMessageSentimentEnum from a JSON string"""
-        return ConversationMessageSentimentEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of FilterOperationTypeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_messages.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_messages.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,55 +14,71 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.conversation_message import ConversationMessage
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ConversationMessages(BaseModel):
     """
-    This is a plural version of ConversationMessage.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ConversationMessage) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(None, description="This is a Map<String, int> where the the key is an ConversationMessage id.")
+    This is a plural version of ConversationMessage.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[ConversationMessage]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an ConversationMessage id.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConversationMessages:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ConversationMessages from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
@@ -71,24 +87,24 @@
             _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConversationMessages:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ConversationMessages from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConversationMessages.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConversationMessages.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [ConversationMessage.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ConversationMessage.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
             "indices": obj.get("indices"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_summarize_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_summarize_input.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_conversation_messages import FlattenedConversationMessages
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ConversationSummarizeInput(BaseModel):
     """
-    Optionally you may pass in a list of conversation message that you would like to use for the summary.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    Optionally you may pass in a list of conversation message that you would like to use for the summary.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     messages: Optional[FlattenedConversationMessages] = None
-    __properties = ["schema", "messages"]
+    __properties: ClassVar[List[str]] = ["schema", "messages"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConversationSummarizeInput:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ConversationSummarizeInput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of messages
         if self.messages:
             _dict['messages'] = self.messages.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConversationSummarizeInput:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ConversationSummarizeInput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConversationSummarizeInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConversationSummarizeInput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "messages": FlattenedConversationMessages.from_dict(obj.get("messages")) if obj.get("messages") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "messages": FlattenedConversationMessages.from_dict(obj["messages"]) if obj.get("messages") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_summarize_output.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversation_grounding.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,75 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.referenced_annotation import ReferencedAnnotation
-from pieces_os_client.models.referenced_conversation import ReferencedConversation
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ConversationSummarizeOutput(BaseModel):
-    """
-    This is the output model for \"/conversation/{conversation}/summarize  # noqa: E501
+class ConversationGrounding(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    conversation: ReferencedConversation = Field(...)
-    annotation: ReferencedAnnotation = Field(...)
-    __properties = ["schema", "conversation", "annotation"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the context used for grounding the ml models with reguard to a conversation.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    messages: Optional[FlattenedConversationMessages] = None
+    __properties: ClassVar[List[str]] = ["schema", "messages"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConversationSummarizeOutput:
-        """Create an instance of ConversationSummarizeOutput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ConversationGrounding from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of conversation
-        if self.conversation:
-            _dict['conversation'] = self.conversation.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of annotation
-        if self.annotation:
-            _dict['annotation'] = self.annotation.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of messages
+        if self.messages:
+            _dict['messages'] = self.messages.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConversationSummarizeOutput:
-        """Create an instance of ConversationSummarizeOutput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ConversationGrounding from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConversationSummarizeOutput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConversationSummarizeOutput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "conversation": ReferencedConversation.from_dict(obj.get("conversation")) if obj.get("conversation") is not None else None,
-            "annotation": ReferencedAnnotation.from_dict(obj.get("annotation")) if obj.get("annotation") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "messages": FlattenedConversationMessages.from_dict(obj["messages"]) if obj.get("messages") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.flattened_conversation_messages import FlattenedConversationMessages
+# TODO: Rewrite to not use raise_errors
+ConversationGrounding.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/conversation_type_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/sensitive_severity_enum.py`

 * *Files 23% similar despite different names*

```diff
@@ -9,32 +9,31 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class ConversationTypeEnum(str, Enum):
+class SensitiveSeverityEnum(str, Enum):
     """
-    This is a type of conversation, for now just COPILOT.
+    This is the enum used to describe the severity of our sensitive model. ie low, moderate, high
     """
 
     """
     allowed enum values
     """
-    COPILOT = 'COPILOT'
+    LOW = 'LOW'
+    MODERATE = 'MODERATE'
+    HIGH = 'HIGH'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConversationTypeEnum:
-        """Create an instance of ConversationTypeEnum from a JSON string"""
-        return ConversationTypeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of SensitiveSeverityEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/conversations.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/code_analyses.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,81 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
-from pieces_os_client.models.conversation import Conversation
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.code_analysis import CodeAnalysis
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Conversations(BaseModel):
-    """
-    This is a plural version of a Conversation.  # noqa: E501
+class CodeAnalyses(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Conversation) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(None, description="This is a Map<String, int> where the the key is an Conversation id.")
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CodeAnalyses
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[CodeAnalysis]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Conversations:
-        """Create an instance of Conversations from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of CodeAnalyses from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Conversations:
-        """Create an instance of Conversations from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of CodeAnalyses from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Conversations.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Conversations.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Conversation.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "indices": obj.get("indices"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [CodeAnalysis.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/conversations_create_from_asset_output.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversations_create_from_asset_output.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.referenced_conversation import ReferencedConversation
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ConversationsCreateFromAssetOutput(BaseModel):
     """
-    This is the model for the output for the \"/conversations/create/from_asset/{asset}\" endpoints.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    conversation: ReferencedConversation = Field(...)
-    __properties = ["schema", "conversation"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the model for the output for the \"/conversations/create/from_asset/{asset}\" endpoints.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    conversation: ReferencedConversation
+    __properties: ClassVar[List[str]] = ["schema", "conversation"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConversationsCreateFromAssetOutput:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ConversationsCreateFromAssetOutput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversation
         if self.conversation:
             _dict['conversation'] = self.conversation.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConversationsCreateFromAssetOutput:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ConversationsCreateFromAssetOutput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConversationsCreateFromAssetOutput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConversationsCreateFromAssetOutput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "conversation": ReferencedConversation.from_dict(obj.get("conversation")) if obj.get("conversation") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "conversation": ReferencedConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/created_external_provider_api_key.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/mailgun_distribution.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
-from pieces_os_client.models.auth0_user_metadata import Auth0UserMetadata
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.recipients import Recipients
+from typing import Optional, Set
+from typing_extensions import Self
 
-class CreatedExternalProviderApiKey(BaseModel):
-    """
-    This is the outputmodel for /external_provider/api_key/create  # noqa: E501
+class MailgunDistribution(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    metadata: Auth0UserMetadata = Field(...)
-    __properties = ["schema", "metadata"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a specific Distribution for mailgun specific information.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    recipients: Recipients
+    __properties: ClassVar[List[str]] = ["schema", "recipients"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CreatedExternalProviderApiKey:
-        """Create an instance of CreatedExternalProviderApiKey from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of MailgunDistribution from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of metadata
-        if self.metadata:
-            _dict['metadata'] = self.metadata.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of recipients
+        if self.recipients:
+            _dict['recipients'] = self.recipients.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CreatedExternalProviderApiKey:
-        """Create an instance of CreatedExternalProviderApiKey from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of MailgunDistribution from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CreatedExternalProviderApiKey.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CreatedExternalProviderApiKey.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "metadata": Auth0UserMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "recipients": Recipients.from_dict(obj["recipients"]) if obj.get("recipients") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/deleted_external_provider_api_key.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/updated_external_provider_api_key.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.auth0_user_metadata import Auth0UserMetadata
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class DeletedExternalProviderApiKey(BaseModel):
-    """
-    This is the returnable for the \"\"/external_provider/api_key/delete\" endpoint  # noqa: E501
+class UpdatedExternalProviderApiKey(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    metadata: Auth0UserMetadata = Field(...)
-    __properties = ["schema", "metadata"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the update Auth0UserMetadata object, and the specific update output model for \"/external_provider/api_key/update\"
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    metadata: Auth0UserMetadata
+    __properties: ClassVar[List[str]] = ["schema", "metadata"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DeletedExternalProviderApiKey:
-        """Create an instance of DeletedExternalProviderApiKey from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UpdatedExternalProviderApiKey from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
             _dict['metadata'] = self.metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DeletedExternalProviderApiKey:
-        """Create an instance of DeletedExternalProviderApiKey from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UpdatedExternalProviderApiKey from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DeletedExternalProviderApiKey.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DeletedExternalProviderApiKey.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "metadata": Auth0UserMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "metadata": Auth0UserMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_connector_asset.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,89 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.seeded_asset_metadata import SeededAssetMetadata
-from pieces_os_client.models.seeded_file import SeededFile
-from pieces_os_client.models.seeded_fragment import SeededFragment
-from pieces_os_client.models.tlp_directed_discovery_filters import TLPDirectedDiscoveryFilters
+from pieces_os_client.models.seeded_format import SeededFormat
+from typing import Optional, Set
+from typing_extensions import Self
 
-class DiscoveredAsset(BaseModel):
-    """
-      # noqa: E501
+class SeededConnectorAsset(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    file: Optional[SeededFile] = None
-    fragment: Optional[SeededFragment] = None
-    directory: Optional[StrictStr] = None
+    A generic model to use with the Connector API that requires little to no additional information about the current application.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     metadata: Optional[SeededAssetMetadata] = None
-    filters: Optional[TLPDirectedDiscoveryFilters] = None
-    __properties = ["schema", "file", "fragment", "directory", "metadata", "filters"]
+    format: SeededFormat
+    __properties: ClassVar[List[str]] = ["schema", "metadata", "format"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DiscoveredAsset:
-        """Create an instance of DiscoveredAsset from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededConnectorAsset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of file
-        if self.file:
-            _dict['file'] = self.file.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of fragment
-        if self.fragment:
-            _dict['fragment'] = self.fragment.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
             _dict['metadata'] = self.metadata.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of filters
-        if self.filters:
-            _dict['filters'] = self.filters.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of format
+        if self.format:
+            _dict['format'] = self.format.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DiscoveredAsset:
-        """Create an instance of DiscoveredAsset from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededConnectorAsset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DiscoveredAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DiscoveredAsset.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "file": SeededFile.from_dict(obj.get("file")) if obj.get("file") is not None else None,
-            "fragment": SeededFragment.from_dict(obj.get("fragment")) if obj.get("fragment") is not None else None,
-            "directory": obj.get("directory"),
-            "metadata": SeededAssetMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None,
-            "filters": TLPDirectedDiscoveryFilters.from_dict(obj.get("filters")) if obj.get("filters") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "metadata": SeededAssetMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None,
+            "format": SeededFormat.from_dict(obj["format"]) if obj.get("format") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_assets.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_html_webpages.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from pieces_os_client.models.discovered_asset import DiscoveredAsset
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.seeded_discoverable_html_webpage import SeededDiscoverableHtmlWebpage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class DiscoveredAssets(BaseModel):
-    """
-    This is a plural Model that is used within the bulk upload flow in both cases of a file(&& needing snippitization) as well as if the fragments are passed in and they only need to be clustered.  # noqa: E501
+class SeededDiscoverableHtmlWebpages(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    application: StrictStr = Field(..., description="application id.")
-    iterable: conlist(DiscoveredAsset) = Field(..., description="This is an iterable of already snippitized snippets that have been clustered.(These are assets that are going to be uploaded or at minimum the assets that we reccommend to upload)")
-    __properties = ["schema", "application", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SeededDiscoverableHtmlWebpages
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[SeededDiscoverableHtmlWebpage]
+    application: StrictStr = Field(description="This is the applicaiton Id used to connect to Pieces OS.")
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "application"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DiscoveredAssets:
-        """Create an instance of DiscoveredAssets from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededDiscoverableHtmlWebpages from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DiscoveredAssets:
-        """Create an instance of DiscoveredAssets from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededDiscoverableHtmlWebpages from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DiscoveredAssets.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DiscoveredAssets.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "application": obj.get("application"),
-            "iterable": [DiscoveredAsset.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [SeededDiscoverableHtmlWebpage.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "application": obj.get("application")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_html_webpage.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/models.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,71 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.discovered_assets import DiscoveredAssets
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.model import Model
+from typing import Optional, Set
+from typing_extensions import Self
 
-class DiscoveredHtmlWebpage(BaseModel):
-    """
-    This will return assets that were extracted from the html webpage. This will contain the original url so you can double check the results wtih the results you passed in, but it will remain in the same order that it was passed in if used within the /discover/discover/html/webpage endpoint.  # noqa: E501
+class Models(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    assets: DiscoveredAssets = Field(...)
-    url: StrictStr = Field(...)
-    __properties = ["schema", "assets", "url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a List of MachineLearning Models
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Model]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DiscoveredHtmlWebpage:
-        """Create an instance of DiscoveredHtmlWebpage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Models from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of assets
-        if self.assets:
-            _dict['assets'] = self.assets.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
+        _items = []
+        if self.iterable:
+            for _item in self.iterable:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DiscoveredHtmlWebpage:
-        """Create an instance of DiscoveredHtmlWebpage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Models from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DiscoveredHtmlWebpage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DiscoveredHtmlWebpage.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "assets": DiscoveredAssets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "url": obj.get("url")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Model.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_html_webpages.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_html_webpages.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.discovered_html_webpage import DiscoveredHtmlWebpage
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class DiscoveredHtmlWebpages(BaseModel):
     """
-    Assumption: The iterable will be in the exact same order as it was passed in within the seededDiscoveredHtmlWebpages  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(DiscoveredHtmlWebpage) = Field(...)
-    application: StrictStr = Field(...)
-    __properties = ["schema", "iterable", "application"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Assumption: The iterable will be in the exact same order as it was passed in within the seededDiscoveredHtmlWebpages
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[DiscoveredHtmlWebpage]
+    application: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "application"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DiscoveredHtmlWebpages:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of DiscoveredHtmlWebpages from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DiscoveredHtmlWebpages:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of DiscoveredHtmlWebpages from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DiscoveredHtmlWebpages.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DiscoveredHtmlWebpages.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [DiscoveredHtmlWebpage.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [DiscoveredHtmlWebpage.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
             "application": obj.get("application")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_related_tag.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_related_tag.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.seeded_tag import SeededTag
+from typing import Optional, Set
+from typing_extensions import Self
 
 class DiscoveredRelatedTag(BaseModel):
     """
     DiscoveredRelatedTag
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    seed: SeededTag = Field(...)
-    __properties = ["schema", "seed"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    seed: SeededTag
+    __properties: ClassVar[List[str]] = ["schema", "seed"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DiscoveredRelatedTag:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of DiscoveredRelatedTag from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of seed
         if self.seed:
             _dict['seed'] = self.seed.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DiscoveredRelatedTag:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of DiscoveredRelatedTag from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DiscoveredRelatedTag.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DiscoveredRelatedTag.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "seed": SeededTag.from_dict(obj.get("seed")) if obj.get("seed") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "seed": SeededTag.from_dict(obj["seed"]) if obj.get("seed") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_related_tags.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/applications.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,75 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from pieces_os_client.models.discovered_related_tag import DiscoveredRelatedTag
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.application import Application
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class DiscoveredRelatedTags(BaseModel):
-    """
-    DiscoveredRelatedTags
+class Applications(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    application: StrictStr = Field(...)
-    iterable: conlist(DiscoveredRelatedTag) = Field(...)
-    __properties = ["schema", "application", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A list of all the applications
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Application]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DiscoveredRelatedTags:
-        """Create an instance of DiscoveredRelatedTags from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Applications from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DiscoveredRelatedTags:
-        """Create an instance of DiscoveredRelatedTags from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Applications from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DiscoveredRelatedTags.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DiscoveredRelatedTags.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "application": obj.get("application"),
-            "iterable": [DiscoveredRelatedTag.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Application.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_sensitive.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/byte_descriptor.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,71 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_sensitive import SeededSensitive
+from typing import Optional, Set
+from typing_extensions import Self
 
-class DiscoveredSensitive(BaseModel):
-    """
-    This will return a discoveredSensitive, with a seed that can be used to create if automatic is set to false. and will provide the original text provided.  # noqa: E501
+class ByteDescriptor(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    seed: SeededSensitive = Field(...)
-    text: StrictStr = Field(...)
-    __properties = ["schema", "seed", "text"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a nice microclass to help with managing the size of a File or Fragment in a readable way for UI's
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    value: StrictInt
+    readable: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "value", "readable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DiscoveredSensitive:
-        """Create an instance of DiscoveredSensitive from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ByteDescriptor from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of seed
-        if self.seed:
-            _dict['seed'] = self.seed.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DiscoveredSensitive:
-        """Create an instance of DiscoveredSensitive from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ByteDescriptor from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DiscoveredSensitive.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DiscoveredSensitive.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "seed": SeededSensitive.from_dict(obj.get("seed")) if obj.get("seed") is not None else None,
-            "text": obj.get("text")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "value": obj.get("value"),
+            "readable": obj.get("readable")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/discovered_sensitives.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,75 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from pieces_os_client.models.discovered_sensitive import DiscoveredSensitive
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.qgpt_conversation_message import QGPTConversationMessage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class DiscoveredSensitives(BaseModel):
-    """
-      # noqa: E501
+class QGPTConversation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(DiscoveredSensitive) = Field(...)
-    application: StrictStr = Field(...)
-    __properties = ["schema", "iterable", "application"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    QGPTConversation
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: Optional[List[QGPTConversationMessage]] = None
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DiscoveredSensitives:
-        """Create an instance of DiscoveredSensitives from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTConversation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DiscoveredSensitives:
-        """Create an instance of DiscoveredSensitives from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTConversation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DiscoveredSensitives.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DiscoveredSensitives.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [DiscoveredSensitive.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "application": obj.get("application")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [QGPTConversationMessage.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/distribution.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/distribution.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,61 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_share import FlattenedShare
 from pieces_os_client.models.git_hub_distribution import GitHubDistribution
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mailgun_distribution import MailgunDistribution
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Distribution(BaseModel):
     """
-    This is a fully referenced version of a Distribution. TODO add additional distributions such as slack, google_chat, ...etc  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    share: FlattenedShare = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    This is a fully referenced version of a Distribution. TODO add additional distributions such as slack, google_chat, ...etc
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    share: FlattenedShare
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     mailgun: Optional[MailgunDistribution] = None
     github: Optional[GitHubDistribution] = None
-    __properties = ["schema", "id", "share", "created", "updated", "deleted", "mailgun", "github"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "share", "created", "updated", "deleted", "mailgun", "github"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Distribution:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Distribution from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of share
         if self.share:
             _dict['share'] = self.share.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
@@ -85,28 +101,28 @@
             _dict['mailgun'] = self.mailgun.to_dict()
         # override the default output from pydantic by calling `to_dict()` of github
         if self.github:
             _dict['github'] = self.github.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Distribution:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Distribution from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Distribution.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Distribution.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
-            "share": FlattenedShare.from_dict(obj.get("share")) if obj.get("share") is not None else None,
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
-            "mailgun": MailgunDistribution.from_dict(obj.get("mailgun")) if obj.get("mailgun") is not None else None,
-            "github": GitHubDistribution.from_dict(obj.get("github")) if obj.get("github") is not None else None
+            "share": FlattenedShare.from_dict(obj["share"]) if obj.get("share") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "mailgun": MailgunDistribution.from_dict(obj["mailgun"]) if obj.get("mailgun") is not None else None,
+            "github": GitHubDistribution.from_dict(obj["github"]) if obj.get("github") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/distributions.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_distributions.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
-from pieces_os_client.models.distribution import Distribution
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.seeded_distribution import SeededDistribution
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Distributions(BaseModel):
-    """
-    This is the plural Model of a Distribution.  # noqa: E501
+class SeededDistributions(BaseModel):
     """
-    iterable: conlist(Distribution) = Field(...)
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    __properties = ["iterable", "schema"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the plural version of a SeededDistribution that is not referenced just yet.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[SeededDistribution]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Distributions:
-        """Create an instance of Distributions from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededDistributions from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Distributions:
-        """Create an instance of Distributions from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededDistributions from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Distributions.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Distributions.parse_obj({
-            "iterable": [Distribution.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [SeededDistribution.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/edges.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_directed_discovery_filter.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,67 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List
+from pieces_os_client.models.tlp_directed_discovery_filter_enum import TLPDirectedDiscoveryFilterEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from pieces_os_client.models.node import Node
-
-class Edges(BaseModel):
-    """
-    Edges
+class TLPDirectedDiscoveryFilter(BaseModel):
     """
-    iterable: conlist(Node) = Field(...)
-    __properties = ["iterable"]
+    Contains enum which represents code block type
+    """ # noqa: E501
+    name: TLPDirectedDiscoveryFilterEnum
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Edges:
-        """Create an instance of Edges from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPDirectedDiscoveryFilter from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Edges:
-        """Create an instance of Edges from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPDirectedDiscoveryFilter from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Edges.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Edges.parse_obj({
-            "iterable": [Node.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/embedded_model_schema.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_health.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,62 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictInt
-from pieces_os_client.models.embedded_model_schema_semantic_version_enum import EmbeddedModelSchemaSemanticVersionEnum
-
-class EmbeddedModelSchema(BaseModel):
-    """
-    This is a model that will keep track of all of our version related to our models. ie (1) the database migration and (2) the global semantic version of the api.  # noqa: E501
+class OSHealth(BaseModel):
     """
-    migration: StrictInt = Field(..., description="this is the current database version that this model was used for.")
-    semantic: EmbeddedModelSchemaSemanticVersionEnum = Field(...)
-    __properties = ["migration", "semantic"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a specific model for the health of our OS Server.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="id of your OS")
+    version: StrictStr = Field(description="this is the current OS version")
+    __properties: ClassVar[List[str]] = ["schema", "id", "version"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> EmbeddedModelSchema:
-        """Create an instance of EmbeddedModelSchema from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OSHealth from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> EmbeddedModelSchema:
-        """Create an instance of EmbeddedModelSchema from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OSHealth from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return EmbeddedModelSchema.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = EmbeddedModelSchema.parse_obj({
-            "migration": obj.get("migration"),
-            "semantic": obj.get("semantic")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "version": obj.get("version")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/embedded_model_schema_semantic_version_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/embedded_model_schema_semantic_version_enum.py`

 * *Files 15% similar despite different names*

```diff
@@ -9,32 +9,29 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class EmbeddedModelSchemaSemanticVersionEnum(str, Enum):
     """
     This is a Semantic Version Enum that will reflect the Semantic version of the api.
     """
 
     """
     allowed enum values
     """
     MAJOR_0_MINOR_0_PATCH_1 = 'MAJOR_0_MINOR_0_PATCH_1'
 
     @classmethod
-    def from_json(cls, json_str: str) -> EmbeddedModelSchemaSemanticVersionEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of EmbeddedModelSchemaSemanticVersionEnum from a JSON string"""
-        return EmbeddedModelSchemaSemanticVersionEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/embedding.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/embedding.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,55 +14,71 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional, Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictFloat, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.model import Model
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Embedding(BaseModel):
     """
-      # noqa: E501
-    """
-    raw: conlist(Union[StrictFloat, StrictInt]) = Field(..., description="this is the raw value of the embedding")
-    model: Model = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    
+    """ # noqa: E501
+    raw: List[Union[StrictFloat, StrictInt]] = Field(description="this is the raw value of the embedding")
+    model: Model
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    __properties = ["raw", "model", "created", "updated", "deleted"]
+    __properties: ClassVar[List[str]] = ["raw", "model", "created", "updated", "deleted"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Embedding:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Embedding from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of model
         if self.model:
             _dict['model'] = self.model.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -70,25 +86,25 @@
             _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
             _dict['deleted'] = self.deleted.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Embedding:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Embedding from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Embedding.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Embedding.parse_obj({
+        _obj = cls.model_validate({
             "raw": obj.get("raw"),
-            "model": Model.from_dict(obj.get("model")) if obj.get("model") is not None else None,
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None
+            "model": Model.from_dict(obj["model"]) if obj.get("model") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/embeddings.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_directed_discovery_filters.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,67 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List
+from pieces_os_client.models.tlp_directed_discovery_filter import TLPDirectedDiscoveryFilter
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from pieces_os_client.models.embedding import Embedding
-
-class Embeddings(BaseModel):
-    """
-    Embeddings
+class TLPDirectedDiscoveryFilters(BaseModel):
     """
-    iterable: conlist(Embedding) = Field(...)
-    __properties = ["iterable"]
+    Contains array of TLPDirectedDiscoveryFilter
+    """ # noqa: E501
+    iterable: List[TLPDirectedDiscoveryFilter] = Field(description="Array that contains filters like class/function/loop")
+    __properties: ClassVar[List[str]] = ["iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Embeddings:
-        """Create an instance of Embeddings from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPDirectedDiscoveryFilters from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Embeddings:
-        """Create an instance of Embeddings from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPDirectedDiscoveryFilters from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Embeddings.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Embeddings.parse_obj({
-            "iterable": [Embedding.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "iterable": [TLPDirectedDiscoveryFilter.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/existent_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/deleted_external_provider_api_key.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,65 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.auth0_user_metadata import Auth0UserMetadata
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ExistentMetadata(BaseModel):
-    """
-    This is a shared output model for all the exists endpoints: /tags/exists : value here is the tag that you want to see if it exists. /websites/exists: value here is the url you want to see if it exists  # noqa: E501
+class DeletedExternalProviderApiKey(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    value: StrictStr = Field(...)
-    __properties = ["schema", "value"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the returnable for the \"\"/external_provider/api_key/delete\" endpoint
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    metadata: Auth0UserMetadata
+    __properties: ClassVar[List[str]] = ["schema", "metadata"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExistentMetadata:
-        """Create an instance of ExistentMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DeletedExternalProviderApiKey from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of metadata
+        if self.metadata:
+            _dict['metadata'] = self.metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExistentMetadata:
-        """Create an instance of ExistentMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DeletedExternalProviderApiKey from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExistentMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExistentMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "value": obj.get("value")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "metadata": Auth0UserMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/existing_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/available_formats.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,75 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification import Classification
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.referenced_tag import ReferencedTag
-from pieces_os_client.models.referenced_website import ReferencedWebsite
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ExistingMetadata(BaseModel):
-    """
-    This is a shared input model for all the exists endpoints: /tags/exists : if the tag exists you will have a defined tag:ReferencedTag, if not then it doesnt exist. /websites/exists: if the url exists you will have a defined website:ReferencedWebsite, if not then it doesnt exist.  # noqa: E501
+class AvailableFormats(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    website: Optional[ReferencedWebsite] = None
-    tag: Optional[ReferencedTag] = None
-    __properties = ["schema", "website", "tag"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a specific model here used within the SeededAsset that enables us to return all the available formats on a specific seed that was passed as an input within the '/assets/draft' endpoint
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Classification]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExistingMetadata:
-        """Create an instance of ExistingMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AvailableFormats from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of website
-        if self.website:
-            _dict['website'] = self.website.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of tag
-        if self.tag:
-            _dict['tag'] = self.tag.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
+        _items = []
+        if self.iterable:
+            for _item in self.iterable:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExistingMetadata:
-        """Create an instance of ExistingMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AvailableFormats from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExistingMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExistingMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "website": ReferencedWebsite.from_dict(obj.get("website")) if obj.get("website") is not None else None,
-            "tag": ReferencedTag.from_dict(obj.get("tag")) if obj.get("tag") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Classification.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/exported_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_tags.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List
+from pieces_os_client.models.seeded_asset_tag import SeededAssetTag
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.file_format import FileFormat
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
-
-class ExportedAsset(BaseModel):
-    """
-    This is a model for a minimum exported version of an asset.  # noqa: E501
+class SeededAssetTags(BaseModel):
     """
-    name: StrictStr = Field(..., description="this is the title of the asset ")
-    description: StrictStr = Field(..., description="this is the description of the asset")
-    created: GroupedTimestamp = Field(...)
-    raw: FileFormat = Field(...)
-    __properties = ["name", "description", "created", "raw"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SeededAssetTags
+    """ # noqa: E501
+    iterable: List[SeededAssetTag]
+    __properties: ClassVar[List[str]] = ["iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExportedAsset:
-        """Create an instance of ExportedAsset from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededAssetTags from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of created
-        if self.created:
-            _dict['created'] = self.created.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of raw
-        if self.raw:
-            _dict['raw'] = self.raw.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
+        _items = []
+        if self.iterable:
+            for _item in self.iterable:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExportedAsset:
-        """Create an instance of ExportedAsset from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededAssetTags from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExportedAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExportedAsset.parse_obj({
-            "name": obj.get("name"),
-            "description": obj.get("description"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "raw": FileFormat.from_dict(obj.get("raw")) if obj.get("raw") is not None else None
+        _obj = cls.model_validate({
+            "iterable": [SeededAssetTag.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/exported_database.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/external_provider_profile_data.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,122 +14,149 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.exported_database_formats import ExportedDatabaseFormats
-
-class ExportedDatabase(BaseModel):
-    """
-    ExportedDatabase
+class ExternalProviderProfileData(BaseModel):
     """
-    analyses: conlist(StrictInt) = Field(...)
-    applications: conlist(StrictInt) = Field(...)
-    assets: conlist(StrictInt) = Field(...)
-    code_analyses: conlist(StrictInt) = Field(..., alias="codeAnalyses")
-    files: conlist(StrictInt) = Field(...)
-    format_metrics: conlist(StrictInt) = Field(..., alias="formatMetrics")
-    formats: conlist(StrictInt) = Field(...)
-    fragments: conlist(StrictInt) = Field(...)
-    image_analyses: conlist(StrictInt) = Field(..., alias="imageAnalyses")
-    models: conlist(StrictInt) = Field(...)
-    ocr_analyses: conlist(StrictInt) = Field(..., alias="ocrAnalyses")
-    persons: conlist(StrictInt) = Field(...)
-    sensitives: conlist(StrictInt) = Field(...)
-    tags: conlist(StrictInt) = Field(...)
-    websites: conlist(StrictInt) = Field(...)
-    values: ExportedDatabaseFormats = Field(...)
-    version: StrictStr = Field(..., description="This is the version of your os_server or cloud_server that we we exporting from.")
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    relationships: Optional[conlist(StrictInt)] = None
-    activities: Optional[conlist(StrictInt)] = None
-    annotations: Optional[conlist(StrictInt)] = None
-    hints: Optional[conlist(StrictInt)] = None
-    anchors: Optional[conlist(StrictInt)] = None
-    anchor_points: Optional[conlist(StrictInt)] = Field(None, alias="anchorPoints")
-    conversations: Optional[conlist(StrictInt)] = None
-    conversation_messages: Optional[conlist(StrictInt)] = Field(None, alias="conversationMessages")
-    message_values: Optional[ExportedDatabaseFormats] = Field(None, alias="messageValues")
-    __properties = ["analyses", "applications", "assets", "codeAnalyses", "files", "formatMetrics", "formats", "fragments", "imageAnalyses", "models", "ocrAnalyses", "persons", "sensitives", "tags", "websites", "values", "version", "schema", "relationships", "activities", "annotations", "hints", "anchors", "anchorPoints", "conversations", "conversationMessages", "messageValues"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    All of these will be optional.  Will support ProfileData from all our social providers.
+    """ # noqa: E501
+    name: Optional[StrictStr] = None
+    picture: Optional[StrictStr] = None
+    nickname: Optional[StrictStr] = None
+    email: Optional[StrictStr] = None
+    email_verified: Optional[StrictBool] = None
+    node_id: Optional[StrictStr] = None
+    gravatar_id: Optional[StrictStr] = None
+    url: Optional[StrictStr] = None
+    html_url: Optional[StrictStr] = None
+    followers_url: Optional[StrictStr] = None
+    following_url: Optional[StrictStr] = None
+    gists_url: Optional[StrictStr] = None
+    starred_url: Optional[StrictStr] = None
+    subscriptions_url: Optional[StrictStr] = None
+    organizations_url: Optional[StrictStr] = None
+    repos_url: Optional[StrictStr] = None
+    events_url: Optional[StrictStr] = None
+    received_events_url: Optional[StrictStr] = None
+    type: Optional[StrictStr] = None
+    site_admin: Optional[StrictBool] = None
+    company: Optional[StrictStr] = None
+    blog: Optional[StrictStr] = None
+    anchor: Optional[StrictStr] = None
+    hireable: Optional[StrictBool] = None
+    bio: Optional[StrictStr] = None
+    twitter_username: Optional[StrictStr] = None
+    public_repos: Optional[StrictInt] = None
+    public_gists: Optional[StrictInt] = None
+    followers: Optional[StrictInt] = None
+    following: Optional[StrictInt] = None
+    created_at: Optional[StrictStr] = None
+    updated_at: Optional[StrictStr] = None
+    private_gists: Optional[StrictInt] = None
+    total_private_repos: Optional[StrictInt] = None
+    owned_private_repos: Optional[StrictInt] = None
+    disk_usage: Optional[StrictInt] = None
+    collaborators: Optional[StrictInt] = None
+    two_factor_authentication: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["name", "picture", "nickname", "email", "email_verified", "node_id", "gravatar_id", "url", "html_url", "followers_url", "following_url", "gists_url", "starred_url", "subscriptions_url", "organizations_url", "repos_url", "events_url", "received_events_url", "type", "site_admin", "company", "blog", "anchor", "hireable", "bio", "twitter_username", "public_repos", "public_gists", "followers", "following", "created_at", "updated_at", "private_gists", "total_private_repos", "owned_private_repos", "disk_usage", "collaborators", "two_factor_authentication"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExportedDatabase:
-        """Create an instance of ExportedDatabase from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ExternalProviderProfileData from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of values
-        if self.values:
-            _dict['values'] = self.values.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of message_values
-        if self.message_values:
-            _dict['messageValues'] = self.message_values.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExportedDatabase:
-        """Create an instance of ExportedDatabase from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ExternalProviderProfileData from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExportedDatabase.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExportedDatabase.parse_obj({
-            "analyses": obj.get("analyses"),
-            "applications": obj.get("applications"),
-            "assets": obj.get("assets"),
-            "code_analyses": obj.get("codeAnalyses"),
-            "files": obj.get("files"),
-            "format_metrics": obj.get("formatMetrics"),
-            "formats": obj.get("formats"),
-            "fragments": obj.get("fragments"),
-            "image_analyses": obj.get("imageAnalyses"),
-            "models": obj.get("models"),
-            "ocr_analyses": obj.get("ocrAnalyses"),
-            "persons": obj.get("persons"),
-            "sensitives": obj.get("sensitives"),
-            "tags": obj.get("tags"),
-            "websites": obj.get("websites"),
-            "values": ExportedDatabaseFormats.from_dict(obj.get("values")) if obj.get("values") is not None else None,
-            "version": obj.get("version"),
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "relationships": obj.get("relationships"),
-            "activities": obj.get("activities"),
-            "annotations": obj.get("annotations"),
-            "hints": obj.get("hints"),
-            "anchors": obj.get("anchors"),
-            "anchor_points": obj.get("anchorPoints"),
-            "conversations": obj.get("conversations"),
-            "conversation_messages": obj.get("conversationMessages"),
-            "message_values": ExportedDatabaseFormats.from_dict(obj.get("messageValues")) if obj.get("messageValues") is not None else None
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "picture": obj.get("picture"),
+            "nickname": obj.get("nickname"),
+            "email": obj.get("email"),
+            "email_verified": obj.get("email_verified"),
+            "node_id": obj.get("node_id"),
+            "gravatar_id": obj.get("gravatar_id"),
+            "url": obj.get("url"),
+            "html_url": obj.get("html_url"),
+            "followers_url": obj.get("followers_url"),
+            "following_url": obj.get("following_url"),
+            "gists_url": obj.get("gists_url"),
+            "starred_url": obj.get("starred_url"),
+            "subscriptions_url": obj.get("subscriptions_url"),
+            "organizations_url": obj.get("organizations_url"),
+            "repos_url": obj.get("repos_url"),
+            "events_url": obj.get("events_url"),
+            "received_events_url": obj.get("received_events_url"),
+            "type": obj.get("type"),
+            "site_admin": obj.get("site_admin"),
+            "company": obj.get("company"),
+            "blog": obj.get("blog"),
+            "anchor": obj.get("anchor"),
+            "hireable": obj.get("hireable"),
+            "bio": obj.get("bio"),
+            "twitter_username": obj.get("twitter_username"),
+            "public_repos": obj.get("public_repos"),
+            "public_gists": obj.get("public_gists"),
+            "followers": obj.get("followers"),
+            "following": obj.get("following"),
+            "created_at": obj.get("created_at"),
+            "updated_at": obj.get("updated_at"),
+            "private_gists": obj.get("private_gists"),
+            "total_private_repos": obj.get("total_private_repos"),
+            "owned_private_repos": obj.get("owned_private_repos"),
+            "disk_usage": obj.get("disk_usage"),
+            "collaborators": obj.get("collaborators"),
+            "two_factor_authentication": obj.get("two_factor_authentication")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/exported_database_format.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_gpu_hardware_capabilities_information.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,67 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ExportedDatabaseFormat(BaseModel):
-    """
-    ExportedDatabaseFormat
+class OSDeviceGPUHardwareCapabilitiesInformation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="this is the id of the format")
-    raw: conlist(StrictInt) = Field(..., description="these are bytes.")
-    __properties = ["schema", "id", "raw"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will give specific information on task specific capibilites for GPU.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    llm: Optional[StrictBool] = Field(default=None, description="This will let us know if in the case we have a gpu and our gpu has the capabilities to use llms")
+    __properties: ClassVar[List[str]] = ["schema", "llm"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExportedDatabaseFormat:
-        """Create an instance of ExportedDatabaseFormat from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OSDeviceGPUHardwareCapabilitiesInformation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExportedDatabaseFormat:
-        """Create an instance of ExportedDatabaseFormat from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OSDeviceGPUHardwareCapabilitiesInformation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExportedDatabaseFormat.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExportedDatabaseFormat.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id"),
-            "raw": obj.get("raw")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "llm": obj.get("llm")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/exported_database_formats.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_question_answers.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.exported_database_format import ExportedDatabaseFormat
+from pieces_os_client.models.qgpt_question_answer import QGPTQuestionAnswer
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ExportedDatabaseFormats(BaseModel):
-    """
-    ExportedDatabaseFormats
+class QGPTQuestionAnswers(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ExportedDatabaseFormat) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the plural of QGPTQuestionAnswer
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[QGPTQuestionAnswer]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExportedDatabaseFormats:
-        """Create an instance of ExportedDatabaseFormats from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTQuestionAnswers from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExportedDatabaseFormats:
-        """Create an instance of ExportedDatabaseFormats from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTQuestionAnswers from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExportedDatabaseFormats.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExportedDatabaseFormats.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [ExportedDatabaseFormat.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [QGPTQuestionAnswer.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/external_ml_provider_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/external_ml_provider_enum.py`

 * *Files 27% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ExternalMLProviderEnum(str, Enum):
     """
     This is a Model used for the Model class. This will be used to describe the provider in which this Mode lcam from IE meta, google, apple, ...etc
     """
 
@@ -51,12 +48,12 @@
     BLICKDL = 'BLICKDL'
     HONG_KONG_BAPTIST_UNIVERSITY = 'HONG_KONG_BAPTIST_UNIVERSITY'
     BIGCODE = 'BIGCODE'
     JINA = 'JINA'
     PIECES = 'PIECES'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExternalMLProviderEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ExternalMLProviderEnum from a JSON string"""
-        return ExternalMLProviderEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/external_provider.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/external_provider.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,62 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.external_provider_profile_data import ExternalProviderProfileData
 from pieces_os_client.models.external_provider_type_enum import ExternalProviderTypeEnum
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ExternalProvider(BaseModel):
     """
-    I know that profileData and user_id have differeing casing but they are done because they map to Auth0's projeecties.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    type: ExternalProviderTypeEnum = Field(...)
-    user_id: StrictStr = Field(..., description="This is the user_id within the provider.")
-    access_token: Optional[StrictStr] = Field(None, description="This is optional here, but will be present for BB, Github, and google.")
-    expires_in: Optional[StrictInt] = Field(None, description="Some providers have an expiration on their access token. IE BB, Google, NOT Github.")
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
-    profile_data: Optional[ExternalProviderProfileData] = Field(None, alias="profileData")
-    connection: Optional[StrictStr] = Field(None, description="This is an optional field that will be provided onentreprise connections. ie is type == waad then connection might be PiecesApp. However is other cases,you my find your provider and connection is the exact same string. To decifer between the two, you can use the isSocial bool.")
-    is_social: Optional[StrictBool] = Field(None, alias="isSocial")
-    __properties = ["schema", "type", "user_id", "access_token", "expires_in", "created", "updated", "profileData", "connection", "isSocial"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    I know that profileData and user_id have differeing casing but they are done because they map to Auth0's projeecties.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    type: ExternalProviderTypeEnum
+    user_id: StrictStr = Field(description="This is the user_id within the provider.")
+    access_token: Optional[StrictStr] = Field(default=None, description="This is optional here, but will be present for BB, Github, and google.")
+    expires_in: Optional[StrictInt] = Field(default=None, description="Some providers have an expiration on their access token. IE BB, Google, NOT Github.")
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
+    profile_data: Optional[ExternalProviderProfileData] = Field(default=None, alias="profileData")
+    connection: Optional[StrictStr] = Field(default=None, description="This is an optional field that will be provided onentreprise connections. ie is type == waad then connection might be PiecesApp. However is other cases,you my find your provider and connection is the exact same string. To decifer between the two, you can use the isSocial bool.")
+    is_social: Optional[StrictBool] = Field(default=None, alias="isSocial")
+    __properties: ClassVar[List[str]] = ["schema", "type", "user_id", "access_token", "expires_in", "created", "updated", "profileData", "connection", "isSocial"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExternalProvider:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ExternalProvider from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -77,30 +93,30 @@
             _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of profile_data
         if self.profile_data:
             _dict['profileData'] = self.profile_data.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExternalProvider:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ExternalProvider from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExternalProvider.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExternalProvider.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "type": obj.get("type"),
             "user_id": obj.get("user_id"),
             "access_token": obj.get("access_token"),
             "expires_in": obj.get("expires_in"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "profile_data": ExternalProviderProfileData.from_dict(obj.get("profileData")) if obj.get("profileData") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "profileData": ExternalProviderProfileData.from_dict(obj["profileData"]) if obj.get("profileData") is not None else None,
             "connection": obj.get("connection"),
-            "is_social": obj.get("isSocial")
+            "isSocial": obj.get("isSocial")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/external_provider_type_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/external_provider_type_enum.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ExternalProviderTypeEnum(str, Enum):
     """
     This is an enum to describe the provider used to authenticate a user.  IMPORTANT NOT to modify tha values here unless they are explicitly mapped with auth0's provider values(example within cloud server)  'waad': (windows azure active directory)
     """
 
@@ -36,12 +33,12 @@
     BITBUCKET = 'bitbucket'
     LINKEDIN = 'linkedin'
     TWITTER = 'twitter'
     FACEBOOK = 'facebook'
     WAAD = 'waad'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExternalProviderTypeEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ExternalProviderTypeEnum from a JSON string"""
-        return ExternalProviderTypeEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/external_providers.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/external_providers.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.external_provider import ExternalProvider
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ExternalProviders(BaseModel):
     """
     ExternalProviders
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ExternalProvider) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[ExternalProvider]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExternalProviders:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ExternalProviders from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExternalProviders:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ExternalProviders from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExternalProviders.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExternalProviders.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [ExternalProvider.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ExternalProvider.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/file_format.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/pseudo_assets.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,75 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.transferable_bytes import TransferableBytes
-from pieces_os_client.models.transferable_string import TransferableString
+from pieces_os_client.models.flattened_assets import FlattenedAssets
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FileFormat(BaseModel):
-    """
-    This describes a FileFormat. If you need meta data you can get all of that from your format wrapper.  # noqa: E501
+class PseudoAssets(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    bytes: Optional[TransferableBytes] = None
-    string: Optional[TransferableString] = None
-    __properties = ["schema", "bytes", "string"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a model of all optional properties, that will get returned from /assets/pseudo.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    identifiers: Optional[FlattenedAssets] = None
+    __properties: ClassVar[List[str]] = ["schema", "identifiers"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FileFormat:
-        """Create an instance of FileFormat from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PseudoAssets from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of bytes
-        if self.bytes:
-            _dict['bytes'] = self.bytes.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of string
-        if self.string:
-            _dict['string'] = self.string.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of identifiers
+        if self.identifiers:
+            _dict['identifiers'] = self.identifiers.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FileFormat:
-        """Create an instance of FileFormat from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PseudoAssets from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FileFormat.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FileFormat.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "bytes": TransferableBytes.from_dict(obj.get("bytes")) if obj.get("bytes") is not None else None,
-            "string": TransferableString.from_dict(obj.get("string")) if obj.get("string") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "identifiers": FlattenedAssets.from_dict(obj["identifiers"]) if obj.get("identifiers") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/file_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_pipeline_for_generalized_code_dialog.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,70 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
-from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FileMetadata(BaseModel):
-    """
-    This is a model for metadata of a file!  # noqa: E501
+class QGPTConversationPipelineForGeneralizedCodeDialog(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    name: Optional[StrictStr] = Field(None, description="This is the name of your file.")
-    ext: Optional[ClassificationSpecificEnum] = None
-    size: Optional[StrictInt] = Field(None, description="This is the size(in bytes)")
-    __properties = ["schema", "name", "ext", "size"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is for the users that wants to have generalized code conversations without any context.  This is a class so that we can add optional properties in the future.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    __properties: ClassVar[List[str]] = ["schema"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FileMetadata:
-        """Create an instance of FileMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTConversationPipelineForGeneralizedCodeDialog from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FileMetadata:
-        """Create an instance of FileMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTConversationPipelineForGeneralizedCodeDialog from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FileMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FileMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "name": obj.get("name"),
-            "ext": obj.get("ext"),
-            "size": obj.get("size")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/file_picker_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/file_picker_input.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,65 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FilePickerInput(BaseModel):
     """
-    This is the input model for the FilePicker  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    allowed_extensions: Optional[conlist(StrictStr)] = Field(None, alias="allowedExtensions")
-    __properties = ["schema", "allowedExtensions"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the input model for the FilePicker
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    allowed_extensions: Optional[List[StrictStr]] = Field(default=None, alias="allowedExtensions")
+    __properties: ClassVar[List[str]] = ["schema", "allowedExtensions"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FilePickerInput:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FilePickerInput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FilePickerInput:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FilePickerInput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FilePickerInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FilePickerInput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "allowed_extensions": obj.get("allowedExtensions")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "allowedExtensions": obj.get("allowedExtensions")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_activities.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_reprompt_output.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,83 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedActivities(BaseModel):
-    """
-    FlattenedActivities
+class QGPTRepromptOutput(BaseModel):
     """
+    QGPTRepromptOutput
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    query: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "query"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedActivity) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedActivities:
-        """Create an instance of FlattenedActivities from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTRepromptOutput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedActivities:
-        """Create an instance of FlattenedActivities from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTRepromptOutput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedActivities.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedActivities.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedActivity.from_dict(_item) for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "query": obj.get("query")
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_activity import ReferencedActivity
-
-# FlattenedActivities.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_activity.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_activity.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,151 +14,112 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.application import Application
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_user_profile import FlattenedUserProfile
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
+from pieces_os_client.models.referenced_asset import ReferencedAsset
+from pieces_os_client.models.referenced_conversation import ReferencedConversation
+from pieces_os_client.models.referenced_format import ReferencedFormat
+from pieces_os_client.models.referenced_user import ReferencedUser
+from pieces_os_client.models.seeded_connector_tracking import SeededConnectorTracking
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedActivity(BaseModel):
+class SeededActivity(BaseModel):
     """
-    Note: - if mechanism == internal we will not display to the user.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
-    event: SeededConnectorTracking = Field(...)
-    application: Application = Field(...)
-    deleted: Optional[GroupedTimestamp] = None
+    This is the preseed to a full blown Activity.  This is the minimum information needed to create an Activity, used within our [POST] /activities/create  if mechenism is not passed in we will default to AUTOMATIC  NOT required to pass in an asset/user/format.
+    """ # noqa: E501
+    event: SeededConnectorTracking
+    application: Application
     asset: Optional[ReferencedAsset] = None
+    user: Optional[ReferencedUser] = None
     format: Optional[ReferencedFormat] = None
-    user: Optional[FlattenedUserProfile] = None
-    mechanism: MechanismEnum = Field(...)
-    rank: Optional[StrictInt] = None
-    __properties = [
-        "schema",
-        "id",
-        "created",
-        "updated",
-        "event",
-        "application",
-        "deleted",
-        "asset",
-        "format",
-        "user",
-        "mechanism",
-        "rank",
-    ]
-
-    class Config:
-        """Pydantic configuration"""
+    mechanism: Optional[MechanismEnum] = None
+    conversation: Optional[ReferencedConversation] = None
+    __properties: ClassVar[List[str]] = ["event", "application", "asset", "user", "format", "mechanism", "conversation"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedActivity:
-        """Create an instance of FlattenedActivity from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededActivity from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of created
-        if self.created:
-            _dict["created"] = self.created.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of updated
-        if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of event
         if self.event:
-            _dict["event"] = self.event.to_dict()
+            _dict['event'] = self.event.to_dict()
         # override the default output from pydantic by calling `to_dict()` of application
         if self.application:
-            _dict["application"] = self.application.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of deleted
-        if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['application'] = self.application.to_dict()
         # override the default output from pydantic by calling `to_dict()` of asset
         if self.asset:
-            _dict["asset"] = self.asset.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of format
-        if self.format:
-            _dict["format"] = self.format.to_dict()
+            _dict['asset'] = self.asset.to_dict()
         # override the default output from pydantic by calling `to_dict()` of user
         if self.user:
-            _dict["user"] = self.user.to_dict()
+            _dict['user'] = self.user.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of format
+        if self.format:
+            _dict['format'] = self.format.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of conversation
+        if self.conversation:
+            _dict['conversation'] = self.conversation.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedActivity:
-        """Create an instance of FlattenedActivity from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededActivity from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedActivity.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedActivity.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "event": SeededConnectorTracking.from_dict(obj.get("event"))
-                if obj.get("event") is not None
-                else None,
-                "application": Application.from_dict(obj.get("application"))
-                if obj.get("application") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "asset": ReferencedAsset.from_dict(obj.get("asset"))
-                if obj.get("asset") is not None
-                else None,
-                "format": ReferencedFormat.from_dict(obj.get("format"))
-                if obj.get("format") is not None
-                else None,
-                "user": FlattenedUserProfile.from_dict(obj.get("user"))
-                if obj.get("user") is not None
-                else None,
-                "mechanism": obj.get("mechanism"),
-                "rank": obj.get("rank"),
-            }
-        )
+        _obj = cls.model_validate({
+            "event": SeededConnectorTracking.from_dict(obj["event"]) if obj.get("event") is not None else None,
+            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "asset": ReferencedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "user": ReferencedUser.from_dict(obj["user"]) if obj.get("user") is not None else None,
+            "format": ReferencedFormat.from_dict(obj["format"]) if obj.get("format") is not None else None,
+            "mechanism": obj.get("mechanism"),
+            "conversation": ReferencedConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_asset import ReferencedAsset
-from pieces_os_client.models.referenced_format import ReferencedFormat
-from pieces_os_client.models.seeded_connector_tracking import SeededConnectorTracking
-
-# FlattenedActivity.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_analysis.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_tag.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,91 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.code_analysis import CodeAnalysis
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedAnalysis(BaseModel):
-    """
-    FlattenedAnalysis
+class ReferencedTag(BaseModel):
     """
+    [DAG Safe] version of a Tag Model. 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedTag] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    code: Optional[CodeAnalysis] = None
-    id: StrictStr = Field(...)
-    format: StrictStr = Field(
-        ..., description="this is a reference to the format that it belongs too."
-    )
-    image: Optional[FlattenedImageAnalysis] = None
-    __properties = ["schema", "code", "id", "format", "image"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedAnalysis:
-        """Create an instance of FlattenedAnalysis from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedTag from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of code
-        if self.code:
-            _dict["code"] = self.code.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of image
-        if self.image:
-            _dict["image"] = self.image.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of reference
+        if self.reference:
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedAnalysis:
-        """Create an instance of FlattenedAnalysis from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedTag from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedAnalysis.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedAnalysis.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "code": CodeAnalysis.from_dict(obj.get("code"))
-                if obj.get("code") is not None
-                else None,
-                "id": obj.get("id"),
-                "format": obj.get("format"),
-                "image": FlattenedImageAnalysis.from_dict(obj.get("image"))
-                if obj.get("image") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedTag.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.flattened_tag import FlattenedTag
+# TODO: Rewrite to not use raise_errors
+ReferencedTag.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.flattened_image_analysis import FlattenedImageAnalysis
-
-# FlattenedAnalysis.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_anchor.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_anchor.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,156 +14,136 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.anchor_type_enum import AnchorTypeEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedAnchor(BaseModel):
     """
     FlattenedAnchor
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    type: AnchorTypeEnum = Field(...)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    type: AnchorTypeEnum
     watch: Optional[StrictBool] = None
-    points: FlattenedAnchorPoints = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    points: FlattenedAnchorPoints
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     assets: Optional[FlattenedAssets] = None
     name: Optional[StrictStr] = None
     annotations: Optional[FlattenedAnnotations] = None
     conversations: Optional[FlattenedConversations] = None
     score: Optional[Score] = None
-    __properties = [
-        "schema",
-        "id",
-        "type",
-        "watch",
-        "points",
-        "created",
-        "updated",
-        "deleted",
-        "assets",
-        "name",
-        "annotations",
-        "conversations",
-        "score",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "id", "type", "watch", "points", "created", "updated", "deleted", "assets", "name", "annotations", "conversations", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedAnchor:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedAnchor from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of points
         if self.points:
-            _dict["points"] = self.points.to_dict()
+            _dict['points'] = self.points.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of assets
         if self.assets:
-            _dict["assets"] = self.assets.to_dict()
+            _dict['assets'] = self.assets.to_dict()
         # override the default output from pydantic by calling `to_dict()` of annotations
         if self.annotations:
-            _dict["annotations"] = self.annotations.to_dict()
+            _dict['annotations'] = self.annotations.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversations
         if self.conversations:
-            _dict["conversations"] = self.conversations.to_dict()
+            _dict['conversations'] = self.conversations.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedAnchor:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedAnchor from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedAnchor.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedAnchor.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "type": obj.get("type"),
-                "watch": obj.get("watch"),
-                "points": FlattenedAnchorPoints.from_dict(obj.get("points"))
-                if obj.get("points") is not None
-                else None,
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "assets": FlattenedAssets.from_dict(obj.get("assets"))
-                if obj.get("assets") is not None
-                else None,
-                "name": obj.get("name"),
-                "annotations": FlattenedAnnotations.from_dict(obj.get("annotations"))
-                if obj.get("annotations") is not None
-                else None,
-                "conversations": FlattenedConversations.from_dict(
-                    obj.get("conversations")
-                )
-                if obj.get("conversations") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "type": obj.get("type"),
+            "watch": obj.get("watch"),
+            "points": FlattenedAnchorPoints.from_dict(obj["points"]) if obj.get("points") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "name": obj.get("name"),
+            "annotations": FlattenedAnnotations.from_dict(obj["annotations"]) if obj.get("annotations") is not None else None,
+            "conversations": FlattenedConversations.from_dict(obj["conversations"]) if obj.get("conversations") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.flattened_anchor_points import FlattenedAnchorPoints
 from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
 from pieces_os_client.models.flattened_assets import FlattenedAssets
 from pieces_os_client.models.flattened_conversations import FlattenedConversations
+# TODO: Rewrite to not use raise_errors
+FlattenedAnchor.model_rebuild(raise_errors=False)
 
-# FlattenedAnchor.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_anchor_point.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/hint.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,127 +14,123 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
-from pieces_os_client.models.platform_enum import PlatformEnum
+from pieces_os_client.models.hint_type_enum import HintTypeEnum
+from pieces_os_client.models.mechanism_enum import MechanismEnum
+from pieces_os_client.models.referenced_asset import ReferencedAsset
+from pieces_os_client.models.referenced_model import ReferencedModel
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedAnchorPoint(BaseModel):
-    """
-    FlattenedAnchorPoint
+class Hint(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    verified: Optional[StrictBool] = None
-    fullpath: StrictStr = Field(..., description="This is the text of the path.")
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    This is a hint that is attached to an asset, used for suggested_queries, and hints given via the qgpt flow.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    platform: Optional[PlatformEnum] = None
-    anchor: ReferencedAnchor = Field(...)
+    mechanism: Optional[MechanismEnum] = None
+    asset: Optional[ReferencedAsset] = None
+    type: HintTypeEnum
+    text: StrictStr = Field(description="This is the text of the hint.")
+    model: Optional[ReferencedModel] = None
     score: Optional[Score] = None
-    __properties = [
-        "schema",
-        "id",
-        "verified",
-        "fullpath",
-        "created",
-        "updated",
-        "deleted",
-        "platform",
-        "anchor",
-        "score",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "deleted", "mechanism", "asset", "type", "text", "model", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedAnchorPoint:
-        """Create an instance of FlattenedAnchorPoint from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Hint from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of anchor
-        if self.anchor:
-            _dict["anchor"] = self.anchor.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of asset
+        if self.asset:
+            _dict['asset'] = self.asset.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of model
+        if self.model:
+            _dict['model'] = self.model.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedAnchorPoint:
-        """Create an instance of FlattenedAnchorPoint from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Hint from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedAnchorPoint.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedAnchorPoint.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "verified": obj.get("verified"),
-                "fullpath": obj.get("fullpath"),
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "platform": obj.get("platform"),
-                "anchor": ReferencedAnchor.from_dict(obj.get("anchor"))
-                if obj.get("anchor") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "mechanism": obj.get("mechanism"),
+            "asset": ReferencedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "type": obj.get("type"),
+            "text": obj.get("text"),
+            "model": ReferencedModel.from_dict(obj["model"]) if obj.get("model") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_anchor import ReferencedAnchor
-
-# FlattenedAnchorPoint.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_anchor_points.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_sensitives.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,97 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedAnchorPoints(BaseModel):
-    """
-    FlattenedAnchorPoints
+class FlattenedSensitives(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedAnchorPoint) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(
-        None,
-        description="This is a Map<String, int> where the the key is an AnchorPoint id.",
-    )
+    This is a flattened representation of multiple sensitive pieces of data.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[ReferencedSensitive]
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedAnchorPoints:
-        """Create an instance of FlattenedAnchorPoints from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedSensitives from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedAnchorPoints:
-        """Create an instance of FlattenedAnchorPoints from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedSensitives from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedAnchorPoints.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedAnchorPoints.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedAnchorPoint.from_dict(_item)
-                    for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "indices": obj.get("indices"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ReferencedSensitive.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.referenced_sensitive import ReferencedSensitive
+# TODO: Rewrite to not use raise_errors
+FlattenedSensitives.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.referenced_anchor_point import ReferencedAnchorPoint
-
-# FlattenedAnchorPoints.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_anchors.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/anchors.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,96 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.anchor import Anchor
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedAnchors(BaseModel):
-    """
-    FlattenedAnchors
+class Anchors(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedAnchor) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(
-        None,
-        description="This is a Map<String, int> where the the key is an Anchor id.",
-    )
+    This is the plural of Anchor.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Anchor]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an Anchor id.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedAnchors:
-        """Create an instance of FlattenedAnchors from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Anchors from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedAnchors:
-        """Create an instance of FlattenedAnchors from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Anchors from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedAnchors.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedAnchors.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedAnchor.from_dict(_item) for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "indices": obj.get("indices"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Anchor.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "indices": obj.get("indices"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_anchor import ReferencedAnchor
-
-# FlattenedAnchors.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_annotation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_annotation.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,183 +14,153 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.annotation_type_enum import AnnotationTypeEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.referenced_model import ReferencedModel
 from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedAnnotation(BaseModel):
     """
-    This is the flattened Version of the annotation, IMPORTANT: when referencing these, ONLY Take the UUID, do NOT polinate(ie w/ asset/person/model) the FlattenedAnnotation as it can create an infinite loop.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    This is the flattened Version of the annotation, IMPORTANT: when referencing these, ONLY Take the UUID, do NOT polinate(ie w/ asset/person/model) the FlattenedAnnotation as it can create an infinite loop.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     mechanism: Optional[MechanismEnum] = None
     asset: Optional[ReferencedAsset] = None
     person: Optional[ReferencedPerson] = None
-    type: AnnotationTypeEnum = Field(...)
-    text: StrictStr = Field(..., description="This is the text of the annotation.")
+    type: AnnotationTypeEnum
+    text: StrictStr = Field(description="This is the text of the annotation.")
     model: Optional[ReferencedModel] = None
     pseudo: Optional[StrictBool] = None
     favorited: Optional[StrictBool] = None
     anchor: Optional[ReferencedAnchor] = None
     conversation: Optional[ReferencedConversation] = None
     score: Optional[Score] = None
     messages: Optional[FlattenedConversationMessages] = None
-    __properties = [
-        "schema",
-        "id",
-        "created",
-        "updated",
-        "deleted",
-        "mechanism",
-        "asset",
-        "person",
-        "type",
-        "text",
-        "model",
-        "pseudo",
-        "favorited",
-        "anchor",
-        "conversation",
-        "score",
-        "messages",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "deleted", "mechanism", "asset", "person", "type", "text", "model", "pseudo", "favorited", "anchor", "conversation", "score", "messages"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedAnnotation:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedAnnotation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of asset
         if self.asset:
-            _dict["asset"] = self.asset.to_dict()
+            _dict['asset'] = self.asset.to_dict()
         # override the default output from pydantic by calling `to_dict()` of person
         if self.person:
-            _dict["person"] = self.person.to_dict()
+            _dict['person'] = self.person.to_dict()
         # override the default output from pydantic by calling `to_dict()` of model
         if self.model:
-            _dict["model"] = self.model.to_dict()
+            _dict['model'] = self.model.to_dict()
         # override the default output from pydantic by calling `to_dict()` of anchor
         if self.anchor:
-            _dict["anchor"] = self.anchor.to_dict()
+            _dict['anchor'] = self.anchor.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversation
         if self.conversation:
-            _dict["conversation"] = self.conversation.to_dict()
+            _dict['conversation'] = self.conversation.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         # override the default output from pydantic by calling `to_dict()` of messages
         if self.messages:
-            _dict["messages"] = self.messages.to_dict()
+            _dict['messages'] = self.messages.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedAnnotation:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedAnnotation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedAnnotation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedAnnotation.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "mechanism": obj.get("mechanism"),
-                "asset": ReferencedAsset.from_dict(obj.get("asset"))
-                if obj.get("asset") is not None
-                else None,
-                "person": ReferencedPerson.from_dict(obj.get("person"))
-                if obj.get("person") is not None
-                else None,
-                "type": obj.get("type"),
-                "text": obj.get("text"),
-                "model": ReferencedModel.from_dict(obj.get("model"))
-                if obj.get("model") is not None
-                else None,
-                "pseudo": obj.get("pseudo"),
-                "favorited": obj.get("favorited"),
-                "anchor": ReferencedAnchor.from_dict(obj.get("anchor"))
-                if obj.get("anchor") is not None
-                else None,
-                "conversation": ReferencedConversation.from_dict(
-                    obj.get("conversation")
-                )
-                if obj.get("conversation") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-                "messages": FlattenedConversationMessages.from_dict(obj.get("messages"))
-                if obj.get("messages") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "mechanism": obj.get("mechanism"),
+            "asset": ReferencedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "person": ReferencedPerson.from_dict(obj["person"]) if obj.get("person") is not None else None,
+            "type": obj.get("type"),
+            "text": obj.get("text"),
+            "model": ReferencedModel.from_dict(obj["model"]) if obj.get("model") is not None else None,
+            "pseudo": obj.get("pseudo"),
+            "favorited": obj.get("favorited"),
+            "anchor": ReferencedAnchor.from_dict(obj["anchor"]) if obj.get("anchor") is not None else None,
+            "conversation": ReferencedConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None,
+            "messages": FlattenedConversationMessages.from_dict(obj["messages"]) if obj.get("messages") is not None else None
+        })
         return _obj
 
-
-from pieces_os_client.models.flattened_conversation_messages import (
-    FlattenedConversationMessages,
-)
+from pieces_os_client.models.flattened_conversation_messages import FlattenedConversationMessages
 from pieces_os_client.models.referenced_anchor import ReferencedAnchor
 from pieces_os_client.models.referenced_asset import ReferencedAsset
 from pieces_os_client.models.referenced_conversation import ReferencedConversation
 from pieces_os_client.models.referenced_person import ReferencedPerson
+# TODO: Rewrite to not use raise_errors
+FlattenedAnnotation.model_rebuild(raise_errors=False)
 
-# FlattenedAnnotation.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_annotations.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/hints.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,97 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.hint import Hint
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedAnnotations(BaseModel):
-    """
-    This is a flattened plural of Annotation, typically this will just be a list of uuids.  # noqa: E501
+class Hints(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedAnnotation) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(
-        None,
-        description="This is a Map<String, int> where the the key is an annotation id.",
-    )
+    This is the plural of a Hint.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Hint]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an hint id.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedAnnotations:
-        """Create an instance of FlattenedAnnotations from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Hints from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedAnnotations:
-        """Create an instance of FlattenedAnnotations from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Hints from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedAnnotations.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedAnnotations.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedAnnotation.from_dict(_item)
-                    for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "indices": obj.get("indices"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Hint.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "indices": obj.get("indices"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_annotation import ReferencedAnnotation
-
-# FlattenedAnnotations.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_asset.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,268 +14,206 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_preview import FlattenedPreview
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedAsset(BaseModel):
     """
-    An Asset Model representing data extracted from an Application connecting a group of data containing one or more Formats. [DAG Compatible - Directed Acyclic Graph Data Structure]  FlattenedAsset prevent Cycles in Reference because all outbound references are strings as opposed to crosspollinated objects.  i.e. FlattenedFormat.formats is Type String[] or List\\<String\\>, FlattenedFormat.preview is Type String, and FlattenedFormat.original is Type String  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(
-        ...,
-        description="The globally available UID representing the asset in the Database, both locally and in the cloud.",
-    )
+    An Asset Model representing data extracted from an Application connecting a group of data containing one or more Formats. [DAG Compatible - Directed Acyclic Graph Data Structure]  FlattenedAsset prevent Cycles in Reference because all outbound references are strings as opposed to crosspollinated objects.  i.e. FlattenedFormat.formats is Type String[] or List\\<String\\>, FlattenedFormat.preview is Type String, and FlattenedFormat.original is Type String
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="The globally available UID representing the asset in the Database, both locally and in the cloud.")
     name: Optional[StrictStr] = None
-    creator: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    creator: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     synced: Optional[GroupedTimestamp] = None
     deleted: Optional[GroupedTimestamp] = None
-    formats: FlattenedFormats = Field(...)
-    preview: FlattenedPreview = Field(...)
-    original: StrictStr = Field(
-        ...,
-        description="An identifier of the format that is a reference to the original.",
-    )
+    formats: FlattenedFormats
+    preview: FlattenedPreview
+    original: StrictStr = Field(description="An identifier of the format that is a reference to the original.")
     shares: Optional[FlattenedShares] = None
-    mechanism: MechanismEnum = Field(...)
+    mechanism: MechanismEnum
     websites: Optional[FlattenedWebsites] = None
     interacted: Optional[GroupedTimestamp] = None
     tags: Optional[FlattenedTags] = None
     sensitives: Optional[FlattenedSensitives] = None
     persons: Optional[FlattenedPersons] = None
-    curated: Optional[StrictBool] = Field(
-        None,
-        description="This is an optional boolean that will flag that this asset came from a currated collection.",
-    )
+    curated: Optional[StrictBool] = Field(default=None, description="This is an optional boolean that will flag that this asset came from a currated collection.")
     discovered: Optional[StrictBool] = None
     activities: Optional[FlattenedActivities] = None
     score: Optional[Score] = None
     favorited: Optional[StrictBool] = None
     pseudo: Optional[StrictBool] = None
     annotations: Optional[FlattenedAnnotations] = None
     hints: Optional[FlattenedHints] = None
     anchors: Optional[FlattenedAnchors] = None
     conversations: Optional[FlattenedConversations] = None
-    __properties = [
-        "schema",
-        "id",
-        "name",
-        "creator",
-        "created",
-        "updated",
-        "synced",
-        "deleted",
-        "formats",
-        "preview",
-        "original",
-        "shares",
-        "mechanism",
-        "websites",
-        "interacted",
-        "tags",
-        "sensitives",
-        "persons",
-        "curated",
-        "discovered",
-        "activities",
-        "score",
-        "favorited",
-        "pseudo",
-        "annotations",
-        "hints",
-        "anchors",
-        "conversations",
-    ]
+    demo: Optional[StrictBool] = Field(default=None, description="This will let us know if this asset was generated as a 'demo' snippet")
+    __properties: ClassVar[List[str]] = ["schema", "id", "name", "creator", "created", "updated", "synced", "deleted", "formats", "preview", "original", "shares", "mechanism", "websites", "interacted", "tags", "sensitives", "persons", "curated", "discovered", "activities", "score", "favorited", "pseudo", "annotations", "hints", "anchors", "conversations", "demo"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedAsset:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedAsset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of synced
         if self.synced:
-            _dict["synced"] = self.synced.to_dict()
+            _dict['synced'] = self.synced.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of formats
         if self.formats:
-            _dict["formats"] = self.formats.to_dict()
+            _dict['formats'] = self.formats.to_dict()
         # override the default output from pydantic by calling `to_dict()` of preview
         if self.preview:
-            _dict["preview"] = self.preview.to_dict()
+            _dict['preview'] = self.preview.to_dict()
         # override the default output from pydantic by calling `to_dict()` of shares
         if self.shares:
-            _dict["shares"] = self.shares.to_dict()
+            _dict['shares'] = self.shares.to_dict()
         # override the default output from pydantic by calling `to_dict()` of websites
         if self.websites:
-            _dict["websites"] = self.websites.to_dict()
+            _dict['websites'] = self.websites.to_dict()
         # override the default output from pydantic by calling `to_dict()` of interacted
         if self.interacted:
-            _dict["interacted"] = self.interacted.to_dict()
+            _dict['interacted'] = self.interacted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of tags
         if self.tags:
-            _dict["tags"] = self.tags.to_dict()
+            _dict['tags'] = self.tags.to_dict()
         # override the default output from pydantic by calling `to_dict()` of sensitives
         if self.sensitives:
-            _dict["sensitives"] = self.sensitives.to_dict()
+            _dict['sensitives'] = self.sensitives.to_dict()
         # override the default output from pydantic by calling `to_dict()` of persons
         if self.persons:
-            _dict["persons"] = self.persons.to_dict()
+            _dict['persons'] = self.persons.to_dict()
         # override the default output from pydantic by calling `to_dict()` of activities
         if self.activities:
-            _dict["activities"] = self.activities.to_dict()
+            _dict['activities'] = self.activities.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         # override the default output from pydantic by calling `to_dict()` of annotations
         if self.annotations:
-            _dict["annotations"] = self.annotations.to_dict()
+            _dict['annotations'] = self.annotations.to_dict()
         # override the default output from pydantic by calling `to_dict()` of hints
         if self.hints:
-            _dict["hints"] = self.hints.to_dict()
+            _dict['hints'] = self.hints.to_dict()
         # override the default output from pydantic by calling `to_dict()` of anchors
         if self.anchors:
-            _dict["anchors"] = self.anchors.to_dict()
+            _dict['anchors'] = self.anchors.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversations
         if self.conversations:
-            _dict["conversations"] = self.conversations.to_dict()
+            _dict['conversations'] = self.conversations.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedAsset:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedAsset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedAsset.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "name": obj.get("name"),
-                "creator": obj.get("creator"),
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "synced": GroupedTimestamp.from_dict(obj.get("synced"))
-                if obj.get("synced") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "formats": FlattenedFormats.from_dict(obj.get("formats"))
-                if obj.get("formats") is not None
-                else None,
-                "preview": FlattenedPreview.from_dict(obj.get("preview"))
-                if obj.get("preview") is not None
-                else None,
-                "original": obj.get("original"),
-                "shares": FlattenedShares.from_dict(obj.get("shares"))
-                if obj.get("shares") is not None
-                else None,
-                "mechanism": obj.get("mechanism"),
-                "websites": FlattenedWebsites.from_dict(obj.get("websites"))
-                if obj.get("websites") is not None
-                else None,
-                "interacted": GroupedTimestamp.from_dict(obj.get("interacted"))
-                if obj.get("interacted") is not None
-                else None,
-                "tags": FlattenedTags.from_dict(obj.get("tags"))
-                if obj.get("tags") is not None
-                else None,
-                "sensitives": FlattenedSensitives.from_dict(obj.get("sensitives"))
-                if obj.get("sensitives") is not None
-                else None,
-                "persons": FlattenedPersons.from_dict(obj.get("persons"))
-                if obj.get("persons") is not None
-                else None,
-                "curated": obj.get("curated"),
-                "discovered": obj.get("discovered"),
-                "activities": FlattenedActivities.from_dict(obj.get("activities"))
-                if obj.get("activities") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-                "favorited": obj.get("favorited"),
-                "pseudo": obj.get("pseudo"),
-                "annotations": FlattenedAnnotations.from_dict(obj.get("annotations"))
-                if obj.get("annotations") is not None
-                else None,
-                "hints": FlattenedHints.from_dict(obj.get("hints"))
-                if obj.get("hints") is not None
-                else None,
-                "anchors": FlattenedAnchors.from_dict(obj.get("anchors"))
-                if obj.get("anchors") is not None
-                else None,
-                "conversations": FlattenedConversations.from_dict(
-                    obj.get("conversations")
-                )
-                if obj.get("conversations") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "name": obj.get("name"),
+            "creator": obj.get("creator"),
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "synced": GroupedTimestamp.from_dict(obj["synced"]) if obj.get("synced") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "formats": FlattenedFormats.from_dict(obj["formats"]) if obj.get("formats") is not None else None,
+            "preview": FlattenedPreview.from_dict(obj["preview"]) if obj.get("preview") is not None else None,
+            "original": obj.get("original"),
+            "shares": FlattenedShares.from_dict(obj["shares"]) if obj.get("shares") is not None else None,
+            "mechanism": obj.get("mechanism"),
+            "websites": FlattenedWebsites.from_dict(obj["websites"]) if obj.get("websites") is not None else None,
+            "interacted": GroupedTimestamp.from_dict(obj["interacted"]) if obj.get("interacted") is not None else None,
+            "tags": FlattenedTags.from_dict(obj["tags"]) if obj.get("tags") is not None else None,
+            "sensitives": FlattenedSensitives.from_dict(obj["sensitives"]) if obj.get("sensitives") is not None else None,
+            "persons": FlattenedPersons.from_dict(obj["persons"]) if obj.get("persons") is not None else None,
+            "curated": obj.get("curated"),
+            "discovered": obj.get("discovered"),
+            "activities": FlattenedActivities.from_dict(obj["activities"]) if obj.get("activities") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None,
+            "favorited": obj.get("favorited"),
+            "pseudo": obj.get("pseudo"),
+            "annotations": FlattenedAnnotations.from_dict(obj["annotations"]) if obj.get("annotations") is not None else None,
+            "hints": FlattenedHints.from_dict(obj["hints"]) if obj.get("hints") is not None else None,
+            "anchors": FlattenedAnchors.from_dict(obj["anchors"]) if obj.get("anchors") is not None else None,
+            "conversations": FlattenedConversations.from_dict(obj["conversations"]) if obj.get("conversations") is not None else None,
+            "demo": obj.get("demo")
+        })
         return _obj
 
-
 from pieces_os_client.models.flattened_activities import FlattenedActivities
 from pieces_os_client.models.flattened_anchors import FlattenedAnchors
 from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
 from pieces_os_client.models.flattened_conversations import FlattenedConversations
 from pieces_os_client.models.flattened_formats import FlattenedFormats
 from pieces_os_client.models.flattened_hints import FlattenedHints
 from pieces_os_client.models.flattened_persons import FlattenedPersons
 from pieces_os_client.models.flattened_sensitives import FlattenedSensitives
 from pieces_os_client.models.flattened_shares import FlattenedShares
 from pieces_os_client.models.flattened_tags import FlattenedTags
 from pieces_os_client.models.flattened_websites import FlattenedWebsites
+# TODO: Rewrite to not use raise_errors
+FlattenedAsset.model_rebuild(raise_errors=False)
 
-# FlattenedAsset.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_assets.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_assets.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,95 +14,99 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedAssets(BaseModel):
     """
-    A collection of Assets specific to the authenticated user. [DAG Compatible - Directed Acyclic Graph Data Structure]  FlattenedAssets prevent Cycles in Reference because all outbound references are strings as opposed to crosspollinated objects.  i.e. Asset asset = FlattenedAssets.iterable[0] => Format format = asset.preview => String id = format.asset => String id  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: Optional[conlist(ReferencedAsset)] = None
-    indices: Optional[Dict[str, StrictInt]] = Field(
-        None, description="This is a Map<String, int> where the the key is an asset id."
-    )
+    A collection of Assets specific to the authenticated user. [DAG Compatible - Directed Acyclic Graph Data Structure]  FlattenedAssets prevent Cycles in Reference because all outbound references are strings as opposed to crosspollinated objects.  i.e. Asset asset = FlattenedAssets.iterable[0] => Format format = asset.preview => String id = format.asset => String id
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: Optional[List[ReferencedAsset]] = None
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an asset id.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedAssets:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedAssets from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedAssets:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedAssets from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedAssets.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedAssets.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedAsset.from_dict(_item) for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "indices": obj.get("indices"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ReferencedAsset.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "indices": obj.get("indices"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.referenced_asset import ReferencedAsset
+# TODO: Rewrite to not use raise_errors
+FlattenedAssets.model_rebuild(raise_errors=False)
 
-# FlattenedAssets.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_conversation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_metadata.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,194 +14,147 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.tracked_asset_event_creation_metadata import TrackedAssetEventCreationMetadata
+from pieces_os_client.models.tracked_asset_event_format_reclassification_metadata import TrackedAssetEventFormatReclassificationMetadata
+from pieces_os_client.models.tracked_asset_event_rename_metadata import TrackedAssetEventRenameMetadata
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-from pieces_os_client.models.application import Application
-from pieces_os_client.models.conversation_type_enum import ConversationTypeEnum
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
-from pieces_os_client.models.referenced_model import ReferencedModel
-from pieces_os_client.models.score import Score
-
-
-class FlattenedConversation(BaseModel):
-    """
-    This is a flattend version of the Convsersation for DAG-Safety.  This will hold together a conversation. Ie allthe message within a conversation.  All the additional properties on here used on here like(anchors/assets) are used for context that will seed the conversation.  model is a calculated property, and will be the model of the last message sent if applicable.  # noqa: E501
+class TrackedAssetEventMetadata(BaseModel):
     """
+    TrackedAssetEventMetadata
+    """ # noqa: E501
+    reclassification: Optional[TrackedAssetEventFormatReclassificationMetadata] = None
+    creation: Optional[TrackedAssetEventCreationMetadata] = None
+    rename: Optional[TrackedAssetEventRenameMetadata] = None
+    tag: Optional[ReferencedTag] = None
+    website: Optional[ReferencedWebsite] = None
+    person: Optional[ReferencedPerson] = None
+    sensitive: Optional[ReferencedSensitive] = None
+    share: Optional[ReferencedShare] = None
+    search: Optional[TrackedAssetsEventSearchMetadata] = None
+    annotation: Optional[ReferencedAnnotation] = None
+    hint: Optional[ReferencedHint] = None
+    anchor: Optional[ReferencedAnchor] = None
+    __properties: ClassVar[List[str]] = ["reclassification", "creation", "rename", "tag", "website", "person", "sensitive", "share", "search", "annotation", "hint", "anchor"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    name: Optional[StrictStr] = Field(
-        None, description="This is a name that is customized."
-    )
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
-    deleted: Optional[GroupedTimestamp] = None
-    favorited: Optional[StrictBool] = None
-    application: Optional[Application] = None
-    annotations: Optional[FlattenedAnnotations] = None
-    messages: FlattenedConversationMessages = Field(...)
-    model: Optional[ReferencedModel] = None
-    assets: Optional[FlattenedAssets] = None
-    websites: Optional[FlattenedWebsites] = None
-    anchors: Optional[FlattenedAnchors] = None
-    type: ConversationTypeEnum = Field(...)
-    grounding: Optional[ConversationGrounding] = None
-    score: Optional[Score] = None
-    __properties = [
-        "schema",
-        "id",
-        "name",
-        "created",
-        "updated",
-        "deleted",
-        "favorited",
-        "application",
-        "annotations",
-        "messages",
-        "model",
-        "assets",
-        "websites",
-        "anchors",
-        "type",
-        "grounding",
-        "score",
-    ]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedConversation:
-        """Create an instance of FlattenedConversation from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedAssetEventMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of created
-        if self.created:
-            _dict["created"] = self.created.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of updated
-        if self.updated:
-            _dict["updated"] = self.updated.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of deleted
-        if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of application
-        if self.application:
-            _dict["application"] = self.application.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of annotations
-        if self.annotations:
-            _dict["annotations"] = self.annotations.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of messages
-        if self.messages:
-            _dict["messages"] = self.messages.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of model
-        if self.model:
-            _dict["model"] = self.model.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of assets
-        if self.assets:
-            _dict["assets"] = self.assets.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of websites
-        if self.websites:
-            _dict["websites"] = self.websites.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of anchors
-        if self.anchors:
-            _dict["anchors"] = self.anchors.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of grounding
-        if self.grounding:
-            _dict["grounding"] = self.grounding.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict["score"] = self.score.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of reclassification
+        if self.reclassification:
+            _dict['reclassification'] = self.reclassification.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of creation
+        if self.creation:
+            _dict['creation'] = self.creation.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of rename
+        if self.rename:
+            _dict['rename'] = self.rename.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of tag
+        if self.tag:
+            _dict['tag'] = self.tag.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of website
+        if self.website:
+            _dict['website'] = self.website.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of person
+        if self.person:
+            _dict['person'] = self.person.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of sensitive
+        if self.sensitive:
+            _dict['sensitive'] = self.sensitive.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of share
+        if self.share:
+            _dict['share'] = self.share.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of search
+        if self.search:
+            _dict['search'] = self.search.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of annotation
+        if self.annotation:
+            _dict['annotation'] = self.annotation.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of hint
+        if self.hint:
+            _dict['hint'] = self.hint.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of anchor
+        if self.anchor:
+            _dict['anchor'] = self.anchor.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedConversation:
-        """Create an instance of FlattenedConversation from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedAssetEventMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedConversation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedConversation.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "name": obj.get("name"),
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "favorited": obj.get("favorited"),
-                "application": Application.from_dict(obj.get("application"))
-                if obj.get("application") is not None
-                else None,
-                "annotations": FlattenedAnnotations.from_dict(obj.get("annotations"))
-                if obj.get("annotations") is not None
-                else None,
-                "messages": FlattenedConversationMessages.from_dict(obj.get("messages"))
-                if obj.get("messages") is not None
-                else None,
-                "model": ReferencedModel.from_dict(obj.get("model"))
-                if obj.get("model") is not None
-                else None,
-                "assets": FlattenedAssets.from_dict(obj.get("assets"))
-                if obj.get("assets") is not None
-                else None,
-                "websites": FlattenedWebsites.from_dict(obj.get("websites"))
-                if obj.get("websites") is not None
-                else None,
-                "anchors": FlattenedAnchors.from_dict(obj.get("anchors"))
-                if obj.get("anchors") is not None
-                else None,
-                "type": obj.get("type"),
-                "grounding": ConversationGrounding.from_dict(obj.get("grounding"))
-                if obj.get("grounding") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "reclassification": TrackedAssetEventFormatReclassificationMetadata.from_dict(obj["reclassification"]) if obj.get("reclassification") is not None else None,
+            "creation": TrackedAssetEventCreationMetadata.from_dict(obj["creation"]) if obj.get("creation") is not None else None,
+            "rename": TrackedAssetEventRenameMetadata.from_dict(obj["rename"]) if obj.get("rename") is not None else None,
+            "tag": ReferencedTag.from_dict(obj["tag"]) if obj.get("tag") is not None else None,
+            "website": ReferencedWebsite.from_dict(obj["website"]) if obj.get("website") is not None else None,
+            "person": ReferencedPerson.from_dict(obj["person"]) if obj.get("person") is not None else None,
+            "sensitive": ReferencedSensitive.from_dict(obj["sensitive"]) if obj.get("sensitive") is not None else None,
+            "share": ReferencedShare.from_dict(obj["share"]) if obj.get("share") is not None else None,
+            "search": TrackedAssetsEventSearchMetadata.from_dict(obj["search"]) if obj.get("search") is not None else None,
+            "annotation": ReferencedAnnotation.from_dict(obj["annotation"]) if obj.get("annotation") is not None else None,
+            "hint": ReferencedHint.from_dict(obj["hint"]) if obj.get("hint") is not None else None,
+            "anchor": ReferencedAnchor.from_dict(obj["anchor"]) if obj.get("anchor") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.referenced_anchor import ReferencedAnchor
+from pieces_os_client.models.referenced_annotation import ReferencedAnnotation
+from pieces_os_client.models.referenced_hint import ReferencedHint
+from pieces_os_client.models.referenced_person import ReferencedPerson
+from pieces_os_client.models.referenced_sensitive import ReferencedSensitive
+from pieces_os_client.models.referenced_share import ReferencedShare
+from pieces_os_client.models.referenced_tag import ReferencedTag
+from pieces_os_client.models.referenced_website import ReferencedWebsite
+from pieces_os_client.models.tracked_assets_event_search_metadata import TrackedAssetsEventSearchMetadata
+# TODO: Rewrite to not use raise_errors
+TrackedAssetEventMetadata.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.conversation_grounding import ConversationGrounding
-from pieces_os_client.models.flattened_anchors import FlattenedAnchors
-from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
-from pieces_os_client.models.flattened_assets import FlattenedAssets
-from pieces_os_client.models.flattened_conversation_messages import (
-    FlattenedConversationMessages,
-)
-from pieces_os_client.models.flattened_websites import FlattenedWebsites
-
-# FlattenedConversation.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_conversation_message.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_conversation_message.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,158 +14,135 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.conversation_message_sentiment_enum import (
-    ConversationMessageSentimentEnum,
-)
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.conversation_message_sentiment_enum import ConversationMessageSentimentEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.fragment_format import FragmentFormat
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.model import Model
-from pieces_os_client.models.qgpt_conversation_message_role_enum import (
-    QGPTConversationMessageRoleEnum,
-)
+from pieces_os_client.models.qgpt_conversation_message_role_enum import QGPTConversationMessageRoleEnum
 from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedConversationMessage(BaseModel):
     """
-    This is a flattened DAG safe version of a ConversationMessage.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    This is a flattened DAG safe version of a ConversationMessage.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     model: Optional[Model] = None
     fragment: Optional[FragmentFormat] = None
-    conversation: ReferencedConversation = Field(...)
+    conversation: ReferencedConversation
     sentiment: Optional[ConversationMessageSentimentEnum] = None
-    role: QGPTConversationMessageRoleEnum = Field(...)
+    role: QGPTConversationMessageRoleEnum
     score: Optional[Score] = None
     annotations: Optional[FlattenedAnnotations] = None
-    __properties = [
-        "schema",
-        "id",
-        "created",
-        "updated",
-        "deleted",
-        "model",
-        "fragment",
-        "conversation",
-        "sentiment",
-        "role",
-        "score",
-        "annotations",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "deleted", "model", "fragment", "conversation", "sentiment", "role", "score", "annotations"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedConversationMessage:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedConversationMessage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of model
         if self.model:
-            _dict["model"] = self.model.to_dict()
+            _dict['model'] = self.model.to_dict()
         # override the default output from pydantic by calling `to_dict()` of fragment
         if self.fragment:
-            _dict["fragment"] = self.fragment.to_dict()
+            _dict['fragment'] = self.fragment.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversation
         if self.conversation:
-            _dict["conversation"] = self.conversation.to_dict()
+            _dict['conversation'] = self.conversation.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         # override the default output from pydantic by calling `to_dict()` of annotations
         if self.annotations:
-            _dict["annotations"] = self.annotations.to_dict()
+            _dict['annotations'] = self.annotations.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedConversationMessage:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedConversationMessage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedConversationMessage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedConversationMessage.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "model": Model.from_dict(obj.get("model"))
-                if obj.get("model") is not None
-                else None,
-                "fragment": FragmentFormat.from_dict(obj.get("fragment"))
-                if obj.get("fragment") is not None
-                else None,
-                "conversation": ReferencedConversation.from_dict(
-                    obj.get("conversation")
-                )
-                if obj.get("conversation") is not None
-                else None,
-                "sentiment": obj.get("sentiment"),
-                "role": obj.get("role"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-                "annotations": FlattenedAnnotations.from_dict(obj.get("annotations"))
-                if obj.get("annotations") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "model": Model.from_dict(obj["model"]) if obj.get("model") is not None else None,
+            "fragment": FragmentFormat.from_dict(obj["fragment"]) if obj.get("fragment") is not None else None,
+            "conversation": ReferencedConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
+            "sentiment": obj.get("sentiment"),
+            "role": obj.get("role"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None,
+            "annotations": FlattenedAnnotations.from_dict(obj["annotations"]) if obj.get("annotations") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
 from pieces_os_client.models.referenced_conversation import ReferencedConversation
+# TODO: Rewrite to not use raise_errors
+FlattenedConversationMessage.model_rebuild(raise_errors=False)
 
-# FlattenedConversationMessage.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_conversation_messages.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/conversations.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,99 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.conversation import Conversation
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedConversationMessages(BaseModel):
-    """
-    This is a flattened plural version of ConversationMessages  # noqa: E501
+class Conversations(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedConversationMessage) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(
-        None,
-        description="This is a Map<String, int> where the the key is an ConversationMessage id.",
-    )
+    This is a plural version of a Conversation.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Conversation]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an Conversation id.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedConversationMessages:
-        """Create an instance of FlattenedConversationMessages from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Conversations from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedConversationMessages:
-        """Create an instance of FlattenedConversationMessages from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Conversations from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedConversationMessages.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedConversationMessages.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedConversationMessage.from_dict(_item)
-                    for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "indices": obj.get("indices"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Conversation.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "indices": obj.get("indices"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_conversation_message import (
-    ReferencedConversationMessage,
-)
-
-# FlattenedConversationMessages.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_conversations.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_conversation_event_metadata.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,97 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.score import Score
-
+from pieces_os_client.models.tracked_conversation_event_rename_metadata import TrackedConversationEventRenameMetadata
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlattenedConversations(BaseModel):
-    """
-    Flattened version of conversations.  # noqa: E501
+class TrackedConversationEventMetadata(BaseModel):
     """
+    This is the metadata for the the ConversationEvent
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    rename: Optional[TrackedConversationEventRenameMetadata] = None
+    __properties: ClassVar[List[str]] = ["schema", "rename"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedConversation) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(
-        None,
-        description="This is a Map<String, int> where the the key is an Conversation id.",
-    )
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedConversations:
-        """Create an instance of FlattenedConversations from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedConversationEventMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict["iterable"] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of rename
+        if self.rename:
+            _dict['rename'] = self.rename.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedConversations:
-        """Create an instance of FlattenedConversations from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedConversationEventMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedConversations.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedConversations.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedConversation.from_dict(_item)
-                    for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "indices": obj.get("indices"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "rename": TrackedConversationEventRenameMetadata.from_dict(obj["rename"]) if obj.get("rename") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_conversation import ReferencedConversation
-
-# FlattenedConversations.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_distribution.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_distribution.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,95 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.git_hub_distribution import GitHubDistribution
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mailgun_distribution import MailgunDistribution
+from pieces_os_client.models.seeded_git_hub_distribution import SeededGitHubDistribution
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlattenedDistribution(BaseModel):
-    """
-    FlattenedDistribution
+class SeededDistribution(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    share: StrictStr = Field(..., description="This is the UUId of the share.")
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
-    deleted: Optional[GroupedTimestamp] = None
+    TODO if we add another distribution add to this, Distribution, and flattenedDistribution.  can only use this Model with our Linkify Model.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     mailgun: Optional[MailgunDistribution] = None
-    github: Optional[GitHubDistribution] = None
-    __properties = ["schema", "id", "share", "created", "updated", "deleted", "mailgun", "github"]
+    github: Optional[SeededGitHubDistribution] = None
+    __properties: ClassVar[List[str]] = ["schema", "mailgun", "github"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedDistribution:
-        """Create an instance of FlattenedDistribution from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededDistribution from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of created
-        if self.created:
-            _dict['created'] = self.created.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of updated
-        if self.updated:
-            _dict['updated'] = self.updated.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of deleted
-        if self.deleted:
-            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of mailgun
         if self.mailgun:
             _dict['mailgun'] = self.mailgun.to_dict()
         # override the default output from pydantic by calling `to_dict()` of github
         if self.github:
             _dict['github'] = self.github.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedDistribution:
-        """Create an instance of FlattenedDistribution from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededDistribution from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedDistribution.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedDistribution.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id"),
-            "share": obj.get("share"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
-            "mailgun": MailgunDistribution.from_dict(obj.get("mailgun")) if obj.get("mailgun") is not None else None,
-            "github": GitHubDistribution.from_dict(obj.get("github")) if obj.get("github") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "mailgun": MailgunDistribution.from_dict(obj["mailgun"]) if obj.get("mailgun") is not None else None,
+            "github": SeededGitHubDistribution.from_dict(obj["github"]) if obj.get("github") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_distributions.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_sensitive.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.referenced_distribution import ReferencedDistribution
+from pieces_os_client.models.seeded_sensitive import SeededSensitive
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlattenedDistributions(BaseModel):
-    """
-    FlattenedDistributions
+class DiscoveredSensitive(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedDistribution) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will return a discoveredSensitive, with a seed that can be used to create if automatic is set to false. and will provide the original text provided.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    seed: SeededSensitive
+    text: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "seed", "text"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedDistributions:
-        """Create an instance of FlattenedDistributions from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DiscoveredSensitive from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
+        # override the default output from pydantic by calling `to_dict()` of seed
+        if self.seed:
+            _dict['seed'] = self.seed.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedDistributions:
-        """Create an instance of FlattenedDistributions from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DiscoveredSensitive from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedDistributions.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedDistributions.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [ReferencedDistribution.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "seed": SeededSensitive.from_dict(obj["seed"]) if obj.get("seed") is not None else None,
+            "text": obj.get("text")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_format.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/format.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,212 +14,167 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, constr, validator
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.activities import Activities
 from pieces_os_client.models.application import Application
 from pieces_os_client.models.byte_descriptor import ByteDescriptor
 from pieces_os_client.models.classification import Classification
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.file_format import FileFormat
+from pieces_os_client.models.flattened_asset import FlattenedAsset
 from pieces_os_client.models.fragment_format import FragmentFormat
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.relationship import Relationship
 from pieces_os_client.models.role import Role
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedFormat(BaseModel):
-    """
-    A representation of Data for a particular Form Factor of an Asset.[DAG Compatible - Directed Acyclic Graph Data Structure]  FlattenedFormats prevent Cycles in Reference because all outbound references are strings as opposed to crosspollinated objects.  i.e. FlattenedFormat.asset is Type String  fragment or file will always be defined. Even thought they are both optional.  # noqa: E501
+class Format(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    creator: StrictStr = Field(...)
-    classification: Classification = Field(...)
+    A representation of Data for a particular Form Factor of an Asset.  Below asset HAS to be Flattened because it is a leaf node and must prevent cycles agressively.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    creator: StrictStr
+    classification: Classification
     icon: Optional[StrictStr] = None
-    role: Role = Field(...)
-    application: Application = Field(...)
-    asset: constr(strict=True, max_length=36, min_length=36) = Field(
-        ..., description="A uuid model. 36 Characters (4 Dashes, 32 Numbers/Letters) "
-    )
-    bytes: ByteDescriptor = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    role: Role
+    application: Application
+    asset: FlattenedAsset
+    bytes: ByteDescriptor
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     synced: Optional[GroupedTimestamp] = None
-    cloud: Optional[StrictStr] = Field(
-        None,
-        description="This is a path used to determine what path this format lives at within the cloud.",
-    )
+    cloud: Optional[StrictStr] = Field(default=None, description="This is a path used to determine what path this format lives at within the cloud.")
     fragment: Optional[FragmentFormat] = None
     file: Optional[FileFormat] = None
-    analysis: Optional[FlattenedAnalysis] = None
+    analysis: Optional[Analysis] = None
     relationship: Optional[Relationship] = None
-    activities: Optional[FlattenedActivities] = None
-    __properties = [
-        "schema",
-        "id",
-        "creator",
-        "classification",
-        "icon",
-        "role",
-        "application",
-        "asset",
-        "bytes",
-        "created",
-        "updated",
-        "deleted",
-        "synced",
-        "cloud",
-        "fragment",
-        "file",
-        "analysis",
-        "relationship",
-        "activities",
-    ]
-
-    @validator("asset")
-    def asset_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if not re.match(
-            r"[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}",
-            value,
-        ):
-            raise ValueError(
-                r"must validate the regular expression /[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}/"
-            )
-        return value
+    activities: Optional[Activities] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "creator", "classification", "icon", "role", "application", "asset", "bytes", "created", "updated", "deleted", "synced", "cloud", "fragment", "file", "analysis", "relationship", "activities"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedFormat:
-        """Create an instance of FlattenedFormat from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Format from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of classification
         if self.classification:
-            _dict["classification"] = self.classification.to_dict()
+            _dict['classification'] = self.classification.to_dict()
         # override the default output from pydantic by calling `to_dict()` of application
         if self.application:
-            _dict["application"] = self.application.to_dict()
+            _dict['application'] = self.application.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of asset
+        if self.asset:
+            _dict['asset'] = self.asset.to_dict()
         # override the default output from pydantic by calling `to_dict()` of bytes
         if self.bytes:
-            _dict["bytes"] = self.bytes.to_dict()
+            _dict['bytes'] = self.bytes.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of synced
         if self.synced:
-            _dict["synced"] = self.synced.to_dict()
+            _dict['synced'] = self.synced.to_dict()
         # override the default output from pydantic by calling `to_dict()` of fragment
         if self.fragment:
-            _dict["fragment"] = self.fragment.to_dict()
+            _dict['fragment'] = self.fragment.to_dict()
         # override the default output from pydantic by calling `to_dict()` of file
         if self.file:
-            _dict["file"] = self.file.to_dict()
+            _dict['file'] = self.file.to_dict()
         # override the default output from pydantic by calling `to_dict()` of analysis
         if self.analysis:
-            _dict["analysis"] = self.analysis.to_dict()
+            _dict['analysis'] = self.analysis.to_dict()
         # override the default output from pydantic by calling `to_dict()` of relationship
         if self.relationship:
-            _dict["relationship"] = self.relationship.to_dict()
+            _dict['relationship'] = self.relationship.to_dict()
         # override the default output from pydantic by calling `to_dict()` of activities
         if self.activities:
-            _dict["activities"] = self.activities.to_dict()
+            _dict['activities'] = self.activities.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedFormat:
-        """Create an instance of FlattenedFormat from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Format from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedFormat.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedFormat.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "creator": obj.get("creator"),
-                "classification": Classification.from_dict(obj.get("classification"))
-                if obj.get("classification") is not None
-                else None,
-                "icon": obj.get("icon"),
-                "role": obj.get("role"),
-                "application": Application.from_dict(obj.get("application"))
-                if obj.get("application") is not None
-                else None,
-                "asset": obj.get("asset"),
-                "bytes": ByteDescriptor.from_dict(obj.get("bytes"))
-                if obj.get("bytes") is not None
-                else None,
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "synced": GroupedTimestamp.from_dict(obj.get("synced"))
-                if obj.get("synced") is not None
-                else None,
-                "cloud": obj.get("cloud"),
-                "fragment": FragmentFormat.from_dict(obj.get("fragment"))
-                if obj.get("fragment") is not None
-                else None,
-                "file": FileFormat.from_dict(obj.get("file"))
-                if obj.get("file") is not None
-                else None,
-                "analysis": FlattenedAnalysis.from_dict(obj.get("analysis"))
-                if obj.get("analysis") is not None
-                else None,
-                "relationship": Relationship.from_dict(obj.get("relationship"))
-                if obj.get("relationship") is not None
-                else None,
-                "activities": FlattenedActivities.from_dict(obj.get("activities"))
-                if obj.get("activities") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "creator": obj.get("creator"),
+            "classification": Classification.from_dict(obj["classification"]) if obj.get("classification") is not None else None,
+            "icon": obj.get("icon"),
+            "role": obj.get("role"),
+            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "asset": FlattenedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "bytes": ByteDescriptor.from_dict(obj["bytes"]) if obj.get("bytes") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "synced": GroupedTimestamp.from_dict(obj["synced"]) if obj.get("synced") is not None else None,
+            "cloud": obj.get("cloud"),
+            "fragment": FragmentFormat.from_dict(obj["fragment"]) if obj.get("fragment") is not None else None,
+            "file": FileFormat.from_dict(obj["file"]) if obj.get("file") is not None else None,
+            "analysis": Analysis.from_dict(obj["analysis"]) if obj.get("analysis") is not None else None,
+            "relationship": Relationship.from_dict(obj["relationship"]) if obj.get("relationship") is not None else None,
+            "activities": Activities.from_dict(obj["activities"]) if obj.get("activities") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.analysis import Analysis
+# TODO: Rewrite to not use raise_errors
+Format.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.flattened_activities import FlattenedActivities
-from pieces_os_client.models.flattened_analysis import FlattenedAnalysis
-
-# FlattenedFormat.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_formats.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/segmented_technical_language.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,83 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.segmented_technical_language_fragment import SegmentedTechnicalLanguageFragment
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedFormats(BaseModel):
-    """
-    A collection of Formats specific to the authenticated user. [DAG Compatible - Directed Acyclic Graph Data Structure]  FlattenedFormats prevent Cycles in Reference because all outbound references are strings as opposed to crosspollinated objects.   # noqa: E501
+class SegmentedTechnicalLanguage(BaseModel):
     """
+    This is the output model for '/machine_learning/text/technical_language/parsers/segmentation'  This will have an iterable of the segmented Technical language text/code
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[SegmentedTechnicalLanguageFragment]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedFormat) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedFormats:
-        """Create an instance of FlattenedFormats from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SegmentedTechnicalLanguage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedFormats:
-        """Create an instance of FlattenedFormats from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SegmentedTechnicalLanguage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedFormats.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedFormats.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedFormat.from_dict(_item) for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [SegmentedTechnicalLanguageFragment.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_format import ReferencedFormat
-
-# FlattenedFormats.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_hint.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_hint.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,137 +14,125 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.hint_type_enum import HintTypeEnum
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.referenced_model import ReferencedModel
 from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedHint(BaseModel):
     """
-    This is the flattened version of a hint. Ensure that you DO NOT reference the Asset here as you can create an infinite loop within the packaging.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    This is the flattened version of a hint. Ensure that you DO NOT reference the Asset here as you can create an infinite loop within the packaging.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     mechanism: Optional[MechanismEnum] = None
     asset: Optional[ReferencedAsset] = None
-    type: HintTypeEnum = Field(...)
-    text: StrictStr = Field(..., description="This is the text of the hint.")
+    type: HintTypeEnum
+    text: StrictStr = Field(description="This is the text of the hint.")
     model: Optional[ReferencedModel] = None
     score: Optional[Score] = None
-    __properties = [
-        "schema",
-        "id",
-        "created",
-        "updated",
-        "deleted",
-        "mechanism",
-        "asset",
-        "type",
-        "text",
-        "model",
-        "score",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "deleted", "mechanism", "asset", "type", "text", "model", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedHint:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedHint from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of asset
         if self.asset:
-            _dict["asset"] = self.asset.to_dict()
+            _dict['asset'] = self.asset.to_dict()
         # override the default output from pydantic by calling `to_dict()` of model
         if self.model:
-            _dict["model"] = self.model.to_dict()
+            _dict['model'] = self.model.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedHint:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedHint from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedHint.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedHint.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "mechanism": obj.get("mechanism"),
-                "asset": ReferencedAsset.from_dict(obj.get("asset"))
-                if obj.get("asset") is not None
-                else None,
-                "type": obj.get("type"),
-                "text": obj.get("text"),
-                "model": ReferencedModel.from_dict(obj.get("model"))
-                if obj.get("model") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "mechanism": obj.get("mechanism"),
+            "asset": ReferencedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "type": obj.get("type"),
+            "text": obj.get("text"),
+            "model": ReferencedModel.from_dict(obj["model"]) if obj.get("model") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.referenced_asset import ReferencedAsset
+# TODO: Rewrite to not use raise_errors
+FlattenedHint.model_rebuild(raise_errors=False)
 
-# FlattenedHint.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_hints.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_hints.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,95 +14,99 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedHints(BaseModel):
     """
-    This is the flattened Version of plural hints.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedHint) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(
-        None, description="This is a Map<String, int> where the the key is an hint id."
-    )
+    This is the flattened Version of plural hints.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[ReferencedHint]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an hint id.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedHints:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedHints from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedHints:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedHints from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedHints.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedHints.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedHint.from_dict(_item) for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "indices": obj.get("indices"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ReferencedHint.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "indices": obj.get("indices"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.referenced_hint import ReferencedHint
+# TODO: Rewrite to not use raise_errors
+FlattenedHints.model_rebuild(raise_errors=False)
 
-# FlattenedHints.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_image_analysis.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_file_analytics.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,83 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedImageAnalysis(BaseModel):
-    """
-    FlattenedImageAnalysis
+class TLPCodeFileAnalytics(BaseModel):
     """
+    TLPCodeFileAnalytics
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    ocr: Optional[FlattenedOCRAnalysis] = None
-    analysis: StrictStr = Field(
-        ..., description="this is a reference to our (parent)analysis"
-    )
-    __properties = ["schema", "id", "ocr", "analysis"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedImageAnalysis:
-        """Create an instance of FlattenedImageAnalysis from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPCodeFileAnalytics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of ocr
-        if self.ocr:
-            _dict["ocr"] = self.ocr.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedImageAnalysis:
-        """Create an instance of FlattenedImageAnalysis from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPCodeFileAnalytics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedImageAnalysis.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedImageAnalysis.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "ocr": FlattenedOCRAnalysis.from_dict(obj.get("ocr"))
-                if obj.get("ocr") is not None
-                else None,
-                "analysis": obj.get("analysis"),
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id")
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_ocr_analysis import FlattenedOCRAnalysis
-
-# FlattenedImageAnalysis.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_ocr_analysis.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_person.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,98 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.model import Model
-
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlattenedOCRAnalysis(BaseModel):
-    """
-    [DAG Safe] Ocr Analysis that will reference FlattenedFormats.  # noqa: E501
+class ReferencedPerson(BaseModel):
     """
+    [DAG Safe] version of a Person Model. 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedPerson] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    raw: ReferencedFormat = Field(...)
-    hocr: ReferencedFormat = Field(...)
-    model: Model = Field(...)
-    image: StrictStr = Field(
-        ..., description="this is a refernece to the image analysis."
-    )
-    __properties = ["schema", "id", "raw", "hocr", "model", "image"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedOCRAnalysis:
-        """Create an instance of FlattenedOCRAnalysis from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedPerson from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of raw
-        if self.raw:
-            _dict["raw"] = self.raw.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of hocr
-        if self.hocr:
-            _dict["hocr"] = self.hocr.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of model
-        if self.model:
-            _dict["model"] = self.model.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of reference
+        if self.reference:
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedOCRAnalysis:
-        """Create an instance of FlattenedOCRAnalysis from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedPerson from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedOCRAnalysis.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedOCRAnalysis.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "raw": ReferencedFormat.from_dict(obj.get("raw"))
-                if obj.get("raw") is not None
-                else None,
-                "hocr": ReferencedFormat.from_dict(obj.get("hocr"))
-                if obj.get("hocr") is not None
-                else None,
-                "model": Model.from_dict(obj.get("model"))
-                if obj.get("model") is not None
-                else None,
-                "image": obj.get("image"),
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedPerson.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.flattened_person import FlattenedPerson
+# TODO: Rewrite to not use raise_errors
+ReferencedPerson.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.referenced_format import ReferencedFormat
-
-# FlattenedOCRAnalysis.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_person.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/person.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,206 +14,168 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
+from pieces_os_client.models.flattened_assets import FlattenedAssets
+from pieces_os_client.models.flattened_tags import FlattenedTags
+from pieces_os_client.models.flattened_websites import FlattenedWebsites
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.person_access import PersonAccess
+from pieces_os_client.models.person_model import PersonModel
 from pieces_os_client.models.person_type import PersonType
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedPerson(BaseModel):
-    """
-    if expiration is add then, after the alloted expiration date the user will only have view && comment only permissions. Only present in the case there is a scope such as a defined collection/asset...  if asset is passed then that means this person belongs to a scoped asset.  # noqa: E501
+class Person(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    if expiration is add then, after the alloted expiration date the user will only have view && comment only permissions. Only present in the case there is a scope such as a defined collection/asset...  if asset is passed then that means this person belongs to a scoped asset.  NOTE****: annotations here are annotations to describe the person!!! if in the future we want to add who wrote an annotation on and asset or soemthing like that, we will want to add a new field on here called authorships.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    type: PersonType = Field(...)
+    type: PersonType
     assets: Optional[FlattenedAssets] = None
-    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(
-        None,
-        description="This is a Map<String, MechanismEnum> where the the key is an asset id.",
-    )
-    interactions: Optional[StrictInt] = Field(
-        None,
-        description="This is an optional value that will keep track of the number of times this has been interacted with.",
-    )
-    access: Optional[Dict[str, PersonAccess]] = Field(
-        None,
-        description="This is a Map<String, PersonAccess> where the the key is an asset id.",
-    )
+    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(default=None, description="This is a Map<String, MechanismEnum> where the the key is an asset id.")
+    interactions: Optional[StrictInt] = Field(default=None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
+    access: Optional[Dict[str, PersonAccess]] = Field(default=None, description="This is a Map<String, PersonAccess> where the the key is an asset id.")
     tags: Optional[FlattenedTags] = None
     websites: Optional[FlattenedWebsites] = None
-    models: Optional[Dict[str, PersonModel]] = Field(
-        None,
-        description="This is a Map<String, PersonModel>, where the the key is an asset id.",
-    )
+    models: Optional[Dict[str, PersonModel]] = Field(default=None, description="This is a Map<String, PersonModel>, where the the key is an asset id.")
     annotations: Optional[FlattenedAnnotations] = None
     score: Optional[Score] = None
-    __properties = [
-        "schema",
-        "id",
-        "created",
-        "updated",
-        "deleted",
-        "type",
-        "assets",
-        "mechanisms",
-        "interactions",
-        "access",
-        "tags",
-        "websites",
-        "models",
-        "annotations",
-        "score",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "deleted", "type", "assets", "mechanisms", "interactions", "access", "tags", "websites", "models", "annotations", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedPerson:
-        """Create an instance of FlattenedPerson from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Person from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of type
         if self.type:
-            _dict["type"] = self.type.to_dict()
+            _dict['type'] = self.type.to_dict()
         # override the default output from pydantic by calling `to_dict()` of assets
         if self.assets:
-            _dict["assets"] = self.assets.to_dict()
+            _dict['assets'] = self.assets.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in access (dict)
         _field_dict = {}
         if self.access:
             for _key in self.access:
                 if self.access[_key]:
                     _field_dict[_key] = self.access[_key].to_dict()
-            _dict["access"] = _field_dict
+            _dict['access'] = _field_dict
         # override the default output from pydantic by calling `to_dict()` of tags
         if self.tags:
-            _dict["tags"] = self.tags.to_dict()
+            _dict['tags'] = self.tags.to_dict()
         # override the default output from pydantic by calling `to_dict()` of websites
         if self.websites:
-            _dict["websites"] = self.websites.to_dict()
+            _dict['websites'] = self.websites.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in models (dict)
         _field_dict = {}
         if self.models:
             for _key in self.models:
                 if self.models[_key]:
                     _field_dict[_key] = self.models[_key].to_dict()
-            _dict["models"] = _field_dict
+            _dict['models'] = _field_dict
         # override the default output from pydantic by calling `to_dict()` of annotations
         if self.annotations:
-            _dict["annotations"] = self.annotations.to_dict()
+            _dict['annotations'] = self.annotations.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedPerson:
-        """Create an instance of FlattenedPerson from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Person from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedPerson.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedPerson.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "type": PersonType.from_dict(obj.get("type"))
-                if obj.get("type") is not None
-                else None,
-                "assets": FlattenedAssets.from_dict(obj.get("assets"))
-                if obj.get("assets") is not None
-                else None,
-                "mechanisms": dict(
-                    (_k, _v) for _k, _v in obj.get("mechanisms").items()
-                ),
-                "interactions": obj.get("interactions"),
-                "access": dict(
-                    (_k, PersonAccess.from_dict(_v))
-                    for _k, _v in obj.get("access").items()
-                )
-                if obj.get("access") is not None
-                else None,
-                "tags": FlattenedTags.from_dict(obj.get("tags"))
-                if obj.get("tags") is not None
-                else None,
-                "websites": FlattenedWebsites.from_dict(obj.get("websites"))
-                if obj.get("websites") is not None
-                else None,
-                "models": dict(
-                    (_k, PersonModel.from_dict(_v))
-                    for _k, _v in obj.get("models").items()
-                )
-                if obj.get("models") is not None
-                else None,
-                "annotations": FlattenedAnnotations.from_dict(obj.get("annotations"))
-                if obj.get("annotations") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "type": PersonType.from_dict(obj["type"]) if obj.get("type") is not None else None,
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "mechanisms": dict((_k, _v) for _k, _v in obj.get("mechanisms").items()),
+            "interactions": obj.get("interactions"),
+            "access": dict(
+                (_k, PersonAccess.from_dict(_v))
+                for _k, _v in obj["access"].items()
+            )
+            if obj.get("access") is not None
+            else None,
+            "tags": FlattenedTags.from_dict(obj["tags"]) if obj.get("tags") is not None else None,
+            "websites": FlattenedWebsites.from_dict(obj["websites"]) if obj.get("websites") is not None else None,
+            "models": dict(
+                (_k, PersonModel.from_dict(_v))
+                for _k, _v in obj["models"].items()
+            )
+            if obj.get("models") is not None
+            else None,
+            "annotations": FlattenedAnnotations.from_dict(obj["annotations"]) if obj.get("annotations") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
-from pieces_os_client.models.flattened_assets import FlattenedAssets
-from pieces_os_client.models.flattened_tags import FlattenedTags
-from pieces_os_client.models.flattened_websites import FlattenedWebsites
-from pieces_os_client.models.person_model import PersonModel
-
-# FlattenedPerson.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_persons.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/interacted_assets.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,96 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.score import Score
-
+from pieces_os_client.models.interacted_asset import InteractedAsset
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlattenedPersons(BaseModel):
-    """
-    This is the plural of Person. will have top level meta about the person including an iterable of all the person.  # noqa: E501
+class InteractedAssets(BaseModel):
     """
+    A model which contains a list of InteractedAssets with potentially additional properties.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[InteractedAsset]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedPerson) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(
-        None,
-        description="This is a Map<String, int> where the the key is an person id.",
-    )
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedPersons:
-        """Create an instance of FlattenedPersons from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of InteractedAssets from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedPersons:
-        """Create an instance of FlattenedPersons from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of InteractedAssets from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedPersons.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedPersons.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedPerson.from_dict(_item) for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "indices": obj.get("indices"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [InteractedAsset.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_person import ReferencedPerson
-
-# FlattenedPersons.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_preview.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_user.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,67 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlattenedPreview(BaseModel):
-    """
-    These are the references of the formats **Only UUIDS**  # noqa: E501
+class SeededUser(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    base: StrictStr = Field(..., description="this is a reference(uuid) to the base format")
-    overlay: Optional[StrictStr] = Field(None, description="this is a reference(uuid) to the overlay format")
-    __properties = ["schema", "base", "overlay"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    emails: List[StrictStr]
+    __properties: ClassVar[List[str]] = ["schema", "emails"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedPreview:
-        """Create an instance of FlattenedPreview from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededUser from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedPreview:
-        """Create an instance of FlattenedPreview from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededUser from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedPreview.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedPreview.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "base": obj.get("base"),
-            "overlay": obj.get("overlay")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "emails": obj.get("emails")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_sensitive.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/sensitive.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,153 +14,132 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.flattened_asset import FlattenedAsset
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.score import Score
 from pieces_os_client.models.sensitive_category_enum import SensitiveCategoryEnum
 from pieces_os_client.models.sensitive_metadata import SensitiveMetadata
 from pieces_os_client.models.sensitive_severity_enum import SensitiveSeverityEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedSensitive(BaseModel):
-    """
-    This is a dereferenced representation of a sensitive pieces of data.  # noqa: E501
+class Sensitive(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    This is a fully referenced representation of a sensitive pieces of data.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    asset: ReferencedAsset = Field(...)
-    text: StrictStr = Field(...)
-    mechanism: MechanismEnum = Field(...)
-    category: SensitiveCategoryEnum = Field(...)
-    severity: SensitiveSeverityEnum = Field(...)
-    name: StrictStr = Field(...)
-    description: StrictStr = Field(...)
+    asset: FlattenedAsset
+    text: StrictStr
+    mechanism: MechanismEnum
+    category: SensitiveCategoryEnum
+    severity: SensitiveSeverityEnum
+    name: StrictStr
+    description: StrictStr
     metadata: Optional[SensitiveMetadata] = None
-    interactions: Optional[StrictInt] = Field(
-        None,
-        description="This is an optional value that will keep track of the number of times this has been interacted with.",
-    )
+    interactions: Optional[StrictInt] = Field(default=None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
     score: Optional[Score] = None
-    __properties = [
-        "schema",
-        "id",
-        "created",
-        "updated",
-        "deleted",
-        "asset",
-        "text",
-        "mechanism",
-        "category",
-        "severity",
-        "name",
-        "description",
-        "metadata",
-        "interactions",
-        "score",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "deleted", "asset", "text", "mechanism", "category", "severity", "name", "description", "metadata", "interactions", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedSensitive:
-        """Create an instance of FlattenedSensitive from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Sensitive from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of asset
         if self.asset:
-            _dict["asset"] = self.asset.to_dict()
+            _dict['asset'] = self.asset.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
-            _dict["metadata"] = self.metadata.to_dict()
+            _dict['metadata'] = self.metadata.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedSensitive:
-        """Create an instance of FlattenedSensitive from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Sensitive from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedSensitive.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedSensitive.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "asset": ReferencedAsset.from_dict(obj.get("asset"))
-                if obj.get("asset") is not None
-                else None,
-                "text": obj.get("text"),
-                "mechanism": obj.get("mechanism"),
-                "category": obj.get("category"),
-                "severity": obj.get("severity"),
-                "name": obj.get("name"),
-                "description": obj.get("description"),
-                "metadata": SensitiveMetadata.from_dict(obj.get("metadata"))
-                if obj.get("metadata") is not None
-                else None,
-                "interactions": obj.get("interactions"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "asset": FlattenedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "text": obj.get("text"),
+            "mechanism": obj.get("mechanism"),
+            "category": obj.get("category"),
+            "severity": obj.get("severity"),
+            "name": obj.get("name"),
+            "description": obj.get("description"),
+            "metadata": SensitiveMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None,
+            "interactions": obj.get("interactions"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_asset import ReferencedAsset
-
-# FlattenedSensitive.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_sensitives.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_keyboard_event_identifier_description_pairs.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,92 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlattenedSensitives(BaseModel):
-    """
-    This is a flattened representation of multiple sensitive pieces of data.  # noqa: E501
+class SeededTrackedKeyboardEventIdentifierDescriptionPairs(BaseModel):
     """
+    SeededTrackedKeyboardEventIdentifierDescriptionPairs
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    assets_list_refreshed: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "assets_list_refreshed"]
+
+    @field_validator('assets_list_refreshed')
+    def assets_list_refreshed_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in set(['the_assets_list_was_refreshed_through_a_keyboard_shortcut']):
+            raise ValueError("must be one of enum values ('the_assets_list_was_refreshed_through_a_keyboard_shortcut')")
+        return value
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedSensitive) = Field(...)
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedSensitives:
-        """Create an instance of FlattenedSensitives from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededTrackedKeyboardEventIdentifierDescriptionPairs from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict["iterable"] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedSensitives:
-        """Create an instance of FlattenedSensitives from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededTrackedKeyboardEventIdentifierDescriptionPairs from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedSensitives.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedSensitives.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedSensitive.from_dict(_item)
-                    for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "assets_list_refreshed": obj.get("assets_list_refreshed")
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_sensitive import ReferencedSensitive
-
-# FlattenedSensitives.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_share.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_share.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,146 +14,126 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.access_enum import AccessEnum
 from pieces_os_client.models.accessors import Accessors
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_distributions import FlattenedDistributions
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedShare(BaseModel):
     """
-    This is a dag safe version of the Share.  if user is undefined && access is public then we have an asset that is publicly available.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="This references the share it self.")
-    asset: Optional[StrictStr] = Field(
-        None, description="this is the asset id on the flattened share."
-    )
-    user: Optional[StrictStr] = Field(
-        None, description="this is the uuid of the user that the share is created for."
-    )
-    link: StrictStr = Field(..., description="this is the prebuilt link.")
-    access: AccessEnum = Field(...)
-    accessors: Accessors = Field(...)
-    created: GroupedTimestamp = Field(...)
-    short: StrictStr = Field(
-        ..., description="This is a shortened version of our uuid."
-    )
+    This is a dag safe version of the Share.  if user is undefined && access is public then we have an asset that is publicly available.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="This references the share it self.")
+    asset: Optional[StrictStr] = Field(default=None, description="this is the asset id on the flattened share.")
+    user: Optional[StrictStr] = Field(default=None, description="this is the uuid of the user that the share is created for.")
+    link: StrictStr = Field(description="this is the prebuilt link.")
+    access: AccessEnum
+    accessors: Accessors
+    created: GroupedTimestamp
+    short: StrictStr = Field(description="This is a shortened version of our uuid.")
     name: Optional[StrictStr] = None
     assets: Optional[FlattenedAssets] = None
     distributions: Optional[FlattenedDistributions] = None
     score: Optional[Score] = None
-    __properties = [
-        "schema",
-        "id",
-        "asset",
-        "user",
-        "link",
-        "access",
-        "accessors",
-        "created",
-        "short",
-        "name",
-        "assets",
-        "distributions",
-        "score",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "id", "asset", "user", "link", "access", "accessors", "created", "short", "name", "assets", "distributions", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedShare:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedShare from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of accessors
         if self.accessors:
-            _dict["accessors"] = self.accessors.to_dict()
+            _dict['accessors'] = self.accessors.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of assets
         if self.assets:
-            _dict["assets"] = self.assets.to_dict()
+            _dict['assets'] = self.assets.to_dict()
         # override the default output from pydantic by calling `to_dict()` of distributions
         if self.distributions:
-            _dict["distributions"] = self.distributions.to_dict()
+            _dict['distributions'] = self.distributions.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedShare:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedShare from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedShare.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedShare.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "asset": obj.get("asset"),
-                "user": obj.get("user"),
-                "link": obj.get("link"),
-                "access": obj.get("access"),
-                "accessors": Accessors.from_dict(obj.get("accessors"))
-                if obj.get("accessors") is not None
-                else None,
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "short": obj.get("short"),
-                "name": obj.get("name"),
-                "assets": FlattenedAssets.from_dict(obj.get("assets"))
-                if obj.get("assets") is not None
-                else None,
-                "distributions": FlattenedDistributions.from_dict(
-                    obj.get("distributions")
-                )
-                if obj.get("distributions") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "asset": obj.get("asset"),
+            "user": obj.get("user"),
+            "link": obj.get("link"),
+            "access": obj.get("access"),
+            "accessors": Accessors.from_dict(obj["accessors"]) if obj.get("accessors") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "short": obj.get("short"),
+            "name": obj.get("name"),
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "distributions": FlattenedDistributions.from_dict(obj["distributions"]) if obj.get("distributions") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.flattened_assets import FlattenedAssets
+# TODO: Rewrite to not use raise_errors
+FlattenedShare.model_rebuild(raise_errors=False)
 
-# FlattenedShare.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_shares.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_sensitives.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,91 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.discovered_sensitive import DiscoveredSensitive
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlattenedShares(BaseModel):
-    """
-    This is just an iterable of our individual share models.  # noqa: E501
+class DiscoveredSensitives(BaseModel):
     """
+    
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[DiscoveredSensitive]
+    application: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "application"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(FlattenedShare) = Field(...)
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedShares:
-        """Create an instance of FlattenedShares from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DiscoveredSensitives from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedShares:
-        """Create an instance of FlattenedShares from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DiscoveredSensitives from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedShares.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedShares.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    FlattenedShare.from_dict(_item) for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [DiscoveredSensitive.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "application": obj.get("application")
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_share import FlattenedShare
-
-# FlattenedShares.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_tag.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_tag.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,157 +14,133 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.relationship import Relationship
 from pieces_os_client.models.score import Score
 from pieces_os_client.models.tag_category_enum import TagCategoryEnum
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedTag(BaseModel):
     """
-    This is a Flattened Version of a Tag.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    text: StrictStr = Field(...)
-    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(
-        None,
-        description="This is a Map<String, MechanismEnum> where the the key is an asset id.",
-    )
+    This is a Flattened Version of a Tag.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    text: StrictStr
+    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(default=None, description="This is a Map<String, MechanismEnum> where the the key is an asset id.")
     assets: Optional[FlattenedAssets] = None
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    category: TagCategoryEnum = Field(...)
+    category: TagCategoryEnum
     relationship: Optional[Relationship] = None
-    interactions: Optional[StrictInt] = Field(
-        None,
-        description="This is an optional value that will keep track of the number of times this has been interacted with.",
-    )
+    interactions: Optional[StrictInt] = Field(default=None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
     persons: Optional[FlattenedPersons] = None
     score: Optional[Score] = None
-    __properties = [
-        "schema",
-        "id",
-        "text",
-        "mechanisms",
-        "assets",
-        "created",
-        "updated",
-        "deleted",
-        "category",
-        "relationship",
-        "interactions",
-        "persons",
-        "score",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "id", "text", "mechanisms", "assets", "created", "updated", "deleted", "category", "relationship", "interactions", "persons", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedTag:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedTag from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of assets
         if self.assets:
-            _dict["assets"] = self.assets.to_dict()
+            _dict['assets'] = self.assets.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of relationship
         if self.relationship:
-            _dict["relationship"] = self.relationship.to_dict()
+            _dict['relationship'] = self.relationship.to_dict()
         # override the default output from pydantic by calling `to_dict()` of persons
         if self.persons:
-            _dict["persons"] = self.persons.to_dict()
+            _dict['persons'] = self.persons.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedTag:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedTag from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedTag.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedTag.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "text": obj.get("text"),
-                "mechanisms": dict(
-                    (_k, _v) for _k, _v in obj.get("mechanisms").items()
-                ),
-                "assets": FlattenedAssets.from_dict(obj.get("assets"))
-                if obj.get("assets") is not None
-                else None,
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "category": obj.get("category"),
-                "relationship": Relationship.from_dict(obj.get("relationship"))
-                if obj.get("relationship") is not None
-                else None,
-                "interactions": obj.get("interactions"),
-                "persons": FlattenedPersons.from_dict(obj.get("persons"))
-                if obj.get("persons") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "text": obj.get("text"),
+            "mechanisms": dict((_k, _v) for _k, _v in obj.get("mechanisms").items()),
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "category": obj.get("category"),
+            "relationship": Relationship.from_dict(obj["relationship"]) if obj.get("relationship") is not None else None,
+            "interactions": obj.get("interactions"),
+            "persons": FlattenedPersons.from_dict(obj["persons"]) if obj.get("persons") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.flattened_assets import FlattenedAssets
 from pieces_os_client.models.flattened_persons import FlattenedPersons
+# TODO: Rewrite to not use raise_errors
+FlattenedTag.model_rebuild(raise_errors=False)
 
-# FlattenedTag.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_tags.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/annotations.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,95 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.annotation import Annotation
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedTags(BaseModel):
-    """
-    This is multiple ReferencedTags(which includes an optional FlattenedTag Model within the reference model).  # noqa: E501
+class Annotations(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedTag) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(
-        None, description="This is a Map<String, int> where the the key is an tag id."
-    )
+    This is the plural of Annotation
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Annotation]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an annotation id.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedTags:
-        """Create an instance of FlattenedTags from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Annotations from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedTags:
-        """Create an instance of FlattenedTags from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Annotations from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedTags.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedTags.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedTag.from_dict(_item) for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "indices": obj.get("indices"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Annotation.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "indices": obj.get("indices"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_tag import ReferencedTag
-
-# FlattenedTags.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_user_profile.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_user_profile.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,72 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedUserProfile(BaseModel):
     """
-    This is a FlattenedUserProfile that includes information that is not sensative in relation to a user.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="this is the uuid that identifies a user.")
+    This is a FlattenedUserProfile that includes information that is not sensative in relation to a user.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="this is the uuid that identifies a user.")
     email: Optional[StrictStr] = None
     name: Optional[StrictStr] = None
     username: Optional[StrictStr] = None
     picture: Optional[StrictStr] = None
     vanityname: Optional[StrictStr] = None
-    __properties = ["schema", "id", "email", "name", "username", "picture", "vanityname"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "email", "name", "username", "picture", "vanityname"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedUserProfile:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedUserProfile from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedUserProfile:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedUserProfile from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedUserProfile.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedUserProfile.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
             "email": obj.get("email"),
             "name": obj.get("name"),
             "username": obj.get("username"),
             "picture": obj.get("picture"),
             "vanityname": obj.get("vanityname")
         })
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_website.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/website.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,158 +14,130 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.flattened_assets import FlattenedAssets
+from pieces_os_client.models.flattened_conversations import FlattenedConversations
+from pieces_os_client.models.flattened_persons import FlattenedPersons
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class FlattenedWebsite(BaseModel):
-    """
-    This is a specific model for related websites to an asset.[DAG SAFE]  # noqa: E501
+class Website(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="this is aspecific uuid that represents")
+    This is a specific model for related websites to an asset.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
     assets: Optional[FlattenedAssets] = None
-    name: StrictStr = Field(..., description="A customizable name.")
-    url: StrictStr = Field(..., description="The true url or the website.")
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    url: StrictStr = Field(description="this is the actual website url.")
+    name: StrictStr = Field(description="This is a name that is customized.")
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(
-        None,
-        description="This is a Map<String, MechanismEnum> where the the key is an asset id.",
-    )
-    interactions: Optional[StrictInt] = Field(
-        None,
-        description="This is an optional value that will keep track of the number of times this has been interacted with.",
-    )
+    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(default=None, description="This is a Map<String, MechanismEnum> where the the key is an asset id.")
+    interactions: Optional[StrictInt] = Field(default=None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
     persons: Optional[FlattenedPersons] = None
     conversations: Optional[FlattenedConversations] = None
     score: Optional[Score] = None
-    __properties = [
-        "schema",
-        "id",
-        "assets",
-        "name",
-        "url",
-        "created",
-        "updated",
-        "deleted",
-        "mechanisms",
-        "interactions",
-        "persons",
-        "conversations",
-        "score",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "id", "assets", "url", "name", "created", "updated", "deleted", "mechanisms", "interactions", "persons", "conversations", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedWebsite:
-        """Create an instance of FlattenedWebsite from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Website from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of assets
         if self.assets:
-            _dict["assets"] = self.assets.to_dict()
+            _dict['assets'] = self.assets.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of persons
         if self.persons:
-            _dict["persons"] = self.persons.to_dict()
+            _dict['persons'] = self.persons.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversations
         if self.conversations:
-            _dict["conversations"] = self.conversations.to_dict()
+            _dict['conversations'] = self.conversations.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedWebsite:
-        """Create an instance of FlattenedWebsite from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Website from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedWebsite.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedWebsite.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "assets": FlattenedAssets.from_dict(obj.get("assets"))
-                if obj.get("assets") is not None
-                else None,
-                "name": obj.get("name"),
-                "url": obj.get("url"),
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "mechanisms": dict(
-                    (_k, _v) for _k, _v in obj.get("mechanisms").items()
-                ),
-                "interactions": obj.get("interactions"),
-                "persons": FlattenedPersons.from_dict(obj.get("persons"))
-                if obj.get("persons") is not None
-                else None,
-                "conversations": FlattenedConversations.from_dict(
-                    obj.get("conversations")
-                )
-                if obj.get("conversations") is not None
-                else None,
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "url": obj.get("url"),
+            "name": obj.get("name"),
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "mechanisms": dict((_k, _v) for _k, _v in obj.get("mechanisms").items()),
+            "interactions": obj.get("interactions"),
+            "persons": FlattenedPersons.from_dict(obj["persons"]) if obj.get("persons") is not None else None,
+            "conversations": FlattenedConversations.from_dict(obj["conversations"]) if obj.get("conversations") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_assets import FlattenedAssets
-from pieces_os_client.models.flattened_conversations import FlattenedConversations
-from pieces_os_client.models.flattened_persons import FlattenedPersons
-
-# FlattenedWebsite.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/flattened_websites.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_websites.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,96 +14,99 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlattenedWebsites(BaseModel):
     """
-    This is a specific model for related websites to an asset.[DAG SAFE]  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ReferencedWebsite) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(
-        None,
-        description="This is a Map<String, int> where the the key is an website id.",
-    )
+    This is a specific model for related websites to an asset.[DAG SAFE]
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[ReferencedWebsite]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an website id.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlattenedWebsites:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlattenedWebsites from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["iterable"] = _items
+            _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
-            _dict["score"] = self.score.to_dict()
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlattenedWebsites:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlattenedWebsites from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlattenedWebsites.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlattenedWebsites.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "iterable": [
-                    ReferencedWebsite.from_dict(_item) for _item in obj.get("iterable")
-                ]
-                if obj.get("iterable") is not None
-                else None,
-                "indices": obj.get("indices"),
-                "score": Score.from_dict(obj.get("score"))
-                if obj.get("score") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ReferencedWebsite.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "indices": obj.get("indices"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.referenced_website import ReferencedWebsite
+# TODO: Rewrite to not use raise_errors
+FlattenedWebsites.model_rebuild(raise_errors=False)
 
-# FlattenedWebsites.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/font.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_pipeline_for_contextualized_code_generation.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,65 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Font(BaseModel):
-    """
-    This will describe the font that the user sees.  # noqa: E501
+class QGPTConversationPipelineForContextualizedCodeGeneration(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    size: StrictInt = Field(...)
-    __properties = ["schema", "size"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This type of conversation is reccomended to be provided when a user want generate code w/ context provided.  This is a class so that we can add optional properties in the future.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    __properties: ClassVar[List[str]] = ["schema"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Font:
-        """Create an instance of Font from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTConversationPipelineForContextualizedCodeGeneration from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Font:
-        """Create an instance of Font from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTConversationPipelineForContextualizedCodeGeneration from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Font.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Font.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "size": obj.get("size")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/format.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_format.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,204 +14,171 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.activities import Activities
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from pieces_os_client.models.application import Application
 from pieces_os_client.models.byte_descriptor import ByteDescriptor
 from pieces_os_client.models.classification import Classification
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.file_format import FileFormat
-from pieces_os_client.models.flattened_asset import FlattenedAsset
 from pieces_os_client.models.fragment_format import FragmentFormat
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.relationship import Relationship
 from pieces_os_client.models.role import Role
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class Format(BaseModel):
-    """
-    A representation of Data for a particular Form Factor of an Asset.  Below asset HAS to be Flattened because it is a leaf node and must prevent cycles agressively.  # noqa: E501
+class FlattenedFormat(BaseModel):
     """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    creator: StrictStr = Field(...)
-    classification: Classification = Field(...)
+    A representation of Data for a particular Form Factor of an Asset.[DAG Compatible - Directed Acyclic Graph Data Structure]  FlattenedFormats prevent Cycles in Reference because all outbound references are strings as opposed to crosspollinated objects.  i.e. FlattenedFormat.asset is Type String  fragment or file will always be defined. Even thought they are both optional.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    creator: StrictStr
+    classification: Classification
     icon: Optional[StrictStr] = None
-    role: Role = Field(...)
-    application: Application = Field(...)
-    asset: FlattenedAsset = Field(...)
-    bytes: ByteDescriptor = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    role: Role
+    application: Application
+    asset: Annotated[str, Field(min_length=36, strict=True, max_length=36)] = Field(description="A uuid model. 36 Characters (4 Dashes, 32 Numbers/Letters) ")
+    bytes: ByteDescriptor
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
     synced: Optional[GroupedTimestamp] = None
-    cloud: Optional[StrictStr] = Field(
-        None,
-        description="This is a path used to determine what path this format lives at within the cloud.",
-    )
+    cloud: Optional[StrictStr] = Field(default=None, description="This is a path used to determine what path this format lives at within the cloud.")
     fragment: Optional[FragmentFormat] = None
     file: Optional[FileFormat] = None
-    analysis: Optional[Analysis] = None
+    analysis: Optional[FlattenedAnalysis] = None
     relationship: Optional[Relationship] = None
-    activities: Optional[Activities] = None
-    __properties = [
-        "schema",
-        "id",
-        "creator",
-        "classification",
-        "icon",
-        "role",
-        "application",
-        "asset",
-        "bytes",
-        "created",
-        "updated",
-        "deleted",
-        "synced",
-        "cloud",
-        "fragment",
-        "file",
-        "analysis",
-        "relationship",
-        "activities",
-    ]
+    activities: Optional[FlattenedActivities] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "creator", "classification", "icon", "role", "application", "asset", "bytes", "created", "updated", "deleted", "synced", "cloud", "fragment", "file", "analysis", "relationship", "activities"]
 
-    class Config:
-        """Pydantic configuration"""
+    @field_validator('asset')
+    def asset_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if not re.match(r"[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}", value):
+            raise ValueError(r"must validate the regular expression /[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}/")
+        return value
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Format:
-        """Create an instance of Format from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedFormat from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of classification
         if self.classification:
-            _dict["classification"] = self.classification.to_dict()
+            _dict['classification'] = self.classification.to_dict()
         # override the default output from pydantic by calling `to_dict()` of application
         if self.application:
-            _dict["application"] = self.application.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of asset
-        if self.asset:
-            _dict["asset"] = self.asset.to_dict()
+            _dict['application'] = self.application.to_dict()
         # override the default output from pydantic by calling `to_dict()` of bytes
         if self.bytes:
-            _dict["bytes"] = self.bytes.to_dict()
+            _dict['bytes'] = self.bytes.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
-            _dict["created"] = self.created.to_dict()
+            _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
-            _dict["updated"] = self.updated.to_dict()
+            _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
+            _dict['deleted'] = self.deleted.to_dict()
         # override the default output from pydantic by calling `to_dict()` of synced
         if self.synced:
-            _dict["synced"] = self.synced.to_dict()
+            _dict['synced'] = self.synced.to_dict()
         # override the default output from pydantic by calling `to_dict()` of fragment
         if self.fragment:
-            _dict["fragment"] = self.fragment.to_dict()
+            _dict['fragment'] = self.fragment.to_dict()
         # override the default output from pydantic by calling `to_dict()` of file
         if self.file:
-            _dict["file"] = self.file.to_dict()
+            _dict['file'] = self.file.to_dict()
         # override the default output from pydantic by calling `to_dict()` of analysis
         if self.analysis:
-            _dict["analysis"] = self.analysis.to_dict()
+            _dict['analysis'] = self.analysis.to_dict()
         # override the default output from pydantic by calling `to_dict()` of relationship
         if self.relationship:
-            _dict["relationship"] = self.relationship.to_dict()
+            _dict['relationship'] = self.relationship.to_dict()
         # override the default output from pydantic by calling `to_dict()` of activities
         if self.activities:
-            _dict["activities"] = self.activities.to_dict()
+            _dict['activities'] = self.activities.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Format:
-        """Create an instance of Format from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedFormat from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Format.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Format.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "creator": obj.get("creator"),
-                "classification": Classification.from_dict(obj.get("classification"))
-                if obj.get("classification") is not None
-                else None,
-                "icon": obj.get("icon"),
-                "role": obj.get("role"),
-                "application": Application.from_dict(obj.get("application"))
-                if obj.get("application") is not None
-                else None,
-                "asset": FlattenedAsset.from_dict(obj.get("asset"))
-                if obj.get("asset") is not None
-                else None,
-                "bytes": ByteDescriptor.from_dict(obj.get("bytes"))
-                if obj.get("bytes") is not None
-                else None,
-                "created": GroupedTimestamp.from_dict(obj.get("created"))
-                if obj.get("created") is not None
-                else None,
-                "updated": GroupedTimestamp.from_dict(obj.get("updated"))
-                if obj.get("updated") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "synced": GroupedTimestamp.from_dict(obj.get("synced"))
-                if obj.get("synced") is not None
-                else None,
-                "cloud": obj.get("cloud"),
-                "fragment": FragmentFormat.from_dict(obj.get("fragment"))
-                if obj.get("fragment") is not None
-                else None,
-                "file": FileFormat.from_dict(obj.get("file"))
-                if obj.get("file") is not None
-                else None,
-                "analysis": Analysis.from_dict(obj.get("analysis"))
-                if obj.get("analysis") is not None
-                else None,
-                "relationship": Relationship.from_dict(obj.get("relationship"))
-                if obj.get("relationship") is not None
-                else None,
-                "activities": Activities.from_dict(obj.get("activities"))
-                if obj.get("activities") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "creator": obj.get("creator"),
+            "classification": Classification.from_dict(obj["classification"]) if obj.get("classification") is not None else None,
+            "icon": obj.get("icon"),
+            "role": obj.get("role"),
+            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "asset": obj.get("asset"),
+            "bytes": ByteDescriptor.from_dict(obj["bytes"]) if obj.get("bytes") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "synced": GroupedTimestamp.from_dict(obj["synced"]) if obj.get("synced") is not None else None,
+            "cloud": obj.get("cloud"),
+            "fragment": FragmentFormat.from_dict(obj["fragment"]) if obj.get("fragment") is not None else None,
+            "file": FileFormat.from_dict(obj["file"]) if obj.get("file") is not None else None,
+            "analysis": FlattenedAnalysis.from_dict(obj["analysis"]) if obj.get("analysis") is not None else None,
+            "relationship": Relationship.from_dict(obj["relationship"]) if obj.get("relationship") is not None else None,
+            "activities": FlattenedActivities.from_dict(obj["activities"]) if obj.get("activities") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.flattened_activities import FlattenedActivities
+from pieces_os_client.models.flattened_analysis import FlattenedAnalysis
+# TODO: Rewrite to not use raise_errors
+FlattenedFormat.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.analysis import Analysis
-
-# Format.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/format_metric.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/reuse_reaction.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,71 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from pieces_os_client.models.classification_generic_enum import ClassificationGenericEnum
-from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FormatMetric(BaseModel):
-    """
-    FormatMetric  This is a model that will represent the about of specific formats. ie Generic: 'CODE' specific: 'DART' identifiers: ['FormatUID1, 'FormatUID2']  # noqa: E501
+class ReuseReaction(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    generic: ClassificationGenericEnum = Field(...)
-    specific: ClassificationSpecificEnum = Field(...)
-    identifiers: conlist(StrictStr) = Field(..., description="this is a list of format ids")
-    __properties = ["schema", "generic", "specific", "identifiers"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    if reuse was used in the reaction then we can provide the uuid of the asset that was reused.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    asset: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "asset"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FormatMetric:
-        """Create an instance of FormatMetric from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReuseReaction from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FormatMetric:
-        """Create an instance of FormatMetric from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReuseReaction from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FormatMetric.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FormatMetric.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "generic": obj.get("generic"),
-            "specific": obj.get("specific"),
-            "identifiers": obj.get("identifiers")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "asset": obj.get("asset")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/format_reclassification.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_format_event_metadata.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,72 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.tracked_asset_event_format_reclassification_metadata import TrackedAssetEventFormatReclassificationMetadata
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field
-from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.format import Format
-
-class FormatReclassification(BaseModel):
-    """
-    This is a model that will represent the miminum properties required to update the classification of this format.  # noqa: E501
+class TrackedFormatEventMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    ext: ClassificationSpecificEnum = Field(...)
-    format: Format = Field(...)
-    __properties = ["schema", "ext", "format"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TrackedFormatEventMetadata
+    """ # noqa: E501
+    reclassification: Optional[TrackedAssetEventFormatReclassificationMetadata] = None
+    __properties: ClassVar[List[str]] = ["reclassification"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FormatReclassification:
-        """Create an instance of FormatReclassification from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedFormatEventMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of format
-        if self.format:
-            _dict['format'] = self.format.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of reclassification
+        if self.reclassification:
+            _dict['reclassification'] = self.reclassification.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FormatReclassification:
-        """Create an instance of FormatReclassification from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedFormatEventMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FormatReclassification.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FormatReclassification.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "ext": obj.get("ext"),
-            "format": Format.from_dict(obj.get("format")) if obj.get("format") is not None else None
+        _obj = cls.model_validate({
+            "reclassification": TrackedAssetEventFormatReclassificationMetadata.from_dict(obj["reclassification"]) if obj.get("reclassification") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/formats.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/resulted_pkce.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.format import Format
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Formats(BaseModel):
-    """
-    A base class for a collection of formats and some additional meta properties.  # noqa: E501
+class ResultedPKCE(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Format) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A Model To Represent the Code Returned from a PKCE Response
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    code: StrictStr = Field(description="The PKCE Code to be used to access a Token.")
+    state: StrictStr = Field(description="Likely the state that will be returned which should match the requested state as well as the nonce")
+    __properties: ClassVar[List[str]] = ["schema", "code", "state"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Formats:
-        """Create an instance of Formats from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ResultedPKCE from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Formats:
-        """Create an instance of Formats from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ResultedPKCE from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Formats.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Formats.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Format.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "code": obj.get("code"),
+            "state": obj.get("state")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/formats_metrics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/edges.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List
+from pieces_os_client.models.node import Node
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.format_metric import FormatMetric
-
-class FormatsMetrics(BaseModel):
-    """
-      # noqa: E501
+class Edges(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(FormatMetric) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Edges
+    """ # noqa: E501
+    iterable: List[Node]
+    __properties: ClassVar[List[str]] = ["iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FormatsMetrics:
-        """Create an instance of FormatsMetrics from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Edges from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FormatsMetrics:
-        """Create an instance of FormatsMetrics from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Edges from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FormatsMetrics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FormatsMetrics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [FormatMetric.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "iterable": [Node.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/fragment_format.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/fragment_format.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,56 +14,72 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.fragment_metadata import FragmentMetadata
 from pieces_os_client.models.transferable_bytes import TransferableBytes
 from pieces_os_client.models.transferable_string import TransferableString
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FragmentFormat(BaseModel):
     """
-    This will be either a TransferableString or TransferableBytes that represent your fragment. ONLY Pass one or the other DONT pass both or neither.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This will be either a TransferableString or TransferableBytes that represent your fragment. ONLY Pass one or the other DONT pass both or neither.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     string: Optional[TransferableString] = None
     bytes: Optional[TransferableBytes] = None
     metadata: Optional[FragmentMetadata] = None
-    __properties = ["schema", "string", "bytes", "metadata"]
+    __properties: ClassVar[List[str]] = ["schema", "string", "bytes", "metadata"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FragmentFormat:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FragmentFormat from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of string
         if self.string:
             _dict['string'] = self.string.to_dict()
         # override the default output from pydantic by calling `to_dict()` of bytes
@@ -71,24 +87,24 @@
             _dict['bytes'] = self.bytes.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
             _dict['metadata'] = self.metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FragmentFormat:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FragmentFormat from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FragmentFormat.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FragmentFormat.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "string": TransferableString.from_dict(obj.get("string")) if obj.get("string") is not None else None,
-            "bytes": TransferableBytes.from_dict(obj.get("bytes")) if obj.get("bytes") is not None else None,
-            "metadata": FragmentMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "string": TransferableString.from_dict(obj["string"]) if obj.get("string") is not None else None,
+            "bytes": TransferableBytes.from_dict(obj["bytes"]) if obj.get("bytes") is not None else None,
+            "metadata": FragmentMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/fragment_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_suggested_reuse.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,66 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
-from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FragmentMetadata(BaseModel):
-    """
-    This is a model for metadata of a file!  # noqa: E501
+class TLPCodeFragmentSuggestedReuse(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    ext: Optional[ClassificationSpecificEnum] = None
-    __properties = ["schema", "ext"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TLPCodeFragmentSuggestedReuse
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FragmentMetadata:
-        """Create an instance of FragmentMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPCodeFragmentSuggestedReuse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FragmentMetadata:
-        """Create an instance of FragmentMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPCodeFragmentSuggestedReuse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FragmentMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FragmentMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "ext": obj.get("ext")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/git_hub_distribution.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/revoked_pkce.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,69 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.git_hub_gist_distribution import GitHubGistDistribution
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GitHubDistribution(BaseModel):
-    """
-    GitHubDistribution
+class RevokedPKCE(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    gist: Optional[GitHubGistDistribution] = None
-    __properties = ["schema", "gist"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A model to support revoking a Token Generated Through PKCE  The behaviour of this endpoint depends on the state of the Refresh Token Revocation Deletes Grant toggle.  If this toggle is enabled, then each revocation request invalidates not only the specific token, but all other tokens based on the same authorization grant.  This means that all Refresh Tokens that have been issued for the same user, application, and audience will be revoked. If this toggle is disabled, then only the refresh token is revoked, while the grant is left intact
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    client_id: StrictStr = Field(description="Your application's Client ID. The application should match the one the Refresh Token was issued for.")
+    token: StrictStr = Field(description="The Refresh Token you want to revoke.")
+    __properties: ClassVar[List[str]] = ["schema", "client_id", "token"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GitHubDistribution:
-        """Create an instance of GitHubDistribution from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of RevokedPKCE from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of gist
-        if self.gist:
-            _dict['gist'] = self.gist.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GitHubDistribution:
-        """Create an instance of GitHubDistribution from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of RevokedPKCE from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GitHubDistribution.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GitHubDistribution.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "gist": GitHubGistDistribution.from_dict(obj.get("gist")) if obj.get("gist") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "client_id": obj.get("client_id"),
+            "token": obj.get("token")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/git_hub_gist_distribution.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/git_hub_gist_distribution.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,61 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.recipients import Recipients
+from typing import Optional, Set
+from typing_extensions import Self
 
 class GitHubGistDistribution(BaseModel):
     """
-    This is a published Github Gist.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    recipients: Recipients = Field(...)
-    public: StrictBool = Field(..., description="This will let us know if the gist is public or private.")
-    description: Optional[StrictStr] = Field(None, description="This is the description of the Gist Distribution")
-    name: StrictStr = Field(..., description="This is the name of the gist you will add.")
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    This is a published Github Gist.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    recipients: Recipients
+    public: StrictBool = Field(description="This will let us know if the gist is public or private.")
+    description: Optional[StrictStr] = Field(default=None, description="This is the description of the Gist Distribution")
+    name: StrictStr = Field(description="This is the name of the gist you will add.")
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    github_id: StrictStr = Field(..., description="This is the id that github uses to represent the gist.")
-    url: StrictStr = Field(..., description="This is the url where the gist is.")
-    __properties = ["schema", "recipients", "public", "description", "name", "created", "updated", "deleted", "github_id", "url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    github_id: StrictStr = Field(description="This is the id that github uses to represent the gist.")
+    url: StrictStr = Field(description="This is the url where the gist is.")
+    __properties: ClassVar[List[str]] = ["schema", "recipients", "public", "description", "name", "created", "updated", "deleted", "github_id", "url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GitHubGistDistribution:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of GitHubGistDistribution from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of recipients
         if self.recipients:
             _dict['recipients'] = self.recipients.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
@@ -79,30 +95,30 @@
             _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
             _dict['deleted'] = self.deleted.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GitHubGistDistribution:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of GitHubGistDistribution from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GitHubGistDistribution.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GitHubGistDistribution.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "recipients": Recipients.from_dict(obj.get("recipients")) if obj.get("recipients") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "recipients": Recipients.from_dict(obj["recipients"]) if obj.get("recipients") is not None else None,
             "public": obj.get("public"),
             "description": obj.get("description"),
             "name": obj.get("name"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
             "github_id": obj.get("github_id"),
             "url": obj.get("url")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_image_descriptive_statistics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_svg_statistics.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,77 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GraphicalImageDescriptiveStatistics(BaseModel):
-    """
-    Model for collecting descriptive statistics of images uploaded to Pieces  # noqa: E501
+class GraphicalSVGStatistics(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    width: StrictStr = Field(...)
-    height: StrictStr = Field(...)
-    channels: StrictStr = Field(...)
-    asset: StrictStr = Field(...)
-    user: Optional[StrictStr] = None
-    created: StrictStr = Field(...)
-    os: StrictStr = Field(...)
-    __properties = ["schema", "width", "height", "channels", "asset", "user", "created", "os"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GraphicalSVGStatistics
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GraphicalImageDescriptiveStatistics:
-        """Create an instance of GraphicalImageDescriptiveStatistics from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GraphicalSVGStatistics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GraphicalImageDescriptiveStatistics:
-        """Create an instance of GraphicalImageDescriptiveStatistics from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GraphicalSVGStatistics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GraphicalImageDescriptiveStatistics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GraphicalImageDescriptiveStatistics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "width": obj.get("width"),
-            "height": obj.get("height"),
-            "channels": obj.get("channels"),
-            "asset": obj.get("asset"),
-            "user": obj.get("user"),
-            "created": obj.get("created"),
-            "os": obj.get("os")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_image_processing.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/sensitive_metadata.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,69 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictFloat, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.graphical_image_statistics import GraphicalImageStatistics
+from pieces_os_client.models.text_match import TextMatch
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GraphicalImageProcessing(BaseModel):
-    """
-    GraphicalImageProcessing
+class SensitiveMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    statistics: Optional[GraphicalImageStatistics] = None
-    __properties = ["schema", "statistics"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is optional metatdata attached to a sensitive piece of data.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    match: Optional[TextMatch] = None
+    entropy: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="entropy of the sensitive")
+    __properties: ClassVar[List[str]] = ["schema", "match", "entropy"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GraphicalImageProcessing:
-        """Create an instance of GraphicalImageProcessing from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SensitiveMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of statistics
-        if self.statistics:
-            _dict['statistics'] = self.statistics.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of match
+        if self.match:
+            _dict['match'] = self.match.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GraphicalImageProcessing:
-        """Create an instance of GraphicalImageProcessing from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SensitiveMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GraphicalImageProcessing.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GraphicalImageProcessing.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "statistics": GraphicalImageStatistics.from_dict(obj.get("statistics")) if obj.get("statistics") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "match": TextMatch.from_dict(obj["match"]) if obj.get("match") is not None else None,
+            "entropy": obj.get("entropy")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_image_statistics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_image_statistics.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.graphical_image_descriptive_statistics import GraphicalImageDescriptiveStatistics
+from typing import Optional, Set
+from typing_extensions import Self
 
 class GraphicalImageStatistics(BaseModel):
     """
     GraphicalImageStatistics
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     descriptive: Optional[GraphicalImageDescriptiveStatistics] = None
-    __properties = ["schema", "descriptive"]
+    __properties: ClassVar[List[str]] = ["schema", "descriptive"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GraphicalImageStatistics:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of GraphicalImageStatistics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of descriptive
         if self.descriptive:
             _dict['descriptive'] = self.descriptive.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GraphicalImageStatistics:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of GraphicalImageStatistics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GraphicalImageStatistics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GraphicalImageStatistics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "descriptive": GraphicalImageDescriptiveStatistics.from_dict(obj.get("descriptive")) if obj.get("descriptive") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "descriptive": GraphicalImageDescriptiveStatistics.from_dict(obj["descriptive"]) if obj.get("descriptive") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_machine_learning_processing_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_ocr_processing.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,81 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.graphical_image_processing import GraphicalImageProcessing
-from pieces_os_client.models.graphical_ocr_processing import GraphicalOCRProcessing
-from pieces_os_client.models.graphical_svg_statistics import GraphicalSVGStatistics
+from pieces_os_client.models.graphical_ocr_statistics import GraphicalOCRStatistics
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GraphicalMachineLearningProcessingEvent(BaseModel):
-    """
-    GraphicalMachineLearningProcessingEvent
+class GraphicalOCRProcessing(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    ocr: Optional[GraphicalOCRProcessing] = None
-    image: Optional[GraphicalImageProcessing] = None
-    svg: Optional[GraphicalSVGStatistics] = None
-    __properties = ["schema", "ocr", "image", "svg"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GraphicalOCRProcessing
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    statistics: Optional[GraphicalOCRStatistics] = None
+    __properties: ClassVar[List[str]] = ["schema", "statistics"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GraphicalMachineLearningProcessingEvent:
-        """Create an instance of GraphicalMachineLearningProcessingEvent from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GraphicalOCRProcessing from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of ocr
-        if self.ocr:
-            _dict['ocr'] = self.ocr.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of image
-        if self.image:
-            _dict['image'] = self.image.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of svg
-        if self.svg:
-            _dict['svg'] = self.svg.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of statistics
+        if self.statistics:
+            _dict['statistics'] = self.statistics.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GraphicalMachineLearningProcessingEvent:
-        """Create an instance of GraphicalMachineLearningProcessingEvent from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GraphicalOCRProcessing from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GraphicalMachineLearningProcessingEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GraphicalMachineLearningProcessingEvent.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "ocr": GraphicalOCRProcessing.from_dict(obj.get("ocr")) if obj.get("ocr") is not None else None,
-            "image": GraphicalImageProcessing.from_dict(obj.get("image")) if obj.get("image") is not None else None,
-            "svg": GraphicalSVGStatistics.from_dict(obj.get("svg")) if obj.get("svg") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "statistics": GraphicalOCRStatistics.from_dict(obj["statistics"]) if obj.get("statistics") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_ocr_descriptive_statistics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_ocr_statistics.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,81 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.graphical_ocr_descriptive_statistics_confidence import GraphicalOCRDescriptiveStatisticsConfidence
+from pieces_os_client.models.graphical_ocr_descriptive_statistics import GraphicalOCRDescriptiveStatistics
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GraphicalOCRDescriptiveStatistics(BaseModel):
-    """
-    Model for monitoring and evaluating the OCR feature  # noqa: E501
+class GraphicalOCRStatistics(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: StrictStr = Field(...)
-    user: StrictStr = Field(...)
-    model: StrictStr = Field(...)
-    created: StrictStr = Field(...)
-    os: StrictStr = Field(...)
-    confidence: GraphicalOCRDescriptiveStatisticsConfidence = Field(...)
-    duration: StrictStr = Field(...)
-    __properties = ["schema", "asset", "user", "model", "created", "os", "confidence", "duration"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GraphicalOCRStatistics
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    descriptive: Optional[GraphicalOCRDescriptiveStatistics] = None
+    __properties: ClassVar[List[str]] = ["schema", "descriptive"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GraphicalOCRDescriptiveStatistics:
-        """Create an instance of GraphicalOCRDescriptiveStatistics from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GraphicalOCRStatistics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of confidence
-        if self.confidence:
-            _dict['confidence'] = self.confidence.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of descriptive
+        if self.descriptive:
+            _dict['descriptive'] = self.descriptive.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GraphicalOCRDescriptiveStatistics:
-        """Create an instance of GraphicalOCRDescriptiveStatistics from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GraphicalOCRStatistics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GraphicalOCRDescriptiveStatistics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GraphicalOCRDescriptiveStatistics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "asset": obj.get("asset"),
-            "user": obj.get("user"),
-            "model": obj.get("model"),
-            "created": obj.get("created"),
-            "os": obj.get("os"),
-            "confidence": GraphicalOCRDescriptiveStatisticsConfidence.from_dict(obj.get("confidence")) if obj.get("confidence") is not None else None,
-            "duration": obj.get("duration")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "descriptive": GraphicalOCRDescriptiveStatistics.from_dict(obj["descriptive"]) if obj.get("descriptive") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_ocr_processing.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_tagify.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.graphical_ocr_statistics import GraphicalOCRStatistics
+from pieces_os_client.models.tlp_code_snippet_tagify_code import TLPCodeSnippetTagifyCode
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GraphicalOCRProcessing(BaseModel):
-    """
-    GraphicalOCRProcessing
+class TLPCodeFragmentTagify(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    statistics: Optional[GraphicalOCRStatistics] = None
-    __properties = ["schema", "statistics"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TLPCodeFragmentTagify
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    code: Optional[TLPCodeSnippetTagifyCode] = None
+    __properties: ClassVar[List[str]] = ["schema", "code"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GraphicalOCRProcessing:
-        """Create an instance of GraphicalOCRProcessing from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPCodeFragmentTagify from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of statistics
-        if self.statistics:
-            _dict['statistics'] = self.statistics.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of code
+        if self.code:
+            _dict['code'] = self.code.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GraphicalOCRProcessing:
-        """Create an instance of GraphicalOCRProcessing from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPCodeFragmentTagify from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GraphicalOCRProcessing.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GraphicalOCRProcessing.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "statistics": GraphicalOCRStatistics.from_dict(obj.get("statistics")) if obj.get("statistics") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "code": TLPCodeSnippetTagifyCode.from_dict(obj["code"]) if obj.get("code") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_ocr_statistics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_statistics.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.graphical_ocr_descriptive_statistics import GraphicalOCRDescriptiveStatistics
+from pieces_os_client.models.tlp_code_fragment_descriptive_statistics import TLPCodeFragmentDescriptiveStatistics
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GraphicalOCRStatistics(BaseModel):
-    """
-    GraphicalOCRStatistics
+class TLPCodeFragmentStatistics(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    descriptive: Optional[GraphicalOCRDescriptiveStatistics] = None
-    __properties = ["schema", "descriptive"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TLPCodeFragmentStatistics
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    descriptive: Optional[TLPCodeFragmentDescriptiveStatistics] = None
+    __properties: ClassVar[List[str]] = ["schema", "descriptive"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GraphicalOCRStatistics:
-        """Create an instance of GraphicalOCRStatistics from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPCodeFragmentStatistics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of descriptive
         if self.descriptive:
             _dict['descriptive'] = self.descriptive.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GraphicalOCRStatistics:
-        """Create an instance of GraphicalOCRStatistics from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPCodeFragmentStatistics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GraphicalOCRStatistics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GraphicalOCRStatistics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "descriptive": GraphicalOCRDescriptiveStatistics.from_dict(obj.get("descriptive")) if obj.get("descriptive") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "descriptive": TLPCodeFragmentDescriptiveStatistics.from_dict(obj["descriptive"]) if obj.get("descriptive") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/graphical_svg_statistics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/existent_metadata.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,65 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GraphicalSVGStatistics(BaseModel):
-    """
-    GraphicalSVGStatistics
+class ExistentMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: Optional[StrictStr] = None
-    __properties = ["schema", "id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a shared output model for all the exists endpoints: /tags/exists : value here is the tag that you want to see if it exists. /websites/exists: value here is the url you want to see if it exists
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    value: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "value"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GraphicalSVGStatistics:
-        """Create an instance of GraphicalSVGStatistics from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ExistentMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GraphicalSVGStatistics:
-        """Create an instance of GraphicalSVGStatistics from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ExistentMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GraphicalSVGStatistics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GraphicalSVGStatistics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "value": obj.get("value")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/grouped_timestamp.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/health.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,67 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.os_health import OSHealth
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GroupedTimestamp(BaseModel):
+class Health(BaseModel):
     """
-    A helper classs to wrap Date-Time Values with Useful Helper Properties  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    value: datetime = Field(...)
-    readable: Optional[StrictStr] = None
-    __properties = ["schema", "value", "readable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a health model used to determine the \"health\" of the os server and cloud server(Coming Soon). READONLY Model.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    os: OSHealth
+    __properties: ClassVar[List[str]] = ["schema", "os"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GroupedTimestamp:
-        """Create an instance of GroupedTimestamp from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Health from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of os
+        if self.os:
+            _dict['os'] = self.os.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GroupedTimestamp:
-        """Create an instance of GroupedTimestamp from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Health from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GroupedTimestamp.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GroupedTimestamp.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "value": obj.get("value"),
-            "readable": obj.get("readable")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "os": OSHealth.from_dict(obj["os"]) if obj.get("os") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/health.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/open_ai_models_list_output.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.os_health import OSHealth
+from pieces_os_client.models.seeded_models import SeededModels
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Health(BaseModel):
-    """
-    This is a health model used to determine the \"health\" of the os server and cloud server(Coming Soon). READONLY Model.  # noqa: E501
+class OpenAIModelsListOutput(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    os: OSHealth = Field(...)
-    __properties = ["schema", "os"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the output model for the /open_ai/models/list endpoint.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    models: SeededModels
+    __properties: ClassVar[List[str]] = ["schema", "models"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Health:
-        """Create an instance of Health from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OpenAIModelsListOutput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of os
-        if self.os:
-            _dict['os'] = self.os.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of models
+        if self.models:
+            _dict['models'] = self.models.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Health:
-        """Create an instance of Health from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OpenAIModelsListOutput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Health.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Health.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "os": OSHealth.from_dict(obj.get("os")) if obj.get("os") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "models": SeededModels.from_dict(obj["models"]) if obj.get("models") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/hint.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_anchor_point.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,107 +14,118 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
-from pieces_os_client.models.hint_type_enum import HintTypeEnum
-from pieces_os_client.models.mechanism_enum import MechanismEnum
-from pieces_os_client.models.referenced_asset import ReferencedAsset
-from pieces_os_client.models.referenced_model import ReferencedModel
+from pieces_os_client.models.platform_enum import PlatformEnum
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Hint(BaseModel):
-    """
-    This is a hint that is attached to an asset, used for suggested_queries, and hints given via the qgpt flow.  # noqa: E501
+class FlattenedAnchorPoint(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    FlattenedAnchorPoint
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    verified: Optional[StrictBool] = None
+    fullpath: StrictStr = Field(description="This is the text of the path.")
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    mechanism: Optional[MechanismEnum] = None
-    asset: Optional[ReferencedAsset] = None
-    type: HintTypeEnum = Field(...)
-    text: StrictStr = Field(..., description="This is the text of the hint.")
-    model: Optional[ReferencedModel] = None
+    platform: Optional[PlatformEnum] = None
+    anchor: ReferencedAnchor
     score: Optional[Score] = None
-    __properties = ["schema", "id", "created", "updated", "deleted", "mechanism", "asset", "type", "text", "model", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "verified", "fullpath", "created", "updated", "deleted", "platform", "anchor", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Hint:
-        """Create an instance of Hint from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedAnchorPoint from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
             _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
             _dict['deleted'] = self.deleted.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of asset
-        if self.asset:
-            _dict['asset'] = self.asset.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of model
-        if self.model:
-            _dict['model'] = self.model.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of anchor
+        if self.anchor:
+            _dict['anchor'] = self.anchor.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Hint:
-        """Create an instance of Hint from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedAnchorPoint from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Hint.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Hint.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
-            "mechanism": obj.get("mechanism"),
-            "asset": ReferencedAsset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "type": obj.get("type"),
-            "text": obj.get("text"),
-            "model": ReferencedModel.from_dict(obj.get("model")) if obj.get("model") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "verified": obj.get("verified"),
+            "fullpath": obj.get("fullpath"),
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "platform": obj.get("platform"),
+            "anchor": ReferencedAnchor.from_dict(obj["anchor"]) if obj.get("anchor") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.referenced_anchor import ReferencedAnchor
+# TODO: Rewrite to not use raise_errors
+FlattenedAnchorPoint.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/hint_type_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_type_enum.py`

 * *Files 17% similar despite different names*

```diff
@@ -9,33 +9,31 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class HintTypeEnum(str, Enum):
+class ModelTypeEnum(str, Enum):
     """
-    This is the hint enum used to describe a type of hint.
+    This will describe the type of Model balanced, speed, accuracy...
     """
 
     """
     allowed enum values
     """
-    SUGGESTED_QUERY = 'SUGGESTED_QUERY'
-    QGPT_HINT = 'QGPT_HINT'
+    BALANCED = 'BALANCED'
+    SPEED = 'SPEED'
+    ACCURACY = 'ACCURACY'
 
     @classmethod
-    def from_json(cls, json_str: str) -> HintTypeEnum:
-        """Create an instance of HintTypeEnum from a JSON string"""
-        return HintTypeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ModelTypeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/hints.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/sensitives.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,55 +14,70 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.hint import Hint
 from pieces_os_client.models.score import Score
+from pieces_os_client.models.sensitive import Sensitive
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Hints(BaseModel):
-    """
-    This is the plural of a Hint.  # noqa: E501
+class Sensitives(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Hint) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(None, description="This is a Map<String, int> where the the key is an hint id.")
+    This is a model that represents many individual sensitive pieces of data.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Sensitive]
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Hints:
-        """Create an instance of Hints from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Sensitives from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
@@ -71,24 +86,23 @@
             _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Hints:
-        """Create an instance of Hints from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Sensitives from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Hints.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Hints.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Hint.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "indices": obj.get("indices"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Sensitive.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/image_analyses.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/image_analyses.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.image_analysis import ImageAnalysis
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ImageAnalyses(BaseModel):
     """
     ImageAnalyses
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(ImageAnalysis) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[ImageAnalysis]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ImageAnalyses:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ImageAnalyses from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ImageAnalyses:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ImageAnalyses from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ImageAnalyses.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ImageAnalyses.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [ImageAnalysis.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ImageAnalysis.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/image_analysis.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/returned_user_profile.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,83 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.user_profile import UserProfile
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ImageAnalysis(BaseModel):
-    """
-    This is a model that represents all the information collected during the processing of an image.  # noqa: E501
+class ReturnedUserProfile(BaseModel):
     """
+    This is a modle strictly for the purpose that when calling '/user' and other user related endpoints the UserProfile could potentially be null, so we needed a model to do that.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    user: Optional[UserProfile] = None
+    __properties: ClassVar[List[str]] = ["schema", "user"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(
-        ..., description="this is a uuid that represents a imageAnalysis."
-    )
-    analysis: StrictStr = Field(..., description="this is a reference to the analysis.")
-    ocr: Optional[OCRAnalysis] = None
-    __properties = ["schema", "id", "analysis", "ocr"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ImageAnalysis:
-        """Create an instance of ImageAnalysis from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReturnedUserProfile from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of ocr
-        if self.ocr:
-            _dict["ocr"] = self.ocr.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of user
+        if self.user:
+            _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ImageAnalysis:
-        """Create an instance of ImageAnalysis from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReturnedUserProfile from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ImageAnalysis.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ImageAnalysis.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "analysis": obj.get("analysis"),
-                "ocr": OCRAnalysis.from_dict(obj.get("ocr"))
-                if obj.get("ocr") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "user": UserProfile.from_dict(obj["user"]) if obj.get("user") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.ocr_analysis import OCRAnalysis
-
-# ImageAnalysis.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/interacted_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_connector_creation.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,75 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.seeded_connector_asset import SeededConnectorAsset
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, constr, validator
-from pieces_os_client.models.interacted_asset_interactions import InteractedAssetInteractions
-
-class InteractedAsset(BaseModel):
-    """
-    A model that represents an asset that has been interacted with.   # noqa: E501
+class SeededConnectorCreation(BaseModel):
     """
-    asset: Optional[constr(strict=True, max_length=36, min_length=36)] = Field(None, description="A uuid model. 36 Characters (4 Dashes, 32 Numbers/Letters) ")
-    interactions: Optional[InteractedAssetInteractions] = None
-    __properties = ["asset", "interactions"]
-
-    @validator('asset')
-    def asset_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if value is None:
-            return value
-
-        if not re.match(r"[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}", value):
-            raise ValueError(r"must validate the regular expression /[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A encompasing creation object that can be utilized to create either an asset or a format.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    asset: Optional[SeededConnectorAsset] = None
+    __properties: ClassVar[List[str]] = ["schema", "asset"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> InteractedAsset:
-        """Create an instance of InteractedAsset from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededConnectorCreation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of interactions
-        if self.interactions:
-            _dict['interactions'] = self.interactions.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of asset
+        if self.asset:
+            _dict['asset'] = self.asset.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> InteractedAsset:
-        """Create an instance of InteractedAsset from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededConnectorCreation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return InteractedAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = InteractedAsset.parse_obj({
-            "asset": obj.get("asset"),
-            "interactions": InteractedAssetInteractions.from_dict(obj.get("interactions")) if obj.get("interactions") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "asset": SeededConnectorAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/interacted_asset_interactions.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/interacted_asset_interactions.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,70 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, constr, validator
+from pydantic import BaseModel, Field, StrictBool, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class InteractedAssetInteractions(BaseModel):
     """
     InteractedAssetInteractions
-    """
-    viewed: constr(strict=True) = Field(..., description="https://en.wikipedia.org/wiki/ISO_8601#Time_intervals")
-    touched: Optional[StrictBool] = Field(False, description="If the user touched or panned over the asset.")
-    scrolled: Optional[StrictBool] = Field(False, description="If the user scrolled over the asset.")
-    __properties = ["viewed", "touched", "scrolled"]
+    """ # noqa: E501
+    viewed: Annotated[str, Field(strict=True)] = Field(description="https://en.wikipedia.org/wiki/ISO_8601#Time_intervals")
+    touched: Optional[StrictBool] = Field(default=False, description="If the user touched or panned over the asset.")
+    scrolled: Optional[StrictBool] = Field(default=False, description="If the user scrolled over the asset.")
+    __properties: ClassVar[List[str]] = ["viewed", "touched", "scrolled"]
 
-    @validator('viewed')
+    @field_validator('viewed')
     def viewed_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"P[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]", value):
             raise ValueError(r"must validate the regular expression /P[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> InteractedAssetInteractions:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of InteractedAssetInteractions from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> InteractedAssetInteractions:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of InteractedAssetInteractions from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return InteractedAssetInteractions.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = InteractedAssetInteractions.parse_obj({
+        _obj = cls.model_validate({
             "viewed": obj.get("viewed"),
             "touched": obj.get("touched") if obj.get("touched") is not None else False,
             "scrolled": obj.get("scrolled") if obj.get("scrolled") is not None else False
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/interacted_assets.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_cpu_hardware_information.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.interacted_asset import InteractedAsset
+from typing import Optional, Set
+from typing_extensions import Self
 
-class InteractedAssets(BaseModel):
-    """
-    A model which contains a list of InteractedAssets with potentially additional properties.  # noqa: E501
+class OSDeviceCPUHardwareInformation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(InteractedAsset) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will let us know specific hardware information related to the CPU.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    name: Optional[StrictStr] = None
+    memory: Optional[Union[StrictFloat, StrictInt]] = None
+    __properties: ClassVar[List[str]] = ["schema", "name", "memory"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> InteractedAssets:
-        """Create an instance of InteractedAssets from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OSDeviceCPUHardwareInformation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> InteractedAssets:
-        """Create an instance of InteractedAssets from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OSDeviceCPUHardwareInformation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return InteractedAssets.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = InteractedAssets.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [InteractedAsset.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "name": obj.get("name"),
+            "memory": obj.get("memory")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/linkify.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/linkify.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,60 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.access_enum import AccessEnum
 from pieces_os_client.models.asset import Asset
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.seed import Seed
 from pieces_os_client.models.seeded_distributions import SeededDistributions
 from pieces_os_client.models.seeded_user import SeededUser
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Linkify(BaseModel):
     """
-    This is the incoming linkify model.  if access is PRIVATE then please provide and array of users to enable the link for.   # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is the incoming linkify model.  if access is PRIVATE then please provide and array of users to enable the link for. 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     seed: Optional[Seed] = None
     asset: Optional[Asset] = None
-    users: Optional[conlist(SeededUser)] = Field(None, description="this is an array of users.")
-    access: AccessEnum = Field(...)
+    users: Optional[List[SeededUser]] = Field(default=None, description="this is an array of users.")
+    access: AccessEnum
     distributions: Optional[SeededDistributions] = None
-    __properties = ["schema", "seed", "asset", "users", "access", "distributions"]
+    __properties: ClassVar[List[str]] = ["schema", "seed", "asset", "users", "access", "distributions"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Linkify:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Linkify from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of seed
         if self.seed:
             _dict['seed'] = self.seed.to_dict()
         # override the default output from pydantic by calling `to_dict()` of asset
@@ -82,26 +98,26 @@
             _dict['users'] = _items
         # override the default output from pydantic by calling `to_dict()` of distributions
         if self.distributions:
             _dict['distributions'] = self.distributions.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Linkify:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Linkify from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Linkify.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Linkify.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "seed": Seed.from_dict(obj.get("seed")) if obj.get("seed") is not None else None,
-            "asset": Asset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "users": [SeededUser.from_dict(_item) for _item in obj.get("users")] if obj.get("users") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "seed": Seed.from_dict(obj["seed"]) if obj.get("seed") is not None else None,
+            "asset": Asset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "users": [SeededUser.from_dict(_item) for _item in obj["users"]] if obj.get("users") is not None else None,
             "access": obj.get("access"),
-            "distributions": SeededDistributions.from_dict(obj.get("distributions")) if obj.get("distributions") is not None else None
+            "distributions": SeededDistributions.from_dict(obj["distributions"]) if obj.get("distributions") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/linkify_multiple.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/linkify_multiple.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,80 +14,96 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.access_enum import AccessEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.seeded_user import SeededUser
+from typing import Optional, Set
+from typing_extensions import Self
 
 class LinkifyMultiple(BaseModel):
     """
-    This is the incoming linkify model.  if access is PRIVATE then please provide and array of users to enable the link for.  Assumption, all assets are already backed up to the cloud.   # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    assets: conlist(StrictStr) = Field(..., description="This is an array or string that represents an already backed up asset. That will be added to a collection.")
-    users: Optional[conlist(SeededUser)] = Field(None, description="this is an array of users.")
-    access: AccessEnum = Field(...)
-    name: Optional[StrictStr] = Field(None, description="optionally can give the collection a name if you want.")
-    __properties = ["schema", "assets", "users", "access", "name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the incoming linkify model.  if access is PRIVATE then please provide and array of users to enable the link for.  Assumption, all assets are already backed up to the cloud. 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    assets: List[StrictStr] = Field(description="This is an array or string that represents an already backed up asset. That will be added to a collection.")
+    users: Optional[List[SeededUser]] = Field(default=None, description="this is an array of users.")
+    access: AccessEnum
+    name: Optional[StrictStr] = Field(default=None, description="optionally can give the collection a name if you want.")
+    __properties: ClassVar[List[str]] = ["schema", "assets", "users", "access", "name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LinkifyMultiple:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of LinkifyMultiple from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in users (list)
         _items = []
         if self.users:
             for _item in self.users:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['users'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LinkifyMultiple:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of LinkifyMultiple from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LinkifyMultiple.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LinkifyMultiple.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "assets": obj.get("assets"),
-            "users": [SeededUser.from_dict(_item) for _item in obj.get("users")] if obj.get("users") is not None else None,
+            "users": [SeededUser.from_dict(_item) for _item in obj["users"]] if obj.get("users") is not None else None,
             "access": obj.get("access"),
             "name": obj.get("name")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/mailgun_distribution.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/assets_search_with_filters_output.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.recipients import Recipients
+from pieces_os_client.models.searched_assets import SearchedAssets
+from typing import Optional, Set
+from typing_extensions import Self
 
-class MailgunDistribution(BaseModel):
-    """
-    This is a specific Distribution for mailgun specific information.  # noqa: E501
+class AssetsSearchWithFiltersOutput(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    recipients: Recipients = Field(...)
-    __properties = ["schema", "recipients"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    output for the /assets/search [POST] 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    results: SearchedAssets
+    __properties: ClassVar[List[str]] = ["schema", "results"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> MailgunDistribution:
-        """Create an instance of MailgunDistribution from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AssetsSearchWithFiltersOutput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of recipients
-        if self.recipients:
-            _dict['recipients'] = self.recipients.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of results
+        if self.results:
+            _dict['results'] = self.results.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> MailgunDistribution:
-        """Create an instance of MailgunDistribution from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AssetsSearchWithFiltersOutput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return MailgunDistribution.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = MailgunDistribution.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "recipients": Recipients.from_dict(obj.get("recipients")) if obj.get("recipients") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "results": SearchedAssets.from_dict(obj["results"]) if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/mailgun_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/mailgun_metadata.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,65 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class MailgunMetadata(BaseModel):
     """
-    TODO add additional properties. TODO eventually modify this model to look like the response from Mailgun.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    message_id: StrictStr = Field(..., alias="messageId", description="This is the id given to us from mailgun when the email was sent successfully.")
-    __properties = ["schema", "messageId"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TODO add additional properties. TODO eventually modify this model to look like the response from Mailgun.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    message_id: StrictStr = Field(description="This is the id given to us from mailgun when the email was sent successfully.", alias="messageId")
+    __properties: ClassVar[List[str]] = ["schema", "messageId"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> MailgunMetadata:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of MailgunMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> MailgunMetadata:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of MailgunMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return MailgunMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = MailgunMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "message_id": obj.get("messageId")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "messageId": obj.get("messageId")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/mechanism_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/mechanism_enum.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class MechanismEnum(str, Enum):
     """
     This will let us know how an asset was uploaded.  MANUAL: this is an event such as a user driven send to pieces, or a paste to pieces.  RECOMMENDED: This is an event that was initiall recommended via the suggestion flow, and a user decided totake the recommendation.  AUTOMATIC: This is not user driven at all and the asset was automatically uploaded via the suggestion flow. or other methods.  INTERNAL: This is an undelete able enum used for internal use only.
     """
 
@@ -33,12 +30,12 @@
     MANUAL = 'MANUAL'
     RECOMMENDED = 'RECOMMENDED'
     AUTOMATIC = 'AUTOMATIC'
     INTERNAL = 'INTERNAL'
     DELETED = 'DELETED'
 
     @classmethod
-    def from_json(cls, json_str: str) -> MechanismEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of MechanismEnum from a JSON string"""
-        return MechanismEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/model.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,78 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
 from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.byte_descriptor import ByteDescriptor
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.external_ml_provider_enum import ExternalMLProviderEnum
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.model_foundation_enum import ModelFoundationEnum
 from pieces_os_client.models.model_max_tokens import ModelMaxTokens
 from pieces_os_client.models.model_type_enum import ModelTypeEnum
 from pieces_os_client.models.model_usage_enum import ModelUsageEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Model(BaseModel):
     """
-    This is a Machine Learning Model, that will give readable information about the Machine Learning Model Used.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="uuid ")
-    version: StrictStr = Field(..., description="this is a version of the model.")
-    created: GroupedTimestamp = Field(...)
-    name: StrictStr = Field(..., description="This is an Optional Name of the Model.")
-    description: Optional[StrictStr] = Field(None, description="An Optional Description of the model itself.")
-    cloud: StrictBool = Field(..., description="This will inform the user if this was a model that is hosted in the cloud")
-    type: ModelTypeEnum = Field(...)
-    usage: ModelUsageEnum = Field(...)
+    This is a Machine Learning Model, that will give readable information about the Machine Learning Model Used.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="uuid ")
+    version: StrictStr = Field(description="this is a version of the model.")
+    created: GroupedTimestamp
+    name: StrictStr = Field(description="This is an Optional Name of the Model.")
+    description: Optional[StrictStr] = Field(default=None, description="An Optional Description of the model itself.")
+    cloud: StrictBool = Field(description="This will inform the user if this was a model that is hosted in the cloud")
+    type: ModelTypeEnum
+    usage: ModelUsageEnum
     bytes: Optional[ByteDescriptor] = None
     ram: Optional[ByteDescriptor] = None
-    quantization: Optional[StrictStr] = Field(None, description="quantization is a string like: q8f16_0,  q4f16_1, etc...")
+    quantization: Optional[StrictStr] = Field(default=None, description="quantization is a string like: q8f16_0,  q4f16_1, etc...")
     foundation: Optional[ModelFoundationEnum] = None
-    downloaded: Optional[StrictBool] = Field(None, description="This is an optional bool to let us know if this model has been downloaded locally.")
-    loaded: Optional[StrictBool] = Field(None, description="This is a boolean that represents if the model is loaded into memory.(this is not persisted, and is calculated on the fly.)")
-    unique: Optional[StrictStr] = Field(None, description="This is the unique model name used to load the model.")
-    parameters: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="This is the number of parameters in terms of billions.")
+    downloaded: Optional[StrictBool] = Field(default=None, description="This is an optional bool to let us know if this model has been downloaded locally.")
+    loaded: Optional[StrictBool] = Field(default=None, description="This is a boolean that represents if the model is loaded into memory.(this is not persisted, and is calculated on the fly.)")
+    unique: Optional[StrictStr] = Field(default=None, description="This is the unique model name used to load the model.")
+    parameters: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="This is the number of parameters in terms of billions.")
     provider: Optional[ExternalMLProviderEnum] = None
-    cpu: Optional[StrictBool] = Field(None, description="This is an optional bool that is optimized for CPU usage.")
-    downloading: Optional[StrictBool] = Field(None, description="This is a calculated property, that will say if this is currently downloading.")
-    max_tokens: Optional[ModelMaxTokens] = Field(None, alias="maxTokens")
+    cpu: Optional[StrictBool] = Field(default=None, description="This is an optional bool that is optimized for CPU usage.")
+    downloading: Optional[StrictBool] = Field(default=None, description="This is a calculated property, that will say if this is currently downloading.")
+    max_tokens: Optional[ModelMaxTokens] = Field(default=None, alias="maxTokens")
     custom: Optional[StrictBool] = None
-    __properties = ["schema", "id", "version", "created", "name", "description", "cloud", "type", "usage", "bytes", "ram", "quantization", "foundation", "downloaded", "loaded", "unique", "parameters", "provider", "cpu", "downloading", "maxTokens", "custom"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "version", "created", "name", "description", "cloud", "type", "usage", "bytes", "ram", "quantization", "foundation", "downloaded", "loaded", "unique", "parameters", "provider", "cpu", "downloading", "maxTokens", "custom"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Model:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Model from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of bytes
@@ -94,49 +110,49 @@
         # override the default output from pydantic by calling `to_dict()` of ram
         if self.ram:
             _dict['ram'] = self.ram.to_dict()
         # override the default output from pydantic by calling `to_dict()` of max_tokens
         if self.max_tokens:
             _dict['maxTokens'] = self.max_tokens.to_dict()
         # set to None if parameters (nullable) is None
-        # and __fields_set__ contains the field
-        if self.parameters is None and "parameters" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.parameters is None and "parameters" in self.model_fields_set:
             _dict['parameters'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Model:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Model from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Model.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Model.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
             "version": obj.get("version"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
             "name": obj.get("name"),
             "description": obj.get("description"),
             "cloud": obj.get("cloud"),
             "type": obj.get("type"),
             "usage": obj.get("usage"),
-            "bytes": ByteDescriptor.from_dict(obj.get("bytes")) if obj.get("bytes") is not None else None,
-            "ram": ByteDescriptor.from_dict(obj.get("ram")) if obj.get("ram") is not None else None,
+            "bytes": ByteDescriptor.from_dict(obj["bytes"]) if obj.get("bytes") is not None else None,
+            "ram": ByteDescriptor.from_dict(obj["ram"]) if obj.get("ram") is not None else None,
             "quantization": obj.get("quantization"),
             "foundation": obj.get("foundation"),
             "downloaded": obj.get("downloaded"),
             "loaded": obj.get("loaded"),
             "unique": obj.get("unique"),
             "parameters": obj.get("parameters"),
             "provider": obj.get("provider"),
             "cpu": obj.get("cpu"),
             "downloading": obj.get("downloading"),
-            "max_tokens": ModelMaxTokens.from_dict(obj.get("maxTokens")) if obj.get("maxTokens") is not None else None,
+            "maxTokens": ModelMaxTokens.from_dict(obj["maxTokens"]) if obj.get("maxTokens") is not None else None,
             "custom": obj.get("custom")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/model_delete_cache_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_delete_cache_input.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,63 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ModelDeleteCacheInput(BaseModel):
     """
-    This is the input model for '/model/{model}/delete/cache'  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    __properties = ["schema"]
+    This is the input model for '/model/{model}/delete/cache'
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    __properties: ClassVar[List[str]] = ["schema"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ModelDeleteCacheInput:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ModelDeleteCacheInput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ModelDeleteCacheInput:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ModelDeleteCacheInput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ModelDeleteCacheInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ModelDeleteCacheInput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/model_delete_cache_output.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_delete_cache_output.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.referenced_model import ReferencedModel
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ModelDeleteCacheOutput(BaseModel):
     """
-    This is the output model for '/model/{model}/delete/cache'  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    model: ReferencedModel = Field(...)
-    __properties = ["schema", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the output model for '/model/{model}/delete/cache'
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    model: ReferencedModel
+    __properties: ClassVar[List[str]] = ["schema", "model"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ModelDeleteCacheOutput:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ModelDeleteCacheOutput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of model
         if self.model:
             _dict['model'] = self.model.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ModelDeleteCacheOutput:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ModelDeleteCacheOutput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ModelDeleteCacheOutput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ModelDeleteCacheOutput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "model": ReferencedModel.from_dict(obj.get("model")) if obj.get("model") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "model": ReferencedModel.from_dict(obj["model"]) if obj.get("model") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/model_download_progress.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_download_progress.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
 from pydantic import BaseModel, Field, StrictFloat, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.model_download_progress_status_enum import ModelDownloadProgressStatusEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ModelDownloadProgress(BaseModel):
     """
-    This is the model that is sent over our ws for streaming the progress of a model that is being downloaded.  can eventually add a number that display the percent downloaded an so on.(this is called percent 0-100)  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is the model that is sent over our ws for streaming the progress of a model that is being downloaded.  can eventually add a number that display the percent downloaded an so on.(this is called percent 0-100)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     status: Optional[ModelDownloadProgressStatusEnum] = None
-    percentage: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Optionally if the download is in progress you will recieve a download percent(from 0-100).")
-    __properties = ["schema", "status", "percentage"]
+    percentage: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Optionally if the download is in progress you will recieve a download percent(from 0-100).")
+    __properties: ClassVar[List[str]] = ["schema", "status", "percentage"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ModelDownloadProgress:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ModelDownloadProgress from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # set to None if percentage (nullable) is None
-        # and __fields_set__ contains the field
-        if self.percentage is None and "percentage" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.percentage is None and "percentage" in self.model_fields_set:
             _dict['percentage'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ModelDownloadProgress:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ModelDownloadProgress from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ModelDownloadProgress.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ModelDownloadProgress.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "status": obj.get("status"),
             "percentage": obj.get("percentage")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/model_download_progress_status_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_download_progress_status_enum.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ModelDownloadProgressStatusEnum(str, Enum):
     """
     Enum used for the status of the progress in downloading a model.
     """
 
@@ -33,12 +30,12 @@
     INITIALIZED = 'INITIALIZED'
     IN_MINUS_PROGRESS = 'IN-PROGRESS'
     COMPLETED = 'COMPLETED'
     FAILED = 'FAILED'
     UNKNOWN = 'UNKNOWN'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ModelDownloadProgressStatusEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ModelDownloadProgressStatusEnum from a JSON string"""
-        return ModelDownloadProgressStatusEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/model_foundation_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_foundation_enum.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ModelFoundationEnum(str, Enum):
     """
     This is used to describe the foundational models used within POS.
     """
 
@@ -102,14 +99,17 @@
     CODECHAT_BISON = 'CODECHAT_BISON'
     CODE_GECKO = 'CODE_GECKO'
     DISTILROBERTA = 'DISTILROBERTA'
     MISTRAL_7_B = 'MISTRAL_7B'
     GEMINI = 'GEMINI'
     FAST_TEXT = 'FAST_TEXT'
     UNIXCODER = 'UNIXCODER'
+    PHI_1_DOT_5 = 'PHI_1.5'
+    PHI_2 = 'PHI_2'
+    MIXTRAL_8_X_7_B = 'MIXTRAL_8_x_7B'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ModelFoundationEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ModelFoundationEnum from a JSON string"""
-        return ModelFoundationEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/model_max_tokens.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_conversation.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,84 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ModelMaxTokens(BaseModel):
-    """
-    This will describe the MaxTokens for an MLModel  total is required.  iff there is a differentiator with inputs/outputs, then we can also provide those as well.  # noqa: E501
+class ReferencedConversation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    total: Optional[Union[StrictFloat, StrictInt]] = Field(...)
-    input: Optional[Union[StrictFloat, StrictInt]] = None
-    output: Optional[Union[StrictFloat, StrictInt]] = None
-    __properties = ["schema", "total", "input", "output"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a DAG-Safe Minimal version of a Conversation.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedConversation] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ModelMaxTokens:
-        """Create an instance of ModelMaxTokens from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedConversation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # set to None if total (nullable) is None
-        # and __fields_set__ contains the field
-        if self.total is None and "total" in self.__fields_set__:
-            _dict['total'] = None
-
-        # set to None if input (nullable) is None
-        # and __fields_set__ contains the field
-        if self.input is None and "input" in self.__fields_set__:
-            _dict['input'] = None
-
-        # set to None if output (nullable) is None
-        # and __fields_set__ contains the field
-        if self.output is None and "output" in self.__fields_set__:
-            _dict['output'] = None
-
+        # override the default output from pydantic by calling `to_dict()` of reference
+        if self.reference:
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ModelMaxTokens:
-        """Create an instance of ModelMaxTokens from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedConversation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ModelMaxTokens.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ModelMaxTokens.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "total": obj.get("total"),
-            "input": obj.get("input"),
-            "output": obj.get("output")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedConversation.from_dict(obj["reference"]) if obj.get("reference") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.flattened_conversation import FlattenedConversation
+# TODO: Rewrite to not use raise_errors
+ReferencedConversation.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/model_type_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/hint_type_enum.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,34 +9,30 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class ModelTypeEnum(str, Enum):
+class HintTypeEnum(str, Enum):
     """
-    This will describe the type of Model balanced, speed, accuracy...
+    This is the hint enum used to describe a type of hint.
     """
 
     """
     allowed enum values
     """
-    BALANCED = 'BALANCED'
-    SPEED = 'SPEED'
-    ACCURACY = 'ACCURACY'
+    SUGGESTED_QUERY = 'SUGGESTED_QUERY'
+    QGPT_HINT = 'QGPT_HINT'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ModelTypeEnum:
-        """Create an instance of ModelTypeEnum from a JSON string"""
-        return ModelTypeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of HintTypeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/model_usage_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/model_usage_enum.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ModelUsageEnum(str, Enum):
     """
     These are all the possible uses for a model, i.e. code classification, OCR, text vs code,  tagify code, tag-based code search, neural code search, tagify color and code description.
     """
 
@@ -49,12 +46,12 @@
     CODE_RELATED_PEOPLE = 'CODE_RELATED_PEOPLE'
     CODE_FRAMEWORK = 'CODE_FRAMEWORK'
     VIDEO_OCR = 'VIDEO_OCR'
     TEXT_VS_CODE_SEGMENTATION = 'TEXT_VS_CODE_SEGMENTATION'
     TEXT_EMBEDDING = 'TEXT_EMBEDDING'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ModelUsageEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ModelUsageEnum from a JSON string"""
-        return ModelUsageEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/models.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/relationships.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List
+from pieces_os_client.models.relationship import Relationship
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.model import Model
-
-class Models(BaseModel):
-    """
-    This is a List of MachineLearning Models  # noqa: E501
+class Relationships(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Model) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Relationships
+    """ # noqa: E501
+    iterable: List[Relationship]
+    __properties: ClassVar[List[str]] = ["iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Models:
-        """Create an instance of Models from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Relationships from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Models:
-        """Create an instance of Models from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Relationships from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Models.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Models.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Model.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "iterable": [Relationship.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/node.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/node.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,70 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.node_type_enum import NodeTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Node(BaseModel):
     """
-    This describes a node within a relationship graph used to related like types. ie asset to asset, tag to tag, ...etc  created: is here to let us know when the node was attached.  id: this is the the id of the type ie, if the type is Asset the id here points to the asset that this node represents.  # noqa: E501
-    """
-    id: StrictStr = Field(...)
-    type: NodeTypeEnum = Field(...)
-    root: StrictBool = Field(..., description="This is a boolean to let us know if this node is the root or origin of the relationship graph.")
-    created: GroupedTimestamp = Field(...)
-    __properties = ["id", "type", "root", "created"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This describes a node within a relationship graph used to related like types. ie asset to asset, tag to tag, ...etc  created: is here to let us know when the node was attached.  id: this is the the id of the type ie, if the type is Asset the id here points to the asset that this node represents.
+    """ # noqa: E501
+    id: StrictStr
+    type: NodeTypeEnum
+    root: StrictBool = Field(description="This is a boolean to let us know if this node is the root or origin of the relationship graph.")
+    created: GroupedTimestamp
+    __properties: ClassVar[List[str]] = ["id", "type", "root", "created"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Node:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Node from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Node:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Node from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Node.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Node.parse_obj({
+        _obj = cls.model_validate({
             "id": obj.get("id"),
             "type": obj.get("type"),
             "root": obj.get("root"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/node_type_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/node_type_enum.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class NodeTypeEnum(str, Enum):
     """
     This describes the type of a node ie an asset, tag, website, format... ETC
     """
 
@@ -32,12 +29,12 @@
     """
     TAG = 'TAG'
     WEBSITE = 'WEBSITE'
     FORMAT = 'FORMAT'
     ASSET = 'ASSET'
 
     @classmethod
-    def from_json(cls, json_str: str) -> NodeTypeEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of NodeTypeEnum from a JSON string"""
-        return NodeTypeEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/notification.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/save_suggestion.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,71 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Notification(BaseModel):
-    """
-    config model for notification invoking  # noqa: E501
+class SaveSuggestion(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictInt = Field(...)
-    title: Optional[StrictStr] = None
-    message: Optional[StrictStr] = None
-    payload: Optional[StrictStr] = None
-    __properties = ["schema", "id", "title", "message", "payload"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the SaveSuggestion. Mainly creating an additional model here because I imagine that we will want to add some additional data to this in the future (potentially with more numerical data that is emitted from the ML Models)  **Note: suggested is required here because we will want to say if we reccomend to take this action of save or not.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    suggested: StrictBool = Field(description="This is a boolean, that will say if you should or should not take action.")
+    __properties: ClassVar[List[str]] = ["schema", "suggested"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Notification:
-        """Create an instance of Notification from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SaveSuggestion from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Notification:
-        """Create an instance of Notification from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SaveSuggestion from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Notification.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Notification.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id"),
-            "title": obj.get("title"),
-            "message": obj.get("message"),
-            "payload": obj.get("payload")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "suggested": obj.get("suggested")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/o_auth_account.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/o_auth_account.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,69 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-
-from pydantic import BaseModel, Field, constr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class OAuthAccount(BaseModel):
     """
-    A Model to support account creation to Auth0's Database.  # noqa: E501
-    """
-    client_id: constr(strict=True, min_length=1) = Field(..., description="The client_id of your client.")
-    email: constr(strict=True, min_length=1) = Field(..., description="The user's email address.")
-    connection: constr(strict=True, min_length=1) = Field(..., description="The name of the database configured to your client.")
-    username: constr(strict=True, min_length=1) = Field(..., description="The user's username. Only valid if the connection requires a username.")
-    given_name: constr(strict=True, min_length=1) = Field(..., description="The user's given name(s).")
-    family_name: constr(strict=True, min_length=1) = Field(..., description="The user's family name(s).")
-    name: constr(strict=True, min_length=1) = Field(..., description="The user's full name.")
-    picture: constr(strict=True, min_length=1) = Field(..., description="A URI pointing to the user's picture.")
-    nickname: constr(strict=True, min_length=1) = Field(..., description="The user's nickname.")
-    __properties = ["client_id", "email", "connection", "username", "given_name", "family_name", "name", "picture", "nickname"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A Model to support account creation to Auth0's Database.
+    """ # noqa: E501
+    client_id: Annotated[str, Field(min_length=1, strict=True)] = Field(description="The client_id of your client.")
+    email: Annotated[str, Field(min_length=1, strict=True)] = Field(description="The user's email address.")
+    connection: Annotated[str, Field(min_length=1, strict=True)] = Field(description="The name of the database configured to your client.")
+    username: Annotated[str, Field(min_length=1, strict=True)] = Field(description="The user's username. Only valid if the connection requires a username.")
+    given_name: Annotated[str, Field(min_length=1, strict=True)] = Field(description="The user's given name(s).")
+    family_name: Annotated[str, Field(min_length=1, strict=True)] = Field(description="The user's family name(s).")
+    name: Annotated[str, Field(min_length=1, strict=True)] = Field(description="The user's full name.")
+    picture: Annotated[str, Field(min_length=1, strict=True)] = Field(description="A URI pointing to the user's picture.")
+    nickname: Annotated[str, Field(min_length=1, strict=True)] = Field(description="The user's nickname.")
+    __properties: ClassVar[List[str]] = ["client_id", "email", "connection", "username", "given_name", "family_name", "name", "picture", "nickname"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuthAccount:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of OAuthAccount from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuthAccount:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of OAuthAccount from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuthAccount.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuthAccount.parse_obj({
+        _obj = cls.model_validate({
             "client_id": obj.get("client_id"),
             "email": obj.get("email"),
             "connection": obj.get("connection"),
             "username": obj.get("username"),
             "given_name": obj.get("given_name"),
             "family_name": obj.get("family_name"),
             "name": obj.get("name"),
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/o_auth_group.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/o_auth_group.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.o_auth_account import OAuthAccount
 from pieces_os_client.models.o_auth_token import OAuthToken
+from typing import Optional, Set
+from typing_extensions import Self
 
 class OAuthGroup(BaseModel):
     """
-    A model to group all of the properties associated with OAuthGroup  # noqa: E501
-    """
+    A model to group all of the properties associated with OAuthGroup
+    """ # noqa: E501
     token: Optional[OAuthToken] = None
     account: Optional[OAuthAccount] = None
-    __properties = ["token", "account"]
+    __properties: ClassVar[List[str]] = ["token", "account"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuthGroup:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of OAuthGroup from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of token
         if self.token:
             _dict['token'] = self.token.to_dict()
         # override the default output from pydantic by calling `to_dict()` of account
         if self.account:
             _dict['account'] = self.account.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuthGroup:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of OAuthGroup from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuthGroup.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuthGroup.parse_obj({
-            "token": OAuthToken.from_dict(obj.get("token")) if obj.get("token") is not None else None,
-            "account": OAuthAccount.from_dict(obj.get("account")) if obj.get("account") is not None else None
+        _obj = cls.model_validate({
+            "token": OAuthToken.from_dict(obj["token"]) if obj.get("token") is not None else None,
+            "account": OAuthAccount.from_dict(obj["account"]) if obj.get("account") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/o_auth_token.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/o_auth_token.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,79 +14,95 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, validator
+from pydantic import BaseModel, Field, StrictInt, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class OAuthToken(BaseModel):
     """
-    A model representing a returnable response for a OAuthGroup Token  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    access_token: StrictStr = Field(..., description="The Access Token")
-    token_type: StrictStr = Field(...)
-    expires_in: StrictInt = Field(...)
-    scope: StrictStr = Field(...)
+    A model representing a returnable response for a OAuthGroup Token
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    access_token: StrictStr = Field(description="The Access Token")
+    token_type: StrictStr
+    expires_in: StrictInt
+    scope: StrictStr
     refresh_token: Optional[StrictStr] = None
     id_token: Optional[StrictStr] = None
-    __properties = ["schema", "access_token", "token_type", "expires_in", "scope", "refresh_token", "id_token"]
+    __properties: ClassVar[List[str]] = ["schema", "access_token", "token_type", "expires_in", "scope", "refresh_token", "id_token"]
 
-    @validator('token_type')
+    @field_validator('token_type')
     def token_type_validate_enum(cls, value):
         """Validates the enum"""
-        if value not in ('Bearer'):
+        if value not in set(['Bearer']):
             raise ValueError("must be one of enum values ('Bearer')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuthToken:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of OAuthToken from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuthToken:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of OAuthToken from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuthToken.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuthToken.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "access_token": obj.get("access_token"),
             "token_type": obj.get("token_type"),
             "expires_in": obj.get("expires_in"),
             "scope": obj.get("scope"),
             "refresh_token": obj.get("refresh_token"),
             "id_token": obj.get("id_token")
         })
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/ocr_analyses.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_reclassification.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.asset import Asset
+from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.ocr_analysis import OCRAnalysis
+from typing import Optional, Set
+from typing_extensions import Self
 
-class OCRAnalyses(BaseModel):
-    """
-    OCRAnalyses
+class AssetReclassification(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(OCRAnalysis) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a model that will represent the miminum properties required to update the classification of this asset.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    ext: ClassificationSpecificEnum
+    asset: Asset
+    __properties: ClassVar[List[str]] = ["schema", "ext", "asset"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OCRAnalyses:
-        """Create an instance of OCRAnalyses from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AssetReclassification from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
+        # override the default output from pydantic by calling `to_dict()` of asset
+        if self.asset:
+            _dict['asset'] = self.asset.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OCRAnalyses:
-        """Create an instance of OCRAnalyses from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AssetReclassification from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OCRAnalyses.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OCRAnalyses.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [OCRAnalysis.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "ext": obj.get("ext"),
+            "asset": Asset.from_dict(obj["asset"]) if obj.get("asset") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/ocr_analysis.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/format_reclassification.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,98 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.model import Model
-
+from pieces_os_client.models.format import Format
+from typing import Optional, Set
+from typing_extensions import Self
 
-class OCRAnalysis(BaseModel):
+class FormatReclassification(BaseModel):
     """
-    This is the data collected during the ocr analysis of an image.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    raw: Format = Field(...)
-    hocr: Format = Field(...)
-    image: StrictStr = Field(
-        ..., description="this is a reference the the imageAnalysis."
-    )
-    model: Model = Field(...)
-    __properties = ["schema", "id", "raw", "hocr", "image", "model"]
-
-    class Config:
-        """Pydantic configuration"""
+    This is a model that will represent the miminum properties required to update the classification of this format.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    ext: ClassificationSpecificEnum
+    format: Format
+    __properties: ClassVar[List[str]] = ["schema", "ext", "format"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OCRAnalysis:
-        """Create an instance of OCRAnalysis from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FormatReclassification from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of raw
-        if self.raw:
-            _dict["raw"] = self.raw.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of hocr
-        if self.hocr:
-            _dict["hocr"] = self.hocr.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of model
-        if self.model:
-            _dict["model"] = self.model.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of format
+        if self.format:
+            _dict['format'] = self.format.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OCRAnalysis:
-        """Create an instance of OCRAnalysis from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FormatReclassification from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OCRAnalysis.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OCRAnalysis.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "raw": Format.from_dict(obj.get("raw"))
-                if obj.get("raw") is not None
-                else None,
-                "hocr": Format.from_dict(obj.get("hocr"))
-                if obj.get("hocr") is not None
-                else None,
-                "image": obj.get("image"),
-                "model": Model.from_dict(obj.get("model"))
-                if obj.get("model") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "ext": obj.get("ext"),
+            "format": Format.from_dict(obj["format"]) if obj.get("format") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.format import Format
-
-# OCRAnalysis.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/open_ai_models_list_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/preonboarded_persona_details.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,65 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class OpenAIModelsListInput(BaseModel):
-    """
-    This is the input model for the /open_ai/models/list endpoint.  # noqa: E501
+class PreonboardedPersonaDetails(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    user: StrictStr = Field(...)
-    __properties = ["schema", "user"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is an input body for the /machine_learning/text/technical_processing/generators/personification endpoint.  This will accept some of the personal details ie languages/personas && will transform this in to onbaording snippets
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    languages: Optional[List[StrictStr]] = None
+    personas: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["schema", "languages", "personas"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OpenAIModelsListInput:
-        """Create an instance of OpenAIModelsListInput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PreonboardedPersonaDetails from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OpenAIModelsListInput:
-        """Create an instance of OpenAIModelsListInput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PreonboardedPersonaDetails from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OpenAIModelsListInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OpenAIModelsListInput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "user": obj.get("user")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "languages": obj.get("languages"),
+            "personas": obj.get("personas")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/open_ai_models_list_output.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/notification.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,69 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_models import SeededModels
+from typing import Optional, Set
+from typing_extensions import Self
 
-class OpenAIModelsListOutput(BaseModel):
-    """
-    This is the output model for the /open_ai/models/list endpoint.  # noqa: E501
+class Notification(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    models: SeededModels = Field(...)
-    __properties = ["schema", "models"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    config model for notification invoking
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictInt
+    title: Optional[StrictStr] = None
+    message: Optional[StrictStr] = None
+    payload: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "title", "message", "payload"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OpenAIModelsListOutput:
-        """Create an instance of OpenAIModelsListOutput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Notification from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of models
-        if self.models:
-            _dict['models'] = self.models.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OpenAIModelsListOutput:
-        """Create an instance of OpenAIModelsListOutput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Notification from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OpenAIModelsListOutput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OpenAIModelsListOutput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "models": SeededModels.from_dict(obj.get("models")) if obj.get("models") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "title": obj.get("title"),
+            "message": obj.get("message"),
+            "payload": obj.get("payload")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/ordered_metrics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_keyboard_event.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,65 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class OrderedMetrics(BaseModel):
-    """
-    This is a returnable for the metrics/formats/ordered  # noqa: E501
+class TrackedKeyboardEvent(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    ordered: conlist(StrictStr) = Field(...)
-    __properties = ["schema", "ordered"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a model that will hold relavent information in relation to a keyboard(including shortcuts) analytics event (usage).
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    description: StrictStr = Field(description="this is a description of the event, optional.")
+    shortcut: List[StrictInt] = Field(description="this is an array of of ascii values that represent numerics on your keyboard.")
+    __properties: ClassVar[List[str]] = ["schema", "description", "shortcut"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderedMetrics:
-        """Create an instance of OrderedMetrics from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedKeyboardEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderedMetrics:
-        """Create an instance of OrderedMetrics from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedKeyboardEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderedMetrics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderedMetrics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "ordered": obj.get("ordered")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "description": obj.get("description"),
+            "shortcut": obj.get("shortcut")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/os_health.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/theme.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,67 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class OSHealth(BaseModel):
-    """
-    This is a specific model for the health of our OS Server.  # noqa: E501
+class Theme(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="id of your OS")
-    version: StrictStr = Field(..., description="this is the current OS version")
-    __properties = ["schema", "id", "version"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will describe the theme that belongs to a user.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    dark: StrictBool
+    __properties: ClassVar[List[str]] = ["schema", "dark"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OSHealth:
-        """Create an instance of OSHealth from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Theme from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OSHealth:
-        """Create an instance of OSHealth from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Theme from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OSHealth.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OSHealth.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id"),
-            "version": obj.get("version")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "dark": obj.get("dark")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/person.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_person.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,74 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
-from pieces_os_client.models.flattened_assets import FlattenedAssets
-from pieces_os_client.models.flattened_tags import FlattenedTags
-from pieces_os_client.models.flattened_websites import FlattenedWebsites
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.person_access import PersonAccess
-from pieces_os_client.models.person_model import PersonModel
 from pieces_os_client.models.person_type import PersonType
 from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Person(BaseModel):
+class FlattenedPerson(BaseModel):
     """
-    if expiration is add then, after the alloted expiration date the user will only have view && comment only permissions. Only present in the case there is a scope such as a defined collection/asset...  if asset is passed then that means this person belongs to a scoped asset.  NOTE****: annotations here are annotations to describe the person!!! if in the future we want to add who wrote an annotation on and asset or soemthing like that, we will want to add a new field on here called authorships.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    if expiration is add then, after the alloted expiration date the user will only have view && comment only permissions. Only present in the case there is a scope such as a defined collection/asset...  if asset is passed then that means this person belongs to a scoped asset.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    type: PersonType = Field(...)
+    type: PersonType
     assets: Optional[FlattenedAssets] = None
-    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(None, description="This is a Map<String, MechanismEnum> where the the key is an asset id.")
-    interactions: Optional[StrictInt] = Field(None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
-    access: Optional[Dict[str, PersonAccess]] = Field(None, description="This is a Map<String, PersonAccess> where the the key is an asset id.")
+    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(default=None, description="This is a Map<String, MechanismEnum> where the the key is an asset id.")
+    interactions: Optional[StrictInt] = Field(default=None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
+    access: Optional[Dict[str, PersonAccess]] = Field(default=None, description="This is a Map<String, PersonAccess> where the the key is an asset id.")
     tags: Optional[FlattenedTags] = None
     websites: Optional[FlattenedWebsites] = None
-    models: Optional[Dict[str, PersonModel]] = Field(None, description="This is a Map<String, PersonModel>, where the the key is an asset id.")
+    models: Optional[Dict[str, PersonModel]] = Field(default=None, description="This is a Map<String, PersonModel>, where the the key is an asset id.")
     annotations: Optional[FlattenedAnnotations] = None
     score: Optional[Score] = None
-    __properties = ["schema", "id", "created", "updated", "deleted", "type", "assets", "mechanisms", "interactions", "access", "tags", "websites", "models", "annotations", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "deleted", "type", "assets", "mechanisms", "interactions", "access", "tags", "websites", "models", "annotations", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Person:
-        """Create an instance of Person from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedPerson from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -121,45 +132,52 @@
             _dict['annotations'] = self.annotations.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Person:
-        """Create an instance of Person from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedPerson from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Person.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Person.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
-            "type": PersonType.from_dict(obj.get("type")) if obj.get("type") is not None else None,
-            "assets": FlattenedAssets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "type": PersonType.from_dict(obj["type"]) if obj.get("type") is not None else None,
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
             "mechanisms": dict((_k, _v) for _k, _v in obj.get("mechanisms").items()),
             "interactions": obj.get("interactions"),
             "access": dict(
                 (_k, PersonAccess.from_dict(_v))
-                for _k, _v in obj.get("access").items()
+                for _k, _v in obj["access"].items()
             )
             if obj.get("access") is not None
             else None,
-            "tags": FlattenedTags.from_dict(obj.get("tags")) if obj.get("tags") is not None else None,
-            "websites": FlattenedWebsites.from_dict(obj.get("websites")) if obj.get("websites") is not None else None,
+            "tags": FlattenedTags.from_dict(obj["tags"]) if obj.get("tags") is not None else None,
+            "websites": FlattenedWebsites.from_dict(obj["websites"]) if obj.get("websites") is not None else None,
             "models": dict(
                 (_k, PersonModel.from_dict(_v))
-                for _k, _v in obj.get("models").items()
+                for _k, _v in obj["models"].items()
             )
             if obj.get("models") is not None
             else None,
-            "annotations": FlattenedAnnotations.from_dict(obj.get("annotations")) if obj.get("annotations") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "annotations": FlattenedAnnotations.from_dict(obj["annotations"]) if obj.get("annotations") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.flattened_annotations import FlattenedAnnotations
+from pieces_os_client.models.flattened_assets import FlattenedAssets
+from pieces_os_client.models.flattened_tags import FlattenedTags
+from pieces_os_client.models.flattened_websites import FlattenedWebsites
+from pieces_os_client.models.person_model import PersonModel
+# TODO: Rewrite to not use raise_errors
+FlattenedPerson.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/person_access.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/grouped_timestamp.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,72 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from datetime import datetime
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
-from pieces_os_client.models.person_access_scoped_enum import PersonAccessScopedEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PersonAccess(BaseModel):
-    """
-    if scoped is provided will let us know what level of permission(access) this specific person has in relation to what scope.(collection, asset,...etc)  in the future will expand to global (with its own enumeration for a global entire project/cloud scope)  # noqa: E501
+class GroupedTimestamp(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    scoped: Optional[PersonAccessScopedEnum] = None
-    deleted: Optional[GroupedTimestamp] = None
-    __properties = ["schema", "scoped", "deleted"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A helper classs to wrap Date-Time Values with Useful Helper Properties
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    value: datetime
+    readable: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "value", "readable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PersonAccess:
-        """Create an instance of PersonAccess from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GroupedTimestamp from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of deleted
-        if self.deleted:
-            _dict['deleted'] = self.deleted.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PersonAccess:
-        """Create an instance of PersonAccess from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GroupedTimestamp from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PersonAccess.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PersonAccess.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "scoped": obj.get("scoped"),
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "value": obj.get("value"),
+            "readable": obj.get("readable")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/person_access_scoped_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/access_enum.py`

 * *Files 19% similar despite different names*

```diff
@@ -9,35 +9,30 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class PersonAccessScopedEnum(str, Enum):
+class AccessEnum(str, Enum):
     """
-    This is an enum that will help provide information around what permission this person has in relate to their scope.
+    AccessEnum
     """
 
     """
     allowed enum values
     """
-    OWNER = 'OWNER'
-    EDITOR = 'EDITOR'
-    COMMENTER = 'COMMENTER'
-    VIEWER = 'VIEWER'
+    PUBLIC = 'PUBLIC'
+    PRIVATE = 'PRIVATE'
 
     @classmethod
-    def from_json(cls, json_str: str) -> PersonAccessScopedEnum:
-        """Create an instance of PersonAccessScopedEnum from a JSON string"""
-        return PersonAccessScopedEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of AccessEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/person_basic_type.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/person_basic_type.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,82 +14,98 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.externally_sourced_enum import ExternallySourcedEnum
 from pieces_os_client.models.mailgun_metadata import MailgunMetadata
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PersonBasicType(BaseModel):
     """
-    This is all optional properties around the most basic information around a non-pieces user.  A Basic type will NOT have a scope as it is not an actual pieces user.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    username: Optional[StrictStr] = Field(None, description="username or twitter handle...etc")
-    name: Optional[StrictStr] = Field(None, description="This is the name of the basic user.")
-    picture: Optional[StrictStr] = Field(None, description="this is a url picture representation of a user.")
-    email: Optional[StrictStr] = Field(None, description="an email that was extracted.")
+    This is all optional properties around the most basic information around a non-pieces user.  A Basic type will NOT have a scope as it is not an actual pieces user.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    username: Optional[StrictStr] = Field(default=None, description="username or twitter handle...etc")
+    name: Optional[StrictStr] = Field(default=None, description="This is the name of the basic user.")
+    picture: Optional[StrictStr] = Field(default=None, description="this is a url picture representation of a user.")
+    email: Optional[StrictStr] = Field(default=None, description="an email that was extracted.")
     sourced: Optional[ExternallySourcedEnum] = None
-    url: Optional[StrictStr] = Field(None, description="This is a specific url that this basic user came from.")
+    url: Optional[StrictStr] = Field(default=None, description="This is a specific url that this basic user came from.")
     mailgun: Optional[MailgunMetadata] = None
-    __properties = ["schema", "username", "name", "picture", "email", "sourced", "url", "mailgun"]
+    __properties: ClassVar[List[str]] = ["schema", "username", "name", "picture", "email", "sourced", "url", "mailgun"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PersonBasicType:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PersonBasicType from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of mailgun
         if self.mailgun:
             _dict['mailgun'] = self.mailgun.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PersonBasicType:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PersonBasicType from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PersonBasicType.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PersonBasicType.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "username": obj.get("username"),
             "name": obj.get("name"),
             "picture": obj.get("picture"),
             "email": obj.get("email"),
             "sourced": obj.get("sourced"),
             "url": obj.get("url"),
-            "mailgun": MailgunMetadata.from_dict(obj.get("mailgun")) if obj.get("mailgun") is not None else None
+            "mailgun": MailgunMetadata.from_dict(obj["mailgun"]) if obj.get("mailgun") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/person_model.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/streamed_identifier.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,93 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.referenced_asset import ReferencedAsset
+from pieces_os_client.models.referenced_conversation import ReferencedConversation
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
-from pieces_os_client.models.referenced_model import ReferencedModel
-
-
-class PersonModel(BaseModel):
+class StreamedIdentifier(BaseModel):
     """
-    This is a PersonSpecific Model. and will let us know for all the assets that get attached to the person if, this person was attached via a model or just attached automatically.  explanation here are the reason why a Person was attached to an asset.  # noqa: E501
-    """
-
+    This is currently only used within /assets/steam/identifiers && /conversations/steam/identifiers but can be used with other as well, if we want to expand this class.
+    """ # noqa: E501
     asset: Optional[ReferencedAsset] = None
-    model: Optional[ReferencedModel] = None
-    deleted: Optional[GroupedTimestamp] = None
-    explanation: Optional[ReferencedAnnotation] = None
-    __properties = ["asset", "model", "deleted", "explanation"]
-
-    class Config:
-        """Pydantic configuration"""
+    conversation: Optional[ReferencedConversation] = None
+    deleted: Optional[StrictBool] = Field(default=None, description="This is a specific bool that will let us know if we deleted an Identifierfrom the db.")
+    __properties: ClassVar[List[str]] = ["asset", "conversation", "deleted"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PersonModel:
-        """Create an instance of PersonModel from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of StreamedIdentifier from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of asset
         if self.asset:
-            _dict["asset"] = self.asset.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of model
-        if self.model:
-            _dict["model"] = self.model.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of deleted
-        if self.deleted:
-            _dict["deleted"] = self.deleted.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of explanation
-        if self.explanation:
-            _dict["explanation"] = self.explanation.to_dict()
+            _dict['asset'] = self.asset.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of conversation
+        if self.conversation:
+            _dict['conversation'] = self.conversation.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PersonModel:
-        """Create an instance of PersonModel from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of StreamedIdentifier from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PersonModel.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PersonModel.parse_obj(
-            {
-                "asset": ReferencedAsset.from_dict(obj.get("asset"))
-                if obj.get("asset") is not None
-                else None,
-                "model": ReferencedModel.from_dict(obj.get("model"))
-                if obj.get("model") is not None
-                else None,
-                "deleted": GroupedTimestamp.from_dict(obj.get("deleted"))
-                if obj.get("deleted") is not None
-                else None,
-                "explanation": ReferencedAnnotation.from_dict(obj.get("explanation"))
-                if obj.get("explanation") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "asset": ReferencedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "conversation": ReferencedConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
+            "deleted": obj.get("deleted")
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_annotation import ReferencedAnnotation
-from pieces_os_client.models.referenced_asset import ReferencedAsset
-
-# PersonModel.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/person_type.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_hardware_information.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.person_basic_type import PersonBasicType
-from pieces_os_client.models.user_profile import UserProfile
+from pieces_os_client.models.os_device_cpu_hardware_information import OSDeviceCPUHardwareInformation
+from pieces_os_client.models.os_device_gpu_hardware_information import OSDeviceGPUHardwareInformation
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PersonType(BaseModel):
-    """
-    basic or platform is absolutely required here. basic: if provided is just information that has been either extracted from the piece or other wise added here. platform: is a real Pieces User.(this user will also exist within the user's users collection. && if not then we will just use the data we have.)  # noqa: E501
+class OSDeviceHardwareInformation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    basic: Optional[PersonBasicType] = None
-    platform: Optional[UserProfile] = None
-    __properties = ["schema", "basic", "platform"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    this will let us know specific hardware information
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    cpu: Optional[OSDeviceCPUHardwareInformation] = None
+    gpu: Optional[OSDeviceGPUHardwareInformation] = None
+    __properties: ClassVar[List[str]] = ["schema", "cpu", "gpu"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PersonType:
-        """Create an instance of PersonType from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OSDeviceHardwareInformation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of basic
-        if self.basic:
-            _dict['basic'] = self.basic.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of platform
-        if self.platform:
-            _dict['platform'] = self.platform.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of cpu
+        if self.cpu:
+            _dict['cpu'] = self.cpu.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of gpu
+        if self.gpu:
+            _dict['gpu'] = self.gpu.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PersonType:
-        """Create an instance of PersonType from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OSDeviceHardwareInformation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PersonType.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PersonType.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "basic": PersonBasicType.from_dict(obj.get("basic")) if obj.get("basic") is not None else None,
-            "platform": UserProfile.from_dict(obj.get("platform")) if obj.get("platform") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "cpu": OSDeviceCPUHardwareInformation.from_dict(obj["cpu"]) if obj.get("cpu") is not None else None,
+            "gpu": OSDeviceGPUHardwareInformation.from_dict(obj["gpu"]) if obj.get("gpu") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/persons.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/onboarded_persona_details.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,81 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.person import Person
-from pieces_os_client.models.score import Score
+from pieces_os_client.models.seeds import Seeds
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Persons(BaseModel):
-    """
-    This is the plural of Person. will have top level meta about the person including an iterable of all the person.  # noqa: E501
+class OnboardedPersonaDetails(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Person) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(None, description="This is a Map<String, int> where the the key is an person id.")
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is an out body for the /machine_learning/text/technical_processing/generators/personification endpoint.  This will have accepted some of the personal details (in the input body) ie languages/personas && will transform this in to onbaording snippets that we will return with this model
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    seeds: Seeds
+    __properties: ClassVar[List[str]] = ["schema", "seeds"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Persons:
-        """Create an instance of Persons from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OnboardedPersonaDetails from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict['score'] = self.score.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of seeds
+        if self.seeds:
+            _dict['seeds'] = self.seeds.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Persons:
-        """Create an instance of Persons from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OnboardedPersonaDetails from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Persons.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Persons.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Person.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "indices": obj.get("indices"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "seeds": Seeds.from_dict(obj["seeds"]) if obj.get("seeds") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/pkce.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/pkce.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,62 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.auth0 import Auth0
 from pieces_os_client.models.challenged_pkce import ChallengedPKCE
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.resulted_pkce import ResultedPKCE
 from pieces_os_client.models.revoked_pkce import RevokedPKCE
 from pieces_os_client.models.seeded_pkce import SeededPKCE
 from pieces_os_client.models.tokenized_pkce import TokenizedPKCE
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PKCE(BaseModel):
     """
-    An object representing all of the properties involved in a PKCE Authentication Flow  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    An object representing all of the properties involved in a PKCE Authentication Flow
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     result: Optional[ResultedPKCE] = None
     challenge: Optional[ChallengedPKCE] = None
     revocation: Optional[RevokedPKCE] = None
     seed: Optional[SeededPKCE] = None
     token: Optional[TokenizedPKCE] = None
     auth0: Optional[Auth0] = None
-    __properties = ["schema", "result", "challenge", "revocation", "seed", "token", "auth0"]
+    __properties: ClassVar[List[str]] = ["schema", "result", "challenge", "revocation", "seed", "token", "auth0"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PKCE:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PKCE from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of result
         if self.result:
             _dict['result'] = self.result.to_dict()
         # override the default output from pydantic by calling `to_dict()` of challenge
@@ -86,27 +102,27 @@
             _dict['token'] = self.token.to_dict()
         # override the default output from pydantic by calling `to_dict()` of auth0
         if self.auth0:
             _dict['auth0'] = self.auth0.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PKCE:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PKCE from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PKCE.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PKCE.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "result": ResultedPKCE.from_dict(obj.get("result")) if obj.get("result") is not None else None,
-            "challenge": ChallengedPKCE.from_dict(obj.get("challenge")) if obj.get("challenge") is not None else None,
-            "revocation": RevokedPKCE.from_dict(obj.get("revocation")) if obj.get("revocation") is not None else None,
-            "seed": SeededPKCE.from_dict(obj.get("seed")) if obj.get("seed") is not None else None,
-            "token": TokenizedPKCE.from_dict(obj.get("token")) if obj.get("token") is not None else None,
-            "auth0": Auth0.from_dict(obj.get("auth0")) if obj.get("auth0") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "result": ResultedPKCE.from_dict(obj["result"]) if obj.get("result") is not None else None,
+            "challenge": ChallengedPKCE.from_dict(obj["challenge"]) if obj.get("challenge") is not None else None,
+            "revocation": RevokedPKCE.from_dict(obj["revocation"]) if obj.get("revocation") is not None else None,
+            "seed": SeededPKCE.from_dict(obj["seed"]) if obj.get("seed") is not None else None,
+            "token": TokenizedPKCE.from_dict(obj["token"]) if obj.get("token") is not None else None,
+            "auth0": Auth0.from_dict(obj["auth0"]) if obj.get("auth0") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/platform_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/platform_enum.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class PlatformEnum(str, Enum):
     """
     This is an Enumeration for a Platform ie, WEB, MACOS, LINUX, WINDOWS
     """
 
@@ -36,12 +33,12 @@
     WINDOWS = 'WINDOWS'
     FUCHSIA = 'FUCHSIA'
     IOS = 'IOS'
     ANDROID = 'ANDROID'
     UNKNOWN = 'UNKNOWN'
 
     @classmethod
-    def from_json(cls, json_str: str) -> PlatformEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of PlatformEnum from a JSON string"""
-        return PlatformEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/precreated_external_provider_api_key.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/preupdated_external_provider_api_key.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,71 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.auth0_open_ai_user_metadata import Auth0OpenAIUserMetadata
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PrecreatedExternalProviderApiKey(BaseModel):
-    """
-    This is the input model for /external_provider/api_key/create  # noqa: E501
+class PreupdatedExternalProviderApiKey(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    user: StrictStr = Field(..., description="This is the ID of the User.")
-    open_ai: Optional[Auth0OpenAIUserMetadata] = Field(None, alias="open_AI")
-    __properties = ["schema", "user", "open_AI"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the endput model for \"/external_provider/api_key/update\". everything but the uder will be optional, anything that is defined will get an update.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    user: StrictStr
+    open_ai: Optional[Auth0OpenAIUserMetadata] = Field(default=None, alias="open_AI")
+    __properties: ClassVar[List[str]] = ["schema", "user", "open_AI"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PrecreatedExternalProviderApiKey:
-        """Create an instance of PrecreatedExternalProviderApiKey from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PreupdatedExternalProviderApiKey from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of open_ai
         if self.open_ai:
             _dict['open_AI'] = self.open_ai.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PrecreatedExternalProviderApiKey:
-        """Create an instance of PrecreatedExternalProviderApiKey from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PreupdatedExternalProviderApiKey from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PrecreatedExternalProviderApiKey.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PrecreatedExternalProviderApiKey.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "user": obj.get("user"),
-            "open_ai": Auth0OpenAIUserMetadata.from_dict(obj.get("open_AI")) if obj.get("open_AI") is not None else None
+            "open_AI": Auth0OpenAIUserMetadata.from_dict(obj["open_AI"]) if obj.get("open_AI") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/predeleted_external_provider_api_key.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/unchecked_os_update.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,67 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PredeletedExternalProviderApiKey(BaseModel):
-    """
-    This is a predeleted version relating to the /external_provider/api_key/delete endpoint.  This will ensure we remove this specific provider.(anything that is set to true we will reset to null within the database.)  # noqa: E501
+class UncheckedOSUpdate(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    user: StrictStr = Field(...)
-    open_ai: Optional[StrictBool] = Field(None, alias="open_AI")
-    __properties = ["schema", "user", "open_AI"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the input body for /os/update/check, just a placeholder for now.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    __properties: ClassVar[List[str]] = ["schema"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PredeletedExternalProviderApiKey:
-        """Create an instance of PredeletedExternalProviderApiKey from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UncheckedOSUpdate from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PredeletedExternalProviderApiKey:
-        """Create an instance of PredeletedExternalProviderApiKey from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UncheckedOSUpdate from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PredeletedExternalProviderApiKey.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PredeletedExternalProviderApiKey.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "user": obj.get("user"),
-            "open_ai": obj.get("open_AI")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/preupdated_external_provider_api_key.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_repository_analytics.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,71 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.auth0_open_ai_user_metadata import Auth0OpenAIUserMetadata
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PreupdatedExternalProviderApiKey(BaseModel):
-    """
-    This is the endput model for \"/external_provider/api_key/update\". everything but the uder will be optional, anything that is defined will get an update.  # noqa: E501
+class TLPCodeRepositoryAnalytics(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    user: StrictStr = Field(...)
-    open_ai: Optional[Auth0OpenAIUserMetadata] = Field(None, alias="open_AI")
-    __properties = ["schema", "user", "open_AI"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TLPCodeRepositoryAnalytics
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PreupdatedExternalProviderApiKey:
-        """Create an instance of PreupdatedExternalProviderApiKey from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPCodeRepositoryAnalytics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of open_ai
-        if self.open_ai:
-            _dict['open_AI'] = self.open_ai.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PreupdatedExternalProviderApiKey:
-        """Create an instance of PreupdatedExternalProviderApiKey from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPCodeRepositoryAnalytics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PreupdatedExternalProviderApiKey.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PreupdatedExternalProviderApiKey.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "user": obj.get("user"),
-            "open_ai": Auth0OpenAIUserMetadata.from_dict(obj.get("open_AI")) if obj.get("open_AI") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/preview.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/accessor.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,74 +14,93 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.referenced_format import ReferencedFormat
+from pieces_os_client.models.flattened_user_profile import FlattenedUserProfile
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Preview(BaseModel):
-    """
-    This is a preview Model that will hold references to at minimum the base preview. which can be potentiall a base image, or also base text/code and then the oveylay is another format(image/text/code) that is 'overlayed' ontop of the base format.  # noqa: E501
+class Accessor(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    base: ReferencedFormat = Field(...)
-    overlay: Optional[ReferencedFormat] = None
-    __properties = ["schema", "base", "overlay"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is used to determine who has accessed a share. and how many times.  The user here is the user that accessed this Piece.(optional) if undefined then this user was not logged in yet.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    os: StrictStr = Field(description="this is an os id.")
+    share: StrictStr
+    count: StrictInt = Field(description="how many times this user accessed this piece.")
+    user: Optional[FlattenedUserProfile] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "os", "share", "count", "user"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Preview:
-        """Create an instance of Preview from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Accessor from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of base
-        if self.base:
-            _dict['base'] = self.base.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of overlay
-        if self.overlay:
-            _dict['overlay'] = self.overlay.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of user
+        if self.user:
+            _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Preview:
-        """Create an instance of Preview from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Accessor from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Preview.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Preview.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "base": ReferencedFormat.from_dict(obj.get("base")) if obj.get("base") is not None else None,
-            "overlay": ReferencedFormat.from_dict(obj.get("overlay")) if obj.get("overlay") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "os": obj.get("os"),
+            "share": obj.get("share"),
+            "count": obj.get("count"),
+            "user": FlattenedUserProfile.from_dict(obj["user"]) if obj.get("user") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/privacy_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/privacy_enum.py`

 * *Files 17% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class PrivacyEnum(str, Enum):
     """
     OPEN: Means that privacy is fully open CLOSED: Means that privacy is fully locked down, and private ANONYMOUS: Means that we are allowed to collect information but it cannot get attached to me as the user.
     """
 
@@ -31,12 +28,12 @@
     allowed enum values
     """
     OPEN = 'OPEN'
     CLOSED = 'CLOSED'
     ANONYMOUS = 'ANONYMOUS'
 
     @classmethod
-    def from_json(cls, json_str: str) -> PrivacyEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of PrivacyEnum from a JSON string"""
-        return PrivacyEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/pseudo_assets.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_activity.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,69 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_assets import FlattenedAssets
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PseudoAssets(BaseModel):
-    """
-    This is a model of all optional properties, that will get returned from /assets/pseudo.  # noqa: E501
+class ReferencedActivity(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    identifiers: Optional[FlattenedAssets] = None
-    __properties = ["schema", "identifiers"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ReferencedActivity
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedActivity] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PseudoAssets:
-        """Create an instance of PseudoAssets from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedActivity from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of identifiers
-        if self.identifiers:
-            _dict['identifiers'] = self.identifiers.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of reference
+        if self.reference:
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PseudoAssets:
-        """Create an instance of PseudoAssets from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedActivity from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PseudoAssets.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PseudoAssets.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "identifiers": FlattenedAssets.from_dict(obj.get("identifiers")) if obj.get("identifiers") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedActivity.from_dict(obj["reference"]) if obj.get("reference") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.flattened_activity import FlattenedActivity
+# TODO: Rewrite to not use raise_errors
+ReferencedActivity.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_agent_related_routes.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_agent_related_routes.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,65 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class QGPTAgentRelatedRoutes(BaseModel):
     """
-    This is specific for all the related materials, like people, tags, websites... xyz  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    people: Optional[StrictBool] = Field(None, description="optional bool, that will say if we reccomend to run related.people on this conversation, IFF set to TRUE.")
-    __properties = ["schema", "people"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is specific for all the related materials, like people, tags, websites... xyz
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    people: Optional[StrictBool] = Field(default=None, description="optional bool, that will say if we reccomend to run related.people on this conversation, IFF set to TRUE.")
+    __properties: ClassVar[List[str]] = ["schema", "people"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTAgentRelatedRoutes:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of QGPTAgentRelatedRoutes from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTAgentRelatedRoutes:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of QGPTAgentRelatedRoutes from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTAgentRelatedRoutes.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTAgentRelatedRoutes.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "people": obj.get("people")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_agent_routes.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_agent_routes.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.qgpt_agent_related_routes import QGPTAgentRelatedRoutes
+from typing import Optional, Set
+from typing_extensions import Self
 
 class QGPTAgentRoutes(BaseModel):
     """
-    This is apart of the Output and will let the plugin developer know if we reccomend to run specific agent functionality/routes. for instance, related.people, code classification...xyz, for now we start with relatedPeople.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is apart of the Output and will let the plugin developer know if we reccomend to run specific agent functionality/routes. for instance, related.people, code classification...xyz, for now we start with relatedPeople.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     related: Optional[QGPTAgentRelatedRoutes] = None
-    __properties = ["schema", "related"]
+    __properties: ClassVar[List[str]] = ["schema", "related"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTAgentRoutes:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of QGPTAgentRoutes from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of related
         if self.related:
             _dict['related'] = self.related.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTAgentRoutes:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of QGPTAgentRoutes from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTAgentRoutes.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTAgentRoutes.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "related": QGPTAgentRelatedRoutes.from_dict(obj.get("related")) if obj.get("related") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "related": QGPTAgentRelatedRoutes.from_dict(obj["related"]) if obj.get("related") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_conversation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_pipeline_for_contextualized_code_dialog.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.qgpt_conversation_message import QGPTConversationMessage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class QGPTConversation(BaseModel):
-    """
-    QGPTConversation
+class QGPTConversationPipelineForContextualizedCodeDialog(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: Optional[conlist(QGPTConversationMessage)] = None
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is for the users that wants to have contextualized code conversations, meaning conversations around code with Context provided.  This is a class so that we can add optional properties in the future.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    __properties: ClassVar[List[str]] = ["schema"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTConversation:
-        """Create an instance of QGPTConversation from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTConversationPipelineForContextualizedCodeDialog from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTConversation:
-        """Create an instance of QGPTConversation from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTConversationPipelineForContextualizedCodeDialog from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTConversation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTConversation.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [QGPTConversationMessage.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_conversation_message.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/open_ai_models_list_input.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,74 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
-from pieces_os_client.models.qgpt_conversation_message_role_enum import QGPTConversationMessageRoleEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class QGPTConversationMessage(BaseModel):
-    """
-    This will take a single message, and a role.  # noqa: E501
+class OpenAIModelsListInput(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    text: StrictStr = Field(...)
-    role: QGPTConversationMessageRoleEnum = Field(...)
-    timestamp: GroupedTimestamp = Field(...)
-    __properties = ["schema", "text", "role", "timestamp"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the input model for the /open_ai/models/list endpoint.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    user: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "user"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTConversationMessage:
-        """Create an instance of QGPTConversationMessage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OpenAIModelsListInput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of timestamp
-        if self.timestamp:
-            _dict['timestamp'] = self.timestamp.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTConversationMessage:
-        """Create an instance of QGPTConversationMessage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OpenAIModelsListInput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTConversationMessage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTConversationMessage.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "text": obj.get("text"),
-            "role": obj.get("role"),
-            "timestamp": GroupedTimestamp.from_dict(obj.get("timestamp")) if obj.get("timestamp") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "user": obj.get("user")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_hints_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_user_allocation_metadata.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,75 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.qgpt_question_answer import QGPTQuestionAnswer
-from pieces_os_client.models.relevant_qgpt_seeds import RelevantQGPTSeeds
-
-class QGPTHintsInput(BaseModel):
-    """
-    Query is your hints question. Relevant is the relevant snippets. Answer is the previous answer.(that we are asking a hint up for.)  Query and Answer are both optional here because, you may pass over relevant snippets over ahead of hand if you already have them to answer your questions.  # noqa: E501
+class Auth0UserAllocationMetadata(BaseModel):
     """
-    query: Optional[StrictStr] = None
-    answer: Optional[QGPTQuestionAnswer] = None
-    relevant: RelevantQGPTSeeds = Field(...)
-    application: Optional[StrictStr] = Field(None, description="optional application id")
-    model: Optional[StrictStr] = Field(None, description="optional model id")
-    __properties = ["query", "answer", "relevant", "application", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is specifically for our allocation server metadata.
+    """ # noqa: E501
+    project: StrictStr
+    region: StrictStr
+    __properties: ClassVar[List[str]] = ["project", "region"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTHintsInput:
-        """Create an instance of QGPTHintsInput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Auth0UserAllocationMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of answer
-        if self.answer:
-            _dict['answer'] = self.answer.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of relevant
-        if self.relevant:
-            _dict['relevant'] = self.relevant.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTHintsInput:
-        """Create an instance of QGPTHintsInput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Auth0UserAllocationMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTHintsInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTHintsInput.parse_obj({
-            "query": obj.get("query"),
-            "answer": QGPTQuestionAnswer.from_dict(obj.get("answer")) if obj.get("answer") is not None else None,
-            "relevant": RelevantQGPTSeeds.from_dict(obj.get("relevant")) if obj.get("relevant") is not None else None,
-            "application": obj.get("application"),
-            "model": obj.get("model")
+        _obj = cls.model_validate({
+            "project": obj.get("project"),
+            "region": obj.get("region")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_persons_related_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_persons_related_input.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,79 +14,95 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.qgpt_conversation import QGPTConversation
 from pieces_os_client.models.seed import Seed
+from typing import Optional, Set
+from typing_extensions import Self
 
 class QGPTPersonsRelatedInput(BaseModel):
     """
-    This is used for /qgpt/persons/related.  will accept a seed, or conversation all optionally.   # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is used for /qgpt/persons/related.  will accept a seed, or conversation all optionally. 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     seed: Optional[Seed] = None
     conversation: Optional[QGPTConversation] = None
-    application: Optional[StrictStr] = Field(None, description="optional application id")
-    model: Optional[StrictStr] = Field(None, description="optional model id")
-    __properties = ["schema", "seed", "conversation", "application", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    application: Optional[StrictStr] = Field(default=None, description="optional application id")
+    model: Optional[StrictStr] = Field(default=None, description="optional model id")
+    __properties: ClassVar[List[str]] = ["schema", "seed", "conversation", "application", "model"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTPersonsRelatedInput:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of QGPTPersonsRelatedInput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of seed
         if self.seed:
             _dict['seed'] = self.seed.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversation
         if self.conversation:
             _dict['conversation'] = self.conversation.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTPersonsRelatedInput:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of QGPTPersonsRelatedInput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTPersonsRelatedInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTPersonsRelatedInput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "seed": Seed.from_dict(obj.get("seed")) if obj.get("seed") is not None else None,
-            "conversation": QGPTConversation.from_dict(obj.get("conversation")) if obj.get("conversation") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "seed": Seed.from_dict(obj["seed"]) if obj.get("seed") is not None else None,
+            "conversation": QGPTConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
             "application": obj.get("application"),
             "model": obj.get("model")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_persons_related_output.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_persons_related_output.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,71 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.persons import Persons
+from typing import Optional, Set
+from typing_extensions import Self
 
 class QGPTPersonsRelatedOutput(BaseModel):
     """
-    This model is used for the output of the /qgpt/related/persons endpoint.  Explanations here is a custom object with key value pairs, when the key is the personUUId and the value is an explanation as to why this person was reccommended.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    persons: Persons = Field(...)
-    explanations: Optional[Dict[str, StrictStr]] = Field(None, description="This is a Map<String, String> where the the key is a person id. and the value is the explanation.")
-    __properties = ["schema", "persons", "explanations"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This model is used for the output of the /qgpt/related/persons endpoint.  Explanations here is a custom object with key value pairs, when the key is the personUUId and the value is an explanation as to why this person was reccommended.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    persons: Persons
+    explanations: Optional[Dict[str, StrictStr]] = Field(default=None, description="This is a Map<String, String> where the the key is a person id. and the value is the explanation.")
+    __properties: ClassVar[List[str]] = ["schema", "persons", "explanations"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTPersonsRelatedOutput:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of QGPTPersonsRelatedOutput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of persons
         if self.persons:
             _dict['persons'] = self.persons.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTPersonsRelatedOutput:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of QGPTPersonsRelatedOutput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTPersonsRelatedOutput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTPersonsRelatedOutput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "persons": Persons.from_dict(obj.get("persons")) if obj.get("persons") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "persons": Persons.from_dict(obj["persons"]) if obj.get("persons") is not None else None,
             "explanations": obj.get("explanations")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_question_answer.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_question_answer.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,67 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
 from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class QGPTQuestionAnswer(BaseModel):
     """
-    This will be a simple model with a score and a text value that will represent the value returned for this answer.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    score: Union[StrictFloat, StrictInt] = Field(..., description="This is the score from 0-1 on how good this answer is.")
-    text: StrictStr = Field(...)
-    __properties = ["schema", "score", "text"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will be a simple model with a score and a text value that will represent the value returned for this answer.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    score: Union[StrictFloat, StrictInt] = Field(description="This is the score from 0-1 on how good this answer is.")
+    text: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "score", "text"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTQuestionAnswer:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of QGPTQuestionAnswer from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTQuestionAnswer:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of QGPTQuestionAnswer from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTQuestionAnswer.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTQuestionAnswer.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "score": obj.get("score"),
             "text": obj.get("text")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_question_answers.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/detected_external_application.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.qgpt_question_answer import QGPTQuestionAnswer
+from typing import Optional, Set
+from typing_extensions import Self
 
-class QGPTQuestionAnswers(BaseModel):
-    """
-    This is the plural of QGPTQuestionAnswer  # noqa: E501
+class DetectedExternalApplication(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(QGPTQuestionAnswer) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a detected External Application that comes from our endpoint that will get a snapshot of the installed applications on your machine.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    name: StrictStr = Field(description="this is the name of the application")
+    version: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "name", "version"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTQuestionAnswers:
-        """Create an instance of QGPTQuestionAnswers from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DetectedExternalApplication from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTQuestionAnswers:
-        """Create an instance of QGPTQuestionAnswers from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DetectedExternalApplication from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTQuestionAnswers.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTQuestionAnswers.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [QGPTQuestionAnswer.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "name": obj.get("name"),
+            "version": obj.get("version")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_question_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_application.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,81 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.application_name_enum import ApplicationNameEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_conversation_messages import FlattenedConversationMessages
-from pieces_os_client.models.relevant_qgpt_seeds import RelevantQGPTSeeds
+from pieces_os_client.models.platform_enum import PlatformEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class QGPTQuestionInput(BaseModel):
-    """
-    This is the body input for the /code_gpt/question.  Note: - each relevant seed, must require at minimum a Seed or an id used from the /code_gpt/relevance endpoint or we will throw an error.  # noqa: E501
+class TrackedApplication(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    relevant: RelevantQGPTSeeds = Field(...)
-    query: StrictStr = Field(..., description="This is the user asked question.")
-    application: Optional[StrictStr] = Field(None, description="optional application id")
-    model: Optional[StrictStr] = Field(None, description="optional model id")
-    messages: Optional[FlattenedConversationMessages] = None
-    __properties = ["schema", "relevant", "query", "application", "model", "messages"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A Model to describe what application a format/analytics event originated.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="The ID of the tracked application.")
+    name: ApplicationNameEnum
+    version: StrictStr = Field(description="This is the specific version number 0.0.0")
+    platform: PlatformEnum
+    automatic_unload: Optional[StrictBool] = Field(default=None, description="This is a proper that will let us know if we will proactivity unload all of your machine learning models.by default this is false.", alias="automaticUnload")
+    __properties: ClassVar[List[str]] = ["schema", "id", "name", "version", "platform", "automaticUnload"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTQuestionInput:
-        """Create an instance of QGPTQuestionInput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedApplication from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of relevant
-        if self.relevant:
-            _dict['relevant'] = self.relevant.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of messages
-        if self.messages:
-            _dict['messages'] = self.messages.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTQuestionInput:
-        """Create an instance of QGPTQuestionInput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedApplication from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTQuestionInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTQuestionInput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "relevant": RelevantQGPTSeeds.from_dict(obj.get("relevant")) if obj.get("relevant") is not None else None,
-            "query": obj.get("query"),
-            "application": obj.get("application"),
-            "model": obj.get("model"),
-            "messages": FlattenedConversationMessages.from_dict(obj.get("messages")) if obj.get("messages") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "name": obj.get("name"),
+            "version": obj.get("version"),
+            "platform": obj.get("platform"),
+            "automaticUnload": obj.get("automaticUnload")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_question_output.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_rename_metadata.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,69 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.qgpt_question_answers import QGPTQuestionAnswers
+from typing import Optional, Set
+from typing_extensions import Self
 
-class QGPTQuestionOutput(BaseModel):
-    """
-    This is the output/returned value from the /qgpt/question endpoint. && /qgpt/followup  This will just have a single required property. the possible answers to the question, with a score.  # noqa: E501
+class TrackedAssetEventRenameMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    answers: QGPTQuestionAnswers = Field(...)
-    __properties = ["schema", "answers"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will give specific metadata need to determine what the rename was to/from.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    previous: StrictStr
+    current: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "previous", "current"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTQuestionOutput:
-        """Create an instance of QGPTQuestionOutput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedAssetEventRenameMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of answers
-        if self.answers:
-            _dict['answers'] = self.answers.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTQuestionOutput:
-        """Create an instance of QGPTQuestionOutput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedAssetEventRenameMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTQuestionOutput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTQuestionOutput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "answers": QGPTQuestionAnswers.from_dict(obj.get("answers")) if obj.get("answers") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "previous": obj.get("previous"),
+            "current": obj.get("current")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_relevance_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_relevance_input.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,62 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_assets import FlattenedAssets
 from pieces_os_client.models.flattened_conversation_messages import FlattenedConversationMessages
 from pieces_os_client.models.qgpt_relevance_input_options import QGPTRelevanceInputOptions
 from pieces_os_client.models.seeds import Seeds
+from typing import Optional, Set
+from typing_extensions import Self
 
 class QGPTRelevanceInput(BaseModel):
     """
-    This is the input body for the /code_gpt/relevance endpoint.  There are a couple different options that you may take with this Model.  First we will talk about the space in which you will compare your query too. These are the following cases for the space. 1. provide an absolute path on the users machine that we can use locally. 2. provide Seeds that you want to compare to, which will be ONLY fragment/string values(all other values will be ignored) 3. provide assets, here you can provide an iterable of the asset id, and we will do the rest 4. you can set your database boolean to true which will tell us to use your entire DB as the query space.  Note: - for ease of use, we have an additional boolean called 'question', which will also ask your question to gpt3.5, and compare to the relevant snippets that we found. That way you dont need to call /code_gpt/question. Otherwise the next step would be is to take the results and feed them into /code_gpt/question. to get your question answered.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    query: StrictStr = Field(..., description="This is the question that the user is asking.")
-    paths: Optional[conlist(StrictStr)] = Field(None, description="This is an optional list of file || folder paths.")
+    This is the input body for the /code_gpt/relevance endpoint.  There are a couple different options that you may take with this Model.  First we will talk about the space in which you will compare your query too. These are the following cases for the space. 1. provide an absolute path on the users machine that we can use locally. 2. provide Seeds that you want to compare to, which will be ONLY fragment/string values(all other values will be ignored) 3. provide assets, here you can provide an iterable of the asset id, and we will do the rest 4. you can set your database boolean to true which will tell us to use your entire DB as the query space.  Note: - for ease of use, we have an additional boolean called 'question', which will also ask your question to gpt3.5, and compare to the relevant snippets that we found. That way you dont need to call /code_gpt/question. Otherwise the next step would be is to take the results and feed them into /code_gpt/question. to get your question answered.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    query: StrictStr = Field(description="This is the question that the user is asking.")
+    paths: Optional[List[StrictStr]] = Field(default=None, description="This is an optional list of file || folder paths.")
     seeds: Optional[Seeds] = None
     assets: Optional[FlattenedAssets] = None
     messages: Optional[FlattenedConversationMessages] = None
     options: Optional[QGPTRelevanceInputOptions] = None
-    application: Optional[StrictStr] = Field(None, description="optional application id")
-    model: Optional[StrictStr] = Field(None, description="optional model id")
-    __properties = ["schema", "query", "paths", "seeds", "assets", "messages", "options", "application", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    application: Optional[StrictStr] = Field(default=None, description="optional application id")
+    model: Optional[StrictStr] = Field(default=None, description="optional model id")
+    __properties: ClassVar[List[str]] = ["schema", "query", "paths", "seeds", "assets", "messages", "options", "application", "model"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTRelevanceInput:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of QGPTRelevanceInput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of seeds
         if self.seeds:
             _dict['seeds'] = self.seeds.to_dict()
         # override the default output from pydantic by calling `to_dict()` of assets
@@ -80,29 +96,29 @@
             _dict['messages'] = self.messages.to_dict()
         # override the default output from pydantic by calling `to_dict()` of options
         if self.options:
             _dict['options'] = self.options.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTRelevanceInput:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of QGPTRelevanceInput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTRelevanceInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTRelevanceInput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "query": obj.get("query"),
             "paths": obj.get("paths"),
-            "seeds": Seeds.from_dict(obj.get("seeds")) if obj.get("seeds") is not None else None,
-            "assets": FlattenedAssets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "messages": FlattenedConversationMessages.from_dict(obj.get("messages")) if obj.get("messages") is not None else None,
-            "options": QGPTRelevanceInputOptions.from_dict(obj.get("options")) if obj.get("options") is not None else None,
+            "seeds": Seeds.from_dict(obj["seeds"]) if obj.get("seeds") is not None else None,
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "messages": FlattenedConversationMessages.from_dict(obj["messages"]) if obj.get("messages") is not None else None,
+            "options": QGPTRelevanceInputOptions.from_dict(obj["options"]) if obj.get("options") is not None else None,
             "application": obj.get("application"),
             "model": obj.get("model")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_relevance_input_options.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/auth0_open_ai_user_metadata.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,67 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class QGPTRelevanceInputOptions(BaseModel):
-    """
-    QGPTRelevanceInputOptions
+class Auth0OpenAIUserMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    database: Optional[StrictBool] = Field(None, description="This is an optional boolen that will tell us to use our entire snippet database as the sample.")
-    question: Optional[StrictBool] = Field(None, description="This is an optional boolean, that will let the serve know if you want to combine the 2 endpointsboth relevance && the Question endpoint to return the final results.")
-    __properties = ["schema", "database", "question"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Only supporting a single api key per user.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    api_key: Optional[StrictStr] = None
+    api_key_name: Optional[StrictStr] = None
+    organization_key: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "api_key", "api_key_name", "organization_key"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTRelevanceInputOptions:
-        """Create an instance of QGPTRelevanceInputOptions from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Auth0OpenAIUserMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTRelevanceInputOptions:
-        """Create an instance of QGPTRelevanceInputOptions from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Auth0OpenAIUserMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTRelevanceInputOptions.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTRelevanceInputOptions.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "database": obj.get("database"),
-            "question": obj.get("question")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "api_key": obj.get("api_key"),
+            "api_key_name": obj.get("api_key_name"),
+            "organization_key": obj.get("organization_key")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_relevance_output.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_relevance_output.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.qgpt_question_output import QGPTQuestionOutput
 from pieces_os_client.models.relevant_qgpt_seeds import RelevantQGPTSeeds
+from typing import Optional, Set
+from typing_extensions import Self
 
 class QGPTRelevanceOutput(BaseModel):
     """
-    This is the returned value from /code_gpt/relevance.  This will return the snippets that we found are relevant to the query you provided.  (optional) answer: in the case you provided question: true, then we will also return to you the answer to your question.  Note: - relevant: this is required property and will represent the relevant snippets, to your specific query.(NOTE: these snippet will all have respective id's and seed defined. even though id and seed are optional)  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is the returned value from /code_gpt/relevance.  This will return the snippets that we found are relevant to the query you provided.  (optional) answer: in the case you provided question: true, then we will also return to you the answer to your question.  Note: - relevant: this is required property and will represent the relevant snippets, to your specific query.(NOTE: these snippet will all have respective id's and seed defined. even though id and seed are optional)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     answer: Optional[QGPTQuestionOutput] = None
-    relevant: RelevantQGPTSeeds = Field(...)
-    __properties = ["schema", "answer", "relevant"]
+    relevant: RelevantQGPTSeeds
+    __properties: ClassVar[List[str]] = ["schema", "answer", "relevant"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTRelevanceOutput:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of QGPTRelevanceOutput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of answer
         if self.answer:
             _dict['answer'] = self.answer.to_dict()
         # override the default output from pydantic by calling `to_dict()` of relevant
         if self.relevant:
             _dict['relevant'] = self.relevant.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTRelevanceOutput:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of QGPTRelevanceOutput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTRelevanceOutput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTRelevanceOutput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "answer": QGPTQuestionOutput.from_dict(obj.get("answer")) if obj.get("answer") is not None else None,
-            "relevant": RelevantQGPTSeeds.from_dict(obj.get("relevant")) if obj.get("relevant") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "answer": QGPTQuestionOutput.from_dict(obj["answer"]) if obj.get("answer") is not None else None,
+            "relevant": RelevantQGPTSeeds.from_dict(obj["relevant"]) if obj.get("relevant") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_reprompt_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_anchor_point.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.anchor_type_enum import AnchorTypeEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.qgpt_conversation import QGPTConversation
+from pieces_os_client.models.platform_enum import PlatformEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class QGPTRepromptInput(BaseModel):
-    """
-    Query is your followup question.  Conversation is a list of the back and fourth with the qgpt bot. where the first entry in the array was the last message sent.  # noqa: E501
+class SeededAnchorPoint(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    query: StrictStr = Field(...)
-    conversation: QGPTConversation = Field(...)
-    application: Optional[StrictStr] = Field(None, description="optional application id")
-    model: Optional[StrictStr] = Field(None, description="optional model id")
-    __properties = ["schema", "query", "conversation", "application", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SeededAnchorPoint
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    type: AnchorTypeEnum
+    watch: Optional[StrictBool] = None
+    fullpath: StrictStr
+    anchor: StrictStr = Field(description="Cannot create an AnchorPoint w/o a Anchor.")
+    platform: Optional[PlatformEnum] = None
+    __properties: ClassVar[List[str]] = ["schema", "type", "watch", "fullpath", "anchor", "platform"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTRepromptInput:
-        """Create an instance of QGPTRepromptInput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededAnchorPoint from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of conversation
-        if self.conversation:
-            _dict['conversation'] = self.conversation.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTRepromptInput:
-        """Create an instance of QGPTRepromptInput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededAnchorPoint from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTRepromptInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTRepromptInput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "query": obj.get("query"),
-            "conversation": QGPTConversation.from_dict(obj.get("conversation")) if obj.get("conversation") is not None else None,
-            "application": obj.get("application"),
-            "model": obj.get("model")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "type": obj.get("type"),
+            "watch": obj.get("watch"),
+            "fullpath": obj.get("fullpath"),
+            "anchor": obj.get("anchor"),
+            "platform": obj.get("platform")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_reprompt_output.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline_for_code_explanation.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,65 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class QGPTRepromptOutput(BaseModel):
-    """
-    QGPTRepromptOutput
+class QGPTTaskPipelineForCodeExplanation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    query: StrictStr = Field(...)
-    __properties = ["schema", "query"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This task is for explaining a bit of code.  This is a class so that we can add optional properties in the future.  Note: the snippet && language that needs to be explaned should be within the QGPTQuestionInput.relevant
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    __properties: ClassVar[List[str]] = ["schema"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTRepromptOutput:
-        """Create an instance of QGPTRepromptOutput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTTaskPipelineForCodeExplanation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTRepromptOutput:
-        """Create an instance of QGPTRepromptOutput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTTaskPipelineForCodeExplanation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTRepromptOutput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTRepromptOutput.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "query": obj.get("query")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_stream_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_stream_enum.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class QGPTStreamEnum(str, Enum):
     """
     This is a specific Enum used for the QGPT Stream.
     """
 
@@ -36,12 +33,12 @@
     COMPLETED = 'COMPLETED'
     FAILED = 'FAILED'
     UNKNOWN = 'UNKNOWN'
     STOPPED = 'STOPPED'
     RESET = 'RESET'
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTStreamEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of QGPTStreamEnum from a JSON string"""
-        return QGPTStreamEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_stream_input.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_relevance_input_options.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,77 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.qgpt_prompt_pipeline import QGPTPromptPipeline
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-from pieces_os_client.models.qgpt_question_input import QGPTQuestionInput
-from pieces_os_client.models.qgpt_relevance_input import QGPTRelevanceInput
-
-class QGPTStreamInput(BaseModel):
-    """
-    This is the input for the /qgpt/stream endpoint.  # noqa: E501
+class QGPTRelevanceInputOptions(BaseModel):
     """
-    relevance: Optional[QGPTRelevanceInput] = None
-    question: Optional[QGPTQuestionInput] = None
-    request: Optional[StrictStr] = Field(None, description="This is an optional Id you can use to identify the result from your request.")
-    conversation: Optional[StrictStr] = Field(None, description="This is the ID of a predefined persisted conversation, if this is not present we will create a new conversation for the input/output.(in the case of a question)")
-    stop: Optional[StrictBool] = None
-    agent: Optional[StrictBool] = Field(None, description="This will let us know if we want to run the agent routing as well, this is default to true. However if set to false you will save on processing and you will recieve null for the agentRoutes class on the QGPTStreamOutput.")
-    __properties = ["relevance", "question", "request", "conversation", "stop", "agent"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    QGPTRelevanceInputOptions
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    database: Optional[StrictBool] = Field(default=None, description="This is an optional boolen that will tell us to use our entire snippet database as the sample.")
+    question: Optional[StrictBool] = Field(default=None, description="This is an optional boolean, that will let the serve know if you want to combine the 2 endpointsboth relevance && the Question endpoint to return the final results.")
+    pipeline: Optional[QGPTPromptPipeline] = None
+    __properties: ClassVar[List[str]] = ["schema", "database", "question", "pipeline"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTStreamInput:
-        """Create an instance of QGPTStreamInput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTRelevanceInputOptions from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of relevance
-        if self.relevance:
-            _dict['relevance'] = self.relevance.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of question
-        if self.question:
-            _dict['question'] = self.question.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of pipeline
+        if self.pipeline:
+            _dict['pipeline'] = self.pipeline.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTStreamInput:
-        """Create an instance of QGPTStreamInput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTRelevanceInputOptions from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTStreamInput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTStreamInput.parse_obj({
-            "relevance": QGPTRelevanceInput.from_dict(obj.get("relevance")) if obj.get("relevance") is not None else None,
-            "question": QGPTQuestionInput.from_dict(obj.get("question")) if obj.get("question") is not None else None,
-            "request": obj.get("request"),
-            "conversation": obj.get("conversation"),
-            "stop": obj.get("stop"),
-            "agent": obj.get("agent")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "database": obj.get("database"),
+            "question": obj.get("question"),
+            "pipeline": QGPTPromptPipeline.from_dict(obj["pipeline"]) if obj.get("pipeline") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/qgpt_stream_output.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_reprompt_input.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,91 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.qgpt_conversation import QGPTConversation
+from pieces_os_client.models.qgpt_prompt_pipeline import QGPTPromptPipeline
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional, Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
-from pieces_os_client.models.qgpt_agent_routes import QGPTAgentRoutes
-from pieces_os_client.models.qgpt_question_output import QGPTQuestionOutput
-from pieces_os_client.models.qgpt_relevance_output import QGPTRelevanceOutput
-from pieces_os_client.models.qgpt_stream_enum import QGPTStreamEnum
-
-class QGPTStreamOutput(BaseModel):
-    """
-    This is the out for the /qgpt/stream endpoint.  200: success 401: invalid authentication/api key 429: Rate limit/Quota exceeded 500: server had an error 503: the engine is currently overloaded  # noqa: E501
+class QGPTRepromptInput(BaseModel):
     """
-    request: Optional[StrictStr] = Field(None, description="This is the id used to represent the stream of response. this will always be present. We will use the value passed inby the client, or we will generate one.")
-    relevance: Optional[QGPTRelevanceOutput] = None
-    question: Optional[QGPTQuestionOutput] = None
-    status: Optional[QGPTStreamEnum] = None
-    conversation: StrictStr = Field(..., description="This is the ID of a predefined persisted conversation, if this is not present we will create a new conversation for the input/output.(in the case of a question)")
-    status_code: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="statusCode", description="This will be provided")
-    error_message: Optional[StrictStr] = Field(None, alias="errorMessage", description="optional error message is the status code is NOT 200")
-    agent_routes: Optional[QGPTAgentRoutes] = Field(None, alias="agentRoutes")
-    __properties = ["request", "relevance", "question", "status", "conversation", "statusCode", "errorMessage", "agentRoutes"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Query is your followup question.  Conversation is a list of the back and fourth with the qgpt bot. where the first entry in the array was the last message sent.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    query: StrictStr
+    conversation: QGPTConversation
+    application: Optional[StrictStr] = Field(default=None, description="optional application id")
+    model: Optional[StrictStr] = Field(default=None, description="optional model id")
+    pipeline: Optional[QGPTPromptPipeline] = None
+    __properties: ClassVar[List[str]] = ["schema", "query", "conversation", "application", "model", "pipeline"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> QGPTStreamOutput:
-        """Create an instance of QGPTStreamOutput from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTRepromptInput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of relevance
-        if self.relevance:
-            _dict['relevance'] = self.relevance.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of question
-        if self.question:
-            _dict['question'] = self.question.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of agent_routes
-        if self.agent_routes:
-            _dict['agentRoutes'] = self.agent_routes.to_dict()
-        # set to None if status_code (nullable) is None
-        # and __fields_set__ contains the field
-        if self.status_code is None and "status_code" in self.__fields_set__:
-            _dict['statusCode'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of conversation
+        if self.conversation:
+            _dict['conversation'] = self.conversation.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of pipeline
+        if self.pipeline:
+            _dict['pipeline'] = self.pipeline.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> QGPTStreamOutput:
-        """Create an instance of QGPTStreamOutput from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTRepromptInput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return QGPTStreamOutput.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = QGPTStreamOutput.parse_obj({
-            "request": obj.get("request"),
-            "relevance": QGPTRelevanceOutput.from_dict(obj.get("relevance")) if obj.get("relevance") is not None else None,
-            "question": QGPTQuestionOutput.from_dict(obj.get("question")) if obj.get("question") is not None else None,
-            "status": obj.get("status"),
-            "conversation": obj.get("conversation"),
-            "status_code": obj.get("statusCode"),
-            "error_message": obj.get("errorMessage"),
-            "agent_routes": QGPTAgentRoutes.from_dict(obj.get("agentRoutes")) if obj.get("agentRoutes") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "query": obj.get("query"),
+            "conversation": QGPTConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
+            "application": obj.get("application"),
+            "model": obj.get("model"),
+            "pipeline": QGPTPromptPipeline.from_dict(obj["pipeline"]) if obj.get("pipeline") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/reaction.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/reaction.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,77 +14,93 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.reuse_reaction import ReuseReaction
 from pieces_os_client.models.seeded_connector_creation import SeededConnectorCreation
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Reaction(BaseModel):
     """
-    This will the the Request body of the Request Endpoint.  Reuse will not be required here because we do NOT know if the user will choose to reuse what we have suggested.  save will however be required because this will let us know if we should save the coppied asset that was first sent over or not.  seed is required, because we will want to know 100% sure what the original suggestion was made against.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    save: StrictBool = Field(..., description="This will just be a simple boolean here that will say if the use should save the asset or not.")
+    This will the the Request body of the Request Endpoint.  Reuse will not be required here because we do NOT know if the user will choose to reuse what we have suggested.  save will however be required because this will let us know if we should save the coppied asset that was first sent over or not.  seed is required, because we will want to know 100% sure what the original suggestion was made against.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    save: StrictBool = Field(description="This will just be a simple boolean here that will say if the use should save the asset or not.")
     reuse: Optional[ReuseReaction] = None
-    seed: SeededConnectorCreation = Field(...)
-    __properties = ["schema", "save", "reuse", "seed"]
+    seed: SeededConnectorCreation
+    __properties: ClassVar[List[str]] = ["schema", "save", "reuse", "seed"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Reaction:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Reaction from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reuse
         if self.reuse:
             _dict['reuse'] = self.reuse.to_dict()
         # override the default output from pydantic by calling `to_dict()` of seed
         if self.seed:
             _dict['seed'] = self.seed.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Reaction:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Reaction from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Reaction.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Reaction.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "save": obj.get("save"),
-            "reuse": ReuseReaction.from_dict(obj.get("reuse")) if obj.get("reuse") is not None else None,
-            "seed": SeededConnectorCreation.from_dict(obj.get("seed")) if obj.get("seed") is not None else None
+            "reuse": ReuseReaction.from_dict(obj["reuse"]) if obj.get("reuse") is not None else None,
+            "seed": SeededConnectorCreation.from_dict(obj["seed"]) if obj.get("seed") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/recipients.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_distributions.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.person_basic_type import PersonBasicType
+from pieces_os_client.models.referenced_distribution import ReferencedDistribution
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Recipients(BaseModel):
-    """
-    This an iterable of People that are attached to a specific distribution ie, slack, maigun, ...etc  # noqa: E501
+class FlattenedDistributions(BaseModel):
     """
-    iterable: conlist(PersonBasicType) = Field(...)
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    __properties = ["iterable", "schema"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    FlattenedDistributions
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[ReferencedDistribution]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Recipients:
-        """Create an instance of Recipients from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedDistributions from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Recipients:
-        """Create an instance of Recipients from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedDistributions from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Recipients.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Recipients.parse_obj({
-            "iterable": [PersonBasicType.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ReferencedDistribution.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_activity.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_anchor_point.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,79 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedActivity(BaseModel):
-    """
-    ReferencedActivity
+class ReferencedAnchorPoint(BaseModel):
     """
+    ReferencedAnchorPoint
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedAnchorPoint] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedActivity] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedActivity:
-        """Create an instance of ReferencedActivity from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedAnchorPoint from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedActivity:
-        """Create an instance of ReferencedActivity from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedAnchorPoint from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedActivity.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedActivity.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedActivity.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedAnchorPoint.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.flattened_anchor_point import FlattenedAnchorPoint
+# TODO: Rewrite to not use raise_errors
+ReferencedAnchorPoint.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.flattened_activity import FlattenedActivity
-
-# ReferencedActivity.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_anchor.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_distribution.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,79 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.flattened_distribution import FlattenedDistribution
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedAnchor(BaseModel):
-    """
-    This is the referenced version of a Anchor, main used for the uuid.  # noqa: E501
+class ReferencedDistribution(BaseModel):
     """
+    
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedDistribution] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedAnchor] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedAnchor:
-        """Create an instance of ReferencedAnchor from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedDistribution from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedAnchor:
-        """Create an instance of ReferencedAnchor from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedDistribution from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedAnchor.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedAnchor.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedAnchor.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedDistribution.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_anchor import FlattenedAnchor
-
-# ReferencedAnchor.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_anchor_point.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_user.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,79 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.flattened_user_profile import FlattenedUserProfile
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedAnchorPoint(BaseModel):
-    """
-    ReferencedAnchorPoint
+class ReferencedUser(BaseModel):
     """
+    A object to reference a user's ID and optionally a FlattenedUserProfile Instance 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedUserProfile] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedAnchorPoint] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedAnchorPoint:
-        """Create an instance of ReferencedAnchorPoint from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedUser from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedAnchorPoint:
-        """Create an instance of ReferencedAnchorPoint from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedUser from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedAnchorPoint.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedAnchorPoint.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedAnchorPoint.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedUserProfile.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_anchor_point import FlattenedAnchorPoint
-
-# ReferencedAnchorPoint.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_annotation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_annotation.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,79 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ReferencedAnnotation(BaseModel):
     """
-    This is the referenced version of a annotation, main used for the uuid.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
+    This is the referenced version of a annotation, main used for the uuid.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
     reference: Optional[FlattenedAnnotation] = None
-    __properties = ["schema", "id", "reference"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedAnnotation:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ReferencedAnnotation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedAnnotation:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ReferencedAnnotation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedAnnotation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedAnnotation.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedAnnotation.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedAnnotation.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.flattened_annotation import FlattenedAnnotation
+# TODO: Rewrite to not use raise_errors
+ReferencedAnnotation.model_rebuild(raise_errors=False)
 
-# ReferencedAnnotation.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_hint.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,79 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedAsset(BaseModel):
-    """
-    A reference to a asset, which at minimum must have the asset's id. But in the case of a hydrated client API it may have a populated reference of type Asset.  # noqa: E501
+class ReferencedHint(BaseModel):
     """
+    This is the referenced version of a hint, main used for the uuid.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedHint] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedAsset] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedAsset:
-        """Create an instance of ReferencedAsset from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedHint from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedAsset:
-        """Create an instance of ReferencedAsset from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedHint from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedAsset.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedAsset.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedHint.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.flattened_hint import FlattenedHint
+# TODO: Rewrite to not use raise_errors
+ReferencedHint.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.flattened_asset import FlattenedAsset
-
-# ReferencedAsset.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_conversation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_anchor.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,79 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedConversation(BaseModel):
-    """
-    This is a DAG-Safe Minimal version of a Conversation.  # noqa: E501
+class ReferencedAnchor(BaseModel):
     """
+    This is the referenced version of a Anchor, main used for the uuid.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedAnchor] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedConversation] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedConversation:
-        """Create an instance of ReferencedConversation from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedAnchor from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedConversation:
-        """Create an instance of ReferencedConversation from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedAnchor from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedConversation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedConversation.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedConversation.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedAnchor.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.flattened_anchor import FlattenedAnchor
+# TODO: Rewrite to not use raise_errors
+ReferencedAnchor.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.flattened_conversation import FlattenedConversation
-
-# ReferencedConversation.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_conversation_message.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_conversation_message.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,83 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ReferencedConversationMessage(BaseModel):
     """
-    This is a DAG-Safe Minimal version of a ConversationMessage.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
+    This is a DAG-Safe Minimal version of a ConversationMessage.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
     reference: Optional[FlattenedConversationMessage] = None
-    __properties = ["schema", "id", "reference"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedConversationMessage:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ReferencedConversationMessage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedConversationMessage:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ReferencedConversationMessage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedConversationMessage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedConversationMessage.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedConversationMessage.from_dict(
-                    obj.get("reference")
-                )
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedConversationMessage.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.flattened_conversation_message import FlattenedConversationMessage
+# TODO: Rewrite to not use raise_errors
+ReferencedConversationMessage.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.flattened_conversation_message import (
-    FlattenedConversationMessage,
-)
-
-# ReferencedConversationMessage.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_distribution.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_website.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,71 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_distribution import FlattenedDistribution
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ReferencedDistribution(BaseModel):
-    """
-      # noqa: E501
+class ReferencedWebsite(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedDistribution] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ReferencedWebsite
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedWebsite] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedDistribution:
-        """Create an instance of ReferencedDistribution from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedWebsite from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
             _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedDistribution:
-        """Create an instance of ReferencedDistribution from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedWebsite from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedDistribution.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedDistribution.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
-            "reference": FlattenedDistribution.from_dict(obj.get("reference")) if obj.get("reference") is not None else None
+            "reference": FlattenedWebsite.from_dict(obj["reference"]) if obj.get("reference") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.flattened_website import FlattenedWebsite
+# TODO: Rewrite to not use raise_errors
+ReferencedWebsite.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_format.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_sensitive.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,79 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedFormat(BaseModel):
-    """
-    A reference to a format which at minimum must have the format's id. But in the case of a hydrated client API it may have a populated reference of type Format.  # noqa: E501
+class ReferencedSensitive(BaseModel):
     """
+    A reference to a sensitive which at minimum must have the Sensitive id. But in the case of a hydrated client API it may have a populated reference of type Sensitive.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedSensitive] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="The id of the Format")
-    reference: Optional[FlattenedFormat] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedFormat:
-        """Create an instance of ReferencedFormat from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedSensitive from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedFormat:
-        """Create an instance of ReferencedFormat from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedSensitive from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedFormat.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedFormat.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedFormat.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedSensitive.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.flattened_sensitive import FlattenedSensitive
+# TODO: Rewrite to not use raise_errors
+ReferencedSensitive.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.flattened_format import FlattenedFormat
-
-# ReferencedFormat.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_hint.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_question_output.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,79 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.qgpt_question_answers import QGPTQuestionAnswers
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedHint(BaseModel):
-    """
-    This is the referenced version of a hint, main used for the uuid.  # noqa: E501
+class QGPTQuestionOutput(BaseModel):
     """
+    This is the output/returned value from the /qgpt/question endpoint. && /qgpt/followup  This will just have a single required property. the possible answers to the question, with a score.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    answers: QGPTQuestionAnswers
+    __properties: ClassVar[List[str]] = ["schema", "answers"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedHint] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedHint:
-        """Create an instance of ReferencedHint from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTQuestionOutput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of reference
-        if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of answers
+        if self.answers:
+            _dict['answers'] = self.answers.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedHint:
-        """Create an instance of ReferencedHint from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTQuestionOutput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedHint.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedHint.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedHint.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "answers": QGPTQuestionAnswers.from_dict(obj["answers"]) if obj.get("answers") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_hint import FlattenedHint
-
-# ReferencedHint.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_model.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_model.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,65 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ReferencedModel(BaseModel):
     """
-    *****NOTE:***** This is the basic referencedModel, for Now since we dont have a FlattenedModel, im going to simply not include the reference, because I do NOT want to attach a Model here (would cause breaking changes if we switched from a Model -> a flattenedModel). and (2) we are under going Model changes to the Model, so would cause issues.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    __properties = ["schema", "id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    *****NOTE:***** This is the basic referencedModel, for Now since we dont have a FlattenedModel, im going to simply not include the reference, because I do NOT want to attach a Model here (would cause breaking changes if we switched from a Model -> a flattenedModel). and (2) we are under going Model changes to the Model, so would cause issues.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedModel:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ReferencedModel from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedModel:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ReferencedModel from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedModel.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedModel.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_person.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_image_processing.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,79 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.graphical_image_statistics import GraphicalImageStatistics
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedPerson(BaseModel):
-    """
-    [DAG Safe] version of a Person Model.   # noqa: E501
+class GraphicalImageProcessing(BaseModel):
     """
+    GraphicalImageProcessing
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    statistics: Optional[GraphicalImageStatistics] = None
+    __properties: ClassVar[List[str]] = ["schema", "statistics"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedPerson] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedPerson:
-        """Create an instance of ReferencedPerson from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GraphicalImageProcessing from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of reference
-        if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of statistics
+        if self.statistics:
+            _dict['statistics'] = self.statistics.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedPerson:
-        """Create an instance of ReferencedPerson from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GraphicalImageProcessing from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedPerson.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedPerson.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedPerson.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "statistics": GraphicalImageStatistics.from_dict(obj["statistics"]) if obj.get("statistics") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_person import FlattenedPerson
-
-# ReferencedPerson.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_sensitive.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_score.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,79 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedSensitive(BaseModel):
-    """
-    A reference to a sensitive which at minimum must have the Sensitive id. But in the case of a hydrated client API it may have a populated reference of type Sensitive.  # noqa: E501
+class SeededScore(BaseModel):
     """
+    This is the low level seeded score and will let us know what exactly we want to increment on our material.  Note: ONLY include one of these, as we will only increment one of the following.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    reuse: Optional[StrictBool] = None
+    update: Optional[StrictBool] = None
+    reference: Optional[StrictBool] = None
+    priority: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["schema", "reuse", "update", "reference", "priority"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedSensitive] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedSensitive:
-        """Create an instance of ReferencedSensitive from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededScore from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of reference
-        if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedSensitive:
-        """Create an instance of ReferencedSensitive from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededScore from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedSensitive.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedSensitive.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedSensitive.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "reuse": obj.get("reuse"),
+            "update": obj.get("update"),
+            "reference": obj.get("reference"),
+            "priority": obj.get("priority")
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_sensitive import FlattenedSensitive
-
-# ReferencedSensitive.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_share.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_share.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,79 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ReferencedShare(BaseModel):
     """
-    This is a [DAG SAFE] version of a share. with just a required share ID.  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
+    This is a [DAG SAFE] version of a share. with just a required share ID.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
     reference: Optional[FlattenedShare] = None
-    __properties = ["schema", "id", "reference"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedShare:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ReferencedShare from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedShare:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ReferencedShare from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedShare.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedShare.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedShare.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedShare.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.flattened_share import FlattenedShare
+# TODO: Rewrite to not use raise_errors
+ReferencedShare.model_rebuild(raise_errors=False)
 
-# ReferencedShare.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_tag.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_format.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,79 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedTag(BaseModel):
-    """
-    [DAG Safe] version of a Tag Model.   # noqa: E501
+class ReferencedFormat(BaseModel):
     """
+    A reference to a format which at minimum must have the format's id. But in the case of a hydrated client API it may have a populated reference of type Format.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="The id of the Format")
+    reference: Optional[FlattenedFormat] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedTag] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedTag:
-        """Create an instance of ReferencedTag from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedFormat from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reference
         if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedTag:
-        """Create an instance of ReferencedTag from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedFormat from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedTag.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedTag.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedTag.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedFormat.from_dict(obj["reference"]) if obj.get("reference") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.flattened_format import FlattenedFormat
+# TODO: Rewrite to not use raise_errors
+ReferencedFormat.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.flattened_tag import FlattenedTag
-
-# ReferencedTag.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_user.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_website.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,71 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_user_profile import FlattenedUserProfile
+from pieces_os_client.models.mechanism_enum import MechanismEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ReferencedUser(BaseModel):
-    """
-    A object to reference a user's ID and optionally a FlattenedUserProfile Instance   # noqa: E501
+class SeededAssetWebsite(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedUserProfile] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is similar to an SeededWebsite, where this is the minimum information of a website, but this can get added to a seededAsset,  where you may not yet have an asset id.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    url: StrictStr
+    name: StrictStr
+    mechanism: Optional[MechanismEnum] = None
+    __properties: ClassVar[List[str]] = ["schema", "url", "name", "mechanism"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedUser:
-        """Create an instance of ReferencedUser from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededAssetWebsite from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of reference
-        if self.reference:
-            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedUser:
-        """Create an instance of ReferencedUser from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededAssetWebsite from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedUser.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedUser.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id"),
-            "reference": FlattenedUserProfile.from_dict(obj.get("reference")) if obj.get("reference") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "url": obj.get("url"),
+            "name": obj.get("name"),
+            "mechanism": obj.get("mechanism")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/referenced_website.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_mac_os_asset.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,79 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.application import Application
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-class ReferencedWebsite(BaseModel):
-    """
-    ReferencedWebsite
+class SeededMacOSAsset(BaseModel):
     """
+    An Seeded Asset specific to MacOS which takes in a Value, and Application
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    application: Optional[Application] = None
+    value: StrictStr = Field(description="The value of the text that you want to save as an asset.")
+    __properties: ClassVar[List[str]] = ["schema", "application", "value"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    reference: Optional[FlattenedWebsite] = None
-    __properties = ["schema", "id", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReferencedWebsite:
-        """Create an instance of ReferencedWebsite from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededMacOSAsset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of reference
-        if self.reference:
-            _dict["reference"] = self.reference.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of application
+        if self.application:
+            _dict['application'] = self.application.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReferencedWebsite:
-        """Create an instance of ReferencedWebsite from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededMacOSAsset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReferencedWebsite.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReferencedWebsite.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "id": obj.get("id"),
-                "reference": FlattenedWebsite.from_dict(obj.get("reference"))
-                if obj.get("reference") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "value": obj.get("value")
+        })
         return _obj
 
 
-from pieces_os_client.models.flattened_website import FlattenedWebsite
-
-# ReferencedWebsite.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/relationship.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/relationship.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,59 +14,75 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.edges import Edges
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.embeddings import Embeddings
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Relationship(BaseModel):
     """
-    A relationship expresses a graph of like types, to build a relationship graph.   To get the type of relationship, this is for ie Asset, tag, website, format ...etc, you will need to iterate through the edges and get the root or you can just get the first edge's type as a relationship can only be expressed through same type  # noqa: E501
-    """
-    id: StrictStr = Field(...)
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    embeddings: Embeddings = Field(...)
-    edges: Edges = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    A relationship expresses a graph of like types, to build a relationship graph.   To get the type of relationship, this is for ie Asset, tag, website, format ...etc, you will need to iterate through the edges and get the root or you can just get the first edge's type as a relationship can only be expressed through same type
+    """ # noqa: E501
+    id: StrictStr
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    embeddings: Embeddings
+    edges: Edges
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    __properties = ["id", "schema", "embeddings", "edges", "created", "updated", "deleted"]
+    __properties: ClassVar[List[str]] = ["id", "schema", "embeddings", "edges", "created", "updated", "deleted"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Relationship:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Relationship from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of embeddings
         if self.embeddings:
             _dict['embeddings'] = self.embeddings.to_dict()
         # override the default output from pydantic by calling `to_dict()` of edges
@@ -80,27 +96,27 @@
             _dict['updated'] = self.updated.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
             _dict['deleted'] = self.deleted.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Relationship:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Relationship from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Relationship.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Relationship.parse_obj({
+        _obj = cls.model_validate({
             "id": obj.get("id"),
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "embeddings": Embeddings.from_dict(obj.get("embeddings")) if obj.get("embeddings") is not None else None,
-            "edges": Edges.from_dict(obj.get("edges")) if obj.get("edges") is not None else None,
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "embeddings": Embeddings.from_dict(obj["embeddings"]) if obj.get("embeddings") is not None else None,
+            "edges": Edges.from_dict(obj["edges"]) if obj.get("edges") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/relevant_qgpt_seed.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/relevant_qgpt_seed.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,79 +14,95 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.referenced_asset import ReferencedAsset
 from pieces_os_client.models.seed import Seed
+from typing import Optional, Set
+from typing_extensions import Self
 
 class RelevantQGPTSeed(BaseModel):
     """
-    This is a generic model used, to wrap a seed, as well as give an identifier used to further identifiy this snippet.  Seed is optional here because you may just want to provide the id, and not the original seed.  id is also optional here as you may provide an id or not here.(however with specific endpoint this ID is a guarentee.)  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is a generic model used, to wrap a seed, as well as give an identifier used to further identifiy this snippet.  Seed is optional here because you may just want to provide the id, and not the original seed.  id is also optional here as you may provide an id or not here.(however with specific endpoint this ID is a guarentee.)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     id: Optional[StrictStr] = None
     seed: Optional[Seed] = None
-    path: Optional[StrictStr] = Field(None, description="This is an optional file path")
+    path: Optional[StrictStr] = Field(default=None, description="This is an optional file path")
     asset: Optional[ReferencedAsset] = None
-    __properties = ["schema", "id", "seed", "path", "asset"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "seed", "path", "asset"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RelevantQGPTSeed:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of RelevantQGPTSeed from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of seed
         if self.seed:
             _dict['seed'] = self.seed.to_dict()
         # override the default output from pydantic by calling `to_dict()` of asset
         if self.asset:
             _dict['asset'] = self.asset.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RelevantQGPTSeed:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of RelevantQGPTSeed from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RelevantQGPTSeed.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RelevantQGPTSeed.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
-            "seed": Seed.from_dict(obj.get("seed")) if obj.get("seed") is not None else None,
+            "seed": Seed.from_dict(obj["seed"]) if obj.get("seed") is not None else None,
             "path": obj.get("path"),
-            "asset": ReferencedAsset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None
+            "asset": ReferencedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/relevant_qgpt_seeds.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/relevant_qgpt_seeds.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.relevant_qgpt_seed import RelevantQGPTSeed
+from typing import Optional, Set
+from typing_extensions import Self
 
 class RelevantQGPTSeeds(BaseModel):
     """
-    This is a plural of RelevantQGPTSeed.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(RelevantQGPTSeed) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a plural of RelevantQGPTSeed.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[RelevantQGPTSeed]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RelevantQGPTSeeds:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of RelevantQGPTSeeds from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RelevantQGPTSeeds:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of RelevantQGPTSeeds from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RelevantQGPTSeeds.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RelevantQGPTSeeds.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [RelevantQGPTSeed.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [RelevantQGPTSeed.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/resulted_pkce.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/predeleted_external_provider_api_key.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,67 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ResultedPKCE(BaseModel):
-    """
-    A Model To Represent the Code Returned from a PKCE Response  # noqa: E501
+class PredeletedExternalProviderApiKey(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    code: StrictStr = Field(..., description="The PKCE Code to be used to access a Token.")
-    state: StrictStr = Field(..., description="Likely the state that will be returned which should match the requested state as well as the nonce")
-    __properties = ["schema", "code", "state"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a predeleted version relating to the /external_provider/api_key/delete endpoint.  This will ensure we remove this specific provider.(anything that is set to true we will reset to null within the database.)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    user: StrictStr
+    open_ai: Optional[StrictBool] = Field(default=None, alias="open_AI")
+    __properties: ClassVar[List[str]] = ["schema", "user", "open_AI"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ResultedPKCE:
-        """Create an instance of ResultedPKCE from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PredeletedExternalProviderApiKey from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ResultedPKCE:
-        """Create an instance of ResultedPKCE from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PredeletedExternalProviderApiKey from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ResultedPKCE.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ResultedPKCE.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "code": obj.get("code"),
-            "state": obj.get("state")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "user": obj.get("user"),
+            "open_AI": obj.get("open_AI")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/returned_user_profile.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/exported_database_format.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,69 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.user_profile import UserProfile
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ReturnedUserProfile(BaseModel):
-    """
-    This is a modle strictly for the purpose that when calling '/user' and other user related endpoints the UserProfile could potentially be null, so we needed a model to do that.  # noqa: E501
+class ExportedDatabaseFormat(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    user: Optional[UserProfile] = None
-    __properties = ["schema", "user"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ExportedDatabaseFormat
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="this is the id of the format")
+    raw: List[StrictInt] = Field(description="these are bytes.")
+    __properties: ClassVar[List[str]] = ["schema", "id", "raw"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReturnedUserProfile:
-        """Create an instance of ReturnedUserProfile from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ExportedDatabaseFormat from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of user
-        if self.user:
-            _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReturnedUserProfile:
-        """Create an instance of ReturnedUserProfile from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ExportedDatabaseFormat from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReturnedUserProfile.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReturnedUserProfile.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "user": UserProfile.from_dict(obj.get("user")) if obj.get("user") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "raw": obj.get("raw")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/reuse_reaction.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/ordered_metrics.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,65 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ReuseReaction(BaseModel):
-    """
-    if reuse was used in the reaction then we can provide the uuid of the asset that was reused.  # noqa: E501
+class OrderedMetrics(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: StrictStr = Field(...)
-    __properties = ["schema", "asset"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a returnable for the metrics/formats/ordered
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    ordered: List[StrictStr]
+    __properties: ClassVar[List[str]] = ["schema", "ordered"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReuseReaction:
-        """Create an instance of ReuseReaction from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OrderedMetrics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReuseReaction:
-        """Create an instance of ReuseReaction from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OrderedMetrics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReuseReaction.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReuseReaction.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "asset": obj.get("asset")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "ordered": obj.get("ordered")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/reuse_suggestion.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/exported_asset.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,71 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List
+from pieces_os_client.models.file_format import FileFormat
+from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool
-from pieces_os_client.models.assets import Assets
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-
-class ReuseSuggestion(BaseModel):
-    """
-    This is the ReuseSuggestion. Mainly creating an additional model here because I imagine that we will want to add some additional data to this in the future (potentially with more numerical data that is emitted from the ML Models)  **Note: suggested is required here because we will want to say if we suggested to take this action of reuse or not.  ** Thoughts here. We could potentially return Assets: which would be an iterable of assets in most relavent order for the user to reuse if they want.  # noqa: E501
+class ExportedAsset(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    suggested: StrictBool = Field(..., description="This is a boolean, that will say if you should or should not take action.")
-    assets: Assets = Field(...)
-    __properties = ["schema", "suggested", "assets"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a model for a minimum exported version of an asset.
+    """ # noqa: E501
+    name: StrictStr = Field(description="this is the title of the asset ")
+    description: StrictStr = Field(description="this is the description of the asset")
+    created: GroupedTimestamp
+    raw: FileFormat
+    __properties: ClassVar[List[str]] = ["name", "description", "created", "raw"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReuseSuggestion:
-        """Create an instance of ReuseSuggestion from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ExportedAsset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of assets
-        if self.assets:
-            _dict['assets'] = self.assets.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of created
+        if self.created:
+            _dict['created'] = self.created.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of raw
+        if self.raw:
+            _dict['raw'] = self.raw.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReuseSuggestion:
-        """Create an instance of ReuseSuggestion from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ExportedAsset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReuseSuggestion.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReuseSuggestion.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "suggested": obj.get("suggested"),
-            "assets": Assets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "description": obj.get("description"),
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "raw": FileFormat.from_dict(obj["raw"]) if obj.get("raw") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/revoked_pkce.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline_for_code_modification.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,67 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class RevokedPKCE(BaseModel):
-    """
-    A model to support revoking a Token Generated Through PKCE  The behaviour of this endpoint depends on the state of the Refresh Token Revocation Deletes Grant toggle.  If this toggle is enabled, then each revocation request invalidates not only the specific token, but all other tokens based on the same authorization grant.  This means that all Refresh Tokens that have been issued for the same user, application, and audience will be revoked. If this toggle is disabled, then only the refresh token is revoked, while the grant is left intact  # noqa: E501
+class QGPTTaskPipelineForCodeModification(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    client_id: StrictStr = Field(..., description="Your application's Client ID. The application should match the one the Refresh Token was issued for.")
-    token: StrictStr = Field(..., description="The Refresh Token you want to revoke.")
-    __properties = ["schema", "client_id", "token"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This task is for modifying a bit of code, IE modify this code to do xyz.  This is a class so that we can add optional properties in the future.  Note: the snippet && language that needs to be modified should be within the QGPTQuestionInput.relevant
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    instruction: Optional[StrictStr] = Field(default=None, description="This is the instruction that we will use to modify this snippet.")
+    __properties: ClassVar[List[str]] = ["schema", "instruction"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RevokedPKCE:
-        """Create an instance of RevokedPKCE from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTTaskPipelineForCodeModification from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RevokedPKCE:
-        """Create an instance of RevokedPKCE from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTTaskPipelineForCodeModification from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RevokedPKCE.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RevokedPKCE.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "client_id": obj.get("client_id"),
-            "token": obj.get("token")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "instruction": obj.get("instruction")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/role.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/role.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class Role(str, Enum):
     """
     This is the specific role of a format.
     """
 
@@ -32,12 +29,12 @@
     """
     ORIGINAL = 'ORIGINAL'
     ADDITIONAL = 'ADDITIONAL'
     BOTH = 'BOTH'
     PREVIEW = 'PREVIEW'
 
     @classmethod
-    def from_json(cls, json_str: str) -> Role:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of Role from a JSON string"""
-        return Role(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/save_suggestion.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/file_metadata.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,65 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SaveSuggestion(BaseModel):
-    """
-    This is the SaveSuggestion. Mainly creating an additional model here because I imagine that we will want to add some additional data to this in the future (potentially with more numerical data that is emitted from the ML Models)  **Note: suggested is required here because we will want to say if we reccomend to take this action of save or not.  # noqa: E501
+class FileMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    suggested: StrictBool = Field(..., description="This is a boolean, that will say if you should or should not take action.")
-    __properties = ["schema", "suggested"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a model for metadata of a file!
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    name: Optional[StrictStr] = Field(default=None, description="This is the name of your file.")
+    ext: Optional[ClassificationSpecificEnum] = None
+    size: Optional[StrictInt] = Field(default=None, description="This is the size(in bytes)")
+    __properties: ClassVar[List[str]] = ["schema", "name", "ext", "size"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SaveSuggestion:
-        """Create an instance of SaveSuggestion from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FileMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SaveSuggestion:
-        """Create an instance of SaveSuggestion from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FileMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SaveSuggestion.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SaveSuggestion.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "suggested": obj.get("suggested")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "name": obj.get("name"),
+            "ext": obj.get("ext"),
+            "size": obj.get("size")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/score.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline_for_code_fix.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,75 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Score(BaseModel):
-    """
-    This is use as the score for an asset.  Manual: will be the raw sum of the asset activity events ranks with mechanismEnum == manual Automatic: will be the raw sum of the asset activity events ranks with mechanismEnum == automatic  # noqa: E501
+class QGPTTaskPipelineForCodeFix(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    manual: StrictInt = Field(..., description="These are points assigned via manual user driven events.")
-    automatic: StrictInt = Field(..., description="These are point assigned via automatic activity events.")
-    priority: Optional[StrictInt] = None
-    reuse: Optional[StrictInt] = None
-    update: Optional[StrictInt] = None
-    reference: Optional[StrictInt] = None
-    __properties = ["schema", "manual", "automatic", "priority", "reuse", "update", "reference"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This task is for fixing a bit of code.  This is a class so that we can add optional properties in the future.  Note: the snippet && language that needs to be fixed should be within the QGPTQuestionInput.relevant.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    error: Optional[StrictStr] = Field(default=None, description="This is the error message provided from the IDE, that we can use to provide the solution.")
+    __properties: ClassVar[List[str]] = ["schema", "error"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Score:
-        """Create an instance of Score from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTTaskPipelineForCodeFix from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Score:
-        """Create an instance of Score from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTTaskPipelineForCodeFix from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Score.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Score.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "manual": obj.get("manual"),
-            "automatic": obj.get("automatic"),
-            "priority": obj.get("priority"),
-            "reuse": obj.get("reuse"),
-            "update": obj.get("update"),
-            "reference": obj.get("reference")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "error": obj.get("error")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/searched_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_assets_recommendation.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,80 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
-from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr
-from pieces_os_client.models.asset import Asset
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.assets import Assets
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.searched_match_enum import SearchedMatchEnum
+from pieces_os_client.models.interacted_assets import InteractedAssets
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SearchedAsset(BaseModel):
-    """
-    This is a modle that will represent a searched asset!  # noqa: E501
+class SeededAssetsRecommendation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: Optional[Asset] = None
-    exact: StrictBool = Field(...)
-    score: Union[StrictFloat, StrictInt] = Field(...)
-    match: SearchedMatchEnum = Field(...)
-    identifier: StrictStr = Field(..., description="This is the uuid of the asset.")
-    pseudo: Optional[StrictBool] = Field(None, description="If this is a pseudo asset that was also returned.")
-    __properties = ["schema", "asset", "exact", "score", "match", "identifier", "pseudo"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the input data model for the /assets/recommend [GET] endpoint. It includes both a list of assets but also 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    assets: Assets
+    interactions: InteractedAssets
+    __properties: ClassVar[List[str]] = ["schema", "assets", "interactions"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SearchedAsset:
-        """Create an instance of SearchedAsset from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededAssetsRecommendation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of asset
-        if self.asset:
-            _dict['asset'] = self.asset.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of assets
+        if self.assets:
+            _dict['assets'] = self.assets.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of interactions
+        if self.interactions:
+            _dict['interactions'] = self.interactions.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SearchedAsset:
-        """Create an instance of SearchedAsset from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededAssetsRecommendation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SearchedAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SearchedAsset.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "asset": Asset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "exact": obj.get("exact"),
-            "score": obj.get("score"),
-            "match": obj.get("match"),
-            "identifier": obj.get("identifier"),
-            "pseudo": obj.get("pseudo")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "assets": Assets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "interactions": InteractedAssets.from_dict(obj["interactions"]) if obj.get("interactions") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/searched_assets.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_related_tags.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,77 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional, Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.searched_asset import SearchedAsset
+from pieces_os_client.models.seeded_discoverable_related_tag import SeededDiscoverableRelatedTag
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SearchedAssets(BaseModel):
-    """
-    This is a modle that will return fro mthe search endpoint that will just contain an array of assets!  # noqa: E501
+class SeededDiscoverableRelatedTags(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(SearchedAsset) = Field(...)
-    suggested: Union[StrictFloat, StrictInt] = Field(..., description="the number of fuzzy/suggested search results.")
-    exact: Union[StrictFloat, StrictInt] = Field(..., description="the number of exact results")
-    __properties = ["schema", "iterable", "suggested", "exact"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SeededDiscoverableRelatedTags
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[SeededDiscoverableRelatedTag]
+    application: StrictStr = Field(description="This is the application id that this request is sent from.")
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "application"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SearchedAssets:
-        """Create an instance of SearchedAssets from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededDiscoverableRelatedTags from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SearchedAssets:
-        """Create an instance of SearchedAssets from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededDiscoverableRelatedTags from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SearchedAssets.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SearchedAssets.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [SearchedAsset.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "suggested": obj.get("suggested"),
-            "exact": obj.get("exact")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [SeededDiscoverableRelatedTag.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "application": obj.get("application")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/searched_match_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_directed_discovery_filter_enum.py`

 * *Files 23% similar despite different names*

```diff
@@ -9,40 +9,38 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class SearchedMatchEnum(str, Enum):
+class TLPDirectedDiscoveryFilterEnum(str, Enum):
     """
-    SearchedMatchEnum
+    Code block type like function, class, abstract
     """
 
     """
     allowed enum values
     """
-    TITLE = 'TITLE'
-    ANNOTATION = 'ANNOTATION'
-    HINT = 'HINT'
-    CONTENT = 'CONTENT'
-    FUZZY = 'FUZZY'
-    MULTIPLE = 'MULTIPLE'
-    TAGS = 'TAGS'
-    WEBSITES = 'WEBSITES'
-    PERSONS = 'PERSONS'
+    FUNCTION = 'FUNCTION'
+    METHOD = 'METHOD'
+    CLASS = 'CLASS'
+    STRUCT = 'STRUCT'
+    ABSTRACT = 'ABSTRACT'
+    COMMENT = 'COMMENT'
+    IMPORT = 'IMPORT'
+    IF = 'IF'
+    LOOP = 'LOOP'
+    RETURN = 'RETURN'
 
     @classmethod
-    def from_json(cls, json_str: str) -> SearchedMatchEnum:
-        """Create an instance of SearchedMatchEnum from a JSON string"""
-        return SearchedMatchEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of TLPDirectedDiscoveryFilterEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seed.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline_for_code_commentation.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,78 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_asset import SeededAsset
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Seed(BaseModel):
-    """
-    A seed Model used to wrap a format or asset  # noqa: E501
+class QGPTTaskPipelineForCodeCommentation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: Optional[SeededAsset] = None
-    type: StrictStr = Field(...)
-    __properties = ["schema", "asset", "type"]
-
-    @validator('type')
-    def type_validate_enum(cls, value):
-        """Validates the enum"""
-        if value not in ('SEEDED_FORMAT', 'SEEDED_ASSET'):
-            raise ValueError("must be one of enum values ('SEEDED_FORMAT', 'SEEDED_ASSET')")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This task is for commenting a bit of code.  This is a class so that we can add optional properties in the future.  Note: the snippet && language that needs to be commented should be within the QGPTQuestionInput.relevant
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    __properties: ClassVar[List[str]] = ["schema"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Seed:
-        """Create an instance of Seed from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTTaskPipelineForCodeCommentation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of asset
-        if self.asset:
-            _dict['asset'] = self.asset.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Seed:
-        """Create an instance of Seed from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTTaskPipelineForCodeCommentation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Seed.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Seed.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "asset": SeededAsset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "type": obj.get("type")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_accessor.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_directory_analytics.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_user_profile import FlattenedUserProfile
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededAccessor(BaseModel):
-    """
-    This is a pre-created accessor that simply takes an os id and an optional user(flattened)  # noqa: E501
+class TLPCodeDirectoryAnalytics(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    os: StrictStr = Field(..., description="this is an os id.")
-    user: Optional[FlattenedUserProfile] = None
-    share: StrictStr = Field(..., description="this is the share that the asset is apart of.")
-    __properties = ["schema", "os", "user", "share"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TLPCodeDirectoryAnalytics
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAccessor:
-        """Create an instance of SeededAccessor from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPCodeDirectoryAnalytics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of user
-        if self.user:
-            _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAccessor:
-        """Create an instance of SeededAccessor from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPCodeDirectoryAnalytics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAccessor.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAccessor.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "os": obj.get("os"),
-            "user": FlattenedUserProfile.from_dict(obj.get("user")) if obj.get("user") is not None else None,
-            "share": obj.get("share")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_activity.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_conversation_message.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,96 +14,109 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
-from pieces_os_client.models.application import Application
-from pieces_os_client.models.mechanism_enum import MechanismEnum
-from pieces_os_client.models.referenced_asset import ReferencedAsset
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.conversation_message_sentiment_enum import ConversationMessageSentimentEnum
+from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.fragment_format import FragmentFormat
+from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from pieces_os_client.models.model import Model
+from pieces_os_client.models.qgpt_conversation_message_role_enum import QGPTConversationMessageRoleEnum
 from pieces_os_client.models.referenced_conversation import ReferencedConversation
-from pieces_os_client.models.referenced_format import ReferencedFormat
-from pieces_os_client.models.referenced_user import ReferencedUser
-from pieces_os_client.models.seeded_connector_tracking import SeededConnectorTracking
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededActivity(BaseModel):
-    """
-    This is the preseed to a full blown Activity.  This is the minimum information needed to create an Activity, used within our [POST] /activities/create  if mechenism is not passed in we will default to AUTOMATIC  NOT required to pass in an asset/user/format.  # noqa: E501
+class SeededConversationMessage(BaseModel):
     """
-    event: SeededConnectorTracking = Field(...)
-    application: Application = Field(...)
-    asset: Optional[ReferencedAsset] = None
-    user: Optional[ReferencedUser] = None
-    format: Optional[ReferencedFormat] = None
-    mechanism: Optional[MechanismEnum] = None
+    This is a seeded version of a ConversationMessage.  conversation is optional, this is because it can be used within the SeededConversation, however if this is passed into the /messages/create w/o a conversation uuid then we will throw an error.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    created: Optional[GroupedTimestamp] = None
+    model: Optional[Model] = None
+    fragment: FragmentFormat
     conversation: Optional[ReferencedConversation] = None
-    __properties = ["event", "application", "asset", "user", "format", "mechanism", "conversation"]
+    sentiment: Optional[ConversationMessageSentimentEnum] = None
+    role: QGPTConversationMessageRoleEnum
+    __properties: ClassVar[List[str]] = ["schema", "created", "model", "fragment", "conversation", "sentiment", "role"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededActivity:
-        """Create an instance of SeededActivity from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededConversationMessage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of event
-        if self.event:
-            _dict['event'] = self.event.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of application
-        if self.application:
-            _dict['application'] = self.application.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of asset
-        if self.asset:
-            _dict['asset'] = self.asset.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of user
-        if self.user:
-            _dict['user'] = self.user.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of format
-        if self.format:
-            _dict['format'] = self.format.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of created
+        if self.created:
+            _dict['created'] = self.created.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of model
+        if self.model:
+            _dict['model'] = self.model.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of fragment
+        if self.fragment:
+            _dict['fragment'] = self.fragment.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversation
         if self.conversation:
             _dict['conversation'] = self.conversation.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededActivity:
-        """Create an instance of SeededActivity from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededConversationMessage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededActivity.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededActivity.parse_obj({
-            "event": SeededConnectorTracking.from_dict(obj.get("event")) if obj.get("event") is not None else None,
-            "application": Application.from_dict(obj.get("application")) if obj.get("application") is not None else None,
-            "asset": ReferencedAsset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "user": ReferencedUser.from_dict(obj.get("user")) if obj.get("user") is not None else None,
-            "format": ReferencedFormat.from_dict(obj.get("format")) if obj.get("format") is not None else None,
-            "mechanism": obj.get("mechanism"),
-            "conversation": ReferencedConversation.from_dict(obj.get("conversation")) if obj.get("conversation") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "model": Model.from_dict(obj["model"]) if obj.get("model") is not None else None,
+            "fragment": FragmentFormat.from_dict(obj["fragment"]) if obj.get("fragment") is not None else None,
+            "conversation": ReferencedConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
+            "sentiment": obj.get("sentiment"),
+            "role": obj.get("role")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_anchor.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_anchor.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,89 +14,105 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.anchor_type_enum import AnchorTypeEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.platform_enum import PlatformEnum
 from pieces_os_client.models.seeded_annotation import SeededAnnotation
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededAnchor(BaseModel):
     """
     SeededAnchor
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    type: AnchorTypeEnum = Field(...)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    type: AnchorTypeEnum
     watch: Optional[StrictBool] = None
-    fullpath: StrictStr = Field(...)
-    asset: Optional[StrictStr] = Field(None, description="You may associate a SeededAnchor with an asset")
+    fullpath: StrictStr
+    asset: Optional[StrictStr] = Field(default=None, description="You may associate a SeededAnchor with an asset")
     platform: Optional[PlatformEnum] = None
     name: Optional[StrictStr] = None
-    annotations: Optional[conlist(SeededAnnotation)] = None
+    annotations: Optional[List[SeededAnnotation]] = None
     conversation: Optional[StrictStr] = None
-    __properties = ["schema", "type", "watch", "fullpath", "asset", "platform", "name", "annotations", "conversation"]
+    __properties: ClassVar[List[str]] = ["schema", "type", "watch", "fullpath", "asset", "platform", "name", "annotations", "conversation"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAnchor:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededAnchor from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in annotations (list)
         _items = []
         if self.annotations:
             for _item in self.annotations:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['annotations'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAnchor:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededAnchor from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAnchor.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAnchor.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "type": obj.get("type"),
             "watch": obj.get("watch"),
             "fullpath": obj.get("fullpath"),
             "asset": obj.get("asset"),
             "platform": obj.get("platform"),
             "name": obj.get("name"),
-            "annotations": [SeededAnnotation.from_dict(_item) for _item in obj.get("annotations")] if obj.get("annotations") is not None else None,
+            "annotations": [SeededAnnotation.from_dict(_item) for _item in obj["annotations"]] if obj.get("annotations") is not None else None,
             "conversation": obj.get("conversation")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_annotation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_annotation.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,91 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.annotation_type_enum import AnnotationTypeEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_conversation_messages import FlattenedConversationMessages
 from pieces_os_client.models.mechanism_enum import MechanismEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededAnnotation(BaseModel):
     """
-    This is the percursor to a fully referenced Annotation.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is the percursor to a fully referenced Annotation.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     mechanism: Optional[MechanismEnum] = None
     asset: Optional[StrictStr] = None
     person: Optional[StrictStr] = None
-    type: AnnotationTypeEnum = Field(...)
-    text: StrictStr = Field(..., description="This is the text of the annotation.")
+    type: AnnotationTypeEnum
+    text: StrictStr = Field(description="This is the text of the annotation.")
     model: Optional[StrictStr] = None
     pseudo: Optional[StrictBool] = None
     favorited: Optional[StrictBool] = None
     anchor: Optional[StrictStr] = None
     conversation: Optional[StrictStr] = None
     messages: Optional[FlattenedConversationMessages] = None
-    __properties = ["schema", "mechanism", "asset", "person", "type", "text", "model", "pseudo", "favorited", "anchor", "conversation", "messages"]
+    __properties: ClassVar[List[str]] = ["schema", "mechanism", "asset", "person", "type", "text", "model", "pseudo", "favorited", "anchor", "conversation", "messages"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAnnotation:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededAnnotation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of messages
         if self.messages:
             _dict['messages'] = self.messages.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAnnotation:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededAnnotation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAnnotation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAnnotation.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "mechanism": obj.get("mechanism"),
             "asset": obj.get("asset"),
             "person": obj.get("person"),
             "type": obj.get("type"),
             "text": obj.get("text"),
             "model": obj.get("model"),
             "pseudo": obj.get("pseudo"),
             "favorited": obj.get("favorited"),
             "anchor": obj.get("anchor"),
             "conversation": obj.get("conversation"),
-            "messages": FlattenedConversationMessages.from_dict(obj.get("messages")) if obj.get("messages") is not None else None
+            "messages": FlattenedConversationMessages.from_dict(obj["messages"]) if obj.get("messages") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,62 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.application import Application
 from pieces_os_client.models.available_formats import AvailableFormats
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.seeded_asset_enrichment import SeededAssetEnrichment
 from pieces_os_client.models.seeded_asset_metadata import SeededAssetMetadata
 from pieces_os_client.models.seeded_format import SeededFormat
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededAsset(BaseModel):
     """
-    This is seed data that will be come an asset.  discovered: if set to true this seededAsset was discovered using one of our discovery endpoints.  pseudo: if this is an asset that a user did NOT explicitly save.  available: This is a model that is used within our '/assets/draft' endpoint that will emitt a seed with all the available format that one can generate based on the original seed that was passed in. ie if a png was passed in, we may  say that there is a text/code format available. If available formats is passed into the '/assets/create' we will short curcuit certain operations to speed up the process, for instance, if we determine that there is no text within this image then there is no sense in running ocr.   # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is seed data that will be come an asset.  discovered: if set to true this seededAsset was discovered using one of our discovery endpoints.  pseudo: if this is an asset that a user did NOT explicitly save.  available: This is a model that is used within our '/assets/draft' endpoint that will emitt a seed with all the available format that one can generate based on the original seed that was passed in. ie if a png was passed in, we may  say that there is a text/code format available. If available formats is passed into the '/assets/create' we will short curcuit certain operations to speed up the process, for instance, if we determine that there is no text within this image then there is no sense in running ocr. 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     metadata: Optional[SeededAssetMetadata] = None
-    application: Application = Field(...)
-    format: SeededFormat = Field(...)
+    application: Application
+    format: SeededFormat
     discovered: Optional[StrictBool] = None
     available: Optional[AvailableFormats] = None
     pseudo: Optional[StrictBool] = None
     enrichment: Optional[SeededAssetEnrichment] = None
-    __properties = ["schema", "metadata", "application", "format", "discovered", "available", "pseudo", "enrichment"]
+    demo: Optional[StrictBool] = Field(default=None, description="This will let us know if this asset was generated as a 'demo' snippet")
+    __properties: ClassVar[List[str]] = ["schema", "metadata", "application", "format", "discovered", "available", "pseudo", "enrichment", "demo"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAsset:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededAsset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
             _dict['metadata'] = self.metadata.to_dict()
         # override the default output from pydantic by calling `to_dict()` of application
@@ -83,28 +100,29 @@
             _dict['available'] = self.available.to_dict()
         # override the default output from pydantic by calling `to_dict()` of enrichment
         if self.enrichment:
             _dict['enrichment'] = self.enrichment.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAsset:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededAsset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAsset.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "metadata": SeededAssetMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None,
-            "application": Application.from_dict(obj.get("application")) if obj.get("application") is not None else None,
-            "format": SeededFormat.from_dict(obj.get("format")) if obj.get("format") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "metadata": SeededAssetMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None,
+            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "format": SeededFormat.from_dict(obj["format"]) if obj.get("format") is not None else None,
             "discovered": obj.get("discovered"),
-            "available": AvailableFormats.from_dict(obj.get("available")) if obj.get("available") is not None else None,
+            "available": AvailableFormats.from_dict(obj["available"]) if obj.get("available") is not None else None,
             "pseudo": obj.get("pseudo"),
-            "enrichment": SeededAssetEnrichment.from_dict(obj.get("enrichment")) if obj.get("enrichment") is not None else None
+            "enrichment": SeededAssetEnrichment.from_dict(obj["enrichment"]) if obj.get("enrichment") is not None else None,
+            "demo": obj.get("demo")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_enrichment.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_preview.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,71 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededAssetEnrichment(BaseModel):
-    """
-    This is a specific Model for the SeededAsset that will enable the developer to modify the enrichment levels of persons, tags, websites.  These enrichment levels will guarentee that the # of people/tags/websites do not eceeed the provided value, but will not guarentee a minimum.  # noqa: E501
+class FlattenedPreview(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    tags: Optional[StrictInt] = None
-    websites: Optional[StrictInt] = None
-    persons: Optional[StrictInt] = None
-    hints: Optional[StrictInt] = None
-    __properties = ["schema", "tags", "websites", "persons", "hints"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    These are the references of the formats **Only UUIDS**
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    base: StrictStr = Field(description="this is a reference(uuid) to the base format")
+    overlay: Optional[StrictStr] = Field(default=None, description="this is a reference(uuid) to the overlay format")
+    __properties: ClassVar[List[str]] = ["schema", "base", "overlay"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAssetEnrichment:
-        """Create an instance of SeededAssetEnrichment from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedPreview from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAssetEnrichment:
-        """Create an instance of SeededAssetEnrichment from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedPreview from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAssetEnrichment.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAssetEnrichment.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "tags": obj.get("tags"),
-            "websites": obj.get("websites"),
-            "persons": obj.get("persons"),
-            "hints": obj.get("hints")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "base": obj.get("base"),
+            "overlay": obj.get("overlay")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_metadata.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,67 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.seeded_anchor import SeededAnchor
 from pieces_os_client.models.seeded_annotation import SeededAnnotation
 from pieces_os_client.models.seeded_asset_sensitive import SeededAssetSensitive
 from pieces_os_client.models.seeded_asset_tag import SeededAssetTag
 from pieces_os_client.models.seeded_asset_website import SeededAssetWebsite
 from pieces_os_client.models.seeded_hint import SeededHint
 from pieces_os_client.models.seeded_person import SeededPerson
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededAssetMetadata(BaseModel):
     """
-    This is optional metadata sent with the SeededAsset and other SeededAssets ie (UE, Jetbrains...)  Note: if a user/develop didnt explicitly state a mechanism we will default to manual(user Driven only)  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    name: Optional[StrictStr] = Field(None, description="This is the name of the asset.")
+    This is optional metadata sent with the SeededAsset and other SeededAssets ie (UE, Jetbrains...)  Note: if a user/develop didnt explicitly state a mechanism we will default to manual(user Driven only)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    name: Optional[StrictStr] = Field(default=None, description="This is the name of the asset.")
     mechanism: Optional[MechanismEnum] = None
-    tags: Optional[conlist(SeededAssetTag)] = Field(None, description="(optional) can add some tags to associate to this asset.")
-    websites: Optional[conlist(SeededAssetWebsite)] = None
-    sensitives: Optional[conlist(SeededAssetSensitive)] = None
-    persons: Optional[conlist(SeededPerson)] = None
-    annotations: Optional[conlist(SeededAnnotation)] = None
-    hints: Optional[conlist(SeededHint)] = None
-    anchors: Optional[conlist(SeededAnchor)] = None
-    __properties = ["schema", "name", "mechanism", "tags", "websites", "sensitives", "persons", "annotations", "hints", "anchors"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    tags: Optional[List[SeededAssetTag]] = Field(default=None, description="(optional) can add some tags to associate to this asset.")
+    websites: Optional[List[SeededAssetWebsite]] = None
+    sensitives: Optional[List[SeededAssetSensitive]] = None
+    persons: Optional[List[SeededPerson]] = None
+    annotations: Optional[List[SeededAnnotation]] = None
+    hints: Optional[List[SeededHint]] = None
+    anchors: Optional[List[SeededAnchor]] = None
+    __properties: ClassVar[List[str]] = ["schema", "name", "mechanism", "tags", "websites", "sensitives", "persons", "annotations", "hints", "anchors"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAssetMetadata:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededAssetMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in tags (list)
         _items = []
         if self.tags:
             for _item in self.tags:
@@ -122,30 +138,30 @@
             for _item in self.anchors:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['anchors'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAssetMetadata:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededAssetMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAssetMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAssetMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "name": obj.get("name"),
             "mechanism": obj.get("mechanism"),
-            "tags": [SeededAssetTag.from_dict(_item) for _item in obj.get("tags")] if obj.get("tags") is not None else None,
-            "websites": [SeededAssetWebsite.from_dict(_item) for _item in obj.get("websites")] if obj.get("websites") is not None else None,
-            "sensitives": [SeededAssetSensitive.from_dict(_item) for _item in obj.get("sensitives")] if obj.get("sensitives") is not None else None,
-            "persons": [SeededPerson.from_dict(_item) for _item in obj.get("persons")] if obj.get("persons") is not None else None,
-            "annotations": [SeededAnnotation.from_dict(_item) for _item in obj.get("annotations")] if obj.get("annotations") is not None else None,
-            "hints": [SeededHint.from_dict(_item) for _item in obj.get("hints")] if obj.get("hints") is not None else None,
-            "anchors": [SeededAnchor.from_dict(_item) for _item in obj.get("anchors")] if obj.get("anchors") is not None else None
+            "tags": [SeededAssetTag.from_dict(_item) for _item in obj["tags"]] if obj.get("tags") is not None else None,
+            "websites": [SeededAssetWebsite.from_dict(_item) for _item in obj["websites"]] if obj.get("websites") is not None else None,
+            "sensitives": [SeededAssetSensitive.from_dict(_item) for _item in obj["sensitives"]] if obj.get("sensitives") is not None else None,
+            "persons": [SeededPerson.from_dict(_item) for _item in obj["persons"]] if obj.get("persons") is not None else None,
+            "annotations": [SeededAnnotation.from_dict(_item) for _item in obj["annotations"]] if obj.get("annotations") is not None else None,
+            "hints": [SeededHint.from_dict(_item) for _item in obj["hints"]] if obj.get("hints") is not None else None,
+            "anchors": [SeededAnchor.from_dict(_item) for _item in obj["anchors"]] if obj.get("anchors") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_sensitive.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_sensitive.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,84 +14,100 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.sensitive_category_enum import SensitiveCategoryEnum
 from pieces_os_client.models.sensitive_metadata import SensitiveMetadata
 from pieces_os_client.models.sensitive_severity_enum import SensitiveSeverityEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededAssetSensitive(BaseModel):
     """
-    This is the seededAssetSensitive, this does not have an id yet as we will add it on the server side.  can optionally pass in our mechanism here, as the default will be manual unless specified.  This is different that hte SeededSensitive as this is pre-before the asset has been created.(but added when the asset is created.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    text: StrictStr = Field(..., description="this is the string representative of the sensative piece of data.")
+    This is the seededAssetSensitive, this does not have an id yet as we will add it on the server side.  can optionally pass in our mechanism here, as the default will be manual unless specified.  This is different that hte SeededSensitive as this is pre-before the asset has been created.(but added when the asset is created.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    text: StrictStr = Field(description="this is the string representative of the sensative piece of data.")
     mechanism: Optional[MechanismEnum] = None
-    category: SensitiveCategoryEnum = Field(...)
-    severity: SensitiveSeverityEnum = Field(...)
-    name: StrictStr = Field(...)
-    description: StrictStr = Field(...)
+    category: SensitiveCategoryEnum
+    severity: SensitiveSeverityEnum
+    name: StrictStr
+    description: StrictStr
     metadata: Optional[SensitiveMetadata] = None
-    __properties = ["schema", "text", "mechanism", "category", "severity", "name", "description", "metadata"]
+    __properties: ClassVar[List[str]] = ["schema", "text", "mechanism", "category", "severity", "name", "description", "metadata"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAssetSensitive:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededAssetSensitive from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
             _dict['metadata'] = self.metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAssetSensitive:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededAssetSensitive from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAssetSensitive.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAssetSensitive.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "text": obj.get("text"),
             "mechanism": obj.get("mechanism"),
             "category": obj.get("category"),
             "severity": obj.get("severity"),
             "name": obj.get("name"),
             "description": obj.get("description"),
-            "metadata": SensitiveMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None
+            "metadata": SensitiveMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_tag.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/text_location.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,71 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.mechanism_enum import MechanismEnum
-from pieces_os_client.models.tag_category_enum import TagCategoryEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededAssetTag(BaseModel):
-    """
-    This is similar to an SeededTag, where this is the minimum information of a tag, but this can get added to a seededAsset,  where you may not yet have an asset id.  # noqa: E501
+class TextLocation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    text: StrictStr = Field(..., description="this is the text that represents the tag.")
-    mechanism: Optional[MechanismEnum] = None
-    category: Optional[TagCategoryEnum] = None
-    __properties = ["schema", "text", "mechanism", "category"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a generic model that is used for text location.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    text: StrictStr = Field(description="this is the value that was found.")
+    start: StrictInt = Field(description="this is the start index within the original string.")
+    end: StrictInt = Field(description="this is the end index within the original string.")
+    __properties: ClassVar[List[str]] = ["schema", "text", "start", "end"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAssetTag:
-        """Create an instance of SeededAssetTag from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TextLocation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAssetTag:
-        """Create an instance of SeededAssetTag from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TextLocation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAssetTag.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAssetTag.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "text": obj.get("text"),
-            "mechanism": obj.get("mechanism"),
-            "category": obj.get("category")
+            "start": obj.get("start"),
+            "end": obj.get("end")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_tags.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/asset_filters.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,67 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.filter_operation_type_enum import FilterOperationTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from pieces_os_client.models.seeded_asset_tag import SeededAssetTag
-
-class SeededAssetTags(BaseModel):
-    """
-    SeededAssetTags
+class AssetFilters(BaseModel):
     """
-    iterable: conlist(SeededAssetTag) = Field(...)
-    __properties = ["iterable"]
+    AssetFilters
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[AssetFilter]
+    type: Optional[FilterOperationTypeEnum] = None
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAssetTags:
-        """Create an instance of SeededAssetTags from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AssetFilters from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAssetTags:
-        """Create an instance of SeededAssetTags from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AssetFilters from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAssetTags.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAssetTags.parse_obj({
-            "iterable": [SeededAssetTag.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [AssetFilter.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "type": obj.get("type")
         })
         return _obj
 
+from pieces_os_client.models.asset_filter import AssetFilter
+# TODO: Rewrite to not use raise_errors
+AssetFilters.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_asset_website.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/unsegmented_technical_language.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,70 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.mechanism_enum import MechanismEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededAssetWebsite(BaseModel):
-    """
-    This is similar to an SeededWebsite, where this is the minimum information of a website, but this can get added to a seededAsset,  where you may not yet have an asset id.  # noqa: E501
+class UnsegmentedTechnicalLanguage(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    url: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    mechanism: Optional[MechanismEnum] = None
-    __properties = ["schema", "url", "name", "mechanism"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the input model for '/machine_learning/text/technical_language/parsers/segmentation'  This will take the unsegmentedText here!
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    value: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "value"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAssetWebsite:
-        """Create an instance of SeededAssetWebsite from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UnsegmentedTechnicalLanguage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAssetWebsite:
-        """Create an instance of SeededAssetWebsite from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UnsegmentedTechnicalLanguage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAssetWebsite.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAssetWebsite.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "url": obj.get("url"),
-            "name": obj.get("name"),
-            "mechanism": obj.get("mechanism")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "value": obj.get("value")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_assets_recommendation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/format_metric.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,75 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
-from pieces_os_client.models.assets import Assets
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification_generic_enum import ClassificationGenericEnum
+from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.interacted_assets import InteractedAssets
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededAssetsRecommendation(BaseModel):
-    """
-    This is the input data model for the /assets/recommend [GET] endpoint. It includes both a list of assets but also   # noqa: E501
+class FormatMetric(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    assets: Assets = Field(...)
-    interactions: InteractedAssets = Field(...)
-    __properties = ["schema", "assets", "interactions"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    FormatMetric  This is a model that will represent the about of specific formats. ie Generic: 'CODE' specific: 'DART' identifiers: ['FormatUID1, 'FormatUID2']
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    generic: ClassificationGenericEnum
+    specific: ClassificationSpecificEnum
+    identifiers: List[StrictStr] = Field(description="this is a list of format ids")
+    __properties: ClassVar[List[str]] = ["schema", "generic", "specific", "identifiers"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededAssetsRecommendation:
-        """Create an instance of SeededAssetsRecommendation from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FormatMetric from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of assets
-        if self.assets:
-            _dict['assets'] = self.assets.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of interactions
-        if self.interactions:
-            _dict['interactions'] = self.interactions.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededAssetsRecommendation:
-        """Create an instance of SeededAssetsRecommendation from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FormatMetric from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededAssetsRecommendation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededAssetsRecommendation.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "assets": Assets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "interactions": InteractedAssets.from_dict(obj.get("interactions")) if obj.get("interactions") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "generic": obj.get("generic"),
+            "specific": obj.get("specific"),
+            "identifiers": obj.get("identifiers")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_classification.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_classification.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,72 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.classification_generic_enum import ClassificationGenericEnum
 from pieces_os_client.models.classification_rendering_enum import ClassificationRenderingEnum
 from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededClassification(BaseModel):
     """
-    This is the specific classification of an Asset's Format.(This is on a per format basis b/c an asset could have different formats that are different format representations of the Asset.)  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is the specific classification of an Asset's Format.(This is on a per format basis b/c an asset could have different formats that are different format representations of the Asset.)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     generic: Optional[ClassificationGenericEnum] = None
     specific: Optional[ClassificationSpecificEnum] = None
     rendering: Optional[ClassificationRenderingEnum] = None
-    __properties = ["schema", "generic", "specific", "rendering"]
+    __properties: ClassVar[List[str]] = ["schema", "generic", "specific", "rendering"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededClassification:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededClassification from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededClassification:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededClassification from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededClassification.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededClassification.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "generic": obj.get("generic"),
             "specific": obj.get("specific"),
             "rendering": obj.get("rendering")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_connector_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_format_reclassification_metadata.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,75 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification import Classification
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_asset_metadata import SeededAssetMetadata
-from pieces_os_client.models.seeded_format import SeededFormat
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededConnectorAsset(BaseModel):
-    """
-    A generic model to use with the Connector API that requires little to no additional information about the current application.  # noqa: E501
+class TrackedAssetEventFormatReclassificationMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    metadata: Optional[SeededAssetMetadata] = None
-    format: SeededFormat = Field(...)
-    __properties = ["schema", "metadata", "format"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Metadata of a format reclassification event
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    previous: Optional[Classification] = None
+    current: Optional[Classification] = None
+    __properties: ClassVar[List[str]] = ["schema", "previous", "current"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededConnectorAsset:
-        """Create an instance of SeededConnectorAsset from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedAssetEventFormatReclassificationMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of metadata
-        if self.metadata:
-            _dict['metadata'] = self.metadata.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of format
-        if self.format:
-            _dict['format'] = self.format.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of previous
+        if self.previous:
+            _dict['previous'] = self.previous.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of current
+        if self.current:
+            _dict['current'] = self.current.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededConnectorAsset:
-        """Create an instance of SeededConnectorAsset from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedAssetEventFormatReclassificationMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededConnectorAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededConnectorAsset.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "metadata": SeededAssetMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None,
-            "format": SeededFormat.from_dict(obj.get("format")) if obj.get("format") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "previous": Classification.from_dict(obj["previous"]) if obj.get("previous") is not None else None,
+            "current": Classification.from_dict(obj["current"]) if obj.get("current") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_connector_creation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_classification_metadata.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,69 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification import Classification
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_connector_asset import SeededConnectorAsset
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededConnectorCreation(BaseModel):
-    """
-    A encompasing creation object that can be utilized to create either an asset or a format.  # noqa: E501
+class TLPCodeFragmentClassificationMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: Optional[SeededConnectorAsset] = None
-    __properties = ["schema", "asset"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TLPCodeFragmentClassificationMetadata
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    context: Optional[Classification] = None
+    prior: Optional[Classification] = None
+    __properties: ClassVar[List[str]] = ["schema", "context", "prior"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededConnectorCreation:
-        """Create an instance of SeededConnectorCreation from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPCodeFragmentClassificationMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of asset
-        if self.asset:
-            _dict['asset'] = self.asset.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of context
+        if self.context:
+            _dict['context'] = self.context.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of prior
+        if self.prior:
+            _dict['prior'] = self.prior.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededConnectorCreation:
-        """Create an instance of SeededConnectorCreation from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPCodeFragmentClassificationMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededConnectorCreation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededConnectorCreation.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "asset": SeededConnectorAsset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "context": Classification.from_dict(obj["context"]) if obj.get("context") is not None else None,
+            "prior": Classification.from_dict(obj["prior"]) if obj.get("prior") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_connector_tracking.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_connector_tracking.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,168 +14,135 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_tracked_adoption_event import (
-    SeededTrackedAdoptionEvent,
-)
-from pieces_os_client.models.seeded_tracked_interaction_event import (
-    SeededTrackedInteractionEvent,
-)
-from pieces_os_client.models.seeded_tracked_keyboard_event import (
-    SeededTrackedKeyboardEvent,
-)
-from pieces_os_client.models.seeded_tracked_machine_learning_event import (
-    SeededTrackedMachineLearningEvent,
-)
-from pieces_os_client.models.seeded_tracked_session_event import (
-    SeededTrackedSessionEvent,
-)
-
+from pieces_os_client.models.seeded_tracked_adoption_event import SeededTrackedAdoptionEvent
+from pieces_os_client.models.seeded_tracked_interaction_event import SeededTrackedInteractionEvent
+from pieces_os_client.models.seeded_tracked_keyboard_event import SeededTrackedKeyboardEvent
+from pieces_os_client.models.seeded_tracked_machine_learning_event import SeededTrackedMachineLearningEvent
+from pieces_os_client.models.seeded_tracked_session_event import SeededTrackedSessionEvent
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededConnectorTracking(BaseModel):
     """
-    This model is designed to be light weight and low friction while most of the heavy lifting will be happening inside of the context servers.  This Model is important because this has references to our materials, instead of fully referenced materials.(very similar to our SeededTrackedEvent, consider consolidating and converting these to Referenced models instead of ID's)  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This model is designed to be light weight and low friction while most of the heavy lifting will be happening inside of the context servers.  This Model is important because this has references to our materials, instead of fully referenced materials.(very similar to our SeededTrackedEvent, consider consolidating and converting these to Referenced models instead of ID's)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     format: Optional[SeededTrackedFormatEvent] = None
     asset: Optional[SeededTrackedAssetEvent] = None
     interaction: Optional[SeededTrackedInteractionEvent] = None
     keyboard: Optional[SeededTrackedKeyboardEvent] = None
     session: Optional[SeededTrackedSessionEvent] = None
     assets: Optional[SeededTrackedAssetsEvent] = None
     ml: Optional[SeededTrackedMachineLearningEvent] = None
     adoption: Optional[SeededTrackedAdoptionEvent] = None
     conversation: Optional[SeededTrackedConversationEvent] = None
-    __properties = [
-        "schema",
-        "format",
-        "asset",
-        "interaction",
-        "keyboard",
-        "session",
-        "assets",
-        "ml",
-        "adoption",
-        "conversation",
-    ]
+    __properties: ClassVar[List[str]] = ["schema", "format", "asset", "interaction", "keyboard", "session", "assets", "ml", "adoption", "conversation"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededConnectorTracking:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededConnectorTracking from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of format
         if self.format:
-            _dict["format"] = self.format.to_dict()
+            _dict['format'] = self.format.to_dict()
         # override the default output from pydantic by calling `to_dict()` of asset
         if self.asset:
-            _dict["asset"] = self.asset.to_dict()
+            _dict['asset'] = self.asset.to_dict()
         # override the default output from pydantic by calling `to_dict()` of interaction
         if self.interaction:
-            _dict["interaction"] = self.interaction.to_dict()
+            _dict['interaction'] = self.interaction.to_dict()
         # override the default output from pydantic by calling `to_dict()` of keyboard
         if self.keyboard:
-            _dict["keyboard"] = self.keyboard.to_dict()
+            _dict['keyboard'] = self.keyboard.to_dict()
         # override the default output from pydantic by calling `to_dict()` of session
         if self.session:
-            _dict["session"] = self.session.to_dict()
+            _dict['session'] = self.session.to_dict()
         # override the default output from pydantic by calling `to_dict()` of assets
         if self.assets:
-            _dict["assets"] = self.assets.to_dict()
+            _dict['assets'] = self.assets.to_dict()
         # override the default output from pydantic by calling `to_dict()` of ml
         if self.ml:
-            _dict["ml"] = self.ml.to_dict()
+            _dict['ml'] = self.ml.to_dict()
         # override the default output from pydantic by calling `to_dict()` of adoption
         if self.adoption:
-            _dict["adoption"] = self.adoption.to_dict()
+            _dict['adoption'] = self.adoption.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversation
         if self.conversation:
-            _dict["conversation"] = self.conversation.to_dict()
+            _dict['conversation'] = self.conversation.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededConnectorTracking:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededConnectorTracking from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededConnectorTracking.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededConnectorTracking.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "format": SeededTrackedFormatEvent.from_dict(obj.get("format"))
-                if obj.get("format") is not None
-                else None,
-                "asset": SeededTrackedAssetEvent.from_dict(obj.get("asset"))
-                if obj.get("asset") is not None
-                else None,
-                "interaction": SeededTrackedInteractionEvent.from_dict(
-                    obj.get("interaction")
-                )
-                if obj.get("interaction") is not None
-                else None,
-                "keyboard": SeededTrackedKeyboardEvent.from_dict(obj.get("keyboard"))
-                if obj.get("keyboard") is not None
-                else None,
-                "session": SeededTrackedSessionEvent.from_dict(obj.get("session"))
-                if obj.get("session") is not None
-                else None,
-                "assets": SeededTrackedAssetsEvent.from_dict(obj.get("assets"))
-                if obj.get("assets") is not None
-                else None,
-                "ml": SeededTrackedMachineLearningEvent.from_dict(obj.get("ml"))
-                if obj.get("ml") is not None
-                else None,
-                "adoption": SeededTrackedAdoptionEvent.from_dict(obj.get("adoption"))
-                if obj.get("adoption") is not None
-                else None,
-                "conversation": SeededTrackedConversationEvent.from_dict(
-                    obj.get("conversation")
-                )
-                if obj.get("conversation") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "format": SeededTrackedFormatEvent.from_dict(obj["format"]) if obj.get("format") is not None else None,
+            "asset": SeededTrackedAssetEvent.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "interaction": SeededTrackedInteractionEvent.from_dict(obj["interaction"]) if obj.get("interaction") is not None else None,
+            "keyboard": SeededTrackedKeyboardEvent.from_dict(obj["keyboard"]) if obj.get("keyboard") is not None else None,
+            "session": SeededTrackedSessionEvent.from_dict(obj["session"]) if obj.get("session") is not None else None,
+            "assets": SeededTrackedAssetsEvent.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "ml": SeededTrackedMachineLearningEvent.from_dict(obj["ml"]) if obj.get("ml") is not None else None,
+            "adoption": SeededTrackedAdoptionEvent.from_dict(obj["adoption"]) if obj.get("adoption") is not None else None,
+            "conversation": SeededTrackedConversationEvent.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.seeded_tracked_asset_event import SeededTrackedAssetEvent
 from pieces_os_client.models.seeded_tracked_assets_event import SeededTrackedAssetsEvent
-from pieces_os_client.models.seeded_tracked_conversation_event import (
-    SeededTrackedConversationEvent,
-)
+from pieces_os_client.models.seeded_tracked_conversation_event import SeededTrackedConversationEvent
 from pieces_os_client.models.seeded_tracked_format_event import SeededTrackedFormatEvent
+# TODO: Rewrite to not use raise_errors
+SeededConnectorTracking.model_rebuild(raise_errors=False)
 
-# SeededConnectorTracking.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_conversation.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_person.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,124 +14,112 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from pieces_os_client.models.application import Application
-from pieces_os_client.models.conversation_type_enum import ConversationTypeEnum
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_assets import FlattenedAssets
-from pieces_os_client.models.flattened_websites import FlattenedWebsites
-from pieces_os_client.models.referenced_model import ReferencedModel
-from pieces_os_client.models.seeded_anchor import SeededAnchor
+from pieces_os_client.models.mechanism_enum import MechanismEnum
+from pieces_os_client.models.person_access import PersonAccess
+from pieces_os_client.models.person_model import PersonModel
+from pieces_os_client.models.person_type import PersonType
 from pieces_os_client.models.seeded_annotation import SeededAnnotation
-from pieces_os_client.models.seeded_conversation_message import SeededConversationMessage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededConversation(BaseModel):
-    """
-    This is a pre-Conversation object.  This will hold together a conversation. Ie allthe message within a conversation.  All the additional properties on here used on here like(anchors/assets) are used for context that will seed the conversation.  model is a calculated property, and will be the model of the last message sent if applicable.  # noqa: E501
+class SeededPerson(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    name: Optional[StrictStr] = Field(None, description="This is a name that is customized.")
-    favorited: Optional[StrictBool] = None
-    application: Optional[Application] = None
-    annotations: Optional[conlist(SeededAnnotation)] = None
-    messages: Optional[conlist(SeededConversationMessage)] = None
-    model: Optional[ReferencedModel] = None
-    assets: Optional[FlattenedAssets] = None
-    websites: Optional[FlattenedWebsites] = None
-    anchors: Optional[conlist(SeededAnchor)] = None
-    type: ConversationTypeEnum = Field(...)
-    __properties = ["schema", "name", "favorited", "application", "annotations", "messages", "model", "assets", "websites", "anchors", "type"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a per-cursor to a full person.  Will throw an error, if asset is passed in but acces.scope is undefined.  can optionally pass in our mechanism here, as the default will be manual unless specified.  TODO consider updating these asset, format to referenced Models  Note: model, access, mechanism will only be added if the asset is passed in.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    asset: Optional[StrictStr] = None
+    mechanism: Optional[MechanismEnum] = None
+    access: Optional[PersonAccess] = None
+    type: PersonType
+    model: Optional[PersonModel] = None
+    annotations: Optional[List[SeededAnnotation]] = None
+    __properties: ClassVar[List[str]] = ["schema", "asset", "mechanism", "access", "type", "model", "annotations"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededConversation:
-        """Create an instance of SeededConversation from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededPerson from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of application
-        if self.application:
-            _dict['application'] = self.application.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of access
+        if self.access:
+            _dict['access'] = self.access.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of type
+        if self.type:
+            _dict['type'] = self.type.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of model
+        if self.model:
+            _dict['model'] = self.model.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in annotations (list)
         _items = []
         if self.annotations:
             for _item in self.annotations:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['annotations'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in messages (list)
-        _items = []
-        if self.messages:
-            for _item in self.messages:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['messages'] = _items
-        # override the default output from pydantic by calling `to_dict()` of model
-        if self.model:
-            _dict['model'] = self.model.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of assets
-        if self.assets:
-            _dict['assets'] = self.assets.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of websites
-        if self.websites:
-            _dict['websites'] = self.websites.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in anchors (list)
-        _items = []
-        if self.anchors:
-            for _item in self.anchors:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['anchors'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededConversation:
-        """Create an instance of SeededConversation from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededPerson from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededConversation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededConversation.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "name": obj.get("name"),
-            "favorited": obj.get("favorited"),
-            "application": Application.from_dict(obj.get("application")) if obj.get("application") is not None else None,
-            "annotations": [SeededAnnotation.from_dict(_item) for _item in obj.get("annotations")] if obj.get("annotations") is not None else None,
-            "messages": [SeededConversationMessage.from_dict(_item) for _item in obj.get("messages")] if obj.get("messages") is not None else None,
-            "model": ReferencedModel.from_dict(obj.get("model")) if obj.get("model") is not None else None,
-            "assets": FlattenedAssets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "websites": FlattenedWebsites.from_dict(obj.get("websites")) if obj.get("websites") is not None else None,
-            "anchors": [SeededAnchor.from_dict(_item) for _item in obj.get("anchors")] if obj.get("anchors") is not None else None,
-            "type": obj.get("type")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "asset": obj.get("asset"),
+            "mechanism": obj.get("mechanism"),
+            "access": PersonAccess.from_dict(obj["access"]) if obj.get("access") is not None else None,
+            "type": PersonType.from_dict(obj["type"]) if obj.get("type") is not None else None,
+            "model": PersonModel.from_dict(obj["model"]) if obj.get("model") is not None else None,
+            "annotations": [SeededAnnotation.from_dict(_item) for _item in obj["annotations"]] if obj.get("annotations") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_conversation_message.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_asset.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,93 +14,105 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
-from pieces_os_client.models.conversation_message_sentiment_enum import ConversationMessageSentimentEnum
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.fragment_format import FragmentFormat
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
-from pieces_os_client.models.model import Model
-from pieces_os_client.models.qgpt_conversation_message_role_enum import QGPTConversationMessageRoleEnum
-from pieces_os_client.models.referenced_conversation import ReferencedConversation
+from pieces_os_client.models.seeded_asset_metadata import SeededAssetMetadata
+from pieces_os_client.models.seeded_file import SeededFile
+from pieces_os_client.models.seeded_fragment import SeededFragment
+from pieces_os_client.models.tlp_directed_discovery_filters import TLPDirectedDiscoveryFilters
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededConversationMessage(BaseModel):
-    """
-    This is a seeded version of a ConversationMessage.  conversation is optional, this is because it can be used within the SeededConversation, however if this is passed into the /messages/create w/o a conversation uuid then we will throw an error.  # noqa: E501
+class DiscoveredAsset(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    created: Optional[GroupedTimestamp] = None
-    model: Optional[Model] = None
-    fragment: FragmentFormat = Field(...)
-    conversation: Optional[ReferencedConversation] = None
-    sentiment: Optional[ConversationMessageSentimentEnum] = None
-    role: QGPTConversationMessageRoleEnum = Field(...)
-    __properties = ["schema", "created", "model", "fragment", "conversation", "sentiment", "role"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    file: Optional[SeededFile] = None
+    fragment: Optional[SeededFragment] = None
+    directory: Optional[StrictStr] = None
+    metadata: Optional[SeededAssetMetadata] = None
+    filters: Optional[TLPDirectedDiscoveryFilters] = None
+    __properties: ClassVar[List[str]] = ["schema", "file", "fragment", "directory", "metadata", "filters"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededConversationMessage:
-        """Create an instance of SeededConversationMessage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DiscoveredAsset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of created
-        if self.created:
-            _dict['created'] = self.created.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of model
-        if self.model:
-            _dict['model'] = self.model.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of file
+        if self.file:
+            _dict['file'] = self.file.to_dict()
         # override the default output from pydantic by calling `to_dict()` of fragment
         if self.fragment:
             _dict['fragment'] = self.fragment.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of conversation
-        if self.conversation:
-            _dict['conversation'] = self.conversation.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of metadata
+        if self.metadata:
+            _dict['metadata'] = self.metadata.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of filters
+        if self.filters:
+            _dict['filters'] = self.filters.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededConversationMessage:
-        """Create an instance of SeededConversationMessage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DiscoveredAsset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededConversationMessage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededConversationMessage.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "model": Model.from_dict(obj.get("model")) if obj.get("model") is not None else None,
-            "fragment": FragmentFormat.from_dict(obj.get("fragment")) if obj.get("fragment") is not None else None,
-            "conversation": ReferencedConversation.from_dict(obj.get("conversation")) if obj.get("conversation") is not None else None,
-            "sentiment": obj.get("sentiment"),
-            "role": obj.get("role")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "file": SeededFile.from_dict(obj["file"]) if obj.get("file") is not None else None,
+            "fragment": SeededFragment.from_dict(obj["fragment"]) if obj.get("fragment") is not None else None,
+            "directory": obj.get("directory"),
+            "metadata": SeededAssetMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None,
+            "filters": TLPDirectedDiscoveryFilters.from_dict(obj["filters"]) if obj.get("filters") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_git_hub_gist_distribution.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,83 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_file import SeededFile
-from pieces_os_client.models.seeded_fragment import SeededFragment
-from pieces_os_client.models.tlp_directed_discovery_filters import TLPDirectedDiscoveryFilters
+from pieces_os_client.models.recipients import Recipients
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededDiscoverableAsset(BaseModel):
-    """
-    Assumption: filters applied in this model will overwrite filters passed in SeededDiscoverableAssets  # noqa: E501
+class SeededGitHubGistDistribution(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    file: Optional[SeededFile] = None
-    fragment: Optional[SeededFragment] = None
-    directory: Optional[StrictStr] = None
-    filters: Optional[TLPDirectedDiscoveryFilters] = None
-    __properties = ["schema", "file", "fragment", "directory", "filters"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the minimum information needed to distribute a Piece to a Gist.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    recipients: Optional[Recipients] = None
+    public: Optional[StrictBool] = Field(default=None, description="we will default to true")
+    description: Optional[StrictStr] = Field(default=None, description="This is the description of the Gist Distribution")
+    name: StrictStr = Field(description="This is the name of the gist you will add.")
+    __properties: ClassVar[List[str]] = ["schema", "recipients", "public", "description", "name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededDiscoverableAsset:
-        """Create an instance of SeededDiscoverableAsset from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededGitHubGistDistribution from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of file
-        if self.file:
-            _dict['file'] = self.file.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of fragment
-        if self.fragment:
-            _dict['fragment'] = self.fragment.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of filters
-        if self.filters:
-            _dict['filters'] = self.filters.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of recipients
+        if self.recipients:
+            _dict['recipients'] = self.recipients.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededDiscoverableAsset:
-        """Create an instance of SeededDiscoverableAsset from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededGitHubGistDistribution from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededDiscoverableAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededDiscoverableAsset.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "file": SeededFile.from_dict(obj.get("file")) if obj.get("file") is not None else None,
-            "fragment": SeededFragment.from_dict(obj.get("fragment")) if obj.get("fragment") is not None else None,
-            "directory": obj.get("directory"),
-            "filters": TLPDirectedDiscoveryFilters.from_dict(obj.get("filters")) if obj.get("filters") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "recipients": Recipients.from_dict(obj["recipients"]) if obj.get("recipients") is not None else None,
+            "public": obj.get("public"),
+            "description": obj.get("description"),
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_assets.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_assets.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,81 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.discovered_asset import DiscoveredAsset
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_discoverable_asset import SeededDiscoverableAsset
-from pieces_os_client.models.tlp_directed_discovery_filters import TLPDirectedDiscoveryFilters
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededDiscoverableAssets(BaseModel):
-    """
-    Assumption: filters imposed in this model can be overwritten by passing them in SeededDiscoverableAsset  # noqa: E501
+class DiscoveredAssets(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    application: StrictStr = Field(..., description="application id.")
-    iterable: conlist(SeededDiscoverableAsset) = Field(..., description="This is an iterable of already snippitized snippets that we will compare && cluster.")
-    filters: Optional[TLPDirectedDiscoveryFilters] = None
-    __properties = ["schema", "application", "iterable", "filters"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a plural Model that is used within the bulk upload flow in both cases of a file(&& needing snippitization) as well as if the fragments are passed in and they only need to be clustered.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    application: StrictStr = Field(description="application id.")
+    iterable: List[DiscoveredAsset] = Field(description="This is an iterable of already snippitized snippets that have been clustered.(These are assets that are going to be uploaded or at minimum the assets that we reccommend to upload)")
+    __properties: ClassVar[List[str]] = ["schema", "application", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededDiscoverableAssets:
-        """Create an instance of SeededDiscoverableAssets from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DiscoveredAssets from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
-        # override the default output from pydantic by calling `to_dict()` of filters
-        if self.filters:
-            _dict['filters'] = self.filters.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededDiscoverableAssets:
-        """Create an instance of SeededDiscoverableAssets from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DiscoveredAssets from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededDiscoverableAssets.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededDiscoverableAssets.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "application": obj.get("application"),
-            "iterable": [SeededDiscoverableAsset.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "filters": TLPDirectedDiscoveryFilters.from_dict(obj.get("filters")) if obj.get("filters") is not None else None
+            "iterable": [DiscoveredAsset.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_html_webpage.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_reclassification_updates.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,67 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification import Classification
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededDiscoverableHtmlWebpage(BaseModel):
-    """
-    SeededDiscoverableHtmlWebpage
+class TLPCodeFragmentReclassificationUpdates(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    url: StrictStr = Field(..., description="The route of the page ")
-    page: StrictStr = Field(..., description="page's html as a string")
-    __properties = ["schema", "url", "page"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TLPCodeFragmentReclassificationUpdates
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    previous: Classification
+    current: Classification
+    __properties: ClassVar[List[str]] = ["schema", "previous", "current"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededDiscoverableHtmlWebpage:
-        """Create an instance of SeededDiscoverableHtmlWebpage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPCodeFragmentReclassificationUpdates from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of previous
+        if self.previous:
+            _dict['previous'] = self.previous.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of current
+        if self.current:
+            _dict['current'] = self.current.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededDiscoverableHtmlWebpage:
-        """Create an instance of SeededDiscoverableHtmlWebpage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPCodeFragmentReclassificationUpdates from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededDiscoverableHtmlWebpage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededDiscoverableHtmlWebpage.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "url": obj.get("url"),
-            "page": obj.get("page")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "previous": Classification.from_dict(obj["previous"]) if obj.get("previous") is not None else None,
+            "current": Classification.from_dict(obj["current"]) if obj.get("current") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_html_webpages.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_interaction_event_identifier_description_pairs.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_discoverable_html_webpage import SeededDiscoverableHtmlWebpage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededDiscoverableHtmlWebpages(BaseModel):
-    """
-    SeededDiscoverableHtmlWebpages
+class SeededTrackedInteractionEventIdentifierDescriptionPairs(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(SeededDiscoverableHtmlWebpage) = Field(...)
-    application: StrictStr = Field(..., description="This is the applicaiton Id used to connect to Pieces OS.")
-    __properties = ["schema", "iterable", "application"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SeededTrackedInteractionEventIdentifierDescriptionPairs
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    assets_list_refreshed: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "assets_list_refreshed"]
+
+    @field_validator('assets_list_refreshed')
+    def assets_list_refreshed_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in set(['the_assets_list_was_refreshed_through_ui_element']):
+            raise ValueError("must be one of enum values ('the_assets_list_was_refreshed_through_ui_element')")
+        return value
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededDiscoverableHtmlWebpages:
-        """Create an instance of SeededDiscoverableHtmlWebpages from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededTrackedInteractionEventIdentifierDescriptionPairs from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededDiscoverableHtmlWebpages:
-        """Create an instance of SeededDiscoverableHtmlWebpages from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededTrackedInteractionEventIdentifierDescriptionPairs from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededDiscoverableHtmlWebpages.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededDiscoverableHtmlWebpages.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [SeededDiscoverableHtmlWebpage.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "application": obj.get("application")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "assets_list_refreshed": obj.get("assets_list_refreshed")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_related_tag.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_related_tag.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.tag_category_enum import TagCategoryEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededDiscoverableRelatedTag(BaseModel):
     """
-      # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    text: StrictStr = Field(..., description="This is the description of the tag.")
-    asset: StrictStr = Field(..., description="this is a uuid that references an asset.")
+    
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    text: StrictStr = Field(description="This is the description of the tag.")
+    asset: StrictStr = Field(description="this is a uuid that references an asset.")
     mechanism: Optional[MechanismEnum] = None
-    format: Optional[StrictStr] = Field(None, description="(optionally) you can attach a tag to a format. so when you delete a format this tag will get removed from the asset as well.")
+    format: Optional[StrictStr] = Field(default=None, description="(optionally) you can attach a tag to a format. so when you delete a format this tag will get removed from the asset as well.")
     category: Optional[TagCategoryEnum] = None
-    __properties = ["schema", "text", "asset", "mechanism", "format", "category"]
+    __properties: ClassVar[List[str]] = ["schema", "text", "asset", "mechanism", "format", "category"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededDiscoverableRelatedTag:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededDiscoverableRelatedTag from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededDiscoverableRelatedTag:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededDiscoverableRelatedTag from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededDiscoverableRelatedTag.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededDiscoverableRelatedTag.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "text": obj.get("text"),
             "asset": obj.get("asset"),
             "mechanism": obj.get("mechanism"),
             "format": obj.get("format"),
             "category": obj.get("category")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_related_tags.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_related_tags.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.discovered_related_tag import DiscoveredRelatedTag
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_discoverable_related_tag import SeededDiscoverableRelatedTag
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededDiscoverableRelatedTags(BaseModel):
-    """
-    SeededDiscoverableRelatedTags
+class DiscoveredRelatedTags(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(SeededDiscoverableRelatedTag) = Field(...)
-    application: StrictStr = Field(..., description="This is the application id that this request is sent from.")
-    __properties = ["schema", "iterable", "application"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DiscoveredRelatedTags
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    application: StrictStr
+    iterable: List[DiscoveredRelatedTag]
+    __properties: ClassVar[List[str]] = ["schema", "application", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededDiscoverableRelatedTags:
-        """Create an instance of SeededDiscoverableRelatedTags from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DiscoveredRelatedTags from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededDiscoverableRelatedTags:
-        """Create an instance of SeededDiscoverableRelatedTags from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DiscoveredRelatedTags from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededDiscoverableRelatedTags.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededDiscoverableRelatedTags.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [SeededDiscoverableRelatedTag.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "application": obj.get("application")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "application": obj.get("application"),
+            "iterable": [DiscoveredRelatedTag.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_discoverable_sensitive.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_sensitives.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,86 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.mechanism_enum import MechanismEnum
-from pieces_os_client.models.sensitive_category_enum import SensitiveCategoryEnum
-from pieces_os_client.models.sensitive_metadata import SensitiveMetadata
-from pieces_os_client.models.sensitive_severity_enum import SensitiveSeverityEnum
+from pieces_os_client.models.seeded_discoverable_sensitive import SeededDiscoverableSensitive
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededDiscoverableSensitive(BaseModel):
-    """
-    This is the SeededDiscoverableSensitive, this has every property that the seededSensitive has except this one is all optionally passed in. and will override our classification if provided.  # noqa: E501
+class SeededDiscoverableSensitives(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: StrictStr = Field(...)
-    text: StrictStr = Field(..., description="this is the string representative of the sensative piece of data.")
-    mechanism: Optional[MechanismEnum] = None
-    category: Optional[SensitiveCategoryEnum] = None
-    severity: Optional[SensitiveSeverityEnum] = None
-    name: Optional[StrictStr] = None
-    description: Optional[StrictStr] = None
-    metadata: Optional[SensitiveMetadata] = None
-    __properties = ["schema", "asset", "text", "mechanism", "category", "severity", "name", "description", "metadata"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SeededDiscoverableSensitives
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[SeededDiscoverableSensitive]
+    application: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "application"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededDiscoverableSensitive:
-        """Create an instance of SeededDiscoverableSensitive from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededDiscoverableSensitives from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of metadata
-        if self.metadata:
-            _dict['metadata'] = self.metadata.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
+        _items = []
+        if self.iterable:
+            for _item in self.iterable:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededDiscoverableSensitive:
-        """Create an instance of SeededDiscoverableSensitive from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededDiscoverableSensitives from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededDiscoverableSensitive.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededDiscoverableSensitive.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "asset": obj.get("asset"),
-            "text": obj.get("text"),
-            "mechanism": obj.get("mechanism"),
-            "category": obj.get("category"),
-            "severity": obj.get("severity"),
-            "name": obj.get("name"),
-            "description": obj.get("description"),
-            "metadata": SensitiveMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [SeededDiscoverableSensitive.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "application": obj.get("application")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_file.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_fragment.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,81 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.file_metadata import FileMetadata
+from pieces_os_client.models.fragment_metadata import FragmentMetadata
 from pieces_os_client.models.transferable_bytes import TransferableBytes
 from pieces_os_client.models.transferable_string import TransferableString
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededFile(BaseModel):
-    """
-    This is a base model for a File(Seeded).  We will Throw an Error, if the text and the bytes properties are both null && if both the text and bytes properties are both defined. Ensure that you pass either a text or bytes property.  bytes and string are both optionl but, if both are null or both are defined we will throw an error. So You will be required to pass one or the other, NOT both.  # noqa: E501
+class SeededFragment(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    bytes: Optional[TransferableBytes] = None
+    This will be either a TransferableString or TransferableBytes that represent your fragment. ONLY Pass one or the other DONT pass both or neither.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     string: Optional[TransferableString] = None
-    metadata: Optional[FileMetadata] = None
-    __properties = ["schema", "bytes", "string", "metadata"]
+    bytes: Optional[TransferableBytes] = None
+    metadata: Optional[FragmentMetadata] = None
+    __properties: ClassVar[List[str]] = ["schema", "string", "bytes", "metadata"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededFile:
-        """Create an instance of SeededFile from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededFragment from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of bytes
-        if self.bytes:
-            _dict['bytes'] = self.bytes.to_dict()
         # override the default output from pydantic by calling `to_dict()` of string
         if self.string:
             _dict['string'] = self.string.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of bytes
+        if self.bytes:
+            _dict['bytes'] = self.bytes.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
             _dict['metadata'] = self.metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededFile:
-        """Create an instance of SeededFile from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededFragment from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededFile.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededFile.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "bytes": TransferableBytes.from_dict(obj.get("bytes")) if obj.get("bytes") is not None else None,
-            "string": TransferableString.from_dict(obj.get("string")) if obj.get("string") is not None else None,
-            "metadata": FileMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "string": TransferableString.from_dict(obj["string"]) if obj.get("string") is not None else None,
+            "bytes": TransferableBytes.from_dict(obj["bytes"]) if obj.get("bytes") is not None else None,
+            "metadata": FragmentMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_format.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_format.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,56 +14,72 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.seeded_classification import SeededClassification
 from pieces_os_client.models.seeded_file import SeededFile
 from pieces_os_client.models.seeded_fragment import SeededFragment
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededFormat(BaseModel):
     """
-    This is seeded data that will be come a format.  We will throw an Error if, 1) file and fragment are both defined, 2) file and fragment are both null.  if this is being used within the /assets/create endpoint or the /{application}/create endpoint, we will not take the classificaiton into account, as it is only used in the syntax highlighting related endpoints.That being said if you do want to override your classification, please look at the metadata within the file or the fragment.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is seeded data that will be come a format.  We will throw an Error if, 1) file and fragment are both defined, 2) file and fragment are both null.  if this is being used within the /assets/create endpoint or the /{application}/create endpoint, we will not take the classificaiton into account, as it is only used in the syntax highlighting related endpoints.That being said if you do want to override your classification, please look at the metadata within the file or the fragment.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     file: Optional[SeededFile] = None
     fragment: Optional[SeededFragment] = None
     classification: Optional[SeededClassification] = None
-    __properties = ["schema", "file", "fragment", "classification"]
+    __properties: ClassVar[List[str]] = ["schema", "file", "fragment", "classification"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededFormat:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededFormat from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of file
         if self.file:
             _dict['file'] = self.file.to_dict()
         # override the default output from pydantic by calling `to_dict()` of fragment
@@ -71,24 +87,24 @@
             _dict['fragment'] = self.fragment.to_dict()
         # override the default output from pydantic by calling `to_dict()` of classification
         if self.classification:
             _dict['classification'] = self.classification.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededFormat:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededFormat from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededFormat.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededFormat.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "file": SeededFile.from_dict(obj.get("file")) if obj.get("file") is not None else None,
-            "fragment": SeededFragment.from_dict(obj.get("fragment")) if obj.get("fragment") is not None else None,
-            "classification": SeededClassification.from_dict(obj.get("classification")) if obj.get("classification") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "file": SeededFile.from_dict(obj["file"]) if obj.get("file") is not None else None,
+            "fragment": SeededFragment.from_dict(obj["fragment"]) if obj.get("fragment") is not None else None,
+            "classification": SeededClassification.from_dict(obj["classification"]) if obj.get("classification") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_fragment.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/aesthetics.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,81 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.fragment_metadata import FragmentMetadata
-from pieces_os_client.models.transferable_bytes import TransferableBytes
-from pieces_os_client.models.transferable_string import TransferableString
+from pieces_os_client.models.font import Font
+from pieces_os_client.models.theme import Theme
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededFragment(BaseModel):
-    """
-    This will be either a TransferableString or TransferableBytes that represent your fragment. ONLY Pass one or the other DONT pass both or neither.  # noqa: E501
+class Aesthetics(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    string: Optional[TransferableString] = None
-    bytes: Optional[TransferableBytes] = None
-    metadata: Optional[FragmentMetadata] = None
-    __properties = ["schema", "string", "bytes", "metadata"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    These are aesthetics properties that will ensure the darkmode + font size and other aesthetics properties persist:)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    theme: Theme
+    font: Font
+    __properties: ClassVar[List[str]] = ["schema", "theme", "font"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededFragment:
-        """Create an instance of SeededFragment from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Aesthetics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of string
-        if self.string:
-            _dict['string'] = self.string.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of bytes
-        if self.bytes:
-            _dict['bytes'] = self.bytes.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of metadata
-        if self.metadata:
-            _dict['metadata'] = self.metadata.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of theme
+        if self.theme:
+            _dict['theme'] = self.theme.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of font
+        if self.font:
+            _dict['font'] = self.font.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededFragment:
-        """Create an instance of SeededFragment from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Aesthetics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededFragment.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededFragment.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "string": TransferableString.from_dict(obj.get("string")) if obj.get("string") is not None else None,
-            "bytes": TransferableBytes.from_dict(obj.get("bytes")) if obj.get("bytes") is not None else None,
-            "metadata": FragmentMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "theme": Theme.from_dict(obj["theme"]) if obj.get("theme") is not None else None,
+            "font": Font.from_dict(obj["font"]) if obj.get("font") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_git_hub_gist_distribution.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_task_pipeline_for_code_completion.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,75 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.recipients import Recipients
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededGitHubGistDistribution(BaseModel):
-    """
-    This is the minimum information needed to distribute a Piece to a Gist.  # noqa: E501
+class QGPTTaskPipelineForCodeCompletion(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    recipients: Optional[Recipients] = None
-    public: Optional[StrictBool] = Field(None, description="we will default to true")
-    description: Optional[StrictStr] = Field(None, description="This is the description of the Gist Distribution")
-    name: StrictStr = Field(..., description="This is the name of the gist you will add.")
-    __properties = ["schema", "recipients", "public", "description", "name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This task is for code_completion ie auto-complete.  This is a class so that we can add optional properties in the future.  context: This is additional snippet context within the file that will be useful for the autocompletion.(PLEASE ONLY pass in Seed.asset.format.fragment.string.raw for the context snippet values, and for the classificaiton pass in Seed.asset.format.classification)  Note: the snippet && language that needs to be Actually AutoCompleted should be within the QGPTQuestionInput.relevant.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    context: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["schema", "context"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededGitHubGistDistribution:
-        """Create an instance of SeededGitHubGistDistribution from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTTaskPipelineForCodeCompletion from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of recipients
-        if self.recipients:
-            _dict['recipients'] = self.recipients.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededGitHubGistDistribution:
-        """Create an instance of SeededGitHubGistDistribution from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTTaskPipelineForCodeCompletion from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededGitHubGistDistribution.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededGitHubGistDistribution.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "recipients": Recipients.from_dict(obj.get("recipients")) if obj.get("recipients") is not None else None,
-            "public": obj.get("public"),
-            "description": obj.get("description"),
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "context": obj.get("context")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_github_gists_import.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_creation_metadata_clipboard.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,67 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededGithubGistsImport(BaseModel):
-    """
-    This is the body of the /github/gists/import,  by default we will look for everything from your private gists, (TODO hook up public gists.)&& get clever  currently we will not ensure that this is a good pieces for you but we will just get you the gist and let you do what you want with it(room for improvement, if we want to layer in advanced pieces discovery)  For the future, we might want to add a max number of assets that are returned from this.  # noqa: E501
+class TrackedAssetEventCreationMetadataClipboard(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    application: StrictStr = Field(..., description="application id.")
-    public: Optional[StrictBool] = Field(None, description="This will default to false.(ie private), currently not supporting pulling public gists.")
-    __properties = ["schema", "application", "public"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    If an asset was created from a clipboard event
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    keyboard: Optional[StrictBool] = Field(default=None, description="Whether the clipboard was utilized via the keyboard")
+    interaction: Optional[StrictBool] = Field(default=None, description="Whether the clipboard was extracted through a button click")
+    __properties: ClassVar[List[str]] = ["schema", "keyboard", "interaction"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededGithubGistsImport:
-        """Create an instance of SeededGithubGistsImport from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedAssetEventCreationMetadataClipboard from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededGithubGistsImport:
-        """Create an instance of SeededGithubGistsImport from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedAssetEventCreationMetadataClipboard from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededGithubGistsImport.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededGithubGistsImport.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "application": obj.get("application"),
-            "public": obj.get("public")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "keyboard": obj.get("keyboard"),
+            "interaction": obj.get("interaction")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_hint.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_hint.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.hint_type_enum import HintTypeEnum
 from pieces_os_client.models.mechanism_enum import MechanismEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededHint(BaseModel):
     """
     SeededHint
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     mechanism: Optional[MechanismEnum] = None
-    asset: Optional[StrictStr] = Field(None, description="This is an asset id that we are using to link this to an asset.")
-    type: HintTypeEnum = Field(...)
-    text: StrictStr = Field(..., description="This is the text of the hint.")
-    model: Optional[StrictStr] = Field(None, description="this is a model id. that we are using to link this to a model.")
-    __properties = ["schema", "mechanism", "asset", "type", "text", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    asset: Optional[StrictStr] = Field(default=None, description="This is an asset id that we are using to link this to an asset.")
+    type: HintTypeEnum
+    text: StrictStr = Field(description="This is the text of the hint.")
+    model: Optional[StrictStr] = Field(default=None, description="this is a model id. that we are using to link this to a model.")
+    __properties: ClassVar[List[str]] = ["schema", "mechanism", "asset", "type", "text", "model"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededHint:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededHint from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededHint:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededHint from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededHint.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededHint.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "mechanism": obj.get("mechanism"),
             "asset": obj.get("asset"),
             "type": obj.get("type"),
             "text": obj.get("text"),
             "model": obj.get("model")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_mac_os_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seed.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,71 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.application import Application
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.seeded_asset import SeededAsset
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededMacOSAsset(BaseModel):
-    """
-    An Seeded Asset specific to MacOS which takes in a Value, and Application  # noqa: E501
+class Seed(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    application: Optional[Application] = None
-    value: StrictStr = Field(..., description="The value of the text that you want to save as an asset.")
-    __properties = ["schema", "application", "value"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A seed Model used to wrap a format or asset
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    asset: Optional[SeededAsset] = None
+    type: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "asset", "type"]
+
+    @field_validator('type')
+    def type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in set(['SEEDED_FORMAT', 'SEEDED_ASSET']):
+            raise ValueError("must be one of enum values ('SEEDED_FORMAT', 'SEEDED_ASSET')")
+        return value
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededMacOSAsset:
-        """Create an instance of SeededMacOSAsset from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Seed from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of application
-        if self.application:
-            _dict['application'] = self.application.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of asset
+        if self.asset:
+            _dict['asset'] = self.asset.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededMacOSAsset:
-        """Create an instance of SeededMacOSAsset from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Seed from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededMacOSAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededMacOSAsset.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "application": Application.from_dict(obj.get("application")) if obj.get("application") is not None else None,
-            "value": obj.get("value")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "asset": SeededAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "type": obj.get("type")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_model.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_model.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
 from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.byte_descriptor import ByteDescriptor
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.external_ml_provider_enum import ExternalMLProviderEnum
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.model_foundation_enum import ModelFoundationEnum
 from pieces_os_client.models.model_max_tokens import ModelMaxTokens
 from pieces_os_client.models.model_type_enum import ModelTypeEnum
 from pieces_os_client.models.model_usage_enum import ModelUsageEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededModel(BaseModel):
     """
-    This is Precursor to a Model.  bytes: here is the size of the model in a file local on your computer. ram: is the amount of ram usage when the model is loaded into memory.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    version: StrictStr = Field(..., description="this is a version of the model.")
-    created: GroupedTimestamp = Field(...)
-    name: StrictStr = Field(..., description="This is an Optional Name of the Model.")
-    description: Optional[StrictStr] = Field(None, description="An Optional Description of the model itself.")
-    cloud: StrictBool = Field(..., description="This will inform the user if this was a model that is hosted in the cloud")
-    type: ModelTypeEnum = Field(...)
-    usage: ModelUsageEnum = Field(...)
+    This is Precursor to a Model.  bytes: here is the size of the model in a file local on your computer. ram: is the amount of ram usage when the model is loaded into memory.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    version: StrictStr = Field(description="this is a version of the model.")
+    created: GroupedTimestamp
+    name: StrictStr = Field(description="This is an Optional Name of the Model.")
+    description: Optional[StrictStr] = Field(default=None, description="An Optional Description of the model itself.")
+    cloud: StrictBool = Field(description="This will inform the user if this was a model that is hosted in the cloud")
+    type: ModelTypeEnum
+    usage: ModelUsageEnum
     bytes: Optional[ByteDescriptor] = None
     ram: Optional[ByteDescriptor] = None
-    quantization: Optional[StrictStr] = Field(None, description="quantization is a string like: q8f16_0,  q4f16_1, etc...")
+    quantization: Optional[StrictStr] = Field(default=None, description="quantization is a string like: q8f16_0,  q4f16_1, etc...")
     foundation: Optional[ModelFoundationEnum] = None
-    downloaded: Optional[StrictBool] = Field(None, description="This is an optional bool to let us know if this model has been downloaded locally.")
-    unique: Optional[StrictStr] = Field(None, description="This is the unique model name used to load the model.")
-    parameters: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="This is the number of parameters in terms of billions.")
+    downloaded: Optional[StrictBool] = Field(default=None, description="This is an optional bool to let us know if this model has been downloaded locally.")
+    unique: Optional[StrictStr] = Field(default=None, description="This is the unique model name used to load the model.")
+    parameters: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="This is the number of parameters in terms of billions.")
     provider: Optional[ExternalMLProviderEnum] = None
-    cpu: Optional[StrictBool] = Field(None, description="This is an optional bool that is optimized for CPU usage.")
-    max_tokens: Optional[ModelMaxTokens] = Field(None, alias="maxTokens")
-    custom: Optional[StrictBool] = Field(None, description="This is reserved to custommly registed models.")
-    __properties = ["schema", "version", "created", "name", "description", "cloud", "type", "usage", "bytes", "ram", "quantization", "foundation", "downloaded", "unique", "parameters", "provider", "cpu", "maxTokens", "custom"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    cpu: Optional[StrictBool] = Field(default=None, description="This is an optional bool that is optimized for CPU usage.")
+    max_tokens: Optional[ModelMaxTokens] = Field(default=None, alias="maxTokens")
+    custom: Optional[StrictBool] = Field(default=None, description="This is reserved to custommly registed models.")
+    __properties: ClassVar[List[str]] = ["schema", "version", "created", "name", "description", "cloud", "type", "usage", "bytes", "ram", "quantization", "foundation", "downloaded", "unique", "parameters", "provider", "cpu", "maxTokens", "custom"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededModel:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededModel from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of bytes
@@ -91,46 +107,46 @@
         # override the default output from pydantic by calling `to_dict()` of ram
         if self.ram:
             _dict['ram'] = self.ram.to_dict()
         # override the default output from pydantic by calling `to_dict()` of max_tokens
         if self.max_tokens:
             _dict['maxTokens'] = self.max_tokens.to_dict()
         # set to None if parameters (nullable) is None
-        # and __fields_set__ contains the field
-        if self.parameters is None and "parameters" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.parameters is None and "parameters" in self.model_fields_set:
             _dict['parameters'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededModel:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededModel from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededModel.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededModel.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "version": obj.get("version"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
             "name": obj.get("name"),
             "description": obj.get("description"),
             "cloud": obj.get("cloud"),
             "type": obj.get("type"),
             "usage": obj.get("usage"),
-            "bytes": ByteDescriptor.from_dict(obj.get("bytes")) if obj.get("bytes") is not None else None,
-            "ram": ByteDescriptor.from_dict(obj.get("ram")) if obj.get("ram") is not None else None,
+            "bytes": ByteDescriptor.from_dict(obj["bytes"]) if obj.get("bytes") is not None else None,
+            "ram": ByteDescriptor.from_dict(obj["ram"]) if obj.get("ram") is not None else None,
             "quantization": obj.get("quantization"),
             "foundation": obj.get("foundation"),
             "downloaded": obj.get("downloaded"),
             "unique": obj.get("unique"),
             "parameters": obj.get("parameters"),
             "provider": obj.get("provider"),
             "cpu": obj.get("cpu"),
-            "max_tokens": ModelMaxTokens.from_dict(obj.get("maxTokens")) if obj.get("maxTokens") is not None else None,
+            "maxTokens": ModelMaxTokens.from_dict(obj["maxTokens"]) if obj.get("maxTokens") is not None else None,
             "custom": obj.get("custom")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_models.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_activities.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_model import SeededModel
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededModels(BaseModel):
-    """
-    This is a Model that will hold an iterable of SeededModels.  # noqa: E501
+class FlattenedActivities(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(SeededModel) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    FlattenedActivities
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[ReferencedActivity]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededModels:
-        """Create an instance of SeededModels from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedActivities from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededModels:
-        """Create an instance of SeededModels from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedActivities from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededModels.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededModels.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [SeededModel.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ReferencedActivity.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.referenced_activity import ReferencedActivity
+# TODO: Rewrite to not use raise_errors
+FlattenedActivities.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_person.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/persons.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,96 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.mechanism_enum import MechanismEnum
-from pieces_os_client.models.person_access import PersonAccess
-from pieces_os_client.models.person_model import PersonModel
-from pieces_os_client.models.person_type import PersonType
-from pieces_os_client.models.seeded_annotation import SeededAnnotation
+from pieces_os_client.models.person import Person
+from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededPerson(BaseModel):
-    """
-    This is a per-cursor to a full person.  Will throw an error, if asset is passed in but acces.scope is undefined.  can optionally pass in our mechanism here, as the default will be manual unless specified.  TODO consider updating these asset, format to referenced Models  Note: model, access, mechanism will only be added if the asset is passed in.  # noqa: E501
+class Persons(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: Optional[StrictStr] = None
-    mechanism: Optional[MechanismEnum] = None
-    access: Optional[PersonAccess] = None
-    type: PersonType = Field(...)
-    model: Optional[PersonModel] = None
-    annotations: Optional[conlist(SeededAnnotation)] = None
-    __properties = ["schema", "asset", "mechanism", "access", "type", "model", "annotations"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the plural of Person. will have top level meta about the person including an iterable of all the person.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Person]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an person id.")
+    score: Optional[Score] = None
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededPerson:
-        """Create an instance of SeededPerson from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Persons from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of access
-        if self.access:
-            _dict['access'] = self.access.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of type
-        if self.type:
-            _dict['type'] = self.type.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of model
-        if self.model:
-            _dict['model'] = self.model.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in annotations (list)
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
-        if self.annotations:
-            for _item in self.annotations:
+        if self.iterable:
+            for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['annotations'] = _items
+            _dict['iterable'] = _items
+        # override the default output from pydantic by calling `to_dict()` of score
+        if self.score:
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededPerson:
-        """Create an instance of SeededPerson from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Persons from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededPerson.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededPerson.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "asset": obj.get("asset"),
-            "mechanism": obj.get("mechanism"),
-            "access": PersonAccess.from_dict(obj.get("access")) if obj.get("access") is not None else None,
-            "type": PersonType.from_dict(obj.get("type")) if obj.get("type") is not None else None,
-            "model": PersonModel.from_dict(obj.get("model")) if obj.get("model") is not None else None,
-            "annotations": [SeededAnnotation.from_dict(_item) for _item in obj.get("annotations")] if obj.get("annotations") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Person.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "indices": obj.get("indices"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_pkce.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_pkce.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,151 +14,167 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, validator
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.seeded_pkceadditionalparameters import SeededPKCEADDITIONALPARAMETERS
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededPKCE(BaseModel):
     """
-    A model that initialized a PKCE Authentication Flow.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    response_type: StrictStr = Field(..., description="Indicates to Auth0 which OAuth 2.0 Flow you want to perform. Use code for Authorization Code Grant (PKCE) Flow.")
-    state: StrictStr = Field(..., description="An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.")
-    nonce: StrictStr = Field(..., description="A local key that is held as the comparator to state, thus they should be the same.")
-    redirect_uri: Optional[StrictStr] = Field(None, description="http://localhost:8080/authentication/response")
-    code_challenge: StrictStr = Field(..., description="Generated challenge from the code_verifier.")
-    code_challenge_method: StrictStr = Field(..., description="Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged.")
-    domain: Optional[StrictStr] = Field(None, description="https://auth.pieces.services/authorize")
-    audience: Optional[StrictStr] = Field(None, description="The unique identifier of the target API you want to access. i.e. https://pieces.us.auth0.com/api/v2/")
-    screen_hint: Optional[StrictStr] = Field(None, description="Provides a hint to Auth0 as to what flow should be displayed. The default behavior is to show a login page but you can override this by passing 'signup' to show the signup page instead.")
-    prompt: Optional[StrictStr] = Field(None, description=" To initiate a silent authentication request, use prompt=none (see Remarks for more info).")
+    A model that initialized a PKCE Authentication Flow.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    response_type: StrictStr = Field(description="Indicates to Auth0 which OAuth 2.0 Flow you want to perform. Use code for Authorization Code Grant (PKCE) Flow.")
+    state: StrictStr = Field(description="An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.")
+    nonce: StrictStr = Field(description="A local key that is held as the comparator to state, thus they should be the same.")
+    redirect_uri: Optional[StrictStr] = Field(default=None, description="http://localhost:8080/authentication/response")
+    code_challenge: StrictStr = Field(description="Generated challenge from the code_verifier.")
+    code_challenge_method: StrictStr = Field(description="Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged.")
+    domain: Optional[StrictStr] = Field(default=None, description="https://auth.pieces.services/authorize")
+    audience: Optional[StrictStr] = Field(default=None, description="The unique identifier of the target API you want to access. i.e. https://pieces.us.auth0.com/api/v2/")
+    screen_hint: Optional[StrictStr] = Field(default=None, description="Provides a hint to Auth0 as to what flow should be displayed. The default behavior is to show a login page but you can override this by passing 'signup' to show the signup page instead.")
+    prompt: Optional[StrictStr] = Field(default=None, description=" To initiate a silent authentication request, use prompt=none (see Remarks for more info).")
     organization: Optional[StrictStr] = None
     invitation: Optional[StrictStr] = None
-    scope: conlist(StrictStr) = Field(..., description="The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OpenID Connect (OIDC) scopes about users, such as profile and email, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, read:contacts). Include offline_access to get a Refresh Token.")
-    client_id: StrictStr = Field(..., description="Your application's Client ID.")
-    additional_parameters: Optional[SeededPKCEADDITIONALPARAMETERS] = Field(None, alias="ADDITIONAL_PARAMETERS")
+    scope: List[StrictStr] = Field(description="The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OpenID Connect (OIDC) scopes about users, such as profile and email, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, read:contacts). Include offline_access to get a Refresh Token.")
+    client_id: StrictStr = Field(description="Your application's Client ID.")
+    additional_parameters: Optional[SeededPKCEADDITIONALPARAMETERS] = Field(default=None, alias="ADDITIONAL_PARAMETERS")
     response_mode: Optional[StrictStr] = None
-    __properties = ["schema", "response_type", "state", "nonce", "redirect_uri", "code_challenge", "code_challenge_method", "domain", "audience", "screen_hint", "prompt", "organization", "invitation", "scope", "client_id", "ADDITIONAL_PARAMETERS", "response_mode"]
+    __properties: ClassVar[List[str]] = ["schema", "response_type", "state", "nonce", "redirect_uri", "code_challenge", "code_challenge_method", "domain", "audience", "screen_hint", "prompt", "organization", "invitation", "scope", "client_id", "ADDITIONAL_PARAMETERS", "response_mode"]
 
-    @validator('response_type')
+    @field_validator('response_type')
     def response_type_validate_enum(cls, value):
         """Validates the enum"""
-        if value not in ('code', 'token', 'id_token'):
+        if value not in set(['code', 'token', 'id_token']):
             raise ValueError("must be one of enum values ('code', 'token', 'id_token')")
         return value
 
-    @validator('code_challenge_method')
+    @field_validator('code_challenge_method')
     def code_challenge_method_validate_enum(cls, value):
         """Validates the enum"""
-        if value not in ('S256'):
+        if value not in set(['S256']):
             raise ValueError("must be one of enum values ('S256')")
         return value
 
-    @validator('screen_hint')
+    @field_validator('screen_hint')
     def screen_hint_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('signup'):
+        if value not in set(['signup']):
             raise ValueError("must be one of enum values ('signup')")
         return value
 
-    @validator('prompt')
+    @field_validator('prompt')
     def prompt_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('login', 'none'):
+        if value not in set(['login', 'none']):
             raise ValueError("must be one of enum values ('login', 'none')")
         return value
 
-    @validator('scope')
+    @field_validator('scope')
     def scope_validate_enum(cls, value):
         """Validates the enum"""
         for i in value:
-            if i not in ('offline_access', 'email', 'profile', 'openid'):
+            if i not in set(['offline_access', 'email', 'profile', 'openid']):
                 raise ValueError("each list item must be one of ('offline_access', 'email', 'profile', 'openid')")
         return value
 
-    @validator('response_mode')
+    @field_validator('response_mode')
     def response_mode_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('form_post', 'web_message', 'fragment', 'query'):
+        if value not in set(['form_post', 'web_message', 'fragment', 'query']):
             raise ValueError("must be one of enum values ('form_post', 'web_message', 'fragment', 'query')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededPKCE:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededPKCE from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of additional_parameters
         if self.additional_parameters:
             _dict['ADDITIONAL_PARAMETERS'] = self.additional_parameters.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededPKCE:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededPKCE from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededPKCE.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededPKCE.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "response_type": obj.get("response_type"),
             "state": obj.get("state"),
             "nonce": obj.get("nonce"),
             "redirect_uri": obj.get("redirect_uri"),
             "code_challenge": obj.get("code_challenge"),
             "code_challenge_method": obj.get("code_challenge_method"),
             "domain": obj.get("domain"),
             "audience": obj.get("audience"),
             "screen_hint": obj.get("screen_hint"),
             "prompt": obj.get("prompt"),
             "organization": obj.get("organization"),
             "invitation": obj.get("invitation"),
             "scope": obj.get("scope"),
             "client_id": obj.get("client_id"),
-            "additional_parameters": SeededPKCEADDITIONALPARAMETERS.from_dict(obj.get("ADDITIONAL_PARAMETERS")) if obj.get("ADDITIONAL_PARAMETERS") is not None else None,
+            "ADDITIONAL_PARAMETERS": SeededPKCEADDITIONALPARAMETERS.from_dict(obj["ADDITIONAL_PARAMETERS"]) if obj.get("ADDITIONAL_PARAMETERS") is not None else None,
             "response_mode": obj.get("response_mode")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_pkceadditionalparameters.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_pkceadditionalparameters.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,81 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, StrictStr, validator
+from pydantic import BaseModel, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededPKCEADDITIONALPARAMETERS(BaseModel):
     """
-    Append any additional parameter to the end of your request, and it will be sent to the provider. For example, access_type=offline (for Google Refresh Tokens) , display=popup (for Windows Live popup mode).  # noqa: E501
-    """
+    Append any additional parameter to the end of your request, and it will be sent to the provider. For example, access_type=offline (for Google Refresh Tokens) , display=popup (for Windows Live popup mode).
+    """ # noqa: E501
     access_type: Optional[StrictStr] = None
     display: Optional[StrictStr] = None
-    __properties = ["access_type", "display"]
+    __properties: ClassVar[List[str]] = ["access_type", "display"]
 
-    @validator('access_type')
+    @field_validator('access_type')
     def access_type_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('offline'):
+        if value not in set(['offline']):
             raise ValueError("must be one of enum values ('offline')")
         return value
 
-    @validator('display')
+    @field_validator('display')
     def display_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('popup'):
+        if value not in set(['popup']):
             raise ValueError("must be one of enum values ('popup')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededPKCEADDITIONALPARAMETERS:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededPKCEADDITIONALPARAMETERS from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededPKCEADDITIONALPARAMETERS:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededPKCEADDITIONALPARAMETERS from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededPKCEADDITIONALPARAMETERS.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededPKCEADDITIONALPARAMETERS.parse_obj({
+        _obj = cls.model_validate({
             "access_type": obj.get("access_type"),
             "display": obj.get("display")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_score.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/embedded_model_schema.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,71 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List
+from pieces_os_client.models.embedded_model_schema_semantic_version_enum import EmbeddedModelSchemaSemanticVersionEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-
-class SeededScore(BaseModel):
-    """
-    This is the low level seeded score and will let us know what exactly we want to increment on our material.  Note: ONLY include one of these, as we will only increment one of the following.  # noqa: E501
+class EmbeddedModelSchema(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    reuse: Optional[StrictBool] = None
-    update: Optional[StrictBool] = None
-    reference: Optional[StrictBool] = None
-    priority: Optional[StrictBool] = None
-    __properties = ["schema", "reuse", "update", "reference", "priority"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a model that will keep track of all of our version related to our models. ie (1) the database migration and (2) the global semantic version of the api.
+    """ # noqa: E501
+    migration: StrictInt = Field(description="this is the current database version that this model was used for.")
+    semantic: EmbeddedModelSchemaSemanticVersionEnum
+    __properties: ClassVar[List[str]] = ["migration", "semantic"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededScore:
-        """Create an instance of SeededScore from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of EmbeddedModelSchema from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededScore:
-        """Create an instance of SeededScore from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of EmbeddedModelSchema from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededScore.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededScore.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "reuse": obj.get("reuse"),
-            "update": obj.get("update"),
-            "reference": obj.get("reference"),
-            "priority": obj.get("priority")
+        _obj = cls.model_validate({
+            "migration": obj.get("migration"),
+            "semantic": obj.get("semantic")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_score_increment.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_score_increment.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.seeded_score import SeededScore
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededScoreIncrement(BaseModel):
     """
-    This is the body for a respective scores increment,  This will enable us to know what material we want to increment, all of which are optional, if it is defined we will attempt to increment the material.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    This is the body for a respective scores increment,  This will enable us to know what material we want to increment, all of which are optional, if it is defined we will attempt to increment the material.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     asset: Optional[SeededScore] = None
     assets: Optional[SeededScore] = None
     website: Optional[SeededScore] = None
     websites: Optional[SeededScore] = None
     anchor: Optional[SeededScore] = None
     anchors: Optional[SeededScore] = None
-    anchor_point: Optional[SeededScore] = Field(None, alias="anchorPoint")
-    anchor_points: Optional[SeededScore] = Field(None, alias="anchorPoints")
+    anchor_point: Optional[SeededScore] = Field(default=None, alias="anchorPoint")
+    anchor_points: Optional[SeededScore] = Field(default=None, alias="anchorPoints")
     annotation: Optional[SeededScore] = None
     annotations: Optional[SeededScore] = None
     conversation: Optional[SeededScore] = None
     conversations: Optional[SeededScore] = None
-    conversation_message: Optional[SeededScore] = Field(None, alias="conversationMessage")
-    conversation_messages: Optional[SeededScore] = Field(None, alias="conversationMessages")
+    conversation_message: Optional[SeededScore] = Field(default=None, alias="conversationMessage")
+    conversation_messages: Optional[SeededScore] = Field(default=None, alias="conversationMessages")
     share: Optional[SeededScore] = None
     shares: Optional[SeededScore] = None
     sensitive: Optional[SeededScore] = None
     sensitives: Optional[SeededScore] = None
     hint: Optional[SeededScore] = None
     hints: Optional[SeededScore] = None
     person: Optional[SeededScore] = None
     persons: Optional[SeededScore] = None
     tag: Optional[SeededScore] = None
     tags: Optional[SeededScore] = None
-    __properties = ["schema", "asset", "assets", "website", "websites", "anchor", "anchors", "anchorPoint", "anchorPoints", "annotation", "annotations", "conversation", "conversations", "conversationMessage", "conversationMessages", "share", "shares", "sensitive", "sensitives", "hint", "hints", "person", "persons", "tag", "tags"]
+    __properties: ClassVar[List[str]] = ["schema", "asset", "assets", "website", "websites", "anchor", "anchors", "anchorPoint", "anchorPoints", "annotation", "annotations", "conversation", "conversations", "conversationMessage", "conversationMessages", "share", "shares", "sensitive", "sensitives", "hint", "hints", "person", "persons", "tag", "tags"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededScoreIncrement:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededScoreIncrement from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of asset
         if self.asset:
             _dict['asset'] = self.asset.to_dict()
         # override the default output from pydantic by calling `to_dict()` of assets
@@ -153,45 +169,45 @@
             _dict['tag'] = self.tag.to_dict()
         # override the default output from pydantic by calling `to_dict()` of tags
         if self.tags:
             _dict['tags'] = self.tags.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededScoreIncrement:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededScoreIncrement from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededScoreIncrement.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededScoreIncrement.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "asset": SeededScore.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "assets": SeededScore.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "website": SeededScore.from_dict(obj.get("website")) if obj.get("website") is not None else None,
-            "websites": SeededScore.from_dict(obj.get("websites")) if obj.get("websites") is not None else None,
-            "anchor": SeededScore.from_dict(obj.get("anchor")) if obj.get("anchor") is not None else None,
-            "anchors": SeededScore.from_dict(obj.get("anchors")) if obj.get("anchors") is not None else None,
-            "anchor_point": SeededScore.from_dict(obj.get("anchorPoint")) if obj.get("anchorPoint") is not None else None,
-            "anchor_points": SeededScore.from_dict(obj.get("anchorPoints")) if obj.get("anchorPoints") is not None else None,
-            "annotation": SeededScore.from_dict(obj.get("annotation")) if obj.get("annotation") is not None else None,
-            "annotations": SeededScore.from_dict(obj.get("annotations")) if obj.get("annotations") is not None else None,
-            "conversation": SeededScore.from_dict(obj.get("conversation")) if obj.get("conversation") is not None else None,
-            "conversations": SeededScore.from_dict(obj.get("conversations")) if obj.get("conversations") is not None else None,
-            "conversation_message": SeededScore.from_dict(obj.get("conversationMessage")) if obj.get("conversationMessage") is not None else None,
-            "conversation_messages": SeededScore.from_dict(obj.get("conversationMessages")) if obj.get("conversationMessages") is not None else None,
-            "share": SeededScore.from_dict(obj.get("share")) if obj.get("share") is not None else None,
-            "shares": SeededScore.from_dict(obj.get("shares")) if obj.get("shares") is not None else None,
-            "sensitive": SeededScore.from_dict(obj.get("sensitive")) if obj.get("sensitive") is not None else None,
-            "sensitives": SeededScore.from_dict(obj.get("sensitives")) if obj.get("sensitives") is not None else None,
-            "hint": SeededScore.from_dict(obj.get("hint")) if obj.get("hint") is not None else None,
-            "hints": SeededScore.from_dict(obj.get("hints")) if obj.get("hints") is not None else None,
-            "person": SeededScore.from_dict(obj.get("person")) if obj.get("person") is not None else None,
-            "persons": SeededScore.from_dict(obj.get("persons")) if obj.get("persons") is not None else None,
-            "tag": SeededScore.from_dict(obj.get("tag")) if obj.get("tag") is not None else None,
-            "tags": SeededScore.from_dict(obj.get("tags")) if obj.get("tags") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "asset": SeededScore.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "assets": SeededScore.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "website": SeededScore.from_dict(obj["website"]) if obj.get("website") is not None else None,
+            "websites": SeededScore.from_dict(obj["websites"]) if obj.get("websites") is not None else None,
+            "anchor": SeededScore.from_dict(obj["anchor"]) if obj.get("anchor") is not None else None,
+            "anchors": SeededScore.from_dict(obj["anchors"]) if obj.get("anchors") is not None else None,
+            "anchorPoint": SeededScore.from_dict(obj["anchorPoint"]) if obj.get("anchorPoint") is not None else None,
+            "anchorPoints": SeededScore.from_dict(obj["anchorPoints"]) if obj.get("anchorPoints") is not None else None,
+            "annotation": SeededScore.from_dict(obj["annotation"]) if obj.get("annotation") is not None else None,
+            "annotations": SeededScore.from_dict(obj["annotations"]) if obj.get("annotations") is not None else None,
+            "conversation": SeededScore.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
+            "conversations": SeededScore.from_dict(obj["conversations"]) if obj.get("conversations") is not None else None,
+            "conversationMessage": SeededScore.from_dict(obj["conversationMessage"]) if obj.get("conversationMessage") is not None else None,
+            "conversationMessages": SeededScore.from_dict(obj["conversationMessages"]) if obj.get("conversationMessages") is not None else None,
+            "share": SeededScore.from_dict(obj["share"]) if obj.get("share") is not None else None,
+            "shares": SeededScore.from_dict(obj["shares"]) if obj.get("shares") is not None else None,
+            "sensitive": SeededScore.from_dict(obj["sensitive"]) if obj.get("sensitive") is not None else None,
+            "sensitives": SeededScore.from_dict(obj["sensitives"]) if obj.get("sensitives") is not None else None,
+            "hint": SeededScore.from_dict(obj["hint"]) if obj.get("hint") is not None else None,
+            "hints": SeededScore.from_dict(obj["hints"]) if obj.get("hints") is not None else None,
+            "person": SeededScore.from_dict(obj["person"]) if obj.get("person") is not None else None,
+            "persons": SeededScore.from_dict(obj["persons"]) if obj.get("persons") is not None else None,
+            "tag": SeededScore.from_dict(obj["tag"]) if obj.get("tag") is not None else None,
+            "tags": SeededScore.from_dict(obj["tags"]) if obj.get("tags") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_sensitive.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/reuse_suggestion.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,86 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.assets import Assets
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.mechanism_enum import MechanismEnum
-from pieces_os_client.models.sensitive_category_enum import SensitiveCategoryEnum
-from pieces_os_client.models.sensitive_metadata import SensitiveMetadata
-from pieces_os_client.models.sensitive_severity_enum import SensitiveSeverityEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededSensitive(BaseModel):
-    """
-    This is the seededSensitive, this does not have an id yet as we will add it on the server side.  can optionally pass in our mechanism here, as the default will be manual unless specified.  TODO consider updating these asset,format to referenced Models  # noqa: E501
+class ReuseSuggestion(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: StrictStr = Field(...)
-    text: StrictStr = Field(..., description="this is the string representative of the sensative piece of data.")
-    mechanism: Optional[MechanismEnum] = None
-    category: SensitiveCategoryEnum = Field(...)
-    severity: SensitiveSeverityEnum = Field(...)
-    name: StrictStr = Field(...)
-    description: StrictStr = Field(...)
-    metadata: Optional[SensitiveMetadata] = None
-    __properties = ["schema", "asset", "text", "mechanism", "category", "severity", "name", "description", "metadata"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the ReuseSuggestion. Mainly creating an additional model here because I imagine that we will want to add some additional data to this in the future (potentially with more numerical data that is emitted from the ML Models)  **Note: suggested is required here because we will want to say if we suggested to take this action of reuse or not.  ** Thoughts here. We could potentially return Assets: which would be an iterable of assets in most relavent order for the user to reuse if they want.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    suggested: StrictBool = Field(description="This is a boolean, that will say if you should or should not take action.")
+    assets: Assets
+    __properties: ClassVar[List[str]] = ["schema", "suggested", "assets"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededSensitive:
-        """Create an instance of SeededSensitive from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReuseSuggestion from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of metadata
-        if self.metadata:
-            _dict['metadata'] = self.metadata.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of assets
+        if self.assets:
+            _dict['assets'] = self.assets.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededSensitive:
-        """Create an instance of SeededSensitive from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReuseSuggestion from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededSensitive.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededSensitive.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "asset": obj.get("asset"),
-            "text": obj.get("text"),
-            "mechanism": obj.get("mechanism"),
-            "category": obj.get("category"),
-            "severity": obj.get("severity"),
-            "name": obj.get("name"),
-            "description": obj.get("description"),
-            "metadata": SensitiveMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "suggested": obj.get("suggested"),
+            "assets": Assets.from_dict(obj["assets"]) if obj.get("assets") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_share.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_ultra_suite_asset.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,90 +14,92 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from pieces_os_client.models.access_enum import AccessEnum
-from pieces_os_client.models.asset import Asset
-from pieces_os_client.models.assets import Assets
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_user import SeededUser
+from pieces_os_client.models.seeded_format import SeededFormat
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededShare(BaseModel):
-    """
-     required to pass in an asset or assets.  # noqa: E501
+class SeededUltraSuiteAsset(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: Optional[Asset] = None
-    users: Optional[conlist(SeededUser)] = Field(None, description="if private please specificy some users you want to share this with.")
-    access: AccessEnum = Field(...)
-    assets: Optional[Assets] = None
-    name: Optional[StrictStr] = Field(None, description="optional name, if it is available. and must be unique.")
-    __properties = ["schema", "asset", "users", "access", "assets", "name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A SeededUEAsset is the minimum data sent from UE required to create an asset within Pieces.  Fragment & file are both optional properties however we will throw an internal error if both fragment and file are passed through or if both are undefined.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    name: Optional[StrictStr] = Field(default=None, description="(optional) name is the name of the file")
+    ext: Optional[ClassificationSpecificEnum] = None
+    format: SeededFormat
+    description: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["schema", "name", "ext", "format", "description"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededShare:
-        """Create an instance of SeededShare from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededUltraSuiteAsset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of asset
-        if self.asset:
-            _dict['asset'] = self.asset.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in users (list)
-        _items = []
-        if self.users:
-            for _item in self.users:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['users'] = _items
-        # override the default output from pydantic by calling `to_dict()` of assets
-        if self.assets:
-            _dict['assets'] = self.assets.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of format
+        if self.format:
+            _dict['format'] = self.format.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededShare:
-        """Create an instance of SeededShare from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededUltraSuiteAsset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededShare.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededShare.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "asset": Asset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "users": [SeededUser.from_dict(_item) for _item in obj.get("users")] if obj.get("users") is not None else None,
-            "access": obj.get("access"),
-            "assets": Assets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "name": obj.get("name"),
+            "ext": obj.get("ext"),
+            "format": SeededFormat.from_dict(obj["format"]) if obj.get("format") is not None else None,
+            "description": obj.get("description")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tag.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/person_access.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,75 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.mechanism_enum import MechanismEnum
-from pieces_os_client.models.tag_category_enum import TagCategoryEnum
+from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from pieces_os_client.models.person_access_scoped_enum import PersonAccessScopedEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededTag(BaseModel):
-    """
-    This is the minimum information needed when creating a Tag.  Default we will attach manual to a tag unless otherwise specified for mechanism.  you can optionally add an asset, format, or person uuid to attach this tag directly to it  TODO consider updating these asset,format to referenced Models  # noqa: E501
+class PersonAccess(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    text: StrictStr = Field(..., description="This is the description of the tag.")
-    asset: Optional[StrictStr] = Field(None, description="this is a uuid that references an asset.")
-    mechanism: Optional[MechanismEnum] = None
-    category: Optional[TagCategoryEnum] = None
-    person: Optional[StrictStr] = Field(None, description="uuid of the person, you want to add this tag too")
-    __properties = ["schema", "text", "asset", "mechanism", "category", "person"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    if scoped is provided will let us know what level of permission(access) this specific person has in relation to what scope.(collection, asset,...etc)  in the future will expand to global (with its own enumeration for a global entire project/cloud scope)
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    scoped: Optional[PersonAccessScopedEnum] = None
+    deleted: Optional[GroupedTimestamp] = None
+    __properties: ClassVar[List[str]] = ["schema", "scoped", "deleted"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTag:
-        """Create an instance of SeededTag from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PersonAccess from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of deleted
+        if self.deleted:
+            _dict['deleted'] = self.deleted.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTag:
-        """Create an instance of SeededTag from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PersonAccess from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTag.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTag.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "text": obj.get("text"),
-            "asset": obj.get("asset"),
-            "mechanism": obj.get("mechanism"),
-            "category": obj.get("category"),
-            "person": obj.get("person")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "scoped": obj.get("scoped"),
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_adoption_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_session_event.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
-from pieces_os_client.models.analytics_tracked_adoption_event_identifier_description_pairs import AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.tracked_session_event_identifier_description_pairs import TrackedSessionEventIdentifierDescriptionPairs
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededTrackedAdoptionEvent(BaseModel):
-    """
-    SeededTrackedAdoptionEvent
+class SeededTrackedSessionEvent(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    identifier_description_pair: Optional[AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs] = None
-    __properties = ["schema", "identifier_description_pair"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A simple model to capture a Tracked Session to be send to the Connection API
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    identifier_description_pair: TrackedSessionEventIdentifierDescriptionPairs
+    __properties: ClassVar[List[str]] = ["schema", "identifier_description_pair"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTrackedAdoptionEvent:
-        """Create an instance of SeededTrackedAdoptionEvent from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededTrackedSessionEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of identifier_description_pair
         if self.identifier_description_pair:
             _dict['identifier_description_pair'] = self.identifier_description_pair.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTrackedAdoptionEvent:
-        """Create an instance of SeededTrackedAdoptionEvent from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededTrackedSessionEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTrackedAdoptionEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTrackedAdoptionEvent.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "identifier_description_pair": AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs.from_dict(obj.get("identifier_description_pair")) if obj.get("identifier_description_pair") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "identifier_description_pair": TrackedSessionEventIdentifierDescriptionPairs.from_dict(obj["identifier_description_pair"]) if obj.get("identifier_description_pair") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_application.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_application.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,79 +14,95 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.application_name_enum import ApplicationNameEnum
 from pieces_os_client.models.capabilities_enum import CapabilitiesEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.platform_enum import PlatformEnum
 from pieces_os_client.models.privacy_enum import PrivacyEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededTrackedApplication(BaseModel):
     """
-    A Model to describe what application a format/analytics event originated - Specifically NOT requiring an ID  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    name: ApplicationNameEnum = Field(...)
-    version: StrictStr = Field(..., description="This is the specific version number 0.0.0")
-    platform: PlatformEnum = Field(...)
+    A Model to describe what application a format/analytics event originated - Specifically NOT requiring an ID
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    name: ApplicationNameEnum
+    version: StrictStr = Field(description="This is the specific version number 0.0.0")
+    platform: PlatformEnum
     capabilities: Optional[CapabilitiesEnum] = None
     privacy: Optional[PrivacyEnum] = None
-    automatic_unload: Optional[StrictBool] = Field(None, alias="automaticUnload", description="This is a proper that will let us know if we will proactivity unload all of your machine learning models.by default this is false.")
-    __properties = ["schema", "name", "version", "platform", "capabilities", "privacy", "automaticUnload"]
+    automatic_unload: Optional[StrictBool] = Field(default=None, description="This is a proper that will let us know if we will proactivity unload all of your machine learning models.by default this is false.", alias="automaticUnload")
+    __properties: ClassVar[List[str]] = ["schema", "name", "version", "platform", "capabilities", "privacy", "automaticUnload"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTrackedApplication:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededTrackedApplication from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTrackedApplication:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededTrackedApplication from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTrackedApplication.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTrackedApplication.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "name": obj.get("name"),
             "version": obj.get("version"),
             "platform": obj.get("platform"),
             "capabilities": obj.get("capabilities"),
             "privacy": obj.get("privacy"),
-            "automatic_unload": obj.get("automaticUnload")
+            "automaticUnload": obj.get("automaticUnload")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_asset_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_asset_event.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,103 +14,99 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.tracked_asset_event_identifier_description_pairs import (
-    TrackedAssetEventIdentifierDescriptionPairs,
-)
-
+from pieces_os_client.models.tracked_asset_event_identifier_description_pairs import TrackedAssetEventIdentifierDescriptionPairs
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededTrackedAssetEvent(BaseModel):
     """
-    This seeded tracked asset event will be recieved by a context on the OS Server side, which will then be able to look up the asset id and structure the asset for shipment to Segment aka a fully built TrackedAssetEvent  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: ReferencedAsset = Field(...)
-    identifier_description_pair: TrackedAssetEventIdentifierDescriptionPairs = Field(
-        ...
-    )
+    This seeded tracked asset event will be recieved by a context on the OS Server side, which will then be able to look up the asset id and structure the asset for shipment to Segment aka a fully built TrackedAssetEvent
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    asset: ReferencedAsset
+    identifier_description_pair: TrackedAssetEventIdentifierDescriptionPairs
     metadata: Optional[TrackedAssetEventMetadata] = None
-    __properties = ["schema", "asset", "identifier_description_pair", "metadata"]
+    __properties: ClassVar[List[str]] = ["schema", "asset", "identifier_description_pair", "metadata"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTrackedAssetEvent:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededTrackedAssetEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of asset
         if self.asset:
-            _dict["asset"] = self.asset.to_dict()
+            _dict['asset'] = self.asset.to_dict()
         # override the default output from pydantic by calling `to_dict()` of identifier_description_pair
         if self.identifier_description_pair:
-            _dict[
-                "identifier_description_pair"
-            ] = self.identifier_description_pair.to_dict()
+            _dict['identifier_description_pair'] = self.identifier_description_pair.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
-            _dict["metadata"] = self.metadata.to_dict()
+            _dict['metadata'] = self.metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTrackedAssetEvent:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededTrackedAssetEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTrackedAssetEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTrackedAssetEvent.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "asset": ReferencedAsset.from_dict(obj.get("asset"))
-                if obj.get("asset") is not None
-                else None,
-                "identifier_description_pair": TrackedAssetEventIdentifierDescriptionPairs.from_dict(
-                    obj.get("identifier_description_pair")
-                )
-                if obj.get("identifier_description_pair") is not None
-                else None,
-                "metadata": TrackedAssetEventMetadata.from_dict(obj.get("metadata"))
-                if obj.get("metadata") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "asset": ReferencedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "identifier_description_pair": TrackedAssetEventIdentifierDescriptionPairs.from_dict(obj["identifier_description_pair"]) if obj.get("identifier_description_pair") is not None else None,
+            "metadata": TrackedAssetEventMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.referenced_asset import ReferencedAsset
-from pieces_os_client.models.tracked_asset_event_metadata import (
-    TrackedAssetEventMetadata,
-)
+from pieces_os_client.models.tracked_asset_event_metadata import TrackedAssetEventMetadata
+# TODO: Rewrite to not use raise_errors
+SeededTrackedAssetEvent.model_rebuild(raise_errors=False)
 
-# SeededTrackedAssetEvent.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_assets_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_assets_event.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,97 +14,93 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.tracked_assets_event_identifier_description_pairs import (
-    TrackedAssetsEventIdentifierDescriptionPairs,
-)
-
+from pieces_os_client.models.tracked_assets_event_identifier_description_pairs import TrackedAssetsEventIdentifierDescriptionPairs
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededTrackedAssetsEvent(BaseModel):
     """
-    An seeded event model that can occur at the assets level i.e. search   # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    identifier_description_pair: Optional[
-        TrackedAssetsEventIdentifierDescriptionPairs
-    ] = None
+    An seeded event model that can occur at the assets level i.e. search 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    identifier_description_pair: Optional[TrackedAssetsEventIdentifierDescriptionPairs] = None
     metadata: Optional[SeededTrackedAssetsEventMetadata] = None
-    __properties = ["schema", "identifier_description_pair", "metadata"]
+    __properties: ClassVar[List[str]] = ["schema", "identifier_description_pair", "metadata"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTrackedAssetsEvent:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededTrackedAssetsEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of identifier_description_pair
         if self.identifier_description_pair:
-            _dict[
-                "identifier_description_pair"
-            ] = self.identifier_description_pair.to_dict()
+            _dict['identifier_description_pair'] = self.identifier_description_pair.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
-            _dict["metadata"] = self.metadata.to_dict()
+            _dict['metadata'] = self.metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTrackedAssetsEvent:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededTrackedAssetsEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTrackedAssetsEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTrackedAssetsEvent.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "identifier_description_pair": TrackedAssetsEventIdentifierDescriptionPairs.from_dict(
-                    obj.get("identifier_description_pair")
-                )
-                if obj.get("identifier_description_pair") is not None
-                else None,
-                "metadata": SeededTrackedAssetsEventMetadata.from_dict(
-                    obj.get("metadata")
-                )
-                if obj.get("metadata") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "identifier_description_pair": TrackedAssetsEventIdentifierDescriptionPairs.from_dict(obj["identifier_description_pair"]) if obj.get("identifier_description_pair") is not None else None,
+            "metadata": SeededTrackedAssetsEventMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.seeded_tracked_assets_event_metadata import SeededTrackedAssetsEventMetadata
+# TODO: Rewrite to not use raise_errors
+SeededTrackedAssetsEvent.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.seeded_tracked_assets_event_metadata import (
-    SeededTrackedAssetsEventMetadata,
-)
-
-# SeededTrackedAssetsEvent.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_conversation_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_conversation_event.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,107 +14,99 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.tracked_conversation_event_identifier_description_pairs import (
-    TrackedConversationEventIdentifierDescriptionPairs,
-)
-from pieces_os_client.models.tracked_conversation_event_metadata import (
-    TrackedConversationEventMetadata,
-)
-
+from pieces_os_client.models.tracked_conversation_event_identifier_description_pairs import TrackedConversationEventIdentifierDescriptionPairs
+from pieces_os_client.models.tracked_conversation_event_metadata import TrackedConversationEventMetadata
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededTrackedConversationEvent(BaseModel):
     """
-    This is a pre-created(seed) TrackedConversationEvent  # noqa: E501
-    """
-
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    identifier_description_pair: TrackedConversationEventIdentifierDescriptionPairs = (
-        Field(...)
-    )
-    conversation: ReferencedConversation = Field(...)
+    This is a pre-created(seed) TrackedConversationEvent
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    identifier_description_pair: TrackedConversationEventIdentifierDescriptionPairs
+    conversation: ReferencedConversation
     metadata: Optional[TrackedConversationEventMetadata] = None
-    __properties = ["schema", "identifier_description_pair", "conversation", "metadata"]
+    __properties: ClassVar[List[str]] = ["schema", "identifier_description_pair", "conversation", "metadata"]
 
-    class Config:
-        """Pydantic configuration"""
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTrackedConversationEvent:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededTrackedConversationEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of identifier_description_pair
         if self.identifier_description_pair:
-            _dict[
-                "identifier_description_pair"
-            ] = self.identifier_description_pair.to_dict()
+            _dict['identifier_description_pair'] = self.identifier_description_pair.to_dict()
         # override the default output from pydantic by calling `to_dict()` of conversation
         if self.conversation:
-            _dict["conversation"] = self.conversation.to_dict()
+            _dict['conversation'] = self.conversation.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
-            _dict["metadata"] = self.metadata.to_dict()
+            _dict['metadata'] = self.metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTrackedConversationEvent:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededTrackedConversationEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTrackedConversationEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTrackedConversationEvent.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "identifier_description_pair": TrackedConversationEventIdentifierDescriptionPairs.from_dict(
-                    obj.get("identifier_description_pair")
-                )
-                if obj.get("identifier_description_pair") is not None
-                else None,
-                "conversation": ReferencedConversation.from_dict(
-                    obj.get("conversation")
-                )
-                if obj.get("conversation") is not None
-                else None,
-                "metadata": TrackedConversationEventMetadata.from_dict(
-                    obj.get("metadata")
-                )
-                if obj.get("metadata") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "identifier_description_pair": TrackedConversationEventIdentifierDescriptionPairs.from_dict(obj["identifier_description_pair"]) if obj.get("identifier_description_pair") is not None else None,
+            "conversation": ReferencedConversation.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
+            "metadata": TrackedConversationEventMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
+        })
         return _obj
 
-
 from pieces_os_client.models.referenced_conversation import ReferencedConversation
+# TODO: Rewrite to not use raise_errors
+SeededTrackedConversationEvent.model_rebuild(raise_errors=False)
 
-# SeededTrackedConversationEvent.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_format_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_interaction_event.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,103 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.tracked_format_event_identifier_description_pairs import (
-    TrackedFormatEventIdentifierDescriptionPairs,
-)
-from pieces_os_client.models.tracked_format_event_metadata import (
-    TrackedFormatEventMetadata,
-)
-
+from pieces_os_client.models.seeded_tracked_interaction_event_identifier_description_pairs import SeededTrackedInteractionEventIdentifierDescriptionPairs
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededTrackedFormatEvent(BaseModel):
-    """
-    Again this is a model designed to be sent over to a context server to be built and then sent along to segment.   # noqa: E501
+class SeededTrackedInteractionEvent(BaseModel):
     """
+    This is a model that will hold relavent information in relation to an interaction(ONLY CLICK/TAP) analytics event(usage). If you want to register an event that relates to an interaction with the key then register a Keyboard Event. 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    description: StrictStr = Field(description="These need structure")
+    element: Optional[StrictStr] = None
+    identifier_description_pair: Optional[SeededTrackedInteractionEventIdentifierDescriptionPairs] = None
+    __properties: ClassVar[List[str]] = ["schema", "description", "element", "identifier_description_pair"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    identifier_description_pair: TrackedFormatEventIdentifierDescriptionPairs = Field(
-        ...
-    )
-    format: ReferencedFormat = Field(...)
-    metadata: Optional[TrackedFormatEventMetadata] = None
-    __properties = ["schema", "identifier_description_pair", "format", "metadata"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTrackedFormatEvent:
-        """Create an instance of SeededTrackedFormatEvent from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededTrackedInteractionEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
+            _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of identifier_description_pair
         if self.identifier_description_pair:
-            _dict[
-                "identifier_description_pair"
-            ] = self.identifier_description_pair.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of format
-        if self.format:
-            _dict["format"] = self.format.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of metadata
-        if self.metadata:
-            _dict["metadata"] = self.metadata.to_dict()
+            _dict['identifier_description_pair'] = self.identifier_description_pair.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTrackedFormatEvent:
-        """Create an instance of SeededTrackedFormatEvent from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededTrackedInteractionEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTrackedFormatEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTrackedFormatEvent.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "identifier_description_pair": TrackedFormatEventIdentifierDescriptionPairs.from_dict(
-                    obj.get("identifier_description_pair")
-                )
-                if obj.get("identifier_description_pair") is not None
-                else None,
-                "format": ReferencedFormat.from_dict(obj.get("format"))
-                if obj.get("format") is not None
-                else None,
-                "metadata": TrackedFormatEventMetadata.from_dict(obj.get("metadata"))
-                if obj.get("metadata") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "description": obj.get("description"),
+            "element": obj.get("element"),
+            "identifier_description_pair": SeededTrackedInteractionEventIdentifierDescriptionPairs.from_dict(obj["identifier_description_pair"]) if obj.get("identifier_description_pair") is not None else None
+        })
         return _obj
 
 
-from pieces_os_client.models.referenced_format import ReferencedFormat
-
-# SeededTrackedFormatEvent.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_interaction_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_adoption_event.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.analytics_tracked_adoption_event_identifier_description_pairs import AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_tracked_interaction_event_identifier_description_pairs import SeededTrackedInteractionEventIdentifierDescriptionPairs
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededTrackedInteractionEvent(BaseModel):
-    """
-    This is a model that will hold relavent information in relation to an interaction(ONLY CLICK/TAP) analytics event(usage). If you want to register an event that relates to an interaction with the key then register a Keyboard Event.   # noqa: E501
+class SeededTrackedAdoptionEvent(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    description: StrictStr = Field(..., description="These need structure")
-    element: Optional[StrictStr] = None
-    identifier_description_pair: Optional[SeededTrackedInteractionEventIdentifierDescriptionPairs] = None
-    __properties = ["schema", "description", "element", "identifier_description_pair"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SeededTrackedAdoptionEvent
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    identifier_description_pair: Optional[AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs] = None
+    __properties: ClassVar[List[str]] = ["schema", "identifier_description_pair"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTrackedInteractionEvent:
-        """Create an instance of SeededTrackedInteractionEvent from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededTrackedAdoptionEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of identifier_description_pair
         if self.identifier_description_pair:
             _dict['identifier_description_pair'] = self.identifier_description_pair.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTrackedInteractionEvent:
-        """Create an instance of SeededTrackedInteractionEvent from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededTrackedAdoptionEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTrackedInteractionEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTrackedInteractionEvent.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "description": obj.get("description"),
-            "element": obj.get("element"),
-            "identifier_description_pair": SeededTrackedInteractionEventIdentifierDescriptionPairs.from_dict(obj.get("identifier_description_pair")) if obj.get("identifier_description_pair") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "identifier_description_pair": AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs.from_dict(obj["identifier_description_pair"]) if obj.get("identifier_description_pair") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_interaction_event_identifier_description_pairs.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_assets_event_identifier_description_pairs.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededTrackedInteractionEventIdentifierDescriptionPairs(BaseModel):
-    """
-    SeededTrackedInteractionEventIdentifierDescriptionPairs
+class TrackedAssetsEventIdentifierDescriptionPairs(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    assets_list_refreshed: Optional[StrictStr] = None
-    __properties = ["schema", "assets_list_refreshed"]
+    These are all of the available event types that are permitted in an object pair notation.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    assets_searched: Optional[StrictStr] = Field(default=None, description="A If the assets were searched")
+    __properties: ClassVar[List[str]] = ["schema", "assets_searched"]
 
-    @validator('assets_list_refreshed')
-    def assets_list_refreshed_validate_enum(cls, value):
+    @field_validator('assets_searched')
+    def assets_searched_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('the_assets_list_was_refreshed_through_ui_element'):
-            raise ValueError("must be one of enum values ('the_assets_list_was_refreshed_through_ui_element')")
+        if value not in set(['assets_were_searched']):
+            raise ValueError("must be one of enum values ('assets_were_searched')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTrackedInteractionEventIdentifierDescriptionPairs:
-        """Create an instance of SeededTrackedInteractionEventIdentifierDescriptionPairs from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedAssetsEventIdentifierDescriptionPairs from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTrackedInteractionEventIdentifierDescriptionPairs:
-        """Create an instance of SeededTrackedInteractionEventIdentifierDescriptionPairs from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedAssetsEventIdentifierDescriptionPairs from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTrackedInteractionEventIdentifierDescriptionPairs.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTrackedInteractionEventIdentifierDescriptionPairs.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "assets_list_refreshed": obj.get("assets_list_refreshed")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "assets_searched": obj.get("assets_searched")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_keyboard_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_keyboard_event.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.seeded_tracked_keyboard_event_identifier_description_pairs import SeededTrackedKeyboardEventIdentifierDescriptionPairs
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededTrackedKeyboardEvent(BaseModel):
     """
-    This is a model that will hold relavent information in relation to a keyboard(including shortcuts) analytics event (usage).  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    description: StrictStr = Field(..., description="This also needs structure such as key vals or enums")
-    shortcut: conlist(StrictInt) = Field(...)
+    This is a model that will hold relavent information in relation to a keyboard(including shortcuts) analytics event (usage).
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    description: StrictStr = Field(description="This also needs structure such as key vals or enums")
+    shortcut: List[StrictInt]
     identifier_description_pair: Optional[SeededTrackedKeyboardEventIdentifierDescriptionPairs] = None
-    __properties = ["schema", "description", "shortcut", "identifier_description_pair"]
+    __properties: ClassVar[List[str]] = ["schema", "description", "shortcut", "identifier_description_pair"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTrackedKeyboardEvent:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededTrackedKeyboardEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of identifier_description_pair
         if self.identifier_description_pair:
             _dict['identifier_description_pair'] = self.identifier_description_pair.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTrackedKeyboardEvent:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededTrackedKeyboardEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTrackedKeyboardEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTrackedKeyboardEvent.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "description": obj.get("description"),
             "shortcut": obj.get("shortcut"),
-            "identifier_description_pair": SeededTrackedKeyboardEventIdentifierDescriptionPairs.from_dict(obj.get("identifier_description_pair")) if obj.get("identifier_description_pair") is not None else None
+            "identifier_description_pair": SeededTrackedKeyboardEventIdentifierDescriptionPairs.from_dict(obj["identifier_description_pair"]) if obj.get("identifier_description_pair") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_tracked_machine_learning_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_machine_learning_event.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.graphical_machine_learning_processing_event import GraphicalMachineLearningProcessingEvent
 from pieces_os_client.models.tlp_machine_learning_processing_event import TLPMachineLearningProcessingEvent
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededTrackedMachineLearningEvent(BaseModel):
     """
     SeededTrackedMachineLearningEvent
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     tlp: Optional[TLPMachineLearningProcessingEvent] = None
     graphical: Optional[GraphicalMachineLearningProcessingEvent] = None
-    __properties = ["schema", "tlp", "graphical"]
+    __properties: ClassVar[List[str]] = ["schema", "tlp", "graphical"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededTrackedMachineLearningEvent:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededTrackedMachineLearningEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of tlp
         if self.tlp:
             _dict['tlp'] = self.tlp.to_dict()
         # override the default output from pydantic by calling `to_dict()` of graphical
         if self.graphical:
             _dict['graphical'] = self.graphical.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededTrackedMachineLearningEvent:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededTrackedMachineLearningEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededTrackedMachineLearningEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededTrackedMachineLearningEvent.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "tlp": TLPMachineLearningProcessingEvent.from_dict(obj.get("tlp")) if obj.get("tlp") is not None else None,
-            "graphical": GraphicalMachineLearningProcessingEvent.from_dict(obj.get("graphical")) if obj.get("graphical") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "tlp": TLPMachineLearningProcessingEvent.from_dict(obj["tlp"]) if obj.get("tlp") is not None else None,
+            "graphical": GraphicalMachineLearningProcessingEvent.from_dict(obj["graphical"]) if obj.get("graphical") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_ultra_suite_asset.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/session.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,76 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_format import SeededFormat
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SeededUltraSuiteAsset(BaseModel):
-    """
-    A SeededUEAsset is the minimum data sent from UE required to create an asset within Pieces.  Fragment & file are both optional properties however we will throw an internal error if both fragment and file are passed through or if both are undefined.  # noqa: E501
+class Session(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    name: Optional[StrictStr] = Field(None, description="(optional) name is the name of the file")
-    ext: Optional[ClassificationSpecificEnum] = None
-    format: SeededFormat = Field(...)
-    description: Optional[StrictStr] = None
-    __properties = ["schema", "name", "ext", "format", "description"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a specific model that will let us know at what time this user was using the application.
+    """ # noqa: E501
+    id: StrictStr = Field(description="The UUID of the current Session")
+    opened: GroupedTimestamp
+    closed: Optional[GroupedTimestamp] = None
+    __properties: ClassVar[List[str]] = ["id", "opened", "closed"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededUltraSuiteAsset:
-        """Create an instance of SeededUltraSuiteAsset from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Session from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of format
-        if self.format:
-            _dict['format'] = self.format.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of opened
+        if self.opened:
+            _dict['opened'] = self.opened.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of closed
+        if self.closed:
+            _dict['closed'] = self.closed.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededUltraSuiteAsset:
-        """Create an instance of SeededUltraSuiteAsset from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Session from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededUltraSuiteAsset.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededUltraSuiteAsset.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "name": obj.get("name"),
-            "ext": obj.get("ext"),
-            "format": SeededFormat.from_dict(obj.get("format")) if obj.get("format") is not None else None,
-            "description": obj.get("description")
+        _obj = cls.model_validate({
+            "id": obj.get("id"),
+            "opened": GroupedTimestamp.from_dict(obj["opened"]) if obj.get("opened") is not None else None,
+            "closed": GroupedTimestamp.from_dict(obj["closed"]) if obj.get("closed") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_user.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_external_provider.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,65 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List
+from pieces_os_client.models.external_provider_type_enum import ExternalProviderTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-
-class SeededUser(BaseModel):
-    """
-      # noqa: E501
+class SeededExternalProvider(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    emails: conlist(StrictStr) = Field(...)
-    __properties = ["schema", "emails"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the minimum information needed to connect an additional provider.
+    """ # noqa: E501
+    type: ExternalProviderTypeEnum
+    __properties: ClassVar[List[str]] = ["type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededUser:
-        """Create an instance of SeededUser from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededExternalProvider from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededUser:
-        """Create an instance of SeededUser from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededExternalProvider from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededUser.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededUser.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "emails": obj.get("emails")
+        _obj = cls.model_validate({
+            "type": obj.get("type")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeded_website.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_website.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.mechanism_enum import MechanismEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SeededWebsite(BaseModel):
     """
-    This is the minimum information required to create a website for a specific asset.  you can optionally add an asset, or person id to attach this website directly to it  TODO consider updating these asset,format to referenced Models  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: Optional[StrictStr] = Field(None, description="This is the specific asset that this website is going to get attached to!!")
-    conversation: Optional[StrictStr] = Field(None, description="This is the specific conversation that this website is going to get attached to!!")
-    url: StrictStr = Field(..., description="this is the url of the website.")
-    name: StrictStr = Field(..., description="name of the website.(customizable and updateable as well.)")
+    This is the minimum information required to create a website for a specific asset.  you can optionally add an asset, or person id to attach this website directly to it  TODO consider updating these asset,format to referenced Models
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    asset: Optional[StrictStr] = Field(default=None, description="This is the specific asset that this website is going to get attached to!!")
+    conversation: Optional[StrictStr] = Field(default=None, description="This is the specific conversation that this website is going to get attached to!!")
+    url: StrictStr = Field(description="this is the url of the website.")
+    name: StrictStr = Field(description="name of the website.(customizable and updateable as well.)")
     mechanism: Optional[MechanismEnum] = None
-    person: Optional[StrictStr] = Field(None, description="this is a uuid of a person that we are going to add the website too.")
-    __properties = ["schema", "asset", "conversation", "url", "name", "mechanism", "person"]
+    person: Optional[StrictStr] = Field(default=None, description="this is a uuid of a person that we are going to add the website too.")
+    __properties: ClassVar[List[str]] = ["schema", "asset", "conversation", "url", "name", "mechanism", "person"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeededWebsite:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SeededWebsite from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeededWebsite:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SeededWebsite from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SeededWebsite.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SeededWebsite.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "asset": obj.get("asset"),
             "conversation": obj.get("conversation"),
             "url": obj.get("url"),
             "name": obj.get("name"),
             "mechanism": obj.get("mechanism"),
             "person": obj.get("person")
         })
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/seeds.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/recipients.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seed import Seed
+from pieces_os_client.models.person_basic_type import PersonBasicType
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Seeds(BaseModel):
-    """
-    This is a plural model for multiple Seed.  # noqa: E501
+class Recipients(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Seed) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This an iterable of People that are attached to a specific distribution ie, slack, maigun, ...etc
+    """ # noqa: E501
+    iterable: List[PersonBasicType]
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    __properties: ClassVar[List[str]] = ["iterable", "schema"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Seeds:
-        """Create an instance of Seeds from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Recipients from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Seeds:
-        """Create an instance of Seeds from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Recipients from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Seeds.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Seeds.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Seed.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "iterable": [PersonBasicType.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/segmented_technical_language.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/streamed_identifiers.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.segmented_technical_language_fragment import SegmentedTechnicalLanguageFragment
+from pieces_os_client.models.streamed_identifier import StreamedIdentifier
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SegmentedTechnicalLanguage(BaseModel):
-    """
-    This is the output model for '/machine_learning/text/technical_language/parsers/segmentation'  This will have an iterable of the segmented Technical language text/code  # noqa: E501
+class StreamedIdentifiers(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(SegmentedTechnicalLanguageFragment) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is currently only used within /assets/steam/identifiers && /conversations/steam/identifiers but can be used with other as well, if we want to expand this class. && expand the StreamedIdentifier class.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[StreamedIdentifier]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SegmentedTechnicalLanguage:
-        """Create an instance of SegmentedTechnicalLanguage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of StreamedIdentifiers from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SegmentedTechnicalLanguage:
-        """Create an instance of SegmentedTechnicalLanguage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of StreamedIdentifiers from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SegmentedTechnicalLanguage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SegmentedTechnicalLanguage.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [SegmentedTechnicalLanguageFragment.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [StreamedIdentifier.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/segmented_technical_language_fragment.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/preview.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,75 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
-from pieces_os_client.models.classification_generic_enum import ClassificationGenericEnum
-from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.fragment_format import FragmentFormat
+from pieces_os_client.models.referenced_format import ReferencedFormat
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SegmentedTechnicalLanguageFragment(BaseModel):
-    """
-    This is the output iterable model for '/machine_learning/text/technical_language/parsers/segmentation'  specific is optional here, however you can pass in classify: true to get the specific classificaiton in the case the generic is code.  # noqa: E501
+class Preview(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    generic: ClassificationGenericEnum = Field(...)
-    specific: Optional[ClassificationSpecificEnum] = None
-    fragment: FragmentFormat = Field(...)
-    __properties = ["schema", "generic", "specific", "fragment"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a preview Model that will hold references to at minimum the base preview. which can be potentiall a base image, or also base text/code and then the oveylay is another format(image/text/code) that is 'overlayed' ontop of the base format.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    base: ReferencedFormat
+    overlay: Optional[ReferencedFormat] = None
+    __properties: ClassVar[List[str]] = ["schema", "base", "overlay"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SegmentedTechnicalLanguageFragment:
-        """Create an instance of SegmentedTechnicalLanguageFragment from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Preview from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of fragment
-        if self.fragment:
-            _dict['fragment'] = self.fragment.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of base
+        if self.base:
+            _dict['base'] = self.base.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of overlay
+        if self.overlay:
+            _dict['overlay'] = self.overlay.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SegmentedTechnicalLanguageFragment:
-        """Create an instance of SegmentedTechnicalLanguageFragment from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Preview from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SegmentedTechnicalLanguageFragment.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SegmentedTechnicalLanguageFragment.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "generic": obj.get("generic"),
-            "specific": obj.get("specific"),
-            "fragment": FragmentFormat.from_dict(obj.get("fragment")) if obj.get("fragment") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "base": ReferencedFormat.from_dict(obj["base"]) if obj.get("base") is not None else None,
+            "overlay": ReferencedFormat.from_dict(obj["overlay"]) if obj.get("overlay") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/sensitive.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_sensitive.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,71 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_asset import FlattenedAsset
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.score import Score
 from pieces_os_client.models.sensitive_category_enum import SensitiveCategoryEnum
 from pieces_os_client.models.sensitive_metadata import SensitiveMetadata
 from pieces_os_client.models.sensitive_severity_enum import SensitiveSeverityEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Sensitive(BaseModel):
-    """
-    This is a fully referenced representation of a sensitive pieces of data.  # noqa: E501
+class FlattenedSensitive(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    This is a dereferenced representation of a sensitive pieces of data.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    asset: FlattenedAsset = Field(...)
-    text: StrictStr = Field(...)
-    mechanism: MechanismEnum = Field(...)
-    category: SensitiveCategoryEnum = Field(...)
-    severity: SensitiveSeverityEnum = Field(...)
-    name: StrictStr = Field(...)
-    description: StrictStr = Field(...)
+    asset: ReferencedAsset
+    text: StrictStr
+    mechanism: MechanismEnum
+    category: SensitiveCategoryEnum
+    severity: SensitiveSeverityEnum
+    name: StrictStr
+    description: StrictStr
     metadata: Optional[SensitiveMetadata] = None
-    interactions: Optional[StrictInt] = Field(None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
+    interactions: Optional[StrictInt] = Field(default=None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
     score: Optional[Score] = None
-    __properties = ["schema", "id", "created", "updated", "deleted", "asset", "text", "mechanism", "category", "severity", "name", "description", "metadata", "interactions", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "deleted", "asset", "text", "mechanism", "category", "severity", "name", "description", "metadata", "interactions", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Sensitive:
-        """Create an instance of Sensitive from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedSensitive from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -95,35 +110,38 @@
             _dict['metadata'] = self.metadata.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Sensitive:
-        """Create an instance of Sensitive from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedSensitive from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Sensitive.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Sensitive.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
-            "asset": FlattenedAsset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "asset": ReferencedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
             "text": obj.get("text"),
             "mechanism": obj.get("mechanism"),
             "category": obj.get("category"),
             "severity": obj.get("severity"),
             "name": obj.get("name"),
             "description": obj.get("description"),
-            "metadata": SensitiveMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None,
+            "metadata": SensitiveMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None,
             "interactions": obj.get("interactions"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.referenced_asset import ReferencedAsset
+# TODO: Rewrite to not use raise_errors
+FlattenedSensitive.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/sensitive_category_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/sensitive_category_enum.py`

 * *Files 17% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class SensitiveCategoryEnum(str, Enum):
     """
     This is the enum that is use to describe the category of our Sensitive Model.
     """
 
@@ -41,12 +38,12 @@
     URL = 'URL'
     PUBLIC_KEY = 'PUBLIC_KEY'
     PRIVATE_KEY = 'PRIVATE_KEY'
     API_ID = 'API_ID'
     WEB_HOOK_URL = 'WEB_HOOK_URL'
 
     @classmethod
-    def from_json(cls, json_str: str) -> SensitiveCategoryEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of SensitiveCategoryEnum from a JSON string"""
-        return SensitiveCategoryEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/sensitive_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_formats.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,71 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.text_match import TextMatch
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SensitiveMetadata(BaseModel):
-    """
-    This is optional metatdata attached to a sensitive piece of data.  # noqa: E501
+class FlattenedFormats(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    match: Optional[TextMatch] = None
-    entropy: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="entropy of the sensitive")
-    __properties = ["schema", "match", "entropy"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A collection of Formats specific to the authenticated user. [DAG Compatible - Directed Acyclic Graph Data Structure]  FlattenedFormats prevent Cycles in Reference because all outbound references are strings as opposed to crosspollinated objects. 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[ReferencedFormat]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SensitiveMetadata:
-        """Create an instance of SensitiveMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedFormats from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of match
-        if self.match:
-            _dict['match'] = self.match.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
+        _items = []
+        if self.iterable:
+            for _item in self.iterable:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SensitiveMetadata:
-        """Create an instance of SensitiveMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedFormats from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SensitiveMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SensitiveMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "match": TextMatch.from_dict(obj.get("match")) if obj.get("match") is not None else None,
-            "entropy": obj.get("entropy")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ReferencedFormat.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.referenced_format import ReferencedFormat
+# TODO: Rewrite to not use raise_errors
+FlattenedFormats.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/sensitives.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_application_install.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,79 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.score import Score
-from pieces_os_client.models.sensitive import Sensitive
+from pieces_os_client.models.tracked_application import TrackedApplication
+from pieces_os_client.models.tracked_user_profile import TrackedUserProfile
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Sensitives(BaseModel):
-    """
-    This is a model that represents many individual sensitive pieces of data.  # noqa: E501
+class TrackedApplicationInstall(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Sensitive) = Field(...)
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A model that allows for us to specifically track Application Installs & Related Data
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    application: TrackedApplication
+    user: Optional[TrackedUserProfile] = None
+    __properties: ClassVar[List[str]] = ["schema", "application", "user"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Sensitives:
-        """Create an instance of Sensitives from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedApplicationInstall from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict['score'] = self.score.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of application
+        if self.application:
+            _dict['application'] = self.application.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of user
+        if self.user:
+            _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Sensitives:
-        """Create an instance of Sensitives from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedApplicationInstall from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Sensitives.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Sensitives.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Sensitive.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "application": TrackedApplication.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "user": TrackedUserProfile.from_dict(obj["user"]) if obj.get("user") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/session.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_creation_metadata_file.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,70 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
-
-class Session(BaseModel):
-    """
-    This is a specific model that will let us know at what time this user was using the application.  # noqa: E501
+class TrackedAssetEventCreationMetadataFile(BaseModel):
     """
-    id: StrictStr = Field(..., description="The UUID of the current Session")
-    opened: GroupedTimestamp = Field(...)
-    closed: Optional[GroupedTimestamp] = None
-    __properties = ["id", "opened", "closed"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    If an asset was created from a file attachment
+    """ # noqa: E501
+    keyboard: Optional[StrictBool] = Field(default=None, description="Whether the file was pasted via the keyboard")
+    drag_and_drop: Optional[StrictBool] = Field(default=None, description="Whether the file was dropped onto pieces")
+    interaction: Optional[StrictBool] = Field(default=None, description="Whether the file was attached via a button click")
+    __properties: ClassVar[List[str]] = ["keyboard", "drag_and_drop", "interaction"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Session:
-        """Create an instance of Session from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedAssetEventCreationMetadataFile from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of opened
-        if self.opened:
-            _dict['opened'] = self.opened.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of closed
-        if self.closed:
-            _dict['closed'] = self.closed.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Session:
-        """Create an instance of Session from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedAssetEventCreationMetadataFile from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Session.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Session.parse_obj({
-            "id": obj.get("id"),
-            "opened": GroupedTimestamp.from_dict(obj.get("opened")) if obj.get("opened") is not None else None,
-            "closed": GroupedTimestamp.from_dict(obj.get("closed")) if obj.get("closed") is not None else None
+        _obj = cls.model_validate({
+            "keyboard": obj.get("keyboard"),
+            "drag_and_drop": obj.get("drag_and_drop"),
+            "interaction": obj.get("interaction")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/share.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_stream_output.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,112 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pieces_os_client.models.qgpt_agent_routes import QGPTAgentRoutes
+from pieces_os_client.models.qgpt_question_output import QGPTQuestionOutput
+from pieces_os_client.models.qgpt_relevance_output import QGPTRelevanceOutput
+from pieces_os_client.models.qgpt_stream_enum import QGPTStreamEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.access_enum import AccessEnum
-from pieces_os_client.models.accessors import Accessors
-from pieces_os_client.models.distributions import Distributions
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_asset import FlattenedAsset
-from pieces_os_client.models.flattened_assets import FlattenedAssets
-from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
-from pieces_os_client.models.score import Score
-
-class Share(BaseModel):
-    """
-    This represents what information that is relavent to anything and every sharing related. v1 will look very bare and will add more and more data as we go!  if user is undefined && access is public then we have an asset that is publicly available.  # noqa: E501
+class QGPTStreamOutput(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="This is the uuid that represents this share model.")
-    user: Optional[StrictStr] = Field(None, description="this is the uuid of the user that the share is created for.")
-    asset: Optional[FlattenedAsset] = None
-    assets: Optional[FlattenedAssets] = None
-    link: StrictStr = Field(..., description="This is the prebuilt link.")
-    access: AccessEnum = Field(...)
-    accessors: Accessors = Field(...)
-    created: GroupedTimestamp = Field(...)
-    short: StrictStr = Field(..., description="This is a shortened version of our uuid.")
-    name: Optional[StrictStr] = Field(None, description="this is an optional name we can give to the link, ie ?p=JAVASCRIPT or what ever the user wants as long as it is available.")
-    distributions: Optional[Distributions] = None
-    score: Optional[Score] = None
-    __properties = ["schema", "id", "user", "asset", "assets", "link", "access", "accessors", "created", "short", "name", "distributions", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the out for the /qgpt/stream endpoint.  200: success 401: invalid authentication/api key 429: Rate limit/Quota exceeded 500: server had an error 503: the engine is currently overloaded
+    """ # noqa: E501
+    request: Optional[StrictStr] = Field(default=None, description="This is the id used to represent the stream of response. this will always be present. We will use the value passed inby the client, or we will generate one.")
+    relevance: Optional[QGPTRelevanceOutput] = None
+    question: Optional[QGPTQuestionOutput] = None
+    status: Optional[QGPTStreamEnum] = None
+    conversation: StrictStr = Field(description="This is the ID of a predefined persisted conversation, if this is not present we will create a new conversation for the input/output.(in the case of a question)")
+    status_code: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="This will be provided", alias="statusCode")
+    error_message: Optional[StrictStr] = Field(default=None, description="optional error message is the status code is NOT 200", alias="errorMessage")
+    agent_routes: Optional[QGPTAgentRoutes] = Field(default=None, alias="agentRoutes")
+    __properties: ClassVar[List[str]] = ["request", "relevance", "question", "status", "conversation", "statusCode", "errorMessage", "agentRoutes"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Share:
-        """Create an instance of Share from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTStreamOutput from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of asset
-        if self.asset:
-            _dict['asset'] = self.asset.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of assets
-        if self.assets:
-            _dict['assets'] = self.assets.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of accessors
-        if self.accessors:
-            _dict['accessors'] = self.accessors.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of created
-        if self.created:
-            _dict['created'] = self.created.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of distributions
-        if self.distributions:
-            _dict['distributions'] = self.distributions.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict['score'] = self.score.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of relevance
+        if self.relevance:
+            _dict['relevance'] = self.relevance.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of question
+        if self.question:
+            _dict['question'] = self.question.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of agent_routes
+        if self.agent_routes:
+            _dict['agentRoutes'] = self.agent_routes.to_dict()
+        # set to None if status_code (nullable) is None
+        # and model_fields_set contains the field
+        if self.status_code is None and "status_code" in self.model_fields_set:
+            _dict['statusCode'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Share:
-        """Create an instance of Share from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTStreamOutput from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Share.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Share.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id"),
-            "user": obj.get("user"),
-            "asset": FlattenedAsset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "assets": FlattenedAssets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "link": obj.get("link"),
-            "access": obj.get("access"),
-            "accessors": Accessors.from_dict(obj.get("accessors")) if obj.get("accessors") is not None else None,
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "short": obj.get("short"),
-            "name": obj.get("name"),
-            "distributions": Distributions.from_dict(obj.get("distributions")) if obj.get("distributions") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+        _obj = cls.model_validate({
+            "request": obj.get("request"),
+            "relevance": QGPTRelevanceOutput.from_dict(obj["relevance"]) if obj.get("relevance") is not None else None,
+            "question": QGPTQuestionOutput.from_dict(obj["question"]) if obj.get("question") is not None else None,
+            "status": obj.get("status"),
+            "conversation": obj.get("conversation"),
+            "statusCode": obj.get("statusCode"),
+            "errorMessage": obj.get("errorMessage"),
+            "agentRoutes": QGPTAgentRoutes.from_dict(obj["agentRoutes"]) if obj.get("agentRoutes") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/shares.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_snippet_suggested_interactions.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,79 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.score import Score
-from pieces_os_client.models.share import Share
+from pieces_os_client.models.tlp_code_fragment_suggested_reuse import TLPCodeFragmentSuggestedReuse
+from pieces_os_client.models.tlp_code_fragment_suggested_save import TLPCodeFragmentSuggestedSave
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Shares(BaseModel):
-    """
-    this is just an iterable of our individual share models.  # noqa: E501
+class TLPCodeSnippetSuggestedInteractions(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Share) = Field(..., description="this is just an iterable of our individual share models.")
-    score: Optional[Score] = None
-    __properties = ["schema", "iterable", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TLPCodeSnippetSuggestedInteractions
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    save: Optional[TLPCodeFragmentSuggestedSave] = None
+    reuse: Optional[TLPCodeFragmentSuggestedReuse] = None
+    __properties: ClassVar[List[str]] = ["schema", "save", "reuse"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Shares:
-        """Create an instance of Shares from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TLPCodeSnippetSuggestedInteractions from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict['score'] = self.score.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of save
+        if self.save:
+            _dict['save'] = self.save.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of reuse
+        if self.reuse:
+            _dict['reuse'] = self.reuse.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Shares:
-        """Create an instance of Shares from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TLPCodeSnippetSuggestedInteractions from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Shares.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Shares.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Share.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "save": TLPCodeFragmentSuggestedSave.from_dict(obj["save"]) if obj.get("save") is not None else None,
+            "reuse": TLPCodeFragmentSuggestedReuse.from_dict(obj["reuse"]) if obj.get("reuse") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/space.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/space.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,61 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Space(BaseModel):
     """
-    This is used in the TrackedAssetsEventSearchMetadata  # noqa: E501
-    """
-    size: Optional[StrictInt] = Field(None, description="This is the size of your current catalog.(number of assets)")
-    duration: Optional[StrictInt] = Field(None, description="this is the number in ms it took to run search.")
-    __properties = ["size", "duration"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is used in the TrackedAssetsEventSearchMetadata
+    """ # noqa: E501
+    size: Optional[StrictInt] = Field(default=None, description="This is the size of your current catalog.(number of assets)")
+    duration: Optional[StrictInt] = Field(default=None, description="this is the number in ms it took to run search.")
+    __properties: ClassVar[List[str]] = ["size", "duration"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Space:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Space from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Space:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Space from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Space.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Space.parse_obj({
+        _obj = cls.model_validate({
             "size": obj.get("size"),
             "duration": obj.get("duration")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/streamed_identifier.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_ocr_descriptive_statistics_confidence.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,71 +14,75 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool
-from pieces_os_client.models.referenced_asset import ReferencedAsset
-from pieces_os_client.models.referenced_conversation import ReferencedConversation
-
-class StreamedIdentifier(BaseModel):
-    """
-    This is currently only used within /assets/steam/identifiers && /conversations/steam/identifiers but can be used with other as well, if we want to expand this class.  # noqa: E501
+class GraphicalOCRDescriptiveStatisticsConfidence(BaseModel):
     """
-    asset: Optional[ReferencedAsset] = None
-    conversation: Optional[ReferencedConversation] = None
-    deleted: Optional[StrictBool] = Field(None, description="This is a specific bool that will let us know if we deleted an Identifierfrom the db.")
-    __properties = ["asset", "conversation", "deleted"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GraphicalOCRDescriptiveStatisticsConfidence
+    """ # noqa: E501
+    mean: StrictStr
+    __properties: ClassVar[List[str]] = ["mean"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> StreamedIdentifier:
-        """Create an instance of StreamedIdentifier from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GraphicalOCRDescriptiveStatisticsConfidence from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of asset
-        if self.asset:
-            _dict['asset'] = self.asset.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of conversation
-        if self.conversation:
-            _dict['conversation'] = self.conversation.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> StreamedIdentifier:
-        """Create an instance of StreamedIdentifier from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GraphicalOCRDescriptiveStatisticsConfidence from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return StreamedIdentifier.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = StreamedIdentifier.parse_obj({
-            "asset": ReferencedAsset.from_dict(obj.get("asset")) if obj.get("asset") is not None else None,
-            "conversation": ReferencedConversation.from_dict(obj.get("conversation")) if obj.get("conversation") is not None else None,
-            "deleted": obj.get("deleted")
+        _obj = cls.model_validate({
+            "mean": obj.get("mean")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/streamed_identifiers.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/file_format.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,73 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.streamed_identifier import StreamedIdentifier
+from pieces_os_client.models.transferable_bytes import TransferableBytes
+from pieces_os_client.models.transferable_string import TransferableString
+from typing import Optional, Set
+from typing_extensions import Self
 
-class StreamedIdentifiers(BaseModel):
-    """
-    This is currently only used within /assets/steam/identifiers && /conversations/steam/identifiers but can be used with other as well, if we want to expand this class. && expand the StreamedIdentifier class.  # noqa: E501
+class FileFormat(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(StreamedIdentifier) = Field(...)
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This describes a FileFormat. If you need meta data you can get all of that from your format wrapper.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    bytes: Optional[TransferableBytes] = None
+    string: Optional[TransferableString] = None
+    __properties: ClassVar[List[str]] = ["schema", "bytes", "string"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> StreamedIdentifiers:
-        """Create an instance of StreamedIdentifiers from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FileFormat from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
-        _items = []
-        if self.iterable:
-            for _item in self.iterable:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['iterable'] = _items
+        # override the default output from pydantic by calling `to_dict()` of bytes
+        if self.bytes:
+            _dict['bytes'] = self.bytes.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of string
+        if self.string:
+            _dict['string'] = self.string.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> StreamedIdentifiers:
-        """Create an instance of StreamedIdentifiers from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FileFormat from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return StreamedIdentifiers.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = StreamedIdentifiers.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [StreamedIdentifier.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "bytes": TransferableBytes.from_dict(obj["bytes"]) if obj.get("bytes") is not None else None,
+            "string": TransferableString.from_dict(obj["string"]) if obj.get("string") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/suggestion.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/suggestion.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,59 +14,75 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, Optional, Union
 from pydantic import BaseModel, Field, StrictFloat, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.assets import Assets
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.reuse_suggestion import ReuseSuggestion
 from pieces_os_client.models.save_suggestion import SaveSuggestion
 from pieces_os_client.models.suggestion_target import SuggestionTarget
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Suggestion(BaseModel):
     """
-    This is the model return by the connector's suggest endpoint.  Note: assets are the assets that this target was ran against.  distribution is the distribution that we generated from comparing the target to the asset's vectors.(currently uuid(assetid) : value that is the difference between the asset and the target) **could potentially make an additional model here that is an array from most to least relevent.  *** distribution is required but we are currently unable to reflect that with our current dart generation.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    reuse: ReuseSuggestion = Field(...)
-    save: SaveSuggestion = Field(...)
-    target: SuggestionTarget = Field(...)
-    assets: Assets = Field(...)
+    This is the model return by the connector's suggest endpoint.  Note: assets are the assets that this target was ran against.  distribution is the distribution that we generated from comparing the target to the asset's vectors.(currently uuid(assetid) : value that is the difference between the asset and the target) **could potentially make an additional model here that is an array from most to least relevent.  *** distribution is required but we are currently unable to reflect that with our current dart generation.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    reuse: ReuseSuggestion
+    save: SaveSuggestion
+    target: SuggestionTarget
+    assets: Assets
     distribution: Optional[Dict[str, Union[StrictFloat, StrictInt]]] = None
-    __properties = ["schema", "reuse", "save", "target", "assets", "distribution"]
+    __properties: ClassVar[List[str]] = ["schema", "reuse", "save", "target", "assets", "distribution"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Suggestion:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Suggestion from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of reuse
         if self.reuse:
             _dict['reuse'] = self.reuse.to_dict()
         # override the default output from pydantic by calling `to_dict()` of save
@@ -77,26 +93,26 @@
             _dict['target'] = self.target.to_dict()
         # override the default output from pydantic by calling `to_dict()` of assets
         if self.assets:
             _dict['assets'] = self.assets.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Suggestion:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Suggestion from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Suggestion.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Suggestion.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "reuse": ReuseSuggestion.from_dict(obj.get("reuse")) if obj.get("reuse") is not None else None,
-            "save": SaveSuggestion.from_dict(obj.get("save")) if obj.get("save") is not None else None,
-            "target": SuggestionTarget.from_dict(obj.get("target")) if obj.get("target") is not None else None,
-            "assets": Assets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "reuse": ReuseSuggestion.from_dict(obj["reuse"]) if obj.get("reuse") is not None else None,
+            "save": SaveSuggestion.from_dict(obj["save"]) if obj.get("save") is not None else None,
+            "target": SuggestionTarget.from_dict(obj["target"]) if obj.get("target") is not None else None,
+            "assets": Assets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
             "distribution": obj.get("distribution")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/suggestion_target.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/segmented_technical_language_fragment.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,71 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt
+from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification_generic_enum import ClassificationGenericEnum
+from pieces_os_client.models.classification_specific_enum import ClassificationSpecificEnum
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.seeded_connector_creation import SeededConnectorCreation
+from pieces_os_client.models.fragment_format import FragmentFormat
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SuggestionTarget(BaseModel):
-    """
-    This is the target that was sent to pieces. This will return the string that represents this coppied || pasted asset. This will also send along the SeededConnectorCreation and will send along the vector that we created based on the seed.  # noqa: E501
+class SegmentedTechnicalLanguageFragment(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    seed: SeededConnectorCreation = Field(...)
-    vector: StrictInt = Field(..., description="This is the vector representation of this target that we generated.")
-    __properties = ["schema", "seed", "vector"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the output iterable model for '/machine_learning/text/technical_language/parsers/segmentation'  specific is optional here, however you can pass in classify: true to get the specific classificaiton in the case the generic is code.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    generic: ClassificationGenericEnum
+    specific: Optional[ClassificationSpecificEnum] = None
+    fragment: FragmentFormat
+    __properties: ClassVar[List[str]] = ["schema", "generic", "specific", "fragment"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SuggestionTarget:
-        """Create an instance of SuggestionTarget from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SegmentedTechnicalLanguageFragment from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of seed
-        if self.seed:
-            _dict['seed'] = self.seed.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of fragment
+        if self.fragment:
+            _dict['fragment'] = self.fragment.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SuggestionTarget:
-        """Create an instance of SuggestionTarget from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SegmentedTechnicalLanguageFragment from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SuggestionTarget.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SuggestionTarget.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "seed": SeededConnectorCreation.from_dict(obj.get("seed")) if obj.get("seed") is not None else None,
-            "vector": obj.get("vector")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "generic": obj.get("generic"),
+            "specific": obj.get("specific"),
+            "fragment": FragmentFormat.from_dict(obj["fragment"]) if obj.get("fragment") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/system_execution_cpu_information.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/system_execution_cpu_information.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,63 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-
 from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SystemExecutionCpuInformation(BaseModel):
     """
     SystemExecutionCpuInformation
-    """
-    count: StrictInt = Field(..., description="this is the number of cpus")
-    brand: StrictStr = Field(..., description="this is the brand of cpu")
-    frequency: StrictInt = Field(...)
-    __properties = ["count", "brand", "frequency"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    count: StrictInt = Field(description="this is the number of cpus")
+    brand: StrictStr = Field(description="this is the brand of cpu")
+    frequency: StrictInt
+    __properties: ClassVar[List[str]] = ["count", "brand", "frequency"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SystemExecutionCpuInformation:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SystemExecutionCpuInformation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SystemExecutionCpuInformation:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SystemExecutionCpuInformation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SystemExecutionCpuInformation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SystemExecutionCpuInformation.parse_obj({
+        _obj = cls.model_validate({
             "count": obj.get("count"),
             "brand": obj.get("brand"),
             "frequency": obj.get("frequency")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/system_execution_information.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/system_execution_information.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from pydantic import BaseModel, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
 from pieces_os_client.models.system_execution_cpu_information import SystemExecutionCpuInformation
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SystemExecutionInformation(BaseModel):
     """
-    This is system information that we are able to get from the users machine(rust package TBD). TODO potentially pull this out of TLP.  # noqa: E501
-    """
-    memory: StrictInt = Field(...)
-    os: StrictStr = Field(...)
-    kernel: StrictStr = Field(...)
-    cpu: SystemExecutionCpuInformation = Field(...)
-    __properties = ["memory", "os", "kernel", "cpu"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is system information that we are able to get from the users machine(rust package TBD). TODO potentially pull this out of TLP.
+    """ # noqa: E501
+    memory: StrictInt
+    os: StrictStr
+    kernel: StrictStr
+    cpu: SystemExecutionCpuInformation
+    __properties: ClassVar[List[str]] = ["memory", "os", "kernel", "cpu"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SystemExecutionInformation:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SystemExecutionInformation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of cpu
         if self.cpu:
             _dict['cpu'] = self.cpu.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SystemExecutionInformation:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SystemExecutionInformation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SystemExecutionInformation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SystemExecutionInformation.parse_obj({
+        _obj = cls.model_validate({
             "memory": obj.get("memory"),
             "os": obj.get("os"),
             "kernel": obj.get("kernel"),
-            "cpu": SystemExecutionCpuInformation.from_dict(obj.get("cpu")) if obj.get("cpu") is not None else None
+            "cpu": SystemExecutionCpuInformation.from_dict(obj["cpu"]) if obj.get("cpu") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tag.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tag.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.flattened_assets import FlattenedAssets
 from pieces_os_client.models.flattened_persons import FlattenedPersons
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
 from pieces_os_client.models.relationship import Relationship
 from pieces_os_client.models.score import Score
 from pieces_os_client.models.tag_category_enum import TagCategoryEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Tag(BaseModel):
     """
-    This represents a fully polinated Tag, that is either attached to an asset or a format that adds additional information \"tags\" to describe itself.Helps improve Search and other contextual information that is useful for the user.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="UUID that represents the tag.")
-    text: StrictStr = Field(..., description="represnts the value of a tag.")
-    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(None, description="This is a Map<String, MechanismEnum> where the the key is an asset id.")
+    This represents a fully polinated Tag, that is either attached to an asset or a format that adds additional information \"tags\" to describe itself.Helps improve Search and other contextual information that is useful for the user.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="UUID that represents the tag.")
+    text: StrictStr = Field(description="represnts the value of a tag.")
+    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(default=None, description="This is a Map<String, MechanismEnum> where the the key is an asset id.")
     assets: Optional[FlattenedAssets] = None
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
     deleted: Optional[GroupedTimestamp] = None
-    category: TagCategoryEnum = Field(...)
+    category: TagCategoryEnum
     relationship: Optional[Relationship] = None
-    interactions: Optional[StrictInt] = Field(None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
+    interactions: Optional[StrictInt] = Field(default=None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
     persons: Optional[FlattenedPersons] = None
     score: Optional[Score] = None
-    __properties = ["schema", "id", "text", "mechanisms", "assets", "created", "updated", "deleted", "category", "relationship", "interactions", "persons", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "id", "text", "mechanisms", "assets", "created", "updated", "deleted", "category", "relationship", "interactions", "persons", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Tag:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Tag from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of assets
         if self.assets:
             _dict['assets'] = self.assets.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
@@ -96,33 +112,33 @@
             _dict['persons'] = self.persons.to_dict()
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Tag:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Tag from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Tag.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Tag.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
             "text": obj.get("text"),
             "mechanisms": dict((_k, _v) for _k, _v in obj.get("mechanisms").items()),
-            "assets": FlattenedAssets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
             "category": obj.get("category"),
-            "relationship": Relationship.from_dict(obj.get("relationship")) if obj.get("relationship") is not None else None,
+            "relationship": Relationship.from_dict(obj["relationship"]) if obj.get("relationship") is not None else None,
             "interactions": obj.get("interactions"),
-            "persons": FlattenedPersons.from_dict(obj.get("persons")) if obj.get("persons") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "persons": FlattenedPersons.from_dict(obj["persons"]) if obj.get("persons") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tag_category_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/externally_sourced_enum.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,34 +9,40 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class TagCategoryEnum(str, Enum):
+class ExternallySourcedEnum(str, Enum):
     """
-    This is an enum that describes the category that that this tag is apart of.
+    This is an enum that will highlight something that is externally sourced.
     """
 
     """
     allowed enum values
     """
-    HANDLE = 'HANDLE'
-    EMAIL = 'EMAIL'
-    UNKNOWN = 'UNKNOWN'
+    TWITTER = 'TWITTER'
+    MEDIUM = 'MEDIUM'
+    LINKED_IN = 'LINKED_IN'
+    INSTAGRAM = 'INSTAGRAM'
+    FACEBOOK = 'FACEBOOK'
+    REDDIT = 'REDDIT'
+    DISCORD = 'DISCORD'
+    BIT_BUCKET = 'BIT_BUCKET'
+    GIT_LAB = 'GIT_LAB'
+    GIT_HUB = 'GIT_HUB'
+    SLACK = 'SLACK'
+    MAILGUN = 'MAILGUN'
 
     @classmethod
-    def from_json(cls, json_str: str) -> TagCategoryEnum:
-        """Create an instance of TagCategoryEnum from a JSON string"""
-        return TagCategoryEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ExternallySourcedEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tags.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tags.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,55 +14,71 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
 from pieces_os_client.models.tag import Tag
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Tags(BaseModel):
     """
-    This is a model that represents multiple Tag Models  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Tag) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(None, description="This is a Map<String, int> where the the key is an tag id.")
+    This is a model that represents multiple Tag Models
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Tag]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an tag id.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Tags:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Tags from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
@@ -71,24 +87,24 @@
             _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Tags:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Tags from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Tags.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Tags.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Tag.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Tag.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
             "indices": obj.get("indices"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/text_location.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_user_profile.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,69 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TextLocation(BaseModel):
-    """
-    This is a generic model that is used for text location.  # noqa: E501
+class TrackedUserProfile(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    text: StrictStr = Field(..., description="this is the value that was found.")
-    start: StrictInt = Field(..., description="this is the start index within the original string.")
-    end: StrictInt = Field(..., description="this is the end index within the original string.")
-    __properties = ["schema", "text", "start", "end"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A user that will be passed along with each analytics event
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="The ID of the user that you are tracking.")
+    username: StrictStr = Field(description="This is a username that is attempted to be assigned but is \"Anonymous User\" by default")
+    email: Optional[StrictStr] = Field(default=None, description="The user's email if we have it.")
+    granularity: StrictStr = Field(description="At what level is this user being tracked.")
+    __properties: ClassVar[List[str]] = ["schema", "id", "username", "email", "granularity"]
+
+    @field_validator('granularity')
+    def granularity_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in set(['DEVICE', 'ACCOUNT', 'ANONYMOUS']):
+            raise ValueError("must be one of enum values ('DEVICE', 'ACCOUNT', 'ANONYMOUS')")
+        return value
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TextLocation:
-        """Create an instance of TextLocation from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedUserProfile from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TextLocation:
-        """Create an instance of TextLocation from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedUserProfile from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TextLocation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TextLocation.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "text": obj.get("text"),
-            "start": obj.get("start"),
-            "end": obj.get("end")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "username": obj.get("username") if obj.get("username") is not None else 'unknown',
+            "email": obj.get("email"),
+            "granularity": obj.get("granularity") if obj.get("granularity") is not None else 'ANONYMOUS'
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/text_match.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_dependencies_information.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,74 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.text_location import TextLocation
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TextMatch(BaseModel):
-    """
-    Thext Match currently used for sensitive for scales for people, and anything related to text matching.  group: is the entire match subgroup is the inner match within the group.(optional)  # noqa: E501
+class OSDeviceDependenciesInformation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    group: TextLocation = Field(...)
-    subgroup: Optional[TextLocation] = None
-    __properties = ["schema", "group", "subgroup"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will lets us know about specific dependencies that we are looking for on the device that are needed for specific tasks.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    vulkan: StrictBool = Field(description="This will let us know if vulkan is present = true or not there ==false")
+    __properties: ClassVar[List[str]] = ["schema", "vulkan"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TextMatch:
-        """Create an instance of TextMatch from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OSDeviceDependenciesInformation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of group
-        if self.group:
-            _dict['group'] = self.group.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of subgroup
-        if self.subgroup:
-            _dict['subgroup'] = self.subgroup.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TextMatch:
-        """Create an instance of TextMatch from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OSDeviceDependenciesInformation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TextMatch.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TextMatch.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "group": TextLocation.from_dict(obj.get("group")) if obj.get("group") is not None else None,
-            "subgroup": TextLocation.from_dict(obj.get("subgroup")) if obj.get("subgroup") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "vulkan": obj.get("vulkan")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/theme.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/precreated_external_provider_api_key.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,65 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.auth0_open_ai_user_metadata import Auth0OpenAIUserMetadata
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Theme(BaseModel):
-    """
-    This will describe the theme that belongs to a user.  # noqa: E501
+class PrecreatedExternalProviderApiKey(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    dark: StrictBool = Field(...)
-    __properties = ["schema", "dark"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the input model for /external_provider/api_key/create
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    user: StrictStr = Field(description="This is the ID of the User.")
+    open_ai: Optional[Auth0OpenAIUserMetadata] = Field(default=None, alias="open_AI")
+    __properties: ClassVar[List[str]] = ["schema", "user", "open_AI"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Theme:
-        """Create an instance of Theme from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PrecreatedExternalProviderApiKey from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of open_ai
+        if self.open_ai:
+            _dict['open_AI'] = self.open_ai.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Theme:
-        """Create an instance of Theme from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PrecreatedExternalProviderApiKey from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Theme.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Theme.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "dark": obj.get("dark")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "user": obj.get("user"),
+            "open_AI": Auth0OpenAIUserMetadata.from_dict(obj["open_AI"]) if obj.get("open_AI") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_directory_analytics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/discovered_html_webpage.py`

 * *Files 27% similar despite different names*

```diff
@@ -14,65 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.discovered_assets import DiscoveredAssets
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TLPCodeDirectoryAnalytics(BaseModel):
-    """
-    TLPCodeDirectoryAnalytics
+class DiscoveredHtmlWebpage(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: Optional[StrictStr] = None
-    __properties = ["schema", "id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will return assets that were extracted from the html webpage. This will contain the original url so you can double check the results wtih the results you passed in, but it will remain in the same order that it was passed in if used within the /discover/discover/html/webpage endpoint.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    assets: DiscoveredAssets
+    url: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "assets", "url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeDirectoryAnalytics:
-        """Create an instance of TLPCodeDirectoryAnalytics from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DiscoveredHtmlWebpage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of assets
+        if self.assets:
+            _dict['assets'] = self.assets.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeDirectoryAnalytics:
-        """Create an instance of TLPCodeDirectoryAnalytics from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DiscoveredHtmlWebpage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeDirectoryAnalytics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeDirectoryAnalytics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "assets": DiscoveredAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "url": obj.get("url")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_classification.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_classification.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,93 +14,109 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
 from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.system_execution_information import SystemExecutionInformation
 from pieces_os_client.models.tlp_code_fragment_classification_metadata import TLPCodeFragmentClassificationMetadata
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TLPCodeFragmentClassification(BaseModel):
     """
-    Model for ML big query classification.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: StrictStr = Field(...)
-    model: StrictStr = Field(...)
-    created: StrictStr = Field(...)
-    classification: StrictStr = Field(...)
-    probability: Union[StrictFloat, StrictInt] = Field(...)
-    context: StrictStr = Field(...)
+    Model for ML big query classification.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    asset: StrictStr
+    model: StrictStr
+    created: StrictStr
+    classification: StrictStr
+    probability: Union[StrictFloat, StrictInt]
+    context: StrictStr
     distribution: Optional[StrictStr] = None
     metadata: Optional[TLPCodeFragmentClassificationMetadata] = None
-    user: StrictStr = Field(..., description="identifier for the user")
-    latency: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="this is the time it takes to run this model.")
+    user: StrictStr = Field(description="identifier for the user")
+    latency: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="this is the time it takes to run this model.")
     system: Optional[SystemExecutionInformation] = None
-    __properties = ["schema", "asset", "model", "created", "classification", "probability", "context", "distribution", "metadata", "user", "latency", "system"]
+    __properties: ClassVar[List[str]] = ["schema", "asset", "model", "created", "classification", "probability", "context", "distribution", "metadata", "user", "latency", "system"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeFragmentClassification:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TLPCodeFragmentClassification from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
             _dict['metadata'] = self.metadata.to_dict()
         # override the default output from pydantic by calling `to_dict()` of system
         if self.system:
             _dict['system'] = self.system.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeFragmentClassification:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TLPCodeFragmentClassification from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeFragmentClassification.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeFragmentClassification.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "asset": obj.get("asset"),
             "model": obj.get("model"),
             "created": obj.get("created"),
             "classification": obj.get("classification"),
             "probability": obj.get("probability"),
             "context": obj.get("context"),
             "distribution": obj.get("distribution"),
-            "metadata": TLPCodeFragmentClassificationMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None,
+            "metadata": TLPCodeFragmentClassificationMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None,
             "user": obj.get("user"),
             "latency": obj.get("latency"),
-            "system": SystemExecutionInformation.from_dict(obj.get("system")) if obj.get("system") is not None else None
+            "system": SystemExecutionInformation.from_dict(obj["system"]) if obj.get("system") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_classification_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/graphical_machine_learning_processing_event.py`

 * *Files 27% similar despite different names*

```diff
@@ -14,74 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
-from pieces_os_client.models.classification import Classification
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.graphical_image_processing import GraphicalImageProcessing
+from pieces_os_client.models.graphical_ocr_processing import GraphicalOCRProcessing
+from pieces_os_client.models.graphical_svg_statistics import GraphicalSVGStatistics
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TLPCodeFragmentClassificationMetadata(BaseModel):
-    """
-    TLPCodeFragmentClassificationMetadata
+class GraphicalMachineLearningProcessingEvent(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    context: Optional[Classification] = None
-    prior: Optional[Classification] = None
-    __properties = ["schema", "context", "prior"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GraphicalMachineLearningProcessingEvent
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    ocr: Optional[GraphicalOCRProcessing] = None
+    image: Optional[GraphicalImageProcessing] = None
+    svg: Optional[GraphicalSVGStatistics] = None
+    __properties: ClassVar[List[str]] = ["schema", "ocr", "image", "svg"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeFragmentClassificationMetadata:
-        """Create an instance of TLPCodeFragmentClassificationMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GraphicalMachineLearningProcessingEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of context
-        if self.context:
-            _dict['context'] = self.context.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of prior
-        if self.prior:
-            _dict['prior'] = self.prior.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of ocr
+        if self.ocr:
+            _dict['ocr'] = self.ocr.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of image
+        if self.image:
+            _dict['image'] = self.image.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of svg
+        if self.svg:
+            _dict['svg'] = self.svg.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeFragmentClassificationMetadata:
-        """Create an instance of TLPCodeFragmentClassificationMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GraphicalMachineLearningProcessingEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeFragmentClassificationMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeFragmentClassificationMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "context": Classification.from_dict(obj.get("context")) if obj.get("context") is not None else None,
-            "prior": Classification.from_dict(obj.get("prior")) if obj.get("prior") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "ocr": GraphicalOCRProcessing.from_dict(obj["ocr"]) if obj.get("ocr") is not None else None,
+            "image": GraphicalImageProcessing.from_dict(obj["image"]) if obj.get("image") is not None else None,
+            "svg": GraphicalSVGStatistics.from_dict(obj["svg"]) if obj.get("svg") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_description.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_description.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,68 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
 from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TLPCodeFragmentDescription(BaseModel):
     """
-    Model for ML big query Code Description.  # noqa: E501
-    """
-    description: Optional[StrictStr] = Field(None, description="This is the stringified json of a TLPDescription object")
-    asset: StrictStr = Field(..., description="This is the asset id.")
-    created: StrictStr = Field(..., description="timestamp of creation")
-    model: StrictStr = Field(..., description="this is the model version")
-    latency: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="the time it takes to run this model.")
-    user: StrictStr = Field(..., description="the uuid of the user the description was created for.")
-    context: Optional[StrictStr] = Field(None, description="the application this description was created from.")
-    os: Optional[StrictStr] = Field(None, description="This is the UUID of the OS that this context is currently connected to.")
-    __properties = ["description", "asset", "created", "model", "latency", "user", "context", "os"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Model for ML big query Code Description.
+    """ # noqa: E501
+    description: Optional[StrictStr] = Field(default=None, description="This is the stringified json of a TLPDescription object")
+    asset: StrictStr = Field(description="This is the asset id.")
+    created: StrictStr = Field(description="timestamp of creation")
+    model: StrictStr = Field(description="this is the model version")
+    latency: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="the time it takes to run this model.")
+    user: StrictStr = Field(description="the uuid of the user the description was created for.")
+    context: Optional[StrictStr] = Field(default=None, description="the application this description was created from.")
+    os: Optional[StrictStr] = Field(default=None, description="This is the UUID of the OS that this context is currently connected to.")
+    __properties: ClassVar[List[str]] = ["description", "asset", "created", "model", "latency", "user", "context", "os"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeFragmentDescription:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TLPCodeFragmentDescription from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeFragmentDescription:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TLPCodeFragmentDescription from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeFragmentDescription.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeFragmentDescription.parse_obj({
+        _obj = cls.model_validate({
             "description": obj.get("description"),
             "asset": obj.get("asset"),
             "created": obj.get("created"),
             "model": obj.get("model"),
             "latency": obj.get("latency"),
             "user": obj.get("user"),
             "context": obj.get("context"),
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_descriptive_statistics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_descriptive_statistics.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
 from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TLPCodeFragmentDescriptiveStatistics(BaseModel):
     """
-    Model for ML big query Data collection.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    user: StrictStr = Field(...)
-    os: StrictStr = Field(...)
-    language: StrictStr = Field(...)
-    length: Union[StrictFloat, StrictInt] = Field(...)
-    ast: StrictStr = Field(...)
-    timestamp: StrictStr = Field(...)
-    asset: StrictStr = Field(...)
-    context: StrictStr = Field(..., description="this is the application in which this was created from.")
-    snippet: StrictStr = Field(..., description="this is the value of the snippet")
-    __properties = ["schema", "user", "os", "language", "length", "ast", "timestamp", "asset", "context", "snippet"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Model for ML big query Data collection.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    user: StrictStr
+    os: StrictStr
+    language: StrictStr
+    length: Union[StrictFloat, StrictInt]
+    ast: StrictStr
+    timestamp: StrictStr
+    asset: StrictStr
+    context: StrictStr = Field(description="this is the application in which this was created from.")
+    snippet: StrictStr = Field(description="this is the value of the snippet")
+    __properties: ClassVar[List[str]] = ["schema", "user", "os", "language", "length", "ast", "timestamp", "asset", "context", "snippet"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeFragmentDescriptiveStatistics:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TLPCodeFragmentDescriptiveStatistics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeFragmentDescriptiveStatistics:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TLPCodeFragmentDescriptiveStatistics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeFragmentDescriptiveStatistics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeFragmentDescriptiveStatistics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "user": obj.get("user"),
             "os": obj.get("os"),
             "language": obj.get("language"),
             "length": obj.get("length"),
             "ast": obj.get("ast"),
             "timestamp": obj.get("timestamp"),
             "asset": obj.get("asset"),
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_reclassification.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_fragment_reclassification.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,79 +14,95 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.tlp_code_fragment_reclassification_updates import TLPCodeFragmentReclassificationUpdates
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TLPCodeFragmentReclassification(BaseModel):
     """
-    Model for ML big query Reclassification.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: StrictStr = Field(...)
-    model: StrictStr = Field(...)
-    created: StrictStr = Field(...)
-    updates: TLPCodeFragmentReclassificationUpdates = Field(...)
-    user: StrictStr = Field(..., description="this is the user that is reclassifying")
-    context: StrictStr = Field(..., description="this is the application is which this is from.")
-    __properties = ["schema", "asset", "model", "created", "updates", "user", "context"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Model for ML big query Reclassification.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    asset: StrictStr
+    model: StrictStr
+    created: StrictStr
+    updates: TLPCodeFragmentReclassificationUpdates
+    user: StrictStr = Field(description="this is the user that is reclassifying")
+    context: StrictStr = Field(description="this is the application is which this is from.")
+    __properties: ClassVar[List[str]] = ["schema", "asset", "model", "created", "updates", "user", "context"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeFragmentReclassification:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TLPCodeFragmentReclassification from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updates
         if self.updates:
             _dict['updates'] = self.updates.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeFragmentReclassification:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TLPCodeFragmentReclassification from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeFragmentReclassification.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeFragmentReclassification.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "asset": obj.get("asset"),
             "model": obj.get("model"),
             "created": obj.get("created"),
-            "updates": TLPCodeFragmentReclassificationUpdates.from_dict(obj.get("updates")) if obj.get("updates") is not None else None,
+            "updates": TLPCodeFragmentReclassificationUpdates.from_dict(obj["updates"]) if obj.get("updates") is not None else None,
             "user": obj.get("user"),
             "context": obj.get("context")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_reclassification_updates.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_discoverable_asset.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,74 +14,99 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
-from pieces_os_client.models.classification import Classification
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.seeded_file import SeededFile
+from pieces_os_client.models.seeded_fragment import SeededFragment
+from pieces_os_client.models.tlp_directed_discovery_filters import TLPDirectedDiscoveryFilters
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TLPCodeFragmentReclassificationUpdates(BaseModel):
-    """
-    TLPCodeFragmentReclassificationUpdates
+class SeededDiscoverableAsset(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    previous: Classification = Field(...)
-    current: Classification = Field(...)
-    __properties = ["schema", "previous", "current"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Assumption: filters applied in this model will overwrite filters passed in SeededDiscoverableAssets
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    file: Optional[SeededFile] = None
+    fragment: Optional[SeededFragment] = None
+    directory: Optional[StrictStr] = None
+    filters: Optional[TLPDirectedDiscoveryFilters] = None
+    __properties: ClassVar[List[str]] = ["schema", "file", "fragment", "directory", "filters"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeFragmentReclassificationUpdates:
-        """Create an instance of TLPCodeFragmentReclassificationUpdates from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededDiscoverableAsset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of previous
-        if self.previous:
-            _dict['previous'] = self.previous.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of current
-        if self.current:
-            _dict['current'] = self.current.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of file
+        if self.file:
+            _dict['file'] = self.file.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of fragment
+        if self.fragment:
+            _dict['fragment'] = self.fragment.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of filters
+        if self.filters:
+            _dict['filters'] = self.filters.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeFragmentReclassificationUpdates:
-        """Create an instance of TLPCodeFragmentReclassificationUpdates from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededDiscoverableAsset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeFragmentReclassificationUpdates.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeFragmentReclassificationUpdates.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "previous": Classification.from_dict(obj.get("previous")) if obj.get("previous") is not None else None,
-            "current": Classification.from_dict(obj.get("current")) if obj.get("current") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "file": SeededFile.from_dict(obj["file"]) if obj.get("file") is not None else None,
+            "fragment": SeededFragment.from_dict(obj["fragment"]) if obj.get("fragment") is not None else None,
+            "directory": obj.get("directory"),
+            "filters": TLPDirectedDiscoveryFilters.from_dict(obj["filters"]) if obj.get("filters") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_fragment_suggested_save.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_format.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,79 +14,96 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.classification import Classification
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.role import Role
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TLPCodeFragmentSuggestedSave(BaseModel):
-    """
-    Model for monitoring and evaluating the suggested save feature  # noqa: E501
+class TrackedFormat(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset: StrictStr = Field(...)
-    user: StrictStr = Field(...)
-    model: StrictStr = Field(...)
-    created: StrictStr = Field(...)
-    os: StrictStr = Field(...)
-    context: Optional[StrictStr] = Field(None, description="context from where suggestion came from")
-    score: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="maximum similarity score")
-    candidates: Optional[StrictInt] = Field(None, description="number of candidates")
-    __properties = ["schema", "asset", "user", "model", "created", "os", "context", "score", "candidates"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A minimal format to send to Mixpanel
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="The UUID of the format")
+    classification: Classification
+    role: Role
+    asset: StrictStr = Field(description="The UUID of the asset associated")
+    fragment: StrictBool
+    file: StrictBool
+    __properties: ClassVar[List[str]] = ["schema", "id", "classification", "role", "asset", "fragment", "file"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeFragmentSuggestedSave:
-        """Create an instance of TLPCodeFragmentSuggestedSave from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedFormat from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of classification
+        if self.classification:
+            _dict['classification'] = self.classification.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeFragmentSuggestedSave:
-        """Create an instance of TLPCodeFragmentSuggestedSave from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedFormat from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeFragmentSuggestedSave.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeFragmentSuggestedSave.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "classification": Classification.from_dict(obj["classification"]) if obj.get("classification") is not None else None,
+            "role": obj.get("role"),
             "asset": obj.get("asset"),
-            "user": obj.get("user"),
-            "model": obj.get("model"),
-            "created": obj.get("created"),
-            "os": obj.get("os"),
-            "context": obj.get("context"),
-            "score": obj.get("score"),
-            "candidates": obj.get("candidates")
+            "fragment": obj.get("fragment"),
+            "file": obj.get("file")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_processing.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_share.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,87 +14,106 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.access_enum import AccessEnum
+from pieces_os_client.models.asset import Asset
+from pieces_os_client.models.assets import Assets
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.tlp_code_directory_analytics import TLPCodeDirectoryAnalytics
-from pieces_os_client.models.tlp_code_file_analytics import TLPCodeFileAnalytics
-from pieces_os_client.models.tlp_code_repository_analytics import TLPCodeRepositoryAnalytics
-from pieces_os_client.models.tlp_code_snippet_analytics import TLPCodeSnippetAnalytics
+from pieces_os_client.models.seeded_user import SeededUser
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TLPCodeProcessing(BaseModel):
-    """
-    TLPCodeProcessing
+class SeededShare(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    fragment: Optional[TLPCodeSnippetAnalytics] = None
-    file: Optional[TLPCodeFileAnalytics] = None
-    directory: Optional[TLPCodeDirectoryAnalytics] = None
-    repository: Optional[TLPCodeRepositoryAnalytics] = None
-    __properties = ["schema", "fragment", "file", "directory", "repository"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+     required to pass in an asset or assets.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    asset: Optional[Asset] = None
+    users: Optional[List[SeededUser]] = Field(default=None, description="if private please specificy some users you want to share this with.")
+    access: AccessEnum
+    assets: Optional[Assets] = None
+    name: Optional[StrictStr] = Field(default=None, description="optional name, if it is available. and must be unique.")
+    __properties: ClassVar[List[str]] = ["schema", "asset", "users", "access", "assets", "name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeProcessing:
-        """Create an instance of TLPCodeProcessing from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededShare from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of fragment
-        if self.fragment:
-            _dict['fragment'] = self.fragment.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of file
-        if self.file:
-            _dict['file'] = self.file.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of directory
-        if self.directory:
-            _dict['directory'] = self.directory.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of repository
-        if self.repository:
-            _dict['repository'] = self.repository.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of asset
+        if self.asset:
+            _dict['asset'] = self.asset.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in users (list)
+        _items = []
+        if self.users:
+            for _item in self.users:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['users'] = _items
+        # override the default output from pydantic by calling `to_dict()` of assets
+        if self.assets:
+            _dict['assets'] = self.assets.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeProcessing:
-        """Create an instance of TLPCodeProcessing from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededShare from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeProcessing.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeProcessing.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "fragment": TLPCodeSnippetAnalytics.from_dict(obj.get("fragment")) if obj.get("fragment") is not None else None,
-            "file": TLPCodeFileAnalytics.from_dict(obj.get("file")) if obj.get("file") is not None else None,
-            "directory": TLPCodeDirectoryAnalytics.from_dict(obj.get("directory")) if obj.get("directory") is not None else None,
-            "repository": TLPCodeRepositoryAnalytics.from_dict(obj.get("repository")) if obj.get("repository") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "asset": Asset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "users": [SeededUser.from_dict(_item) for _item in obj["users"]] if obj.get("users") is not None else None,
+            "access": obj.get("access"),
+            "assets": Assets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_repository_analytics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_github_gists_import.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,65 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TLPCodeRepositoryAnalytics(BaseModel):
-    """
-    TLPCodeRepositoryAnalytics
+class SeededGithubGistsImport(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: Optional[StrictStr] = None
-    __properties = ["schema", "id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is the body of the /github/gists/import,  by default we will look for everything from your private gists, (TODO hook up public gists.)&& get clever  currently we will not ensure that this is a good pieces for you but we will just get you the gist and let you do what you want with it(room for improvement, if we want to layer in advanced pieces discovery)  For the future, we might want to add a max number of assets that are returned from this.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    application: StrictStr = Field(description="application id.")
+    public: Optional[StrictBool] = Field(default=None, description="This will default to false.(ie private), currently not supporting pulling public gists.")
+    __properties: ClassVar[List[str]] = ["schema", "application", "public"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeRepositoryAnalytics:
-        """Create an instance of TLPCodeRepositoryAnalytics from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededGithubGistsImport from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeRepositoryAnalytics:
-        """Create an instance of TLPCodeRepositoryAnalytics from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededGithubGistsImport from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeRepositoryAnalytics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeRepositoryAnalytics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "application": obj.get("application"),
+            "public": obj.get("public")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_snippet_analytics.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_snippet_analytics.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,62 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.tlp_code_fragment_classification import TLPCodeFragmentClassification
 from pieces_os_client.models.tlp_code_fragment_description import TLPCodeFragmentDescription
 from pieces_os_client.models.tlp_code_fragment_reclassification import TLPCodeFragmentReclassification
 from pieces_os_client.models.tlp_code_fragment_statistics import TLPCodeFragmentStatistics
 from pieces_os_client.models.tlp_code_fragment_tagify import TLPCodeFragmentTagify
 from pieces_os_client.models.tlp_code_snippet_suggested_interactions import TLPCodeSnippetSuggestedInteractions
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TLPCodeSnippetAnalytics(BaseModel):
     """
     TLPCodeSnippetAnalytics
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     statistics: Optional[TLPCodeFragmentStatistics] = None
     classification: Optional[TLPCodeFragmentClassification] = None
     reclassification: Optional[TLPCodeFragmentReclassification] = None
     suggested: Optional[TLPCodeSnippetSuggestedInteractions] = None
     tagify: Optional[TLPCodeFragmentTagify] = None
     description: Optional[TLPCodeFragmentDescription] = None
-    __properties = ["schema", "statistics", "classification", "reclassification", "suggested", "tagify", "description"]
+    __properties: ClassVar[List[str]] = ["schema", "statistics", "classification", "reclassification", "suggested", "tagify", "description"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeSnippetAnalytics:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TLPCodeSnippetAnalytics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of statistics
         if self.statistics:
             _dict['statistics'] = self.statistics.to_dict()
         # override the default output from pydantic by calling `to_dict()` of classification
@@ -86,27 +102,27 @@
             _dict['tagify'] = self.tagify.to_dict()
         # override the default output from pydantic by calling `to_dict()` of description
         if self.description:
             _dict['description'] = self.description.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeSnippetAnalytics:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TLPCodeSnippetAnalytics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeSnippetAnalytics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeSnippetAnalytics.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "statistics": TLPCodeFragmentStatistics.from_dict(obj.get("statistics")) if obj.get("statistics") is not None else None,
-            "classification": TLPCodeFragmentClassification.from_dict(obj.get("classification")) if obj.get("classification") is not None else None,
-            "reclassification": TLPCodeFragmentReclassification.from_dict(obj.get("reclassification")) if obj.get("reclassification") is not None else None,
-            "suggested": TLPCodeSnippetSuggestedInteractions.from_dict(obj.get("suggested")) if obj.get("suggested") is not None else None,
-            "tagify": TLPCodeFragmentTagify.from_dict(obj.get("tagify")) if obj.get("tagify") is not None else None,
-            "description": TLPCodeFragmentDescription.from_dict(obj.get("description")) if obj.get("description") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "statistics": TLPCodeFragmentStatistics.from_dict(obj["statistics"]) if obj.get("statistics") is not None else None,
+            "classification": TLPCodeFragmentClassification.from_dict(obj["classification"]) if obj.get("classification") is not None else None,
+            "reclassification": TLPCodeFragmentReclassification.from_dict(obj["reclassification"]) if obj.get("reclassification") is not None else None,
+            "suggested": TLPCodeSnippetSuggestedInteractions.from_dict(obj["suggested"]) if obj.get("suggested") is not None else None,
+            "tagify": TLPCodeFragmentTagify.from_dict(obj["tagify"]) if obj.get("tagify") is not None else None,
+            "description": TLPCodeFragmentDescription.from_dict(obj["description"]) if obj.get("description") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_code_snippet_tagify_code.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tlp_code_snippet_tagify_code.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,76 +14,92 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional, Union
 from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TLPCodeSnippetTagifyCode(BaseModel):
     """
-      # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    distribution: StrictStr = Field(..., description="stringified array of numbers")
-    inferred_distribution: StrictStr = Field(..., description="stringified array of numbers")
-    tags: StrictStr = Field(..., description="stringified array of strings")
-    inferred_tags: StrictStr = Field(..., description="stringified array of strings")
-    model: StrictStr = Field(..., description="this is the model version ")
-    label_version: StrictStr = Field(..., description="This is the version of the file that we are using that contains all the possible tags")
-    threshold: Union[StrictFloat, StrictInt] = Field(..., description="this is the minimum score from the model that a tag needs to have to be included in the tags array.")
-    inferred_threshold: Union[StrictFloat, StrictInt] = Field(..., description="this is the minimum score from the postprocessing that a tag needs to have to be included in the inferred_tags array.")
-    context: StrictStr = Field(..., description="this is the origin in which this asset was created, application(string representation)")
-    asset: StrictStr = Field(..., description="This is the asset id.")
-    __properties = ["schema", "distribution", "inferred_distribution", "tags", "inferred_tags", "model", "label_version", "threshold", "inferred_threshold", "context", "asset"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    distribution: StrictStr = Field(description="stringified array of numbers")
+    inferred_distribution: StrictStr = Field(description="stringified array of numbers")
+    tags: StrictStr = Field(description="stringified array of strings")
+    inferred_tags: StrictStr = Field(description="stringified array of strings")
+    model: StrictStr = Field(description="this is the model version ")
+    label_version: StrictStr = Field(description="This is the version of the file that we are using that contains all the possible tags")
+    threshold: Union[StrictFloat, StrictInt] = Field(description="this is the minimum score from the model that a tag needs to have to be included in the tags array.")
+    inferred_threshold: Union[StrictFloat, StrictInt] = Field(description="this is the minimum score from the postprocessing that a tag needs to have to be included in the inferred_tags array.")
+    context: StrictStr = Field(description="this is the origin in which this asset was created, application(string representation)")
+    asset: StrictStr = Field(description="This is the asset id.")
+    __properties: ClassVar[List[str]] = ["schema", "distribution", "inferred_distribution", "tags", "inferred_tags", "model", "label_version", "threshold", "inferred_threshold", "context", "asset"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPCodeSnippetTagifyCode:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TLPCodeSnippetTagifyCode from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TLPCodeSnippetTagifyCode:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TLPCodeSnippetTagifyCode from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TLPCodeSnippetTagifyCode.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TLPCodeSnippetTagifyCode.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "distribution": obj.get("distribution"),
             "inferred_distribution": obj.get("inferred_distribution"),
             "tags": obj.get("tags"),
             "inferred_tags": obj.get("inferred_tags"),
             "model": obj.get("model"),
             "label_version": obj.get("label_version"),
             "threshold": obj.get("threshold"),
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tlp_directed_discovery_filter_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_message_role_enum.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,41 +9,31 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class TLPDirectedDiscoveryFilterEnum(str, Enum):
+class QGPTConversationMessageRoleEnum(str, Enum):
     """
-    Code block type like function, class, abstract
+    This is the role enum used for a QGPT conversation
     """
 
     """
     allowed enum values
     """
-    FUNCTION = 'FUNCTION'
-    METHOD = 'METHOD'
-    CLASS = 'CLASS'
-    STRUCT = 'STRUCT'
-    ABSTRACT = 'ABSTRACT'
-    COMMENT = 'COMMENT'
-    IMPORT = 'IMPORT'
-    IF = 'IF'
-    LOOP = 'LOOP'
-    RETURN = 'RETURN'
+    USER = 'USER'
+    SYSTEM = 'SYSTEM'
+    ASSISTANT = 'ASSISTANT'
 
     @classmethod
-    def from_json(cls, json_str: str) -> TLPDirectedDiscoveryFilterEnum:
-        """Create an instance of TLPDirectedDiscoveryFilterEnum from a JSON string"""
-        return TLPDirectedDiscoveryFilterEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of QGPTConversationMessageRoleEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tokenized_pkce.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tokenized_pkce.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,79 +14,95 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TokenizedPKCE(BaseModel):
     """
-    This is the flow that mobile apps use to access an API. Use this endpoint to exchange an Authorization Code for a Token.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    grant_type: StrictStr = Field(..., description="Denotes the flow you are using. For Authorization Code, use authorization_code or refresh_token.")
-    client_id: StrictStr = Field(..., description="Your application's Client ID.")
-    code: StrictStr = Field(..., description="The Authorization Code received from the initial /authorize call.")
-    redirect_uri: StrictStr = Field(..., description="This is required only if it was set at the GET /authorize endpoint. The values must match.")
-    code_verifier: StrictStr = Field(..., description="Cryptographically random key that was used to generate the code_challenge passed to /authorize.")
-    audience: Optional[StrictStr] = Field(None, description="The audience domain: i.e. https://pieces.us.auth0.com")
-    __properties = ["schema", "grant_type", "client_id", "code", "redirect_uri", "code_verifier", "audience"]
+    This is the flow that mobile apps use to access an API. Use this endpoint to exchange an Authorization Code for a Token.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    grant_type: StrictStr = Field(description="Denotes the flow you are using. For Authorization Code, use authorization_code or refresh_token.")
+    client_id: StrictStr = Field(description="Your application's Client ID.")
+    code: StrictStr = Field(description="The Authorization Code received from the initial /authorize call.")
+    redirect_uri: StrictStr = Field(description="This is required only if it was set at the GET /authorize endpoint. The values must match.")
+    code_verifier: StrictStr = Field(description="Cryptographically random key that was used to generate the code_challenge passed to /authorize.")
+    audience: Optional[StrictStr] = Field(default=None, description="The audience domain: i.e. https://pieces.us.auth0.com")
+    __properties: ClassVar[List[str]] = ["schema", "grant_type", "client_id", "code", "redirect_uri", "code_verifier", "audience"]
 
-    @validator('grant_type')
+    @field_validator('grant_type')
     def grant_type_validate_enum(cls, value):
         """Validates the enum"""
-        if value not in ('refresh_token', 'authorization_code'):
+        if value not in set(['refresh_token', 'authorization_code']):
             raise ValueError("must be one of enum values ('refresh_token', 'authorization_code')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TokenizedPKCE:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TokenizedPKCE from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TokenizedPKCE:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TokenizedPKCE from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TokenizedPKCE.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TokenizedPKCE.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "grant_type": obj.get("grant_type"),
             "client_id": obj.get("client_id"),
             "code": obj.get("code"),
             "redirect_uri": obj.get("redirect_uri"),
             "code_verifier": obj.get("code_verifier"),
             "audience": obj.get("audience")
         })
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_application.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_assets_event_search_metadata.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,75 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-from pieces_os_client.models.application_name_enum import ApplicationNameEnum
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.platform_enum import PlatformEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TrackedApplication(BaseModel):
-    """
-    A Model to describe what application a format/analytics event originated.  # noqa: E501
+class TrackedAssetsEventSearchMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="The ID of the tracked application.")
-    name: ApplicationNameEnum = Field(...)
-    version: StrictStr = Field(..., description="This is the specific version number 0.0.0")
-    platform: PlatformEnum = Field(...)
-    automatic_unload: Optional[StrictBool] = Field(None, alias="automaticUnload", description="This is a proper that will let us know if we will proactivity unload all of your machine learning models.by default this is false.")
-    __properties = ["schema", "id", "name", "version", "platform", "automaticUnload"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Metadata attached to a search event on an Asset
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    query: Optional[StrictStr] = Field(default=None, description="The search query itself")
+    results: Optional[TrackedAssetsEventSearchMetadataResults] = None
+    __properties: ClassVar[List[str]] = ["schema", "query", "results"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedApplication:
-        """Create an instance of TrackedApplication from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedAssetsEventSearchMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of results
+        if self.results:
+            _dict['results'] = self.results.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedApplication:
-        """Create an instance of TrackedApplication from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedAssetsEventSearchMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedApplication.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedApplication.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id"),
-            "name": obj.get("name"),
-            "version": obj.get("version"),
-            "platform": obj.get("platform"),
-            "automatic_unload": obj.get("automaticUnload")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "query": obj.get("query"),
+            "results": TrackedAssetsEventSearchMetadataResults.from_dict(obj["results"]) if obj.get("results") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.tracked_assets_event_search_metadata_results import TrackedAssetsEventSearchMetadataResults
+# TODO: Rewrite to not use raise_errors
+TrackedAssetsEventSearchMetadata.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_application_install.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/exported_database_formats.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,75 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.tracked_application import TrackedApplication
-from pieces_os_client.models.tracked_user_profile import TrackedUserProfile
+from pieces_os_client.models.exported_database_format import ExportedDatabaseFormat
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TrackedApplicationInstall(BaseModel):
-    """
-    A model that allows for us to specifically track Application Installs & Related Data  # noqa: E501
+class ExportedDatabaseFormats(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    application: TrackedApplication = Field(...)
-    user: Optional[TrackedUserProfile] = None
-    __properties = ["schema", "application", "user"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ExportedDatabaseFormats
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[ExportedDatabaseFormat]
+    __properties: ClassVar[List[str]] = ["schema", "iterable"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedApplicationInstall:
-        """Create an instance of TrackedApplicationInstall from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ExportedDatabaseFormats from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of application
-        if self.application:
-            _dict['application'] = self.application.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of user
-        if self.user:
-            _dict['user'] = self.user.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
+        _items = []
+        if self.iterable:
+            for _item in self.iterable:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['iterable'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedApplicationInstall:
-        """Create an instance of TrackedApplicationInstall from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ExportedDatabaseFormats from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedApplicationInstall.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedApplicationInstall.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "application": TrackedApplication.from_dict(obj.get("application")) if obj.get("application") is not None else None,
-            "user": TrackedUserProfile.from_dict(obj.get("user")) if obj.get("user") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [ExportedDatabaseFormat.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_application_update.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_application_update.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,55 +14,71 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.tracked_application import TrackedApplication
 from pieces_os_client.models.tracked_user_profile import TrackedUserProfile
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TrackedApplicationUpdate(BaseModel):
     """
-    This is a model used to track when an Application is Updated  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    current: TrackedApplication = Field(...)
+    This is a model used to track when an Application is Updated
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    current: TrackedApplication
     previous: Optional[TrackedApplication] = None
     user: Optional[TrackedUserProfile] = None
-    __properties = ["schema", "current", "previous", "user"]
+    __properties: ClassVar[List[str]] = ["schema", "current", "previous", "user"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedApplicationUpdate:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TrackedApplicationUpdate from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of current
         if self.current:
             _dict['current'] = self.current.to_dict()
         # override the default output from pydantic by calling `to_dict()` of previous
@@ -70,24 +86,24 @@
             _dict['previous'] = self.previous.to_dict()
         # override the default output from pydantic by calling `to_dict()` of user
         if self.user:
             _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedApplicationUpdate:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TrackedApplicationUpdate from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedApplicationUpdate.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedApplicationUpdate.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "current": TrackedApplication.from_dict(obj.get("current")) if obj.get("current") is not None else None,
-            "previous": TrackedApplication.from_dict(obj.get("previous")) if obj.get("previous") is not None else None,
-            "user": TrackedUserProfile.from_dict(obj.get("user")) if obj.get("user") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "current": TrackedApplication.from_dict(obj["current"]) if obj.get("current") is not None else None,
+            "previous": TrackedApplication.from_dict(obj["previous"]) if obj.get("previous") is not None else None,
+            "user": TrackedUserProfile.from_dict(obj["user"]) if obj.get("user") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_creation_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_creation_metadata.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,75 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.tracked_asset_event_creation_metadata_clipboard import TrackedAssetEventCreationMetadataClipboard
 from pieces_os_client.models.tracked_asset_event_creation_metadata_file import TrackedAssetEventCreationMetadataFile
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TrackedAssetEventCreationMetadata(BaseModel):
     """
-    Metadata attached to a creation event on an Asset  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
+    Metadata attached to a creation event on an Asset
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
     clipboard: Optional[TrackedAssetEventCreationMetadataClipboard] = None
     file: Optional[TrackedAssetEventCreationMetadataFile] = None
-    __properties = ["schema", "clipboard", "file"]
+    __properties: ClassVar[List[str]] = ["schema", "clipboard", "file"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedAssetEventCreationMetadata:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TrackedAssetEventCreationMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of clipboard
         if self.clipboard:
             _dict['clipboard'] = self.clipboard.to_dict()
         # override the default output from pydantic by calling `to_dict()` of file
         if self.file:
             _dict['file'] = self.file.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedAssetEventCreationMetadata:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TrackedAssetEventCreationMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedAssetEventCreationMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedAssetEventCreationMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "clipboard": TrackedAssetEventCreationMetadataClipboard.from_dict(obj.get("clipboard")) if obj.get("clipboard") is not None else None,
-            "file": TrackedAssetEventCreationMetadataFile.from_dict(obj.get("file")) if obj.get("file") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "clipboard": TrackedAssetEventCreationMetadataClipboard.from_dict(obj["clipboard"]) if obj.get("clipboard") is not None else None,
+            "file": TrackedAssetEventCreationMetadataFile.from_dict(obj["file"]) if obj.get("file") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_format_reclassification_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/os_device_gpu_hardware_information.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,74 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
-from pieces_os_client.models.classification import Classification
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.os_device_gpu_hardware_capabilities_information import OSDeviceGPUHardwareCapabilitiesInformation
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TrackedAssetEventFormatReclassificationMetadata(BaseModel):
-    """
-    Metadata of a format reclassification event  # noqa: E501
+class OSDeviceGPUHardwareInformation(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    previous: Optional[Classification] = None
-    current: Optional[Classification] = None
-    __properties = ["schema", "previous", "current"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will let us know specific hardware information related to the GPU.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    name: Optional[StrictStr] = None
+    memory: Optional[Union[StrictFloat, StrictInt]] = None
+    capabilities: Optional[OSDeviceGPUHardwareCapabilitiesInformation] = None
+    __properties: ClassVar[List[str]] = ["schema", "name", "memory", "capabilities"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedAssetEventFormatReclassificationMetadata:
-        """Create an instance of TrackedAssetEventFormatReclassificationMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OSDeviceGPUHardwareInformation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of previous
-        if self.previous:
-            _dict['previous'] = self.previous.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of current
-        if self.current:
-            _dict['current'] = self.current.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of capabilities
+        if self.capabilities:
+            _dict['capabilities'] = self.capabilities.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedAssetEventFormatReclassificationMetadata:
-        """Create an instance of TrackedAssetEventFormatReclassificationMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OSDeviceGPUHardwareInformation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedAssetEventFormatReclassificationMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedAssetEventFormatReclassificationMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "previous": Classification.from_dict(obj.get("previous")) if obj.get("previous") is not None else None,
-            "current": Classification.from_dict(obj.get("current")) if obj.get("current") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "name": obj.get("name"),
+            "memory": obj.get("memory"),
+            "capabilities": OSDeviceGPUHardwareCapabilitiesInformation.from_dict(obj["capabilities"]) if obj.get("capabilities") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_identifier_description_pairs.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_asset_event_identifier_description_pairs.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,462 +14,478 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TrackedAssetEventIdentifierDescriptionPairs(BaseModel):
     """
-    These are all of the available event types that are permitted in an object pair notation.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    asset_created: Optional[StrictStr] = Field(None, description="The key value pair for an asset being created.")
-    asset_viewed: Optional[StrictStr] = Field(None, description="An asset was viewed")
-    asset_format_copied: Optional[StrictStr] = Field(None, description="An asset's format was copied")
-    asset_format_downloaded: Optional[StrictStr] = Field(None, description="An asset's format was downloaded")
-    asset_deleted: Optional[StrictStr] = Field(None, description="An asset was deleted or not")
-    asset_description_updated: Optional[StrictStr] = Field(None, description="An asset was redescribed by the user")
-    asset_name_updated: Optional[StrictStr] = Field(None, description="An asset was renamed by the user")
-    asset_format_generic_classification_updated: Optional[StrictStr] = Field(None, description="A generic classification was changed on a format within an asset")
-    asset_format_specific_classification_updated: Optional[StrictStr] = Field(None, description="A specific classification was changed on a format within an asset")
+    These are all of the available event types that are permitted in an object pair notation.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    asset_created: Optional[StrictStr] = Field(default=None, description="The key value pair for an asset being created.")
+    asset_viewed: Optional[StrictStr] = Field(default=None, description="An asset was viewed")
+    asset_format_copied: Optional[StrictStr] = Field(default=None, description="An asset's format was copied")
+    asset_format_downloaded: Optional[StrictStr] = Field(default=None, description="An asset's format was downloaded")
+    asset_deleted: Optional[StrictStr] = Field(default=None, description="An asset was deleted or not")
+    asset_description_updated: Optional[StrictStr] = Field(default=None, description="An asset was redescribed by the user")
+    asset_name_updated: Optional[StrictStr] = Field(default=None, description="An asset was renamed by the user")
+    asset_format_generic_classification_updated: Optional[StrictStr] = Field(default=None, description="A generic classification was changed on a format within an asset")
+    asset_format_specific_classification_updated: Optional[StrictStr] = Field(default=None, description="A specific classification was changed on a format within an asset")
     asset_creation_failed: Optional[StrictStr] = None
     asset_tag_added: Optional[StrictStr] = None
     asset_link_added: Optional[StrictStr] = None
-    asset_link_generated: Optional[StrictStr] = Field(None, description="user generated a link for the asset")
+    asset_link_generated: Optional[StrictStr] = Field(default=None, description="user generated a link for the asset")
     asset_link_deleted: Optional[StrictStr] = None
     asset_tag_deleted: Optional[StrictStr] = None
-    asset_updated: Optional[StrictStr] = Field(None, description="This is just a generic string for an asset was updated.")
-    asset_format_value_edited: Optional[StrictStr] = Field(None, description="This is a side effect event for a format value getting edited that exists on an asset.")
-    asset_format_updated: Optional[StrictStr] = Field(None, description="This is a generic activity event for an asset getting updated because our format was updated for some reason.")
-    asset_link_revoked: Optional[StrictStr] = Field(None, description="This means that a shareable link was revoked.")
-    asset_person_added: Optional[StrictStr] = Field(None, description="This just means that a person was added via the user.")
-    asset_person_deleted: Optional[StrictStr] = Field(None, description="This just means that a person was deleted via the user.")
-    asset_sensitive_added: Optional[StrictStr] = Field(None, description="This just means that a sensitive was added via the user.")
-    asset_sensitive_deleted: Optional[StrictStr] = Field(None, description="This just means that a sensitive was deleted via the user.")
-    suggested_asset_referenced: Optional[StrictStr] = Field(None, description="This means that an asset was view/used while the user was looking at the suggestion view.")
-    searched_asset_referenced: Optional[StrictStr] = Field(None, description="This means that an asset was view/used while the user was looking at the searching view.")
-    asset_referenced: Optional[StrictStr] = Field(None, description="This means that an asset was view/used while the user was looking at the default view.")
-    activity_asset_referenced: Optional[StrictStr] = Field(None, description="This means that a user referenced an asset by first clicking on an asset within an activity event.(ie from the activity view)")
+    asset_updated: Optional[StrictStr] = Field(default=None, description="This is just a generic string for an asset was updated.")
+    asset_format_value_edited: Optional[StrictStr] = Field(default=None, description="This is a side effect event for a format value getting edited that exists on an asset.")
+    asset_format_updated: Optional[StrictStr] = Field(default=None, description="This is a generic activity event for an asset getting updated because our format was updated for some reason.")
+    asset_link_revoked: Optional[StrictStr] = Field(default=None, description="This means that a shareable link was revoked.")
+    asset_person_added: Optional[StrictStr] = Field(default=None, description="This just means that a person was added via the user.")
+    asset_person_deleted: Optional[StrictStr] = Field(default=None, description="This just means that a person was deleted via the user.")
+    asset_sensitive_added: Optional[StrictStr] = Field(default=None, description="This just means that a sensitive was added via the user.")
+    asset_sensitive_deleted: Optional[StrictStr] = Field(default=None, description="This just means that a sensitive was deleted via the user.")
+    suggested_asset_referenced: Optional[StrictStr] = Field(default=None, description="This means that an asset was view/used while the user was looking at the suggestion view.")
+    searched_asset_referenced: Optional[StrictStr] = Field(default=None, description="This means that an asset was view/used while the user was looking at the searching view.")
+    asset_referenced: Optional[StrictStr] = Field(default=None, description="This means that an asset was view/used while the user was looking at the default view.")
+    activity_asset_referenced: Optional[StrictStr] = Field(default=None, description="This means that a user referenced an asset by first clicking on an asset within an activity event.(ie from the activity view)")
     asset_annotation_added: Optional[StrictStr] = None
     asset_annotation_deleted: Optional[StrictStr] = None
     asset_annotation_updated: Optional[StrictStr] = None
     asset_hint_added: Optional[StrictStr] = None
     asset_hint_deleted: Optional[StrictStr] = None
     asset_hint_updated: Optional[StrictStr] = None
     asset_anchor_added: Optional[StrictStr] = None
     asset_anchor_deleted: Optional[StrictStr] = None
     asset_anchor_updated: Optional[StrictStr] = None
-    __properties = ["schema", "asset_created", "asset_viewed", "asset_format_copied", "asset_format_downloaded", "asset_deleted", "asset_description_updated", "asset_name_updated", "asset_format_generic_classification_updated", "asset_format_specific_classification_updated", "asset_creation_failed", "asset_tag_added", "asset_link_added", "asset_link_generated", "asset_link_deleted", "asset_tag_deleted", "asset_updated", "asset_format_value_edited", "asset_format_updated", "asset_link_revoked", "asset_person_added", "asset_person_deleted", "asset_sensitive_added", "asset_sensitive_deleted", "suggested_asset_referenced", "searched_asset_referenced", "asset_referenced", "activity_asset_referenced", "asset_annotation_added", "asset_annotation_deleted", "asset_annotation_updated", "asset_hint_added", "asset_hint_deleted", "asset_hint_updated", "asset_anchor_added", "asset_anchor_deleted", "asset_anchor_updated"]
+    __properties: ClassVar[List[str]] = ["schema", "asset_created", "asset_viewed", "asset_format_copied", "asset_format_downloaded", "asset_deleted", "asset_description_updated", "asset_name_updated", "asset_format_generic_classification_updated", "asset_format_specific_classification_updated", "asset_creation_failed", "asset_tag_added", "asset_link_added", "asset_link_generated", "asset_link_deleted", "asset_tag_deleted", "asset_updated", "asset_format_value_edited", "asset_format_updated", "asset_link_revoked", "asset_person_added", "asset_person_deleted", "asset_sensitive_added", "asset_sensitive_deleted", "suggested_asset_referenced", "searched_asset_referenced", "asset_referenced", "activity_asset_referenced", "asset_annotation_added", "asset_annotation_deleted", "asset_annotation_updated", "asset_hint_added", "asset_hint_deleted", "asset_hint_updated", "asset_anchor_added", "asset_anchor_deleted", "asset_anchor_updated"]
 
-    @validator('asset_created')
+    @field_validator('asset_created')
     def asset_created_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_was_created'):
+        if value not in set(['an_asset_was_created']):
             raise ValueError("must be one of enum values ('an_asset_was_created')")
         return value
 
-    @validator('asset_viewed')
+    @field_validator('asset_viewed')
     def asset_viewed_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_was_viewed'):
+        if value not in set(['an_asset_was_viewed']):
             raise ValueError("must be one of enum values ('an_asset_was_viewed')")
         return value
 
-    @validator('asset_format_copied')
+    @field_validator('asset_format_copied')
     def asset_format_copied_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_preview_format_was_copied'):
+        if value not in set(['an_asset_preview_format_was_copied']):
             raise ValueError("must be one of enum values ('an_asset_preview_format_was_copied')")
         return value
 
-    @validator('asset_format_downloaded')
+    @field_validator('asset_format_downloaded')
     def asset_format_downloaded_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_format_was_downloaded'):
+        if value not in set(['an_asset_format_was_downloaded']):
             raise ValueError("must be one of enum values ('an_asset_format_was_downloaded')")
         return value
 
-    @validator('asset_deleted')
+    @field_validator('asset_deleted')
     def asset_deleted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_was_deleted'):
+        if value not in set(['an_asset_was_deleted']):
             raise ValueError("must be one of enum values ('an_asset_was_deleted')")
         return value
 
-    @validator('asset_description_updated')
+    @field_validator('asset_description_updated')
     def asset_description_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_was_redescribed_by_the_user'):
+        if value not in set(['an_asset_was_redescribed_by_the_user']):
             raise ValueError("must be one of enum values ('an_asset_was_redescribed_by_the_user')")
         return value
 
-    @validator('asset_name_updated')
+    @field_validator('asset_name_updated')
     def asset_name_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_was_renamed_by_the_user'):
+        if value not in set(['an_asset_was_renamed_by_the_user']):
             raise ValueError("must be one of enum values ('an_asset_was_renamed_by_the_user')")
         return value
 
-    @validator('asset_format_generic_classification_updated')
+    @field_validator('asset_format_generic_classification_updated')
     def asset_format_generic_classification_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_generic_classification_was_changed_on_a_format_within_an_asset'):
+        if value not in set(['a_generic_classification_was_changed_on_a_format_within_an_asset']):
             raise ValueError("must be one of enum values ('a_generic_classification_was_changed_on_a_format_within_an_asset')")
         return value
 
-    @validator('asset_format_specific_classification_updated')
+    @field_validator('asset_format_specific_classification_updated')
     def asset_format_specific_classification_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_specific_classification_was_changed_on_a_format_within_an_asset'):
+        if value not in set(['a_specific_classification_was_changed_on_a_format_within_an_asset']):
             raise ValueError("must be one of enum values ('a_specific_classification_was_changed_on_a_format_within_an_asset')")
         return value
 
-    @validator('asset_creation_failed')
+    @field_validator('asset_creation_failed')
     def asset_creation_failed_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_failed_to_be_created'):
+        if value not in set(['an_asset_failed_to_be_created']):
             raise ValueError("must be one of enum values ('an_asset_failed_to_be_created')")
         return value
 
-    @validator('asset_tag_added')
+    @field_validator('asset_tag_added')
     def asset_tag_added_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_tag_was_added_by_the_user'):
+        if value not in set(['a_tag_was_added_by_the_user']):
             raise ValueError("must be one of enum values ('a_tag_was_added_by_the_user')")
         return value
 
-    @validator('asset_link_added')
+    @field_validator('asset_link_added')
     def asset_link_added_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_link_was_added_by_the_user'):
+        if value not in set(['a_link_was_added_by_the_user']):
             raise ValueError("must be one of enum values ('a_link_was_added_by_the_user')")
         return value
 
-    @validator('asset_link_generated')
+    @field_validator('asset_link_generated')
     def asset_link_generated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_link_was_generated'):
+        if value not in set(['an_asset_link_was_generated']):
             raise ValueError("must be one of enum values ('an_asset_link_was_generated')")
         return value
 
-    @validator('asset_link_deleted')
+    @field_validator('asset_link_deleted')
     def asset_link_deleted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_link_was_deleted_by_the_user'):
+        if value not in set(['a_link_was_deleted_by_the_user']):
             raise ValueError("must be one of enum values ('a_link_was_deleted_by_the_user')")
         return value
 
-    @validator('asset_tag_deleted')
+    @field_validator('asset_tag_deleted')
     def asset_tag_deleted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_tag_was_deleted_by_the_user'):
+        if value not in set(['a_tag_was_deleted_by_the_user']):
             raise ValueError("must be one of enum values ('a_tag_was_deleted_by_the_user')")
         return value
 
-    @validator('asset_updated')
+    @field_validator('asset_updated')
     def asset_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_was_updated'):
+        if value not in set(['an_asset_was_updated']):
             raise ValueError("must be one of enum values ('an_asset_was_updated')")
         return value
 
-    @validator('asset_format_value_edited')
+    @field_validator('asset_format_value_edited')
     def asset_format_value_edited_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_specific_format_value_was_edited_on_an_asset'):
+        if value not in set(['a_specific_format_value_was_edited_on_an_asset']):
             raise ValueError("must be one of enum values ('a_specific_format_value_was_edited_on_an_asset')")
         return value
 
-    @validator('asset_format_updated')
+    @field_validator('asset_format_updated')
     def asset_format_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_specific_format_was_updated_on_an_asset'):
+        if value not in set(['a_specific_format_was_updated_on_an_asset']):
             raise ValueError("must be one of enum values ('a_specific_format_was_updated_on_an_asset')")
         return value
 
-    @validator('asset_link_revoked')
+    @field_validator('asset_link_revoked')
     def asset_link_revoked_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_link_was_revoked'):
+        if value not in set(['an_asset_link_was_revoked']):
             raise ValueError("must be one of enum values ('an_asset_link_was_revoked')")
         return value
 
-    @validator('asset_person_added')
+    @field_validator('asset_person_added')
     def asset_person_added_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_person_was_added_by_the_user'):
+        if value not in set(['a_person_was_added_by_the_user']):
             raise ValueError("must be one of enum values ('a_person_was_added_by_the_user')")
         return value
 
-    @validator('asset_person_deleted')
+    @field_validator('asset_person_deleted')
     def asset_person_deleted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_person_was_deleted_by_the_user'):
+        if value not in set(['a_person_was_deleted_by_the_user']):
             raise ValueError("must be one of enum values ('a_person_was_deleted_by_the_user')")
         return value
 
-    @validator('asset_sensitive_added')
+    @field_validator('asset_sensitive_added')
     def asset_sensitive_added_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_sensitive_was_added_by_the_user'):
+        if value not in set(['a_sensitive_was_added_by_the_user']):
             raise ValueError("must be one of enum values ('a_sensitive_was_added_by_the_user')")
         return value
 
-    @validator('asset_sensitive_deleted')
+    @field_validator('asset_sensitive_deleted')
     def asset_sensitive_deleted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_sensitive_was_deleted_by_the_user'):
+        if value not in set(['a_sensitive_was_deleted_by_the_user']):
             raise ValueError("must be one of enum values ('a_sensitive_was_deleted_by_the_user')")
         return value
 
-    @validator('suggested_asset_referenced')
+    @field_validator('suggested_asset_referenced')
     def suggested_asset_referenced_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_suggested_asset_was_referenced_by_the_user'):
+        if value not in set(['a_suggested_asset_was_referenced_by_the_user']):
             raise ValueError("must be one of enum values ('a_suggested_asset_was_referenced_by_the_user')")
         return value
 
-    @validator('searched_asset_referenced')
+    @field_validator('searched_asset_referenced')
     def searched_asset_referenced_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_searched_asset_was_referenced_by_the_user'):
+        if value not in set(['a_searched_asset_was_referenced_by_the_user']):
             raise ValueError("must be one of enum values ('a_searched_asset_was_referenced_by_the_user')")
         return value
 
-    @validator('asset_referenced')
+    @field_validator('asset_referenced')
     def asset_referenced_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_asset_was_referenced_by_the_user'):
+        if value not in set(['an_asset_was_referenced_by_the_user']):
             raise ValueError("must be one of enum values ('an_asset_was_referenced_by_the_user')")
         return value
 
-    @validator('activity_asset_referenced')
+    @field_validator('activity_asset_referenced')
     def activity_asset_referenced_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_activity_asset_was_referenced_by_the_user'):
+        if value not in set(['an_activity_asset_was_referenced_by_the_user']):
             raise ValueError("must be one of enum values ('an_activity_asset_was_referenced_by_the_user')")
         return value
 
-    @validator('asset_annotation_added')
+    @field_validator('asset_annotation_added')
     def asset_annotation_added_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_annotation_was_added_by_the_user'):
+        if value not in set(['an_annotation_was_added_by_the_user']):
             raise ValueError("must be one of enum values ('an_annotation_was_added_by_the_user')")
         return value
 
-    @validator('asset_annotation_deleted')
+    @field_validator('asset_annotation_deleted')
     def asset_annotation_deleted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_annotation_was_deleted_by_the_user'):
+        if value not in set(['an_annotation_was_deleted_by_the_user']):
             raise ValueError("must be one of enum values ('an_annotation_was_deleted_by_the_user')")
         return value
 
-    @validator('asset_annotation_updated')
+    @field_validator('asset_annotation_updated')
     def asset_annotation_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('an_annotation_was_updated_by_the_user'):
+        if value not in set(['an_annotation_was_updated_by_the_user']):
             raise ValueError("must be one of enum values ('an_annotation_was_updated_by_the_user')")
         return value
 
-    @validator('asset_hint_added')
+    @field_validator('asset_hint_added')
     def asset_hint_added_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_hint_was_added_by_the_user'):
+        if value not in set(['a_hint_was_added_by_the_user']):
             raise ValueError("must be one of enum values ('a_hint_was_added_by_the_user')")
         return value
 
-    @validator('asset_hint_deleted')
+    @field_validator('asset_hint_deleted')
     def asset_hint_deleted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_hint_was_deleted_by_the_user'):
+        if value not in set(['a_hint_was_deleted_by_the_user']):
             raise ValueError("must be one of enum values ('a_hint_was_deleted_by_the_user')")
         return value
 
-    @validator('asset_hint_updated')
+    @field_validator('asset_hint_updated')
     def asset_hint_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_hint_was_updated_by_the_user'):
+        if value not in set(['a_hint_was_updated_by_the_user']):
             raise ValueError("must be one of enum values ('a_hint_was_updated_by_the_user')")
         return value
 
-    @validator('asset_anchor_added')
+    @field_validator('asset_anchor_added')
     def asset_anchor_added_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_anchor_was_added_by_the_user'):
+        if value not in set(['a_anchor_was_added_by_the_user']):
             raise ValueError("must be one of enum values ('a_anchor_was_added_by_the_user')")
         return value
 
-    @validator('asset_anchor_deleted')
+    @field_validator('asset_anchor_deleted')
     def asset_anchor_deleted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_anchor_was_deleted_by_the_user'):
+        if value not in set(['a_anchor_was_deleted_by_the_user']):
             raise ValueError("must be one of enum values ('a_anchor_was_deleted_by_the_user')")
         return value
 
-    @validator('asset_anchor_updated')
+    @field_validator('asset_anchor_updated')
     def asset_anchor_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_anchor_was_updated_by_the_user'):
+        if value not in set(['a_anchor_was_updated_by_the_user']):
             raise ValueError("must be one of enum values ('a_anchor_was_updated_by_the_user')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedAssetEventIdentifierDescriptionPairs:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TrackedAssetEventIdentifierDescriptionPairs from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedAssetEventIdentifierDescriptionPairs:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TrackedAssetEventIdentifierDescriptionPairs from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedAssetEventIdentifierDescriptionPairs.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedAssetEventIdentifierDescriptionPairs.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "asset_created": obj.get("asset_created"),
             "asset_viewed": obj.get("asset_viewed"),
             "asset_format_copied": obj.get("asset_format_copied"),
             "asset_format_downloaded": obj.get("asset_format_downloaded"),
             "asset_deleted": obj.get("asset_deleted"),
             "asset_description_updated": obj.get("asset_description_updated"),
             "asset_name_updated": obj.get("asset_name_updated"),
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_asset_event_rename_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_assets_event_metadata.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,67 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-
-class TrackedAssetEventRenameMetadata(BaseModel):
-    """
-    This will give specific metadata need to determine what the rename was to/from.  # noqa: E501
+class SeededTrackedAssetsEventMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    previous: StrictStr = Field(...)
-    current: StrictStr = Field(...)
-    __properties = ["schema", "previous", "current"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Additional Metadata as Neeeded i.e. Search + Query, etc
+    """ # noqa: E501
+    search: Optional[TrackedAssetsEventSearchMetadata] = None
+    __properties: ClassVar[List[str]] = ["search"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedAssetEventRenameMetadata:
-        """Create an instance of TrackedAssetEventRenameMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededTrackedAssetsEventMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of search
+        if self.search:
+            _dict['search'] = self.search.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedAssetEventRenameMetadata:
-        """Create an instance of TrackedAssetEventRenameMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededTrackedAssetsEventMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedAssetEventRenameMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedAssetEventRenameMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "previous": obj.get("previous"),
-            "current": obj.get("current")
+        _obj = cls.model_validate({
+            "search": TrackedAssetsEventSearchMetadata.from_dict(obj["search"]) if obj.get("search") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.tracked_assets_event_search_metadata import TrackedAssetsEventSearchMetadata
+# TODO: Rewrite to not use raise_errors
+SeededTrackedAssetsEventMetadata.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_assets_event_search_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_assets_event_search_metadata_results.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,83 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, StrictFloat, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pieces_os_client.models.space import Space
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-
-
-class TrackedAssetsEventSearchMetadata(BaseModel):
-    """
-    Metadata attached to a search event on an Asset  # noqa: E501
+class TrackedAssetsEventSearchMetadataResults(BaseModel):
     """
+    Numbers related to search results
+    """ # noqa: E501
+    fuzzy: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Total number of fuzzy results")
+    exact: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Total number of exact results")
+    assets: Optional[FlattenedAssets] = None
+    space: Optional[Space] = None
+    __properties: ClassVar[List[str]] = ["fuzzy", "exact", "assets", "space"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    query: Optional[StrictStr] = Field(None, description="The search query itself")
-    results: Optional[TrackedAssetsEventSearchMetadataResults] = None
-    __properties = ["schema", "query", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedAssetsEventSearchMetadata:
-        """Create an instance of TrackedAssetsEventSearchMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedAssetsEventSearchMetadataResults from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict["schema"] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of results
-        if self.results:
-            _dict["results"] = self.results.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of assets
+        if self.assets:
+            _dict['assets'] = self.assets.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of space
+        if self.space:
+            _dict['space'] = self.space.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedAssetsEventSearchMetadata:
-        """Create an instance of TrackedAssetsEventSearchMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedAssetsEventSearchMetadataResults from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedAssetsEventSearchMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedAssetsEventSearchMetadata.parse_obj(
-            {
-                "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema"))
-                if obj.get("schema") is not None
-                else None,
-                "query": obj.get("query"),
-                "results": TrackedAssetsEventSearchMetadataResults.from_dict(
-                    obj.get("results")
-                )
-                if obj.get("results") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "fuzzy": obj.get("fuzzy"),
+            "exact": obj.get("exact"),
+            "assets": FlattenedAssets.from_dict(obj["assets"]) if obj.get("assets") is not None else None,
+            "space": Space.from_dict(obj["space"]) if obj.get("space") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.flattened_assets import FlattenedAssets
+# TODO: Rewrite to not use raise_errors
+TrackedAssetsEventSearchMetadataResults.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.tracked_assets_event_search_metadata_results import (
-    TrackedAssetsEventSearchMetadataResults,
-)
-
-# TrackedAssetsEventSearchMetadata.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_assets_event_search_metadata_results.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/image_analysis.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,85 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional, Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt
-from pieces_os_client.models.space import Space
-
-
-class TrackedAssetsEventSearchMetadataResults(BaseModel):
-    """
-    Numbers related to search results  # noqa: E501
+class ImageAnalysis(BaseModel):
     """
+    This is a model that represents all the information collected during the processing of an image.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr = Field(description="this is a uuid that represents a imageAnalysis.")
+    analysis: StrictStr = Field(description="this is a reference to the analysis.")
+    ocr: Optional[OCRAnalysis] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "analysis", "ocr"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    fuzzy: Optional[Union[StrictFloat, StrictInt]] = Field(
-        None, description="Total number of fuzzy results"
-    )
-    exact: Optional[Union[StrictFloat, StrictInt]] = Field(
-        None, description="Total number of exact results"
-    )
-    assets: Optional[FlattenedAssets] = None
-    space: Optional[Space] = None
-    __properties = ["fuzzy", "exact", "assets", "space"]
-
-    class Config:
-        """Pydantic configuration"""
-
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedAssetsEventSearchMetadataResults:
-        """Create an instance of TrackedAssetsEventSearchMetadataResults from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ImageAnalysis from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of assets
-        if self.assets:
-            _dict["assets"] = self.assets.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of space
-        if self.space:
-            _dict["space"] = self.space.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of var_schema
+        if self.var_schema:
+            _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of ocr
+        if self.ocr:
+            _dict['ocr'] = self.ocr.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedAssetsEventSearchMetadataResults:
-        """Create an instance of TrackedAssetsEventSearchMetadataResults from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ImageAnalysis from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedAssetsEventSearchMetadataResults.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedAssetsEventSearchMetadataResults.parse_obj(
-            {
-                "fuzzy": obj.get("fuzzy"),
-                "exact": obj.get("exact"),
-                "assets": FlattenedAssets.from_dict(obj.get("assets"))
-                if obj.get("assets") is not None
-                else None,
-                "space": Space.from_dict(obj.get("space"))
-                if obj.get("space") is not None
-                else None,
-            }
-        )
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "analysis": obj.get("analysis"),
+            "ocr": OCRAnalysis.from_dict(obj["ocr"]) if obj.get("ocr") is not None else None
+        })
         return _obj
 
+from pieces_os_client.models.ocr_analysis import OCRAnalysis
+# TODO: Rewrite to not use raise_errors
+ImageAnalysis.model_rebuild(raise_errors=False)
 
-from pieces_os_client.models.flattened_assets import FlattenedAssets
-
-# TrackedAssetsEventSearchMetadataResults.update_forward_refs()
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_conversation_event_identifier_description_pairs.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_conversation_event_identifier_description_pairs.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,143 +14,159 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TrackedConversationEventIdentifierDescriptionPairs(BaseModel):
     """
-    These are all of the available event types that are permitted in an object pair notation.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    conversation_created: Optional[StrictStr] = Field(None, description="The key value pair for an conversation being created.")
-    conversation_referenced: Optional[StrictStr] = Field(None, description="This means that an conversation was view/used while the user was looking at the default view.")
-    conversation_deleted: Optional[StrictStr] = Field(None, description="A conversation was deleted")
-    conversation_summary_annotation_generated_by_the_user: Optional[StrictStr] = Field(None, description="A conversation summary was generated by the user")
-    conversation_name_updated_by_the_system: Optional[StrictStr] = Field(None, description="A conversation was renamed by the system")
-    conversation_name_updated_by_the_user: Optional[StrictStr] = Field(None, description="A conversation was renamed by the user")
-    conversation_summary_annotation_generated_by_the_system: Optional[StrictStr] = Field(None, description="A conversation summary was generated")
-    __properties = ["schema", "conversation_created", "conversation_referenced", "conversation_deleted", "conversation_summary_annotation_generated_by_the_user", "conversation_name_updated_by_the_system", "conversation_name_updated_by_the_user", "conversation_summary_annotation_generated_by_the_system"]
+    These are all of the available event types that are permitted in an object pair notation.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    conversation_created: Optional[StrictStr] = Field(default=None, description="The key value pair for an conversation being created.")
+    conversation_referenced: Optional[StrictStr] = Field(default=None, description="This means that an conversation was view/used while the user was looking at the default view.")
+    conversation_deleted: Optional[StrictStr] = Field(default=None, description="A conversation was deleted")
+    conversation_summary_annotation_generated_by_the_user: Optional[StrictStr] = Field(default=None, description="A conversation summary was generated by the user")
+    conversation_name_updated_by_the_system: Optional[StrictStr] = Field(default=None, description="A conversation was renamed by the system")
+    conversation_name_updated_by_the_user: Optional[StrictStr] = Field(default=None, description="A conversation was renamed by the user")
+    conversation_summary_annotation_generated_by_the_system: Optional[StrictStr] = Field(default=None, description="A conversation summary was generated")
+    __properties: ClassVar[List[str]] = ["schema", "conversation_created", "conversation_referenced", "conversation_deleted", "conversation_summary_annotation_generated_by_the_user", "conversation_name_updated_by_the_system", "conversation_name_updated_by_the_user", "conversation_summary_annotation_generated_by_the_system"]
 
-    @validator('conversation_created')
+    @field_validator('conversation_created')
     def conversation_created_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_conversation_was_created'):
+        if value not in set(['a_conversation_was_created']):
             raise ValueError("must be one of enum values ('a_conversation_was_created')")
         return value
 
-    @validator('conversation_referenced')
+    @field_validator('conversation_referenced')
     def conversation_referenced_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_conversation_was_referenced_by_the_user'):
+        if value not in set(['a_conversation_was_referenced_by_the_user']):
             raise ValueError("must be one of enum values ('a_conversation_was_referenced_by_the_user')")
         return value
 
-    @validator('conversation_deleted')
+    @field_validator('conversation_deleted')
     def conversation_deleted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_conversation_was_deleted'):
+        if value not in set(['a_conversation_was_deleted']):
             raise ValueError("must be one of enum values ('a_conversation_was_deleted')")
         return value
 
-    @validator('conversation_summary_annotation_generated_by_the_user')
+    @field_validator('conversation_summary_annotation_generated_by_the_user')
     def conversation_summary_annotation_generated_by_the_user_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_conversation_summary_annotation_was_generated_by_the_user'):
+        if value not in set(['a_conversation_summary_annotation_was_generated_by_the_user']):
             raise ValueError("must be one of enum values ('a_conversation_summary_annotation_was_generated_by_the_user')")
         return value
 
-    @validator('conversation_name_updated_by_the_system')
+    @field_validator('conversation_name_updated_by_the_system')
     def conversation_name_updated_by_the_system_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_conversation_was_renamed_by_the_system'):
+        if value not in set(['a_conversation_was_renamed_by_the_system']):
             raise ValueError("must be one of enum values ('a_conversation_was_renamed_by_the_system')")
         return value
 
-    @validator('conversation_name_updated_by_the_user')
+    @field_validator('conversation_name_updated_by_the_user')
     def conversation_name_updated_by_the_user_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_conversation_was_renamed_by_the_user'):
+        if value not in set(['a_conversation_was_renamed_by_the_user']):
             raise ValueError("must be one of enum values ('a_conversation_was_renamed_by_the_user')")
         return value
 
-    @validator('conversation_summary_annotation_generated_by_the_system')
+    @field_validator('conversation_summary_annotation_generated_by_the_system')
     def conversation_summary_annotation_generated_by_the_system_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_conversation_summary_annotation_was_generated_by_the_system'):
+        if value not in set(['a_conversation_summary_annotation_was_generated_by_the_system']):
             raise ValueError("must be one of enum values ('a_conversation_summary_annotation_was_generated_by_the_system')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedConversationEventIdentifierDescriptionPairs:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TrackedConversationEventIdentifierDescriptionPairs from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedConversationEventIdentifierDescriptionPairs:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TrackedConversationEventIdentifierDescriptionPairs from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedConversationEventIdentifierDescriptionPairs.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedConversationEventIdentifierDescriptionPairs.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "conversation_created": obj.get("conversation_created"),
             "conversation_referenced": obj.get("conversation_referenced"),
             "conversation_deleted": obj.get("conversation_deleted"),
             "conversation_summary_annotation_generated_by_the_user": obj.get("conversation_summary_annotation_generated_by_the_user"),
             "conversation_name_updated_by_the_system": obj.get("conversation_name_updated_by_the_system"),
             "conversation_name_updated_by_the_user": obj.get("conversation_name_updated_by_the_user"),
             "conversation_summary_annotation_generated_by_the_system": obj.get("conversation_summary_annotation_generated_by_the_system")
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_conversation_event_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_conversation_event_rename_metadata.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,69 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.tracked_conversation_event_rename_metadata import TrackedConversationEventRenameMetadata
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TrackedConversationEventMetadata(BaseModel):
-    """
-    This is the metadata for the the ConversationEvent  # noqa: E501
+class TrackedConversationEventRenameMetadata(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    rename: Optional[TrackedConversationEventRenameMetadata] = None
-    __properties = ["schema", "rename"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will give specific metadata need to determine what the rename was to/from.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    previous: StrictStr
+    current: StrictStr
+    __properties: ClassVar[List[str]] = ["schema", "previous", "current"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedConversationEventMetadata:
-        """Create an instance of TrackedConversationEventMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TrackedConversationEventRenameMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of rename
-        if self.rename:
-            _dict['rename'] = self.rename.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedConversationEventMetadata:
-        """Create an instance of TrackedConversationEventMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TrackedConversationEventRenameMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedConversationEventMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedConversationEventMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "rename": TrackedConversationEventRenameMetadata.from_dict(obj.get("rename")) if obj.get("rename") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "previous": obj.get("previous"),
+            "current": obj.get("current")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_conversation_event_rename_metadata.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/transferable_string.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,67 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TrackedConversationEventRenameMetadata(BaseModel):
-    """
-    This will give specific metadata need to determine what the rename was to/from.  # noqa: E501
+class TransferableString(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    previous: StrictStr = Field(...)
-    current: StrictStr = Field(...)
-    __properties = ["schema", "previous", "current"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a String representaion of any of these changes.  [NOT IMPLEMENTED] base64, base64_url, data_url [IMPLEMENTED] raw
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    raw: Optional[StrictStr] = Field(default=None, description="IMPLEMENTED")
+    var_base64: Optional[StrictStr] = Field(default=None, description="NOT IMPLEMENTED", alias="base64")
+    base64_url: Optional[StrictStr] = Field(default=None, description="NOT IMPLEMENTED")
+    data_url: Optional[StrictStr] = Field(default=None, description="NOT IMPLEMENTED")
+    __properties: ClassVar[List[str]] = ["schema", "raw", "base64", "base64_url", "data_url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedConversationEventRenameMetadata:
-        """Create an instance of TrackedConversationEventRenameMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TransferableString from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedConversationEventRenameMetadata:
-        """Create an instance of TrackedConversationEventRenameMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TransferableString from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedConversationEventRenameMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedConversationEventRenameMetadata.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "previous": obj.get("previous"),
-            "current": obj.get("current")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "raw": obj.get("raw"),
+            "base64": obj.get("base64"),
+            "base64_url": obj.get("base64_url"),
+            "data_url": obj.get("data_url")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_format.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/qgpt_conversation_message.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,80 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-from pieces_os_client.models.classification import Classification
+from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.role import Role
+from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from pieces_os_client.models.qgpt_conversation_message_role_enum import QGPTConversationMessageRoleEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TrackedFormat(BaseModel):
-    """
-    A minimal format to send to Mixpanel  # noqa: E501
+class QGPTConversationMessage(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="The UUID of the format")
-    classification: Classification = Field(...)
-    role: Role = Field(...)
-    asset: StrictStr = Field(..., description="The UUID of the asset associated")
-    fragment: StrictBool = Field(...)
-    file: StrictBool = Field(...)
-    __properties = ["schema", "id", "classification", "role", "asset", "fragment", "file"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This will take a single message, and a role.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    text: StrictStr
+    role: QGPTConversationMessageRoleEnum
+    timestamp: GroupedTimestamp
+    __properties: ClassVar[List[str]] = ["schema", "text", "role", "timestamp"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedFormat:
-        """Create an instance of TrackedFormat from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of QGPTConversationMessage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of classification
-        if self.classification:
-            _dict['classification'] = self.classification.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of timestamp
+        if self.timestamp:
+            _dict['timestamp'] = self.timestamp.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedFormat:
-        """Create an instance of TrackedFormat from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of QGPTConversationMessage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedFormat.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedFormat.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id"),
-            "classification": Classification.from_dict(obj.get("classification")) if obj.get("classification") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "text": obj.get("text"),
             "role": obj.get("role"),
-            "asset": obj.get("asset"),
-            "fragment": obj.get("fragment"),
-            "file": obj.get("file")
+            "timestamp": GroupedTimestamp.from_dict(obj["timestamp"]) if obj.get("timestamp") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_format_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_tracked_format_event.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,81 +14,99 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.tracked_format import TrackedFormat
 from pieces_os_client.models.tracked_format_event_identifier_description_pairs import TrackedFormatEventIdentifierDescriptionPairs
 from pieces_os_client.models.tracked_format_event_metadata import TrackedFormatEventMetadata
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TrackedFormatEvent(BaseModel):
-    """
-    This is a model that represents a generic event that we may want to track in relation to a format, for example beamed, copied, downloaded, and view. ** Note: This is the model that will get returned by our api, and is. Representative of a full TrackedFormat event. **  # noqa: E501
+class SeededTrackedFormatEvent(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    format: TrackedFormat = Field(..., alias=" format")
-    identifier_description_pair: TrackedFormatEventIdentifierDescriptionPairs = Field(...)
+    Again this is a model designed to be sent over to a context server to be built and then sent along to segment. 
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    identifier_description_pair: TrackedFormatEventIdentifierDescriptionPairs
+    format: ReferencedFormat
     metadata: Optional[TrackedFormatEventMetadata] = None
-    __properties = ["schema", " format", "identifier_description_pair", "metadata"]
+    __properties: ClassVar[List[str]] = ["schema", "identifier_description_pair", "format", "metadata"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedFormatEvent:
-        """Create an instance of TrackedFormatEvent from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededTrackedFormatEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of format
-        if self.format:
-            _dict[' format'] = self.format.to_dict()
         # override the default output from pydantic by calling `to_dict()` of identifier_description_pair
         if self.identifier_description_pair:
             _dict['identifier_description_pair'] = self.identifier_description_pair.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of format
+        if self.format:
+            _dict['format'] = self.format.to_dict()
         # override the default output from pydantic by calling `to_dict()` of metadata
         if self.metadata:
             _dict['metadata'] = self.metadata.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedFormatEvent:
-        """Create an instance of TrackedFormatEvent from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededTrackedFormatEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedFormatEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedFormatEvent.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "format": TrackedFormat.from_dict(obj.get(" format")) if obj.get(" format") is not None else None,
-            "identifier_description_pair": TrackedFormatEventIdentifierDescriptionPairs.from_dict(obj.get("identifier_description_pair")) if obj.get("identifier_description_pair") is not None else None,
-            "metadata": TrackedFormatEventMetadata.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "identifier_description_pair": TrackedFormatEventIdentifierDescriptionPairs.from_dict(obj["identifier_description_pair"]) if obj.get("identifier_description_pair") is not None else None,
+            "format": ReferencedFormat.from_dict(obj["format"]) if obj.get("format") is not None else None,
+            "metadata": TrackedFormatEventMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.referenced_format import ReferencedFormat
+# TODO: Rewrite to not use raise_errors
+SeededTrackedFormatEvent.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_format_event_identifier_description_pairs.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_format_event_identifier_description_pairs.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,176 +14,192 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TrackedFormatEventIdentifierDescriptionPairs(BaseModel):
     """
-    This is a model that allows us to send send over super specific format related events such as copied, deleted, downloaded, etc  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    format_created: Optional[StrictStr] = Field(None, description="The key value pair for an asset being created.")
-    format_copied: Optional[StrictStr] = Field(None, description="If a format was copied entirely")
-    format_partially_copied: Optional[StrictStr] = Field(None, description="If a format was copied partially")
-    format_downloaded: Optional[StrictStr] = Field(None, description="If a format was downloaded")
-    format_deleted: Optional[StrictStr] = Field(None, description="If an format was deleted")
-    format_generic_classification_updated: Optional[StrictStr] = Field(None, description="If a generic classification was changed on a format")
-    format_specific_classification_updated: Optional[StrictStr] = Field(None, description="If a specific classification was changed on a format")
-    format_updated: Optional[StrictStr] = Field(None, description="a format was updated, generic update.")
-    format_inserted: Optional[StrictStr] = Field(None, description="a format was inserted")
-    format_value_edited: Optional[StrictStr] = Field(None, description="a format's value was update ie, the text, etc...")
-    __properties = ["schema", "format_created", "format_copied", "format_partially_copied", "format_downloaded", "format_deleted", "format_generic_classification_updated", "format_specific_classification_updated", "format_updated", "format_inserted", "format_value_edited"]
+    This is a model that allows us to send send over super specific format related events such as copied, deleted, downloaded, etc
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    format_created: Optional[StrictStr] = Field(default=None, description="The key value pair for an asset being created.")
+    format_copied: Optional[StrictStr] = Field(default=None, description="If a format was copied entirely")
+    format_partially_copied: Optional[StrictStr] = Field(default=None, description="If a format was copied partially")
+    format_downloaded: Optional[StrictStr] = Field(default=None, description="If a format was downloaded")
+    format_deleted: Optional[StrictStr] = Field(default=None, description="If an format was deleted")
+    format_generic_classification_updated: Optional[StrictStr] = Field(default=None, description="If a generic classification was changed on a format")
+    format_specific_classification_updated: Optional[StrictStr] = Field(default=None, description="If a specific classification was changed on a format")
+    format_updated: Optional[StrictStr] = Field(default=None, description="a format was updated, generic update.")
+    format_inserted: Optional[StrictStr] = Field(default=None, description="a format was inserted")
+    format_value_edited: Optional[StrictStr] = Field(default=None, description="a format's value was update ie, the text, etc...")
+    __properties: ClassVar[List[str]] = ["schema", "format_created", "format_copied", "format_partially_copied", "format_downloaded", "format_deleted", "format_generic_classification_updated", "format_specific_classification_updated", "format_updated", "format_inserted", "format_value_edited"]
 
-    @validator('format_created')
+    @field_validator('format_created')
     def format_created_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_format_was_created'):
+        if value not in set(['a_format_was_created']):
             raise ValueError("must be one of enum values ('a_format_was_created')")
         return value
 
-    @validator('format_copied')
+    @field_validator('format_copied')
     def format_copied_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('if_a_format_was_entirely_copied'):
+        if value not in set(['if_a_format_was_entirely_copied']):
             raise ValueError("must be one of enum values ('if_a_format_was_entirely_copied')")
         return value
 
-    @validator('format_partially_copied')
+    @field_validator('format_partially_copied')
     def format_partially_copied_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('if_a_format_was_partially_copied'):
+        if value not in set(['if_a_format_was_partially_copied']):
             raise ValueError("must be one of enum values ('if_a_format_was_partially_copied')")
         return value
 
-    @validator('format_downloaded')
+    @field_validator('format_downloaded')
     def format_downloaded_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('if_a_format_was_downloaded'):
+        if value not in set(['if_a_format_was_downloaded']):
             raise ValueError("must be one of enum values ('if_a_format_was_downloaded')")
         return value
 
-    @validator('format_deleted')
+    @field_validator('format_deleted')
     def format_deleted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('if_a_format_was_deleted'):
+        if value not in set(['if_a_format_was_deleted']):
             raise ValueError("must be one of enum values ('if_a_format_was_deleted')")
         return value
 
-    @validator('format_generic_classification_updated')
+    @field_validator('format_generic_classification_updated')
     def format_generic_classification_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('if_a_generic_classification_was_changed_on_a_format'):
+        if value not in set(['if_a_generic_classification_was_changed_on_a_format']):
             raise ValueError("must be one of enum values ('if_a_generic_classification_was_changed_on_a_format')")
         return value
 
-    @validator('format_specific_classification_updated')
+    @field_validator('format_specific_classification_updated')
     def format_specific_classification_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('if_a_specific_classification_was_changed_on_a_format'):
+        if value not in set(['if_a_specific_classification_was_changed_on_a_format']):
             raise ValueError("must be one of enum values ('if_a_specific_classification_was_changed_on_a_format')")
         return value
 
-    @validator('format_updated')
+    @field_validator('format_updated')
     def format_updated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_format_was_updated'):
+        if value not in set(['a_format_was_updated']):
             raise ValueError("must be one of enum values ('a_format_was_updated')")
         return value
 
-    @validator('format_inserted')
+    @field_validator('format_inserted')
     def format_inserted_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_format_was_inserted'):
+        if value not in set(['a_format_was_inserted']):
             raise ValueError("must be one of enum values ('a_format_was_inserted')")
         return value
 
-    @validator('format_value_edited')
+    @field_validator('format_value_edited')
     def format_value_edited_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_format_value_was_edited'):
+        if value not in set(['a_format_value_was_edited']):
             raise ValueError("must be one of enum values ('a_format_value_was_edited')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedFormatEventIdentifierDescriptionPairs:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TrackedFormatEventIdentifierDescriptionPairs from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedFormatEventIdentifierDescriptionPairs:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TrackedFormatEventIdentifierDescriptionPairs from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedFormatEventIdentifierDescriptionPairs.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedFormatEventIdentifierDescriptionPairs.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "format_created": obj.get("format_created"),
             "format_copied": obj.get("format_copied"),
             "format_partially_copied": obj.get("format_partially_copied"),
             "format_downloaded": obj.get("format_downloaded"),
             "format_deleted": obj.get("format_deleted"),
             "format_generic_classification_updated": obj.get("format_generic_classification_updated"),
             "format_specific_classification_updated": obj.get("format_specific_classification_updated"),
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_interaction_event.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_tag.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,67 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.mechanism_enum import MechanismEnum
+from pieces_os_client.models.tag_category_enum import TagCategoryEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TrackedInteractionEvent(BaseModel):
-    """
-    This is a model that will hold relavent information in relation to an interaction(ONLY CLICK/TAP) analytics event(usage). If you want to register an event that relates to an interaction with the key then register a Keyboard Event.   # noqa: E501
+class SeededAssetTag(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    description: StrictStr = Field(..., description="(optional) a description of this button that was clicked. or maybe what it did.")
-    element: Optional[StrictStr] = Field(None, description="This is an identifer that will allow the developer to know what unique button/field was interacted with.")
-    __properties = ["schema", "description", "element"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is similar to an SeededTag, where this is the minimum information of a tag, but this can get added to a seededAsset,  where you may not yet have an asset id.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    text: StrictStr = Field(description="this is the text that represents the tag.")
+    mechanism: Optional[MechanismEnum] = None
+    category: Optional[TagCategoryEnum] = None
+    __properties: ClassVar[List[str]] = ["schema", "text", "mechanism", "category"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedInteractionEvent:
-        """Create an instance of TrackedInteractionEvent from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededAssetTag from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedInteractionEvent:
-        """Create an instance of TrackedInteractionEvent from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededAssetTag from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedInteractionEvent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedInteractionEvent.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "description": obj.get("description"),
-            "element": obj.get("element")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "text": obj.get("text"),
+            "mechanism": obj.get("mechanism"),
+            "category": obj.get("category")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_session_event_identifier_description_pairs.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/tracked_session_event_identifier_description_pairs.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,198 +14,214 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
 class TrackedSessionEventIdentifierDescriptionPairs(BaseModel):
     """
-    These are all of the available event types that are permitted in an object pair notation.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    session_initialized: Optional[StrictStr] = Field(None, description="The key value pair for an application being opened.")
-    session_local_connection_succeeded: Optional[StrictStr] = Field(None, description="There was a successful connection locally")
-    session_local_connection_failed: Optional[StrictStr] = Field(None, description="There was a failed connection locally")
-    session_inactive: Optional[StrictStr] = Field(None, description="If the current application is in the background or not, could also be minimized.")
-    session_active: Optional[StrictStr] = Field(None, description="If the application has been brought to the forground.")
-    session_terminated: Optional[StrictStr] = Field(None, description="If the user has closed the application, thus ending the session.")
-    session_authenticated_with_sign_in: Optional[StrictStr] = Field(None, description="A user has signed into this session with a an external account")
-    session_unauthenticated_with_sign_out: Optional[StrictStr] = Field(None, description="A user has signed out of this session")
-    session_unauthenticated_with_dismiss: Optional[StrictStr] = Field(None, description="A user did not sign into the session with a dismissal")
-    session_unauthenticated_with_remind: Optional[StrictStr] = Field(None, description="A user did not sign into the session with a reminder")
-    session_onboarding_initialized: Optional[StrictStr] = Field(None, description="Onboarding has been initialized for this session")
-    session_onboarding_completed: Optional[StrictStr] = Field(None, description="Onboarding has been completed for this session")
-    __properties = ["schema", "session_initialized", "session_local_connection_succeeded", "session_local_connection_failed", "session_inactive", "session_active", "session_terminated", "session_authenticated_with_sign_in", "session_unauthenticated_with_sign_out", "session_unauthenticated_with_dismiss", "session_unauthenticated_with_remind", "session_onboarding_initialized", "session_onboarding_completed"]
+    These are all of the available event types that are permitted in an object pair notation.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    session_initialized: Optional[StrictStr] = Field(default=None, description="The key value pair for an application being opened.")
+    session_local_connection_succeeded: Optional[StrictStr] = Field(default=None, description="There was a successful connection locally")
+    session_local_connection_failed: Optional[StrictStr] = Field(default=None, description="There was a failed connection locally")
+    session_inactive: Optional[StrictStr] = Field(default=None, description="If the current application is in the background or not, could also be minimized.")
+    session_active: Optional[StrictStr] = Field(default=None, description="If the application has been brought to the forground.")
+    session_terminated: Optional[StrictStr] = Field(default=None, description="If the user has closed the application, thus ending the session.")
+    session_authenticated_with_sign_in: Optional[StrictStr] = Field(default=None, description="A user has signed into this session with a an external account")
+    session_unauthenticated_with_sign_out: Optional[StrictStr] = Field(default=None, description="A user has signed out of this session")
+    session_unauthenticated_with_dismiss: Optional[StrictStr] = Field(default=None, description="A user did not sign into the session with a dismissal")
+    session_unauthenticated_with_remind: Optional[StrictStr] = Field(default=None, description="A user did not sign into the session with a reminder")
+    session_onboarding_initialized: Optional[StrictStr] = Field(default=None, description="Onboarding has been initialized for this session")
+    session_onboarding_completed: Optional[StrictStr] = Field(default=None, description="Onboarding has been completed for this session")
+    __properties: ClassVar[List[str]] = ["schema", "session_initialized", "session_local_connection_succeeded", "session_local_connection_failed", "session_inactive", "session_active", "session_terminated", "session_authenticated_with_sign_in", "session_unauthenticated_with_sign_out", "session_unauthenticated_with_dismiss", "session_unauthenticated_with_remind", "session_onboarding_initialized", "session_onboarding_completed"]
 
-    @validator('session_initialized')
+    @field_validator('session_initialized')
     def session_initialized_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_session_has_been_initialized_and_the_application_has_been_opened'):
+        if value not in set(['a_session_has_been_initialized_and_the_application_has_been_opened']):
             raise ValueError("must be one of enum values ('a_session_has_been_initialized_and_the_application_has_been_opened')")
         return value
 
-    @validator('session_local_connection_succeeded')
+    @field_validator('session_local_connection_succeeded')
     def session_local_connection_succeeded_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('one_or_more_applications_has_successfully_connected'):
+        if value not in set(['one_or_more_applications_has_successfully_connected']):
             raise ValueError("must be one of enum values ('one_or_more_applications_has_successfully_connected')")
         return value
 
-    @validator('session_local_connection_failed')
+    @field_validator('session_local_connection_failed')
     def session_local_connection_failed_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('one_or_more_applications_has_failed_to_connect_locally'):
+        if value not in set(['one_or_more_applications_has_failed_to_connect_locally']):
             raise ValueError("must be one of enum values ('one_or_more_applications_has_failed_to_connect_locally')")
         return value
 
-    @validator('session_inactive')
+    @field_validator('session_inactive')
     def session_inactive_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_session_is_inactive_because_the_application_is_not_in_the_foreground'):
+        if value not in set(['a_session_is_inactive_because_the_application_is_not_in_the_foreground']):
             raise ValueError("must be one of enum values ('a_session_is_inactive_because_the_application_is_not_in_the_foreground')")
         return value
 
-    @validator('session_active')
+    @field_validator('session_active')
     def session_active_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_session_is_active_because_the_application_is_in_the_foreground'):
+        if value not in set(['a_session_is_active_because_the_application_is_in_the_foreground']):
             raise ValueError("must be one of enum values ('a_session_is_active_because_the_application_is_in_the_foreground')")
         return value
 
-    @validator('session_terminated')
+    @field_validator('session_terminated')
     def session_terminated_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_session_has_been_ended_and_the_application_has_been_closed'):
+        if value not in set(['a_session_has_been_ended_and_the_application_has_been_closed']):
             raise ValueError("must be one of enum values ('a_session_has_been_ended_and_the_application_has_been_closed')")
         return value
 
-    @validator('session_authenticated_with_sign_in')
+    @field_validator('session_authenticated_with_sign_in')
     def session_authenticated_with_sign_in_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_user_has_signed_into_this_session_with_a_an_external_account'):
+        if value not in set(['a_user_has_signed_into_this_session_with_a_an_external_account']):
             raise ValueError("must be one of enum values ('a_user_has_signed_into_this_session_with_a_an_external_account')")
         return value
 
-    @validator('session_unauthenticated_with_sign_out')
+    @field_validator('session_unauthenticated_with_sign_out')
     def session_unauthenticated_with_sign_out_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_user_has_signed_out_of_this_session'):
+        if value not in set(['a_user_has_signed_out_of_this_session']):
             raise ValueError("must be one of enum values ('a_user_has_signed_out_of_this_session')")
         return value
 
-    @validator('session_unauthenticated_with_dismiss')
+    @field_validator('session_unauthenticated_with_dismiss')
     def session_unauthenticated_with_dismiss_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_user_did_not_sign_into_the_session_with_a_dismissal'):
+        if value not in set(['a_user_did_not_sign_into_the_session_with_a_dismissal']):
             raise ValueError("must be one of enum values ('a_user_did_not_sign_into_the_session_with_a_dismissal')")
         return value
 
-    @validator('session_unauthenticated_with_remind')
+    @field_validator('session_unauthenticated_with_remind')
     def session_unauthenticated_with_remind_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('a_user_did_not_sign_into_the_session_with_a_reminder'):
+        if value not in set(['a_user_did_not_sign_into_the_session_with_a_reminder']):
             raise ValueError("must be one of enum values ('a_user_did_not_sign_into_the_session_with_a_reminder')")
         return value
 
-    @validator('session_onboarding_initialized')
+    @field_validator('session_onboarding_initialized')
     def session_onboarding_initialized_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('onboarding_has_been_initialized_for_this_session'):
+        if value not in set(['onboarding_has_been_initialized_for_this_session']):
             raise ValueError("must be one of enum values ('onboarding_has_been_initialized_for_this_session')")
         return value
 
-    @validator('session_onboarding_completed')
+    @field_validator('session_onboarding_completed')
     def session_onboarding_completed_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
-        if value not in ('onboarding_has_been_completed_for_this_session'):
+        if value not in set(['onboarding_has_been_completed_for_this_session']):
             raise ValueError("must be one of enum values ('onboarding_has_been_completed_for_this_session')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedSessionEventIdentifierDescriptionPairs:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of TrackedSessionEventIdentifierDescriptionPairs from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedSessionEventIdentifierDescriptionPairs:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of TrackedSessionEventIdentifierDescriptionPairs from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedSessionEventIdentifierDescriptionPairs.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedSessionEventIdentifierDescriptionPairs.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "session_initialized": obj.get("session_initialized"),
             "session_local_connection_succeeded": obj.get("session_local_connection_succeeded"),
             "session_local_connection_failed": obj.get("session_local_connection_failed"),
             "session_inactive": obj.get("session_inactive"),
             "session_active": obj.get("session_active"),
             "session_terminated": obj.get("session_terminated"),
             "session_authenticated_with_sign_in": obj.get("session_authenticated_with_sign_in"),
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/tracked_user_profile.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/interacted_asset.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,78 +14,92 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, Field, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from pieces_os_client.models.interacted_asset_interactions import InteractedAssetInteractions
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
-from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-
-class TrackedUserProfile(BaseModel):
-    """
-    A user that will be passed along with each analytics event  # noqa: E501
+class InteractedAsset(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(..., description="The ID of the user that you are tracking.")
-    username: StrictStr = Field(..., description="This is a username that is attempted to be assigned but is \"Anonymous User\" by default")
-    email: Optional[StrictStr] = Field(None, description="The user's email if we have it.")
-    granularity: StrictStr = Field(..., description="At what level is this user being tracked.")
-    __properties = ["schema", "id", "username", "email", "granularity"]
-
-    @validator('granularity')
-    def granularity_validate_enum(cls, value):
-        """Validates the enum"""
-        if value not in ('DEVICE', 'ACCOUNT', 'ANONYMOUS'):
-            raise ValueError("must be one of enum values ('DEVICE', 'ACCOUNT', 'ANONYMOUS')")
+    A model that represents an asset that has been interacted with. 
+    """ # noqa: E501
+    asset: Optional[Annotated[str, Field(min_length=36, strict=True, max_length=36)]] = Field(default=None, description="A uuid model. 36 Characters (4 Dashes, 32 Numbers/Letters) ")
+    interactions: Optional[InteractedAssetInteractions] = None
+    __properties: ClassVar[List[str]] = ["asset", "interactions"]
+
+    @field_validator('asset')
+    def asset_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}", value):
+            raise ValueError(r"must validate the regular expression /[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TrackedUserProfile:
-        """Create an instance of TrackedUserProfile from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of InteractedAsset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of var_schema
-        if self.var_schema:
-            _dict['schema'] = self.var_schema.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of interactions
+        if self.interactions:
+            _dict['interactions'] = self.interactions.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TrackedUserProfile:
-        """Create an instance of TrackedUserProfile from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of InteractedAsset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TrackedUserProfile.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TrackedUserProfile.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "id": obj.get("id"),
-            "username": obj.get("username") if obj.get("username") is not None else 'unknown',
-            "email": obj.get("email"),
-            "granularity": obj.get("granularity") if obj.get("granularity") is not None else 'ANONYMOUS'
+        _obj = cls.model_validate({
+            "asset": obj.get("asset"),
+            "interactions": InteractedAssetInteractions.from_dict(obj["interactions"]) if obj.get("interactions") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/transferable_bytes.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/seeded_asset_enrichment.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,71 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TransferableBytes(BaseModel):
-    """
-    Bytes is a Model for A FileFormat. Raw and file are the only 2 that are currently supported. Raw and file are an array of integers that represent the file.Typical conversion UTF8 -> array[int] or UTF8 -> array[bytes(in hexidecimal)] -> array[int]. Either way you convert is up to you but the type we need here is an array of integers.  [NOT IMPLEMENTED] base64, base64_url, data_url [IMPLEMENTED] raw  # noqa: E501
+class SeededAssetEnrichment(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    raw: Optional[conlist(StrictInt)] = Field(None, description="IMPLEMENTED")
-    var_base64: Optional[conlist(StrictInt)] = Field(None, alias="base64", description="NOT IMPLEMENTED")
-    base64_url: Optional[conlist(StrictInt)] = Field(None, description="NOT IMPLEMENTED")
-    data_url: Optional[conlist(StrictInt)] = Field(None, description="NOT IMPLEMENTED")
-    __properties = ["schema", "raw", "base64", "base64_url", "data_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a specific Model for the SeededAsset that will enable the developer to modify the enrichment levels of persons, tags, websites.  These enrichment levels will guarentee that the # of people/tags/websites do not eceeed the provided value, but will not guarentee a minimum.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    tags: Optional[StrictInt] = None
+    websites: Optional[StrictInt] = None
+    persons: Optional[StrictInt] = None
+    hints: Optional[StrictInt] = None
+    __properties: ClassVar[List[str]] = ["schema", "tags", "websites", "persons", "hints"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TransferableBytes:
-        """Create an instance of TransferableBytes from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SeededAssetEnrichment from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TransferableBytes:
-        """Create an instance of TransferableBytes from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SeededAssetEnrichment from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TransferableBytes.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TransferableBytes.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "raw": obj.get("raw"),
-            "var_base64": obj.get("base64"),
-            "base64_url": obj.get("base64_url"),
-            "data_url": obj.get("data_url")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "tags": obj.get("tags"),
+            "websites": obj.get("websites"),
+            "persons": obj.get("persons"),
+            "hints": obj.get("hints")
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/unchecked_os_update.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_shares.py`

 * *Files 27% similar despite different names*

```diff
@@ -14,63 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-class UncheckedOSUpdate(BaseModel):
-    """
-    This is the input body for /os/update/check, just a placeholder for now.  # noqa: E501
+class FlattenedShares(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    __properties = ["schema"]
+    This is just an iterable of our individual share models.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[FlattenedShare]
+    score: Optional[Score] = None
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UncheckedOSUpdate:
-        """Create an instance of UncheckedOSUpdate from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedShares from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
+        _items = []
+        if self.iterable:
+            for _item in self.iterable:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['iterable'] = _items
+        # override the default output from pydantic by calling `to_dict()` of score
+        if self.score:
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UncheckedOSUpdate:
-        """Create an instance of UncheckedOSUpdate from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedShares from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UncheckedOSUpdate.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UncheckedOSUpdate.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [FlattenedShare.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.flattened_share import FlattenedShare
+# TODO: Rewrite to not use raise_errors
+FlattenedShares.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/unsegmented_technical_language.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/referenced_asset.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,65 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
+from typing import Optional, Set
+from typing_extensions import Self
 
-class UnsegmentedTechnicalLanguage(BaseModel):
-    """
-    This is the input model for '/machine_learning/text/technical_language/parsers/segmentation'  This will take the unsegmentedText here!  # noqa: E501
+class ReferencedAsset(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    value: StrictStr = Field(...)
-    __properties = ["schema", "value"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A reference to a asset, which at minimum must have the asset's id. But in the case of a hydrated client API it may have a populated reference of type Asset.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    reference: Optional[FlattenedAsset] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "reference"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UnsegmentedTechnicalLanguage:
-        """Create an instance of UnsegmentedTechnicalLanguage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReferencedAsset from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of reference
+        if self.reference:
+            _dict['reference'] = self.reference.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UnsegmentedTechnicalLanguage:
-        """Create an instance of UnsegmentedTechnicalLanguage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReferencedAsset from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UnsegmentedTechnicalLanguage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UnsegmentedTechnicalLanguage.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "value": obj.get("value")
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "id": obj.get("id"),
+            "reference": FlattenedAsset.from_dict(obj["reference"]) if obj.get("reference") is not None else None
         })
         return _obj
 
+from pieces_os_client.models.flattened_asset import FlattenedAsset
+# TODO: Rewrite to not use raise_errors
+ReferencedAsset.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/updating_status_enum.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/updating_status_enum.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class UpdatingStatusEnum(str, Enum):
     """
     This is a simple enum used to determine the status of the Updating process.(of PiecesOS)  UpdatingStatusEnum(READY_TO_RESTART, AVAILABLE(but not downloaded), DOWNLOADING, UNKNOWN, UP_TO_DATE)  UNKNOWN: should never be the case  These are some enums that are currently not implemented but are for future support( REINSTALL_REQUIRED, CONTACT_SUPPORT)
     """
 
@@ -35,12 +32,12 @@
     DOWNLOADING = 'DOWNLOADING'
     UNKNOWN = 'UNKNOWN'
     UP_TO_DATE = 'UP_TO_DATE'
     REINSTALL_REQUIRED = 'REINSTALL_REQUIRED'
     CONTACT_SUPPORT = 'CONTACT_SUPPORT'
 
     @classmethod
-    def from_json(cls, json_str: str) -> UpdatingStatusEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of UpdatingStatusEnum from a JSON string"""
-        return UpdatingStatusEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/user_profile.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/user_profile.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,67 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.aesthetics import Aesthetics
 from pieces_os_client.models.allocation_cloud import AllocationCloud
 from pieces_os_client.models.auth0_user_metadata import Auth0UserMetadata
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.external_providers import ExternalProviders
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
+from typing import Optional, Set
+from typing_extensions import Self
 
 class UserProfile(BaseModel):
     """
-    This is the model for a user logged into Pieces.  # noqa: E501
-    """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    picture: Optional[StrictStr] = Field('https://picsum.photos/200', description="mapped from picture.URL pointing to the user's profile picture. ")
+    This is the model for a user logged into Pieces.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    picture: Optional[StrictStr] = Field(default='https://picsum.photos/200', description="mapped from picture.URL pointing to the user's profile picture. ")
     email: Optional[StrictStr] = 'user@pieces.app'
     created: Optional[GroupedTimestamp] = None
     updated: Optional[GroupedTimestamp] = None
-    username: Optional[StrictStr] = Field(None, description=" (unique) User's username.  ")
-    id: StrictStr = Field(...)
-    name: Optional[StrictStr] = Field(None, description="This is the name of the User.")
-    aesthetics: Aesthetics = Field(...)
+    username: Optional[StrictStr] = Field(default=None, description=" (unique) User's username.  ")
+    id: StrictStr
+    name: Optional[StrictStr] = Field(default=None, description="This is the name of the User.")
+    aesthetics: Aesthetics
     vanityname: Optional[StrictStr] = None
     allocation: Optional[AllocationCloud] = None
     providers: Optional[ExternalProviders] = None
     auth0: Optional[Auth0UserMetadata] = None
-    __properties = ["schema", "picture", "email", "created", "updated", "username", "id", "name", "aesthetics", "vanityname", "allocation", "providers", "auth0"]
+    __properties: ClassVar[List[str]] = ["schema", "picture", "email", "created", "updated", "username", "id", "name", "aesthetics", "vanityname", "allocation", "providers", "auth0"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserProfile:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of UserProfile from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
@@ -91,33 +107,33 @@
             _dict['providers'] = self.providers.to_dict()
         # override the default output from pydantic by calling `to_dict()` of auth0
         if self.auth0:
             _dict['auth0'] = self.auth0.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserProfile:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of UserProfile from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserProfile.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserProfile.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "picture": obj.get("picture") if obj.get("picture") is not None else 'https://picsum.photos/200',
             "email": obj.get("email") if obj.get("email") is not None else 'user@pieces.app',
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
             "username": obj.get("username"),
             "id": obj.get("id"),
             "name": obj.get("name"),
-            "aesthetics": Aesthetics.from_dict(obj.get("aesthetics")) if obj.get("aesthetics") is not None else None,
+            "aesthetics": Aesthetics.from_dict(obj["aesthetics"]) if obj.get("aesthetics") is not None else None,
             "vanityname": obj.get("vanityname"),
-            "allocation": AllocationCloud.from_dict(obj.get("allocation")) if obj.get("allocation") is not None else None,
-            "providers": ExternalProviders.from_dict(obj.get("providers")) if obj.get("providers") is not None else None,
-            "auth0": Auth0UserMetadata.from_dict(obj.get("auth0")) if obj.get("auth0") is not None else None
+            "allocation": AllocationCloud.from_dict(obj["allocation"]) if obj.get("allocation") is not None else None,
+            "providers": ExternalProviders.from_dict(obj["providers"]) if obj.get("providers") is not None else None,
+            "auth0": Auth0UserMetadata.from_dict(obj["auth0"]) if obj.get("auth0") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/users.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/websites.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,73 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.user_profile import UserProfile
+from pieces_os_client.models.score import Score
+from pieces_os_client.models.website import Website
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Users(BaseModel):
-    """
-    A base class for a collection of users and some additional meta properties.  # noqa: E501
+class Websites(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: Optional[conlist(UserProfile)] = None
-    __properties = ["schema", "iterable"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    This is a specific model for related websites to an asset.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Website]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an website id.")
+    score: Optional[Score] = None
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Users:
-        """Create an instance of Users from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Websites from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['iterable'] = _items
+        # override the default output from pydantic by calling `to_dict()` of score
+        if self.score:
+            _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Users:
-        """Create an instance of Users from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Websites from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Users.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Users.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [UserProfile.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Website.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
+            "indices": obj.get("indices"),
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/website.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/flattened_activity.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,114 +14,134 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.application import Application
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
-from pieces_os_client.models.flattened_assets import FlattenedAssets
-from pieces_os_client.models.flattened_conversations import FlattenedConversations
-from pieces_os_client.models.flattened_persons import FlattenedPersons
+from pieces_os_client.models.flattened_user_profile import FlattenedUserProfile
 from pieces_os_client.models.grouped_timestamp import GroupedTimestamp
 from pieces_os_client.models.mechanism_enum import MechanismEnum
-from pieces_os_client.models.score import Score
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Website(BaseModel):
-    """
-    This is a specific model for related websites to an asset.  # noqa: E501
+class FlattenedActivity(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    id: StrictStr = Field(...)
-    assets: Optional[FlattenedAssets] = None
-    url: StrictStr = Field(..., description="this is the actual website url.")
-    name: StrictStr = Field(..., description="This is a name that is customized.")
-    created: GroupedTimestamp = Field(...)
-    updated: GroupedTimestamp = Field(...)
+    Note: - if mechanism == internal we will not display to the user.
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    id: StrictStr
+    created: GroupedTimestamp
+    updated: GroupedTimestamp
+    event: SeededConnectorTracking
+    application: Application
     deleted: Optional[GroupedTimestamp] = None
-    mechanisms: Optional[Dict[str, MechanismEnum]] = Field(None, description="This is a Map<String, MechanismEnum> where the the key is an asset id.")
-    interactions: Optional[StrictInt] = Field(None, description="This is an optional value that will keep track of the number of times this has been interacted with.")
-    persons: Optional[FlattenedPersons] = None
-    conversations: Optional[FlattenedConversations] = None
-    score: Optional[Score] = None
-    __properties = ["schema", "id", "assets", "url", "name", "created", "updated", "deleted", "mechanisms", "interactions", "persons", "conversations", "score"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    asset: Optional[ReferencedAsset] = None
+    format: Optional[ReferencedFormat] = None
+    user: Optional[FlattenedUserProfile] = None
+    mechanism: MechanismEnum
+    rank: Optional[StrictInt] = None
+    __properties: ClassVar[List[str]] = ["schema", "id", "created", "updated", "event", "application", "deleted", "asset", "format", "user", "mechanism", "rank"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Website:
-        """Create an instance of Website from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlattenedActivity from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of assets
-        if self.assets:
-            _dict['assets'] = self.assets.to_dict()
         # override the default output from pydantic by calling `to_dict()` of created
         if self.created:
             _dict['created'] = self.created.to_dict()
         # override the default output from pydantic by calling `to_dict()` of updated
         if self.updated:
             _dict['updated'] = self.updated.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of event
+        if self.event:
+            _dict['event'] = self.event.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of application
+        if self.application:
+            _dict['application'] = self.application.to_dict()
         # override the default output from pydantic by calling `to_dict()` of deleted
         if self.deleted:
             _dict['deleted'] = self.deleted.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of persons
-        if self.persons:
-            _dict['persons'] = self.persons.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of conversations
-        if self.conversations:
-            _dict['conversations'] = self.conversations.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of score
-        if self.score:
-            _dict['score'] = self.score.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of asset
+        if self.asset:
+            _dict['asset'] = self.asset.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of format
+        if self.format:
+            _dict['format'] = self.format.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of user
+        if self.user:
+            _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Website:
-        """Create an instance of Website from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlattenedActivity from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Website.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Website.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
             "id": obj.get("id"),
-            "assets": FlattenedAssets.from_dict(obj.get("assets")) if obj.get("assets") is not None else None,
-            "url": obj.get("url"),
-            "name": obj.get("name"),
-            "created": GroupedTimestamp.from_dict(obj.get("created")) if obj.get("created") is not None else None,
-            "updated": GroupedTimestamp.from_dict(obj.get("updated")) if obj.get("updated") is not None else None,
-            "deleted": GroupedTimestamp.from_dict(obj.get("deleted")) if obj.get("deleted") is not None else None,
-            "mechanisms": dict((_k, _v) for _k, _v in obj.get("mechanisms").items()),
-            "interactions": obj.get("interactions"),
-            "persons": FlattenedPersons.from_dict(obj.get("persons")) if obj.get("persons") is not None else None,
-            "conversations": FlattenedConversations.from_dict(obj.get("conversations")) if obj.get("conversations") is not None else None,
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "created": GroupedTimestamp.from_dict(obj["created"]) if obj.get("created") is not None else None,
+            "updated": GroupedTimestamp.from_dict(obj["updated"]) if obj.get("updated") is not None else None,
+            "event": SeededConnectorTracking.from_dict(obj["event"]) if obj.get("event") is not None else None,
+            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
+            "deleted": GroupedTimestamp.from_dict(obj["deleted"]) if obj.get("deleted") is not None else None,
+            "asset": ReferencedAsset.from_dict(obj["asset"]) if obj.get("asset") is not None else None,
+            "format": ReferencedFormat.from_dict(obj["format"]) if obj.get("format") is not None else None,
+            "user": FlattenedUserProfile.from_dict(obj["user"]) if obj.get("user") is not None else None,
+            "mechanism": obj.get("mechanism"),
+            "rank": obj.get("rank")
         })
         return _obj
 
+from pieces_os_client.models.referenced_asset import ReferencedAsset
+from pieces_os_client.models.referenced_format import ReferencedFormat
+from pieces_os_client.models.seeded_connector_tracking import SeededConnectorTracking
+# TODO: Rewrite to not use raise_errors
+FlattenedActivity.model_rebuild(raise_errors=False)
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/models/websites.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/models/assets.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,55 +14,71 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from pieces_os_client.models.asset import Asset
 from pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
 from pieces_os_client.models.score import Score
-from pieces_os_client.models.website import Website
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Websites(BaseModel):
-    """
-    This is a specific model for related websites to an asset.  # noqa: E501
+class Assets(BaseModel):
     """
-    var_schema: Optional[EmbeddedModelSchema] = Field(None, alias="schema")
-    iterable: conlist(Website) = Field(...)
-    indices: Optional[Dict[str, StrictInt]] = Field(None, description="This is a Map<String, int> where the the key is an website id.")
+    A base class for a collection of assets and some additional meta properties. Fully Populated with Formats internally (not just uuid's).
+    """ # noqa: E501
+    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
+    iterable: List[Asset]
+    indices: Optional[Dict[str, StrictInt]] = Field(default=None, description="This is a Map<String, int> where the the key is an asset id.")
     score: Optional[Score] = None
-    __properties = ["schema", "iterable", "indices", "score"]
+    __properties: ClassVar[List[str]] = ["schema", "iterable", "indices", "score"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True,
+        "protected_namespaces": (),
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Websites:
-        """Create an instance of Websites from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Assets from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of var_schema
         if self.var_schema:
             _dict['schema'] = self.var_schema.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in iterable (list)
         _items = []
         if self.iterable:
             for _item in self.iterable:
@@ -71,24 +87,24 @@
             _dict['iterable'] = _items
         # override the default output from pydantic by calling `to_dict()` of score
         if self.score:
             _dict['score'] = self.score.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Websites:
-        """Create an instance of Websites from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Assets from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Websites.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Websites.parse_obj({
-            "var_schema": EmbeddedModelSchema.from_dict(obj.get("schema")) if obj.get("schema") is not None else None,
-            "iterable": [Website.from_dict(_item) for _item in obj.get("iterable")] if obj.get("iterable") is not None else None,
+        _obj = cls.model_validate({
+            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
+            "iterable": [Asset.from_dict(_item) for _item in obj["iterable"]] if obj.get("iterable") is not None else None,
             "indices": obj.get("indices"),
-            "score": Score.from_dict(obj.get("score")) if obj.get("score") is not None else None
+            "score": Score.from_dict(obj["score"]) if obj.get("score") is not None else None
         })
         return _obj
```

### Comparing `pieces_os_client-1.2.7/src/pieces_os_client/rest.py` & `pieces_os_client-2.0.0.post1/src/pieces_os_client/api/ultra_suite_api.py`

 * *Files 27% similar despite different names*

```diff
@@ -8,297 +8,302 @@
     The version of the OpenAPI document: 1.0
     Contact: tsavo@pieces.app
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+import warnings
+from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
+from typing import Any, Dict, List, Optional, Tuple, Union
+from typing_extensions import Annotated
+
+from typing import Optional
+from pieces_os_client.models.asset import Asset
+from pieces_os_client.models.seeded_ultra_suite_asset import SeededUltraSuiteAsset
+
+from pieces_os_client.api_client import ApiClient, RequestSerialized
+from pieces_os_client.api_response import ApiResponse
+from pieces_os_client.rest import RESTResponseType
+
+
+class UltraSuiteApi:
+    """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
 
-import io
-import json
-import logging
-import re
-import ssl
-
-from urllib.parse import urlencode, quote_plus
-import urllib3
-
-from pieces_os_client.exceptions import ApiException, UnauthorizedException, ForbiddenException, NotFoundException, ServiceException, ApiValueError, BadRequestException
-
-
-logger = logging.getLogger(__name__)
-
-
-class RESTResponse(io.IOBase):
-
-    def __init__(self, resp) -> None:
-        self.urllib3_response = resp
-        self.status = resp.status
-        self.reason = resp.reason
-        self.data = resp.data
-
-    def getheaders(self):
-        """Returns a dictionary of the response headers."""
-        return self.urllib3_response.headers
+    Do not edit the class manually.
+    """
 
-    def getheader(self, name, default=None):
-        """Returns a given response header."""
-        return self.urllib3_response.headers.get(name, default)
+    def __init__(self, api_client=None) -> None:
+        if api_client is None:
+            api_client = ApiClient.get_default()
+        self.api_client = api_client
+
+
+    @validate_call
+    def assets_create_ultra_suite_asset(
+        self,
+        seeded_ultra_suite_asset: Optional[SeededUltraSuiteAsset] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> Asset:
+        """/ultra_suite/assets/create [POST]
 
+        This Endpoint will create an Asset that is sent from UltraSuite.
 
-class RESTClientObject:
+        :param seeded_ultra_suite_asset:
+        :type seeded_ultra_suite_asset: SeededUltraSuiteAsset
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._assets_create_ultra_suite_asset_serialize(
+            seeded_ultra_suite_asset=seeded_ultra_suite_asset,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "Asset",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def assets_create_ultra_suite_asset_with_http_info(
+        self,
+        seeded_ultra_suite_asset: Optional[SeededUltraSuiteAsset] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[Asset]:
+        """/ultra_suite/assets/create [POST]
 
-    def __init__(self, configuration, pools_size=4, maxsize=None) -> None:
-        # urllib3.PoolManager will pass all kw parameters to connectionpool
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
-        # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501
-        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501
+        This Endpoint will create an Asset that is sent from UltraSuite.
 
-        # cert_reqs
-        if configuration.verify_ssl:
-            cert_reqs = ssl.CERT_REQUIRED
-        else:
-            cert_reqs = ssl.CERT_NONE
+        :param seeded_ultra_suite_asset:
+        :type seeded_ultra_suite_asset: SeededUltraSuiteAsset
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._assets_create_ultra_suite_asset_serialize(
+            seeded_ultra_suite_asset=seeded_ultra_suite_asset,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "Asset",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def assets_create_ultra_suite_asset_without_preload_content(
+        self,
+        seeded_ultra_suite_asset: Optional[SeededUltraSuiteAsset] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """/ultra_suite/assets/create [POST]
 
-        addition_pool_args = {}
-        if configuration.assert_hostname is not None:
-            addition_pool_args['assert_hostname'] = configuration.assert_hostname  # noqa: E501
-
-        if configuration.retries is not None:
-            addition_pool_args['retries'] = configuration.retries
-
-        if configuration.tls_server_name:
-            addition_pool_args['server_hostname'] = configuration.tls_server_name
-
-
-        if configuration.socket_options is not None:
-            addition_pool_args['socket_options'] = configuration.socket_options
-
-        if maxsize is None:
-            if configuration.connection_pool_maxsize is not None:
-                maxsize = configuration.connection_pool_maxsize
-            else:
-                maxsize = 4
-
-        # https pool manager
-        if configuration.proxy:
-            self.pool_manager = urllib3.ProxyManager(
-                num_pools=pools_size,
-                maxsize=maxsize,
-                cert_reqs=cert_reqs,
-                ca_certs=configuration.ssl_ca_cert,
-                cert_file=configuration.cert_file,
-                key_file=configuration.key_file,
-                proxy_url=configuration.proxy,
-                proxy_headers=configuration.proxy_headers,
-                **addition_pool_args
-            )
-        else:
-            self.pool_manager = urllib3.PoolManager(
-                num_pools=pools_size,
-                maxsize=maxsize,
-                cert_reqs=cert_reqs,
-                ca_certs=configuration.ssl_ca_cert,
-                cert_file=configuration.cert_file,
-                key_file=configuration.key_file,
-                **addition_pool_args
-            )
+        This Endpoint will create an Asset that is sent from UltraSuite.
 
-    def request(self, method, url, query_params=None, headers=None,
-                body=None, post_params=None, _preload_content=True,
-                _request_timeout=None):
-        """Perform requests.
-
-        :param method: http request method
-        :param url: http request url
-        :param query_params: query parameters in the url
-        :param headers: http request headers
-        :param body: request json body, for `application/json`
-        :param post_params: request post parameters,
-                            `application/x-www-form-urlencoded`
-                            and `multipart/form-data`
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param seeded_ultra_suite_asset:
+        :type seeded_ultra_suite_asset: SeededUltraSuiteAsset
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
-        """
-        method = method.upper()
-        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',
-                          'PATCH', 'OPTIONS']
-
-        if post_params and body:
-            raise ApiValueError(
-                "body parameter cannot be used with post_params parameter."
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._assets_create_ultra_suite_asset_serialize(
+            seeded_ultra_suite_asset=seeded_ultra_suite_asset,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "Asset",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _assets_create_ultra_suite_asset_serialize(
+        self,
+        seeded_ultra_suite_asset,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, str] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+        if seeded_ultra_suite_asset is not None:
+            _body_params = seeded_ultra_suite_asset
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+        # set the HTTP header `Content-Type`
+        if _content_type:
+            _header_params['Content-Type'] = _content_type
+        else:
+            _default_content_type = (
+                self.api_client.select_header_content_type(
+                    [
+                        'application/json'
+                    ]
+                )
             )
+            if _default_content_type is not None:
+                _header_params['Content-Type'] = _default_content_type
+
+        # authentication setting
+        _auth_settings: List[str] = [
+        ]
+
+        return self.api_client.param_serialize(
+            method='POST',
+            resource_path='/ultra_suite/assets/create',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
 
-        post_params = post_params or {}
-        headers = headers or {}
-        # url already contains the URL query string
-        # so reset query_params to empty dict
-        query_params = {}
-
-        timeout = None
-        if _request_timeout:
-            if isinstance(_request_timeout, (int,float)):  # noqa: E501,F821
-                timeout = urllib3.Timeout(total=_request_timeout)
-            elif (isinstance(_request_timeout, tuple) and
-                  len(_request_timeout) == 2):
-                timeout = urllib3.Timeout(
-                    connect=_request_timeout[0], read=_request_timeout[1])
-
-        try:
-            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
-            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
-
-                # no content type provided or payload is json
-                if not headers.get('Content-Type') or re.search('json', headers['Content-Type'], re.IGNORECASE):
-                    request_body = None
-                    if body is not None:
-                        request_body = json.dumps(body)
-                    r = self.pool_manager.request(
-                        method, url,
-                        body=request_body,
-                        preload_content=_preload_content,
-                        timeout=timeout,
-                        headers=headers)
-                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
-                    r = self.pool_manager.request(
-                        method, url,
-                        fields=post_params,
-                        encode_multipart=False,
-                        preload_content=_preload_content,
-                        timeout=timeout,
-                        headers=headers)
-                elif headers['Content-Type'] == 'multipart/form-data':
-                    # must del headers['Content-Type'], or the correct
-                    # Content-Type which generated by urllib3 will be
-                    # overwritten.
-                    del headers['Content-Type']
-                    r = self.pool_manager.request(
-                        method, url,
-                        fields=post_params,
-                        encode_multipart=True,
-                        preload_content=_preload_content,
-                        timeout=timeout,
-                        headers=headers)
-                # Pass a `string` parameter directly in the body to support
-                # other content types than Json when `body` argument is
-                # provided in serialized form
-                elif isinstance(body, str) or isinstance(body, bytes):
-                    request_body = body
-                    r = self.pool_manager.request(
-                        method, url,
-                        body=request_body,
-                        preload_content=_preload_content,
-                        timeout=timeout,
-                        headers=headers)
-                else:
-                    # Cannot generate the request from given parameters
-                    msg = """Cannot prepare a request message for provided
-                             arguments. Please check that your arguments match
-                             declared content type."""
-                    raise ApiException(status=0, reason=msg)
-            # For `GET`, `HEAD`
-            else:
-                r = self.pool_manager.request(method, url,
-                                              fields={},
-                                              preload_content=_preload_content,
-                                              timeout=timeout,
-                                              headers=headers)
-        except urllib3.exceptions.SSLError as e:
-            msg = "{0}\n{1}".format(type(e).__name__, str(e))
-            raise ApiException(status=0, reason=msg)
-
-        if _preload_content:
-            r = RESTResponse(r)
-
-            # log response body
-            logger.debug("response body: %s", r.data)
-
-        if not 200 <= r.status <= 299:
-            if r.status == 400:
-                raise BadRequestException(http_resp=r)
-
-            if r.status == 401:
-                raise UnauthorizedException(http_resp=r)
-
-            if r.status == 403:
-                raise ForbiddenException(http_resp=r)
-
-            if r.status == 404:
-                raise NotFoundException(http_resp=r)
-
-            if 500 <= r.status <= 599:
-                raise ServiceException(http_resp=r)
-
-            raise ApiException(http_resp=r)
-
-        return r
-
-    def get_request(self, url, headers=None, query_params=None, _preload_content=True,
-            _request_timeout=None):
-        return self.request("GET", url,
-                            headers=headers,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            query_params=query_params)
-
-    def head_request(self, url, headers=None, query_params=None, _preload_content=True,
-             _request_timeout=None):
-        return self.request("HEAD", url,
-                            headers=headers,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            query_params=query_params)
-
-    def options_request(self, url, headers=None, query_params=None, post_params=None,
-                body=None, _preload_content=True, _request_timeout=None):
-        return self.request("OPTIONS", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def delete_request(self, url, headers=None, query_params=None, body=None,
-               _preload_content=True, _request_timeout=None):
-        return self.request("DELETE", url,
-                            headers=headers,
-                            query_params=query_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def post_request(self, url, headers=None, query_params=None, post_params=None,
-             body=None, _preload_content=True, _request_timeout=None):
-        return self.request("POST", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def put_request(self, url, headers=None, query_params=None, post_params=None,
-            body=None, _preload_content=True, _request_timeout=None):
-        return self.request("PUT", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def patch_request(self, url, headers=None, query_params=None, post_params=None,
-              body=None, _preload_content=True, _request_timeout=None):
-        return self.request("PATCH", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
```

