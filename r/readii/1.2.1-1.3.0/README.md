# Comparing `tmp/readii-1.2.1.tar.gz` & `tmp/readii-1.3.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "readii-1.2.1.tar", max compression
+gzip compressed data, was "readii-1.3.0.tar", max compression
```

## Comparing `readii-1.2.1.tar` & `readii-1.3.0.tar`

### file list

```diff
@@ -1,13 +1,13 @@
--rwxr-xr-x   0        0        0     1069 2024-03-27 14:18:14.678008 readii-1.2.1/LICENSE
--rw-r--r--   0        0        0     2053 2024-03-27 14:18:14.678008 readii-1.2.1/README.md
--rw-r--r--   0        0        0     1381 2024-03-27 14:19:08.929674 readii-1.2.1/pyproject.toml
--rw-r--r--   0        0        0      100 2024-03-27 14:18:59.073733 readii-1.2.1/src/readii/__init__.py
--rw-r--r--   0        0        0        0 2024-03-27 14:18:14.682008 readii-1.2.1/src/readii/data/__init__.py
--rw-r--r--   0        0        0      299 2024-03-27 14:18:14.682008 readii-1.2.1/src/readii/data/default_pyradiomics.yaml
--rw-r--r--   0        0        0    14814 2024-03-27 14:18:14.682008 readii-1.2.1/src/readii/feature_extraction.py
--rw-r--r--   0        0        0    12234 2024-03-27 14:18:14.682008 readii-1.2.1/src/readii/image_processing.py
--rw-r--r--   0        0        0     4192 2024-03-27 14:18:14.682008 readii-1.2.1/src/readii/loaders.py
--rw-r--r--   0        0        0     5959 2024-03-27 14:18:14.682008 readii-1.2.1/src/readii/metadata.py
--rw-r--r--   0        0        0    21618 2024-03-27 14:18:14.682008 readii-1.2.1/src/readii/negative_controls.py
--rw-r--r--   0        0        0     6126 2024-03-27 14:18:14.682008 readii-1.2.1/src/readii/pipeline.py
--rw-r--r--   0        0        0     2828 1970-01-01 00:00:00.000000 readii-1.2.1/PKG-INFO
+-rwxr-xr-x   0        0        0     1069 2024-05-16 19:13:13.001227 readii-1.3.0/LICENSE
+-rw-r--r--   0        0        0     2053 2024-05-16 19:13:13.001227 readii-1.3.0/README.md
+-rw-r--r--   0        0        0     1381 2024-05-16 19:14:04.885192 readii-1.3.0/pyproject.toml
+-rw-r--r--   0        0        0      100 2024-05-16 19:13:55.605198 readii-1.3.0/src/readii/__init__.py
+-rw-r--r--   0        0        0        0 2024-05-16 19:13:13.005227 readii-1.3.0/src/readii/data/__init__.py
+-rw-r--r--   0        0        0      299 2024-05-16 19:13:13.005227 readii-1.3.0/src/readii/data/default_pyradiomics.yaml
+-rw-r--r--   0        0        0    14813 2024-05-16 19:13:13.005227 readii-1.3.0/src/readii/feature_extraction.py
+-rw-r--r--   0        0        0    12227 2024-05-16 19:13:13.005227 readii-1.3.0/src/readii/image_processing.py
+-rw-r--r--   0        0        0     4192 2024-05-16 19:13:13.005227 readii-1.3.0/src/readii/loaders.py
+-rw-r--r--   0        0        0     5959 2024-05-16 19:13:13.005227 readii-1.3.0/src/readii/metadata.py
+-rw-r--r--   0        0        0    24474 2024-05-16 19:13:13.005227 readii-1.3.0/src/readii/negative_controls.py
+-rw-r--r--   0        0        0     6126 2024-05-16 19:13:13.005227 readii-1.3.0/src/readii/pipeline.py
+-rw-r--r--   0        0        0     2828 1970-01-01 00:00:00.000000 readii-1.3.0/PKG-INFO
```

### Comparing `readii-1.2.1/LICENSE` & `readii-1.3.0/LICENSE`

 * *Files identical despite different names*

### Comparing `readii-1.2.1/README.md` & `readii-1.3.0/README.md`

 * *Files identical despite different names*

### Comparing `readii-1.2.1/pyproject.toml` & `readii-1.3.0/pyproject.toml`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "readii"
-version = "1.2.1"
+version = "1.3.0"
 description = "A package to extract radiomic features!"
 authors = ["Katy Scott"]
 license = "MIT"
 readme = "README.md"
 
 [tool.poetry.dependencies]
 python = ">=3.9,<4"
```

### Comparing `readii-1.2.1/src/readii/feature_extraction.py` & `readii-1.3.0/src/readii/feature_extraction.py`

 * *Files 1% similar despite different names*

```diff
@@ -33,15 +33,15 @@
     applyNegativeControl,
     shuffleImage, 
     makeRandomImage,
     makeRandomRoi,
     shuffleROI,
     makeRandomNonRoi,
     shuffleNonROI,
-    randomizeImageFromDistribtutionSampling,
+    randomizeImageFromDistributionSampling,
     makeRandomFromRoiDistribution,
     makeRandomNonRoiFromDistribution,
 )
 
 from typing import Optional, Any
 from collections import OrderedDict
```

### Comparing `readii-1.2.1/src/readii/image_processing.py` & `readii-1.3.0/src/readii/image_processing.py`

 * *Files 1% similar despite different names*

```diff
@@ -338,15 +338,15 @@
 
     # Check that CT and segmentation correspond, segmentationLabel is present, and dimensions match
     segBoundingBox, correctedROIImage = imageoperations.checkMask(
         ctImage, segImage, label=segmentationLabel
     )
     # Update the ROI image if a correction was generated by checkMask
     if correctedROIImage is not None:
-        alignedROIImage = correctedROIImage
+        segImage = correctedROIImage
 
     # Crop the image and mask to a bounding box around the mask to reduce volume size to process
     croppedCT, croppedROI = imageoperations.cropToTumorMask(
         ctImage, segImage, segBoundingBox
     )
 
     return croppedCT, croppedROI
```

### Comparing `readii-1.2.1/src/readii/loaders.py` & `readii-1.3.0/src/readii/loaders.py`

 * *Files identical despite different names*

### Comparing `readii-1.2.1/src/readii/metadata.py` & `readii-1.3.0/src/readii/metadata.py`

 * *Files identical despite different names*

### Comparing `readii-1.2.1/src/readii/negative_controls.py` & `readii-1.3.0/src/readii/negative_controls.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,40 +3,46 @@
 import random
 
 from readii.image_processing import alignImages, getROIVoxelLabel
 
 from typing import Optional
 
 def shuffleImage(
-    imageToShuffle: sitk.Image
+    imageToShuffle: sitk.Image,
+    randomSeed: Optional[int] = None,
 ) -> sitk.Image:
     
     """Function to shuffle all pixel values in a sitk Image (developed for 3D, should work on 2D as well)
 
     Parameters
     ----------
     imageToShuffle : sitk.Image
         Image to shuffle the pixels in
-
+    randomSeed : int
+        Value to initialize random number generator with for shuffling. Set for reproducible results.
+        
     Returns
     -------
     sitk.Image
         Image with all pixel values randomly shuffled with same dimensions as input image
     """
     # Convert the image to an array
     arrImage = sitk.GetArrayFromImage(imageToShuffle)
 
     # Get array dimensions to reshape back to
     imgDimensions = arrImage.shape
 
     # Flatten the 3D array to 1D so values can be shuffled
     flatArrImage = arrImage.flatten()
 
+    # Set the random seed for np random generator
+    randNumGen = np.random.default_rng(seed=randomSeed)
+
     # Shuffle the flat array
-    np.random.shuffle(
+    randNumGen.shuffle(
         flatArrImage,
     )
 
     # Reshape the array back into the original image dimensions
     shuffled3DArrImage = np.reshape(flatArrImage, imgDimensions)
 
     # Convert back to sitk Image
@@ -45,22 +51,25 @@
     # Set the origin/direction/spacing from original image to shuffled image
     alignedShuffledImage = alignImages(imageToShuffle, shuffledImage)
 
     return alignedShuffledImage
 
 
 def makeRandomImage(
-    baseImage: sitk.Image
+    baseImage: sitk.Image,
+    randomSeed: Optional[int] = None
 ) -> sitk.Image:
     """Function to generate random pixel values based on the range of values in a sitk Image (developed for 3D, should work on 2D as well)
 
     Parameters
     ----------
     baseImage : sitk.Image
         Image to randomly generate pixel values
+    randomSeed : int
+        Value to initialize random number generator with for shuffling. Set for reproducible results.
 
     Returns
     -------
     sitk.Image
         Image with all pixel values randomly generated with same dimensions as input image
     """
     # Convert the image to an array
@@ -72,17 +81,20 @@
     # Get min and max HU values to set as range for random values
     minVoxelVal = np.min(arrImage)
     maxVoxelVal = np.max(arrImage)
 
     # Delete arrImage to save memory
     del arrImage
 
-    # Generate random array with same dimensions as baseImage
-    random3DArrImage = np.random.randint(
-        low=minVoxelVal, high=maxVoxelVal, size=imgDimensions
+    # Set the random seed for np random generator
+    randNumGen = np.random.default_rng(seed=randomSeed)
+
+    # Generate random array with same dimensions as baseImage with values ranging from the minimum to maximum inclusive of the original image
+    random3DArrImage = randNumGen.integers(
+        low=minVoxelVal, high=maxVoxelVal, endpoint=True, size=imgDimensions
     )
 
     # Convert random array to a sitk Image
     randomImage = sitk.GetImageFromArray(random3DArrImage)
 
     # Set the origin/direction/spacing from the original image to the random image
     alignedRandomImage = alignImages(baseImage, randomImage)
@@ -90,26 +102,29 @@
     return alignedRandomImage
 
 
 def makeRandomRoi(
     baseImage: sitk.Image, 
     baseROI: sitk.Image, 
     roiLabel: Optional[int] = None,
+    randomSeed: Optional[int] = None
 ) -> sitk.Image:
     """Function to generate random pixel values within the Region of Interest based on the range of values in a sitk Image
 
     Parameters
     ----------
     baseImage : sitk.Image
         Image to randomly generate pixel values in Region of Interest
     baseROI : sitk.Image
         Image detailing Region of Interest
     roiLabel : int
         The label representing the ROI in baseROI
-
+    randomSeed : int
+        Value to initialize random number generator with for shuffling. Set for reproducible results.
+        
     Returns
     -------
     sitk.Image
         Image with all pixel values within the Region of Interest randomly generated with same dimensions as input image
     """
     # Check the ROI Label exists, if not extract it manually
     if not roiLabel:
@@ -133,44 +148,50 @@
                     minVoxelVal = min(minVoxelVal, current_value)
 
     # Create a new base image so we are not directly editing the input image
     new_base = baseImage.__copy__()
     # Delete the input image to save space
     del baseImage
 
+    # Set the random seed for np random generator
+    randNumGen = np.random.default_rng(seed=randomSeed)
+
     # Now iterate over the pixels of the ROI in the image and randomly generate a new value for them
     for x in range(baseROISize[0]):
         for y in range(baseROISize[1]):
             for z in range(baseROISize[2]):
                 if baseROI.GetPixel(x, y, z) == roiLabel:
                     # Randomly assigning the current value to the range [maxVoxelVal, maxVoxelVal]
-                    mapped_value = random.randint(minVoxelVal, maxVoxelVal)
+                    mapped_value = int(randNumGen.integers(low=minVoxelVal, high=maxVoxelVal, endpoint=True))
 
                     # Set the new pixel value
                     new_base.SetPixel(x, y, z, mapped_value)
 
     return new_base
 
 
 def shuffleROI(
     baseImage: sitk.Image, 
     baseROI: sitk.Image, 
     roiLabel: Optional[int] = None,
+    randomSeed: Optional[int] = None,
 ) -> sitk.Image:
     """Function to shuffle all pixel values within the Region of Interest in a sitk Image
 
     Parameters
     ----------
     baseImage : sitk.Image
         Image to shuffle the Region of Interest pixels in
     baseROI : sitk.Image
         Image detailing Region of Interest
     roiLabel : int
         The label representing the ROI in baseROI
-
+    randomSeed : int
+        Value to initialize random number generator with for shuffling. Set for reproducible results.
+        
     Returns
     -------
     sitk.Image
         Image with all pixel values in the Region of Interest randomly shuffled with same dimensions as input image
     """
     # Check the ROI Label exists, if not extract it manually
     if not roiLabel:
@@ -188,15 +209,17 @@
                     count.append(baseImage.GetPixel(x, y, z))
 
     # Create a new base image so we are not directly editing the input image
     new_base = baseImage.__copy__()
     # Delete the input image to save space
     del baseImage
 
-    # # Randomly shuffling the pixel values
+    # Initialize the random number generator
+    random.seed(randomSeed)
+    # Randomly shuffling the pixel values
     random.shuffle(count)
 
     for x in range(baseROISize[0]):
         for y in range(baseROISize[1]):
             for z in range(baseROISize[2]):
                 if baseROI.GetPixel(x, y, z) == roiLabel:
                     # Set the value of a pixel in the ROI to be a shuffled value
@@ -205,25 +228,28 @@
     return new_base
 
 
 def makeRandomNonRoi(
     baseImage: sitk.Image, 
     baseROI: sitk.Image,
     roiLabel: Optional[int] = None,
+    randomSeed: Optional[int] = None
 ) -> sitk.Image:
     """Function to generate random pixel values outside the Region of Interest based on the range of values in a sitk Image
 
     Parameters
     ----------
     baseImage : sitk.Image
         Image to randomly generate pixel values in outside the Region of Interest
     baseROI : sitk.Image
         Image detailing the Region of Interest
     roiLabel : int
         The label representing the ROI in baseROI
+    randomSeed : int
+        Value to initialize random number generator with for shuffling. Set for reproducible results.
 
     Returns
     -------
     sitk.Image
         Image with all pixel values outside the Region of Interest randomly generated with same dimensions as input image
     """
     # Check the ROI Label exists, if not extract it manually
@@ -254,49 +280,54 @@
                     minVoxelVal = min(minVoxelVal, current_value)
 
     # Create a new base image so we are not directly editing the input image
     new_base = baseImage.__copy__()
     # Delete the input image to save space
     del baseImage
 
+    # Set the random seed for np random number generator
+    randNumGen = np.random.default_rng(seed=randomSeed)
+
     # Now iterate over the pixels outside the ROI in the image and randomly generate a new value for them
     for x in range(baseImageSize[0]):
         for y in range(baseImageSize[1]):
             for z in range(baseImageSize[2]):
                 if (
                     x > baseROISize[0]
                     or y > baseROISize[1]
                     or z > baseROISize[2]
                     or baseROI.GetPixel(x, y, z) != roiLabel
                 ):
                     # Randomly assigning the current value to the range [maxVoxelVal, maxVoxelVal]
-                    mapped_value = random.randint(minVoxelVal, maxVoxelVal)
+                    mapped_value = int(randNumGen.integers(low=minVoxelVal, high=maxVoxelVal, endpoint=True))
 
                     # Set the new pixel value
                     new_base.SetPixel(x, y, z, mapped_value)
 
     return new_base
 
 
 def shuffleNonROI(
     baseImage: sitk.Image, 
     baseROI: sitk.Image,
     roiLabel: Optional[int] = None,
+    randomSeed: Optional[int] = None,
 ) -> sitk.Image:
     """Function to shuffle all pixel values that are not within the Region of Interest in a sitk Image
 
     Parameters
     ----------
     baseImage : sitk.Image
         Image to shuffle the pixels outside the Region of Interest in
     baseROI : sitk.Image
         Image detailing Region of Interest
     roiLabel : int
         The label representing the ROI in baseROI
-
+    randomSeed : int
+        Value to initialize random number generator with for shuffling. Set for reproducible results.
     Returns
     -------
     sitk.Image
         Image with all pixel values outside the Region of Interest randomly shuffled with same dimensions as input image
     """
     # Check the ROI Label exists, if not extract it manually
     if not roiLabel:
@@ -320,14 +351,16 @@
                     count.append(baseImage.GetPixel(x, y, z))
 
     # Create a new base image so we are not directly editing the input image
     new_base = baseImage.__copy__()
     # Delete the input image to save space
     del baseImage
 
+    # Initialize the random number generator
+    random.seed(randomSeed)
     # Randomly shuffling the pixel values
     random.shuffle(count)
 
     for x in range(baseImageSize[0]):
         for y in range(baseImageSize[1]):
             for z in range(baseImageSize[2]):
                 if (
@@ -338,40 +371,45 @@
                 ):
                     # Set the value of a pixel outside the ROI to be a shuffled value
                     new_base.SetPixel(x, y, z, count.pop())
 
     return new_base
 
 
-def randomizeImageFromDistribtutionSampling(
-    imageToRandomize: sitk.Image
+def randomizeImageFromDistributionSampling(
+    imageToRandomize: sitk.Image,
+    randomSeed: Optional[int] = None
 ) -> sitk.Image:
     """Function to randomly sample all the pixel values in a sitk Image, from the distribution of existing values
 
     Parameters
     ----------
     imageToRandomize : sitk.Image
         Image to randomly sample the pixels in
-
+    randomSeed : int
+        Value to initialize random number generator with for shuffling. Set for reproducible results.
     Returns
     -------
     sitk.Image
         Image with all pixel values randomly sampled from the initial dstribution of the image, with same dimensions as input image
     """
     # Convert the image to an array
     arrImage = sitk.GetArrayFromImage(imageToRandomize)
 
     # Get array dimensions to reshape back to
     imgDimensions = arrImage.shape
 
     # Flatten the 3D array to 1D so values can be shuffled
     flatArrImage = arrImage.flatten()
 
+    # Set the random seed for np random number generator
+    randNumGen = np.random.default_rng(seed=randomSeed)
+
     # Randomly sample values for new array from original image distribution
-    sampled_array = np.random.choice(flatArrImage, size=len(flatArrImage), replace=True)
+    sampled_array = randNumGen.choice(flatArrImage, size=len(flatArrImage), replace=True)
 
     # Reshape the array back into the original image dimensions
     randomlySampled3DArrImage = np.reshape(sampled_array, imgDimensions)
 
     # Convert back to sitk Image
     randomlySampledImage = sitk.GetImageFromArray(randomlySampled3DArrImage)
 
@@ -381,26 +419,29 @@
     return alignedRandomlySampledImage
 
 
 def makeRandomFromRoiDistribution(
     baseImage: sitk.Image, 
     baseROI: sitk.Image, 
     roiLabel: Optional[int] = None,
+    randomSeed: Optional[int] = None
 ) -> sitk.Image:
     """Function to randomly sample pixel values within the Region of Interest uniformly from the distribution of pixel values in the ROI region sitk Image
 
     Parameters
     ----------
     baseImage : sitk.Image
         Image to randomly generate pixel values in Region of Interest
     baseROI : sitk.Image
         Image detailing Region of Interest
     roiLabel : int
         The label representing the ROI in baseROI
-
+    randomSeed : int
+        Value to initialize random number generator with for shuffling. Set for reproducible results.
+        
     Returns
     -------
     sitk.Image
         Image with all pixel values within the Region of Interest randomly sampled with same dimensions as input image
     """
     # Check the ROI Label exists, if not extract it manually
     if not roiLabel:
@@ -420,43 +461,49 @@
                     distributionROI.append(baseImage.GetPixel(x, y, z))
 
     # Create a new base image so we are not directly editing the input image
     new_base = baseImage.__copy__()
     # Delete the input image to save space
     del (baseImage)
 
+    # Set the random seed for np random number generator
+    randNumGen = np.random.default_rng(seed=randomSeed)
+
     # Now iterate over the pixels of the ROI in the image and randomly generate a new value for them
     for x in range(baseROISize[0]):
         for y in range(baseROISize[1]):
             for z in range(baseROISize[2]):
                 if baseROI.GetPixel(x, y, z) == roiLabel:
                     # Assigning the current value to the randomly sampled value from within the ROI
-                    mapped_value = random.choice(distributionROI)
+                    mapped_value = int(randNumGen.choice(distributionROI))
 
                     # Set the new pixel value
                     new_base.SetPixel(x, y, z, mapped_value)
 
     return new_base
 
 
 def makeRandomNonRoiFromDistribution(
     baseImage: sitk.Image, 
     baseROI: sitk.Image, 
     roiLabel: Optional[int] = None, 
+    randomSeed: Optional[int] = None
 ) -> sitk.Image:
     """Function to random sample pixel values outside the Region of Interest uniformly from the distribution of pixel values outside the ROI in a sitk Image
 
     Parameters
     ----------
     baseImage : sitk.Image
         Image to randomly generate pixel values in outside the Region of Interest
     baseROI : sitk.Image
         Image detailing the Region of Interest
     roiLabel : int
         The label representing the ROI in baseROI
+    randomSeed : int
+        Value to initialize random number generator with for shuffling. Set for reproducible results.
 
     Returns
     -------
     sitk.Image
         Image with all pixel values outside the Region of Interest randomly sample form outside the ROI with same dimensions as input image
     """
     # Check the ROI Label exists, if not extract it manually
@@ -483,90 +530,96 @@
                     distributionROI.append(baseImage.GetPixel(x, y, z))
 
     # Create a new base image so we are not directly editing the input image
     new_base = baseImage.__copy__()
     # Delete the input image to save space
     del baseImage
 
+    # Set the random seed for np random number generator
+    randNumGen = np.random.default_rng(seed=randomSeed)
+
     # Now iterate over the pixels outside the ROI in the image and randomly generate a new value for them
     for x in range(baseImageSize[0]):
         for y in range(baseImageSize[1]):
             for z in range(baseImageSize[2]):
                 if (
                     x > baseROISize[0]
                     or y > baseROISize[1]
                     or z > baseROISize[2]
                     or baseROI.GetPixel(x, y, z) != roiLabel
                 ):
                     # Assigning the current value to the randomly sampled value from within the ROI
-                    mapped_value = random.choice(distributionROI)
+                    mapped_value = int(randNumGen.choice(distributionROI))
 
                     # Set the new pixel value
                     new_base.SetPixel(x, y, z, mapped_value)
 
     return new_base
 
 
 def applyNegativeControl(
     nc_type: str,
     baseImage: sitk.Image,
     baseROI: Optional[sitk.Image] = None,
     roiLabel: Optional[int] = None,
+    randomSeed: Optional[int] = None
 ) -> sitk.Image:
     """Function to generate random pixel values within the Region of Interest based on the range of values in a sitk Image
 
     Parameters
     ----------
     nc_type : str
         The type of negative control to be applied
     baseImage : sitk.Image
         The image to be modified
     baseROI : sitk.Image
         Image detailing Region of Interest
     roiLabel : int
         The label representing the ROI in baseROI
-
+    randomSeed : int
+        Value to initialize random number generator with for shuffling. Set for reproducible results.
+        
     Returns
     -------
     sitk.Image
         The output image with the negative control applied
         
     Raises
     ------
     ValueError
         If the nc_type is not a valid negative control type
     """
     
     if nc_type == "randomized_full":
         # Make negative control version of ctImage (randomized pixel size)
-        return makeRandomImage(baseImage)
+        return makeRandomImage(baseImage, randomSeed)
     elif nc_type == "shuffled_full":
         # Make negative control version of ctImage (random shuffled pixels, same size)
-        return shuffleImage(baseImage)
+        return shuffleImage(baseImage, randomSeed)
     elif nc_type == "randomized_sampled_full":
         # Make negative control version of ctImage (random sampled pixels from original distribution, same size)
-        return randomizeImageFromDistribtutionSampling(baseImage)
+        return randomizeImageFromDistributionSampling(baseImage, randomSeed)
     
     # typesafety check here to ensure baseROI is not None for the following negative control types
     assert baseROI is not None, \
         f"baseROI must be provided for {nc_type} negative control type"
     
     if nc_type == "randomized_roi":
         # Make negative control version of ctImage (randomized pixel size inside the ROI)
-        return makeRandomRoi(baseImage, baseROI, roiLabel)
+        return makeRandomRoi(baseImage, baseROI, roiLabel, randomSeed)
     elif nc_type == "shuffled_roi":
         # Make negative control version of ctImage (random shuffled pixels inside the ROI, same size)
-        return shuffleROI(baseImage, baseROI, roiLabel)
+        return shuffleROI(baseImage, baseROI, roiLabel, randomSeed)
     elif nc_type == "randomized_non_roi":
         # Make negative control version of ctImage (randomized pixel size outside the ROI)
-        return makeRandomNonRoi(baseImage, baseROI, roiLabel)
+        return makeRandomNonRoi(baseImage, baseROI, roiLabel, randomSeed)
     elif nc_type == "shuffled_non_roi":
         # Make negative control version of ctImage (shuffled pixels outside the ROI, same size)
-        return shuffleNonROI(baseImage, baseROI, roiLabel)
+        return shuffleNonROI(baseImage, baseROI, roiLabel, randomSeed)
     elif nc_type == "randomized_sampled_roi":
         # Make negative control version of ctImage (random sampled pixels from original distribution inside ROI, same size)
-        return makeRandomFromRoiDistribution(baseImage, baseROI, roiLabel)
+        return makeRandomFromRoiDistribution(baseImage, baseROI, roiLabel, randomSeed)
     elif nc_type == "randomized_sampled_non_roi":
         # Make negative control version of ctImage (random sampled pixels from original distribution outside ROI, same size)
-        return makeRandomNonRoiFromDistribution(baseImage, baseROI, roiLabel)
+        return makeRandomNonRoiFromDistribution(baseImage, baseROI, roiLabel, randomSeed)
     else:
         raise ValueError("Invalid nc_type. Please choose a valid negative control type.")
```

### Comparing `readii-1.2.1/src/readii/pipeline.py` & `readii-1.3.0/src/readii/pipeline.py`

 * *Files identical despite different names*

### Comparing `readii-1.2.1/PKG-INFO` & `readii-1.3.0/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: readii
-Version: 1.2.1
+Version: 1.3.0
 Summary: A package to extract radiomic features!
 License: MIT
 Author: Katy Scott
 Requires-Python: >=3.9,<4
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.9
```

