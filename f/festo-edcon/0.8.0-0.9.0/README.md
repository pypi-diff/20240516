# Comparing `tmp/festo_edcon-0.8.0-py3-none-any.whl.zip` & `tmp/festo_edcon-0.9.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,36 +1,33 @@
-Zip file size: 31809 bytes, number of entries: 34
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-31 13:41 boollist/__init__.py
--rw-r--r--  2.0 unx     1086 b- defN 23-Mar-31 13:41 boollist/boollist.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-31 13:41 edcon_tools/__init__.py
--rw-r--r--  2.0 unx     1741 b- defN 23-Mar-31 13:41 edcon_tools/generic_bus_argparser.py
--rw-r--r--  2.0 unx     4187 b- defN 23-Mar-31 13:41 edcon_tools/pnu.py
--rw-r--r--  2.0 unx     1784 b- defN 23-Mar-31 13:41 edcon_tools/position.py
--rw-r--r--  2.0 unx     2675 b- defN 23-Mar-31 13:41 edcon_tools/test_tg1.py
--rw-r--r--  2.0 unx     2981 b- defN 23-Mar-31 13:41 edcon_tools/test_tg102.py
--rw-r--r--  2.0 unx     3786 b- defN 23-Mar-31 13:41 edcon_tools/test_tg111.py
--rw-r--r--  2.0 unx     3657 b- defN 23-Mar-31 13:41 edcon_tools/test_tg9.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-31 13:41 edrive/__init__.py
--rw-r--r--  2.0 unx     3447 b- defN 23-Mar-31 13:41 edrive/edrive_base.py
--rw-r--r--  2.0 unx     6455 b- defN 23-Mar-31 13:41 edrive/edrive_ethernetip.py
--rw-r--r--  2.0 unx     1140 b- defN 23-Mar-31 13:41 edrive/edrive_logging.py
--rw-r--r--  2.0 unx     6312 b- defN 23-Mar-31 13:41 edrive/edrive_modbus.py
--rw-r--r--  2.0 unx    25508 b- defN 23-Mar-31 13:41 edrive/edrive_motion.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-31 13:41 edrive/modbus_flavours/__init__.py
--rw-r--r--  2.0 unx      856 b- defN 23-Mar-31 13:41 edrive/modbus_flavours/flavour_base.py
--rw-r--r--  2.0 unx     4904 b- defN 23-Mar-31 13:41 edrive/modbus_flavours/flavour_cmmt_as.py
--rw-r--r--  2.0 unx     1057 b- defN 23-Mar-31 13:41 edrive/modbus_flavours/flavour_cpx_ap.py
--rw-r--r--  2.0 unx      453 b- defN 23-Mar-31 13:41 edrive/modbus_flavours/modbus_flavours.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-31 13:41 profidrive/__init__.py
--rw-r--r--  2.0 unx      906 b- defN 23-Mar-31 13:41 profidrive/telegram1.py
--rw-r--r--  2.0 unx     1822 b- defN 23-Mar-31 13:41 profidrive/telegram102.py
--rw-r--r--  2.0 unx     2677 b- defN 23-Mar-31 13:41 profidrive/telegram111.py
--rw-r--r--  2.0 unx     1934 b- defN 23-Mar-31 13:41 profidrive/telegram9.py
--rw-r--r--  2.0 unx     1163 b- defN 23-Mar-31 13:41 profidrive/telegram_base.py
--rw-r--r--  2.0 unx    17259 b- defN 23-Mar-31 13:41 profidrive/words.py
--rw-rw-rw-  2.0 unx     1074 b- defN 23-Mar-31 13:41 festo_edcon-0.8.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     2107 b- defN 23-Mar-31 13:41 festo_edcon-0.8.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Mar-31 13:41 festo_edcon-0.8.0.dist-info/WHEEL
--rw-r--r--  2.0 unx      310 b- defN 23-Mar-31 13:41 festo_edcon-0.8.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       39 b- defN 23-Mar-31 13:41 festo_edcon-0.8.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2816 b- defN 23-Mar-31 13:41 festo_edcon-0.8.0.dist-info/RECORD
-34 files, 104228 bytes uncompressed, 27297 bytes compressed:  73.8%
+Zip file size: 65741 bytes, number of entries: 31
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-05 15:50 boollist/__init__.py
+-rw-r--r--  2.0 unx     1086 b- defN 23-Apr-05 15:50 boollist/boollist.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-05 15:50 edcon_tools/__init__.py
+-rw-r--r--  2.0 unx     1614 b- defN 23-Apr-05 15:50 edcon_tools/generic_bus_argparser.py
+-rw-r--r--  2.0 unx     1939 b- defN 23-Apr-05 15:50 edcon_tools/pnu.py
+-rw-r--r--  2.0 unx     1749 b- defN 23-Apr-05 15:50 edcon_tools/position.py
+-rw-r--r--  2.0 unx     2653 b- defN 23-Apr-05 15:50 edcon_tools/test_tg1.py
+-rw-r--r--  2.0 unx     2959 b- defN 23-Apr-05 15:50 edcon_tools/test_tg102.py
+-rw-r--r--  2.0 unx     3764 b- defN 23-Apr-05 15:50 edcon_tools/test_tg111.py
+-rw-r--r--  2.0 unx     3635 b- defN 23-Apr-05 15:50 edcon_tools/test_tg9.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-05 15:50 edrive/__init__.py
+-rw-r--r--  2.0 unx     3105 b- defN 23-Apr-05 15:50 edrive/edrive_base.py
+-rw-r--r--  2.0 unx     6455 b- defN 23-Apr-05 15:50 edrive/edrive_ethernetip.py
+-rw-r--r--  2.0 unx     1140 b- defN 23-Apr-05 15:50 edrive/edrive_logging.py
+-rw-r--r--  2.0 unx     9203 b- defN 23-Apr-05 15:50 edrive/edrive_modbus.py
+-rw-r--r--  2.0 unx    25718 b- defN 23-Apr-05 15:50 edrive/edrive_motion.py
+-rw-r--r--  2.0 unx     4525 b- defN 23-Apr-05 15:50 edrive/edrive_pnu_packing.py
+-rw-rw-rw-  2.0 unx   150174 b- defN 23-Apr-05 15:50 edrive/data/pnu_type_map.csv
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-05 15:50 profidrive/__init__.py
+-rw-r--r--  2.0 unx      906 b- defN 23-Apr-05 15:50 profidrive/telegram1.py
+-rw-r--r--  2.0 unx     1822 b- defN 23-Apr-05 15:50 profidrive/telegram102.py
+-rw-r--r--  2.0 unx     2677 b- defN 23-Apr-05 15:50 profidrive/telegram111.py
+-rw-r--r--  2.0 unx     1934 b- defN 23-Apr-05 15:50 profidrive/telegram9.py
+-rw-r--r--  2.0 unx     1163 b- defN 23-Apr-05 15:50 profidrive/telegram_base.py
+-rw-r--r--  2.0 unx    17259 b- defN 23-Apr-05 15:50 profidrive/words.py
+-rw-rw-rw-  2.0 unx     1074 b- defN 23-Apr-05 15:50 festo_edcon-0.9.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3537 b- defN 23-Apr-05 15:50 festo_edcon-0.9.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-05 15:50 festo_edcon-0.9.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx      310 b- defN 23-Apr-05 15:50 festo_edcon-0.9.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       39 b- defN 23-Apr-05 15:50 festo_edcon-0.9.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2514 b- defN 23-Apr-05 15:50 festo_edcon-0.9.0.dist-info/RECORD
+31 files, 253046 bytes uncompressed, 61733 bytes compressed:  75.6%
```

## zipnote {}

```diff
@@ -42,27 +42,18 @@
 
 Filename: edrive/edrive_modbus.py
 Comment: 
 
 Filename: edrive/edrive_motion.py
 Comment: 
 
-Filename: edrive/modbus_flavours/__init__.py
+Filename: edrive/edrive_pnu_packing.py
 Comment: 
 
-Filename: edrive/modbus_flavours/flavour_base.py
-Comment: 
-
-Filename: edrive/modbus_flavours/flavour_cmmt_as.py
-Comment: 
-
-Filename: edrive/modbus_flavours/flavour_cpx_ap.py
-Comment: 
-
-Filename: edrive/modbus_flavours/modbus_flavours.py
+Filename: edrive/data/pnu_type_map.csv
 Comment: 
 
 Filename: profidrive/__init__.py
 Comment: 
 
 Filename: profidrive/telegram1.py
 Comment: 
@@ -78,26 +69,26 @@
 
 Filename: profidrive/telegram_base.py
 Comment: 
 
 Filename: profidrive/words.py
 Comment: 
 
-Filename: festo_edcon-0.8.0.dist-info/LICENSE
+Filename: festo_edcon-0.9.0.dist-info/LICENSE
 Comment: 
 
-Filename: festo_edcon-0.8.0.dist-info/METADATA
+Filename: festo_edcon-0.9.0.dist-info/METADATA
 Comment: 
 
-Filename: festo_edcon-0.8.0.dist-info/WHEEL
+Filename: festo_edcon-0.9.0.dist-info/WHEEL
 Comment: 
 
-Filename: festo_edcon-0.8.0.dist-info/entry_points.txt
+Filename: festo_edcon-0.9.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: festo_edcon-0.8.0.dist-info/top_level.txt
+Filename: festo_edcon-0.9.0.dist-info/top_level.txt
 Comment: 
 
-Filename: festo_edcon-0.8.0.dist-info/RECORD
+Filename: festo_edcon-0.9.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## edcon_tools/generic_bus_argparser.py

```diff
@@ -29,16 +29,14 @@
             "ethernetip", add_help=False,
             description='Use EtherNet/IP communication',
             parents=[self.common])
         modbus_parser = subparsers.add_parser(
             "modbus", add_help=False,
             description='Use Modbus communication',
             parents=[self.common])
-        modbus_parser.add_argument(
-            "--flavour", choices=['CMMT-AS', 'CPX-AP'], default='CMMT-AS', required=False)
 
         args = parser.parse_args()
 
         if args.verbose:
             EDriveLogging(logging.INFO)
         else:
             EDriveLogging(logging.WARNING)
```

## edcon_tools/pnu.py

```diff
@@ -1,11 +1,12 @@
 """CLI Tool to read or write PNUs of a EDrive device."""
 from edcon_tools.generic_bus_argparser import GenericBusArgParser
 from edrive.edrive_modbus import EDriveModbus
 from edrive.edrive_ethernetip import EDriveEthernetip
+from collections import namedtuple
 
 
 def main():
     """Parses command line arguments and reads PNU accordingly."""
     gparser = GenericBusArgParser('Access PNU on an EDrive device.')
     gparser.add_argument("-p", "--pnu", default=3490,
                          help="PNU to use for read/write")
@@ -14,86 +15,40 @@
 
     subparsers = gparser.add_subparsers(dest='subcommand', required=True,
                                         title='action commands',
                                         description="Action to perform on the PNU")
 
     # Options for reading PNU
     parser_read = subparsers.add_parser('read')
-    group_dtype = parser_read.add_mutually_exclusive_group(required=True)
-    group_dtype.add_argument('-b', action='store_true',
-                             help='read bool data')
-    group_dtype.add_argument('-u8', action='store_true',
-                             help='read uint8 data')
-    group_dtype.add_argument('-i8', action='store_true',
-                             help='read int8 data')
-    group_dtype.add_argument('-i16', action='store_true',
-                             help='read int16 data')
-    group_dtype.add_argument('-i32', action='store_true',
-                             help='read int32 data')
-    group_dtype.add_argument('-i64', action='store_true',
-                             help='read int64 data')
-    group_dtype.add_argument('-f', action='store_true',
-                             help='read float data')
-    group_dtype.add_argument('-r', help='length of raw data to read')
+    parser_read.add_argument(
+        '-r', '--raw', help='Raw read of provided number of items')
 
     # Options for writing PNU
     parser_write = subparsers.add_parser('write')
-    group_dtype = parser_write.add_mutually_exclusive_group(required=True)
-    group_dtype.add_argument('-b', help='bool data to write')
-    group_dtype.add_argument('-u8', help='uint8 data to write')
-    group_dtype.add_argument('-i8', help='int8 data to write')
-    group_dtype.add_argument('-i16', help='int16 data to write')
-    group_dtype.add_argument('-i32', help='int32 data to write')
-    group_dtype.add_argument('-i64', help='int64 data to write')
-    group_dtype.add_argument('-f', help='float data to write')
+    parser_write.add_argument('value', help='Value to be written')
 
     args = gparser.create()
 
     # Initialize driver
     if args.com_type == 'modbus':
-        edrive = EDriveModbus(args.ip_address, flavour=args.flavour)
+        edrive = EDriveModbus(args.ip_address)
     elif args.com_type == 'ethernetip':
         edrive = EDriveEthernetip(args.ip_address)
 
     pnu = int(args.pnu)
     subindex = int(args.subindex)
     if args.subcommand == 'read':
-        if args.b:
-            value = edrive.read_pnu(pnu, subindex, '?')
-        if args.u8:
-            value = edrive.read_pnu(pnu, subindex, 'B')
-        if args.i8:
-            value = edrive.read_pnu(pnu, subindex, 'b')
-        if args.i16:
-            value = edrive.read_pnu(pnu, subindex, 'h')
-        if args.i32:
-            value = edrive.read_pnu(pnu, subindex, 'i')
-        if args.i64:
-            value = edrive.read_pnu(pnu, subindex, 'q')
-        elif args.f:
-            value = edrive.read_pnu(pnu, subindex, 'f')
-        elif args.r:
-            value = edrive.read_pnu_raw(
-                pnu, subindex, num_elements=int(args.r))
+        if args.raw:
+            pnu_value = edrive.read_pnu_raw(
+                pnu, subindex, num_elements=int(args.raw))
             if value:
                 print(f"Length: {len(value)}")
-        print(f"Value: {value}")
+        else:
+            pnu_value = edrive.read_pnu(pnu, subindex)
+        print(f"Value: {pnu_value}")
 
     elif args.subcommand == 'write':
-        if args.b:
-            edrive.write_pnu(pnu, subindex, int(args.b), '?')
-        if args.u8:
-            edrive.write_pnu(pnu, subindex, int(args.u8), 'B')
-        if args.i8:
-            edrive.write_pnu(pnu, subindex, int(args.i8), 'b')
-        if args.i16:
-            edrive.write_pnu(pnu, subindex, int(args.i16), 'h')
-        if args.i32:
-            edrive.write_pnu(pnu, subindex, int(args.i32), 'i')
-        if args.i64:
-            edrive.write_pnu(pnu, subindex, int(args.i64), 'q')
-        elif args.f:
-            edrive.write_pnu(pnu, subindex, float(args.f), 'f')
+        edrive.write_pnu(pnu, subindex, args.value)
 
 
 if __name__ == "__main__":
     main()
```

## edcon_tools/position.py

```diff
@@ -19,16 +19,15 @@
     gparser.add_argument('-r', '--reference', action='store_true',
                          help='Perform a referencing task before positioning task')
 
     args = gparser.create()
 
     # Initialize driver
     if args.com_type == 'modbus':
-        edrive = EDriveModbus(
-            args.ip_address, flavour=args.flavour)
+        edrive = EDriveModbus(args.ip_address)
     elif args.com_type == 'ethernetip':
         edrive = EDriveEthernetip(args.ip_address)
 
     try:
         with EDriveMotion(edrive) as mot:
             if not mot.acknowledge_faults():
                 sys.exit(1)
```

## edcon_tools/test_tg1.py

```diff
@@ -24,15 +24,15 @@
             return round(int(args.speed_setpoint) * math.sin(time.time()))
     else:
         def get_setpoint():
             return int(args.speed_setpoint)
 
     # Initialize driver
     if args.com_type == 'modbus':
-        edrive = EDriveModbus(args.ip_address, flavour=args.flavour)
+        edrive = EDriveModbus(args.ip_address)
     elif args.com_type == 'ethernetip':
         edrive = EDriveEthernetip(args.ip_address)
 
     edrive.assert_selected_telegram(1)
 
     # Start process data
     edrive.start_io()
```

## edcon_tools/test_tg102.py

```diff
@@ -26,15 +26,15 @@
             return round(int(args.speed_setpoint) * math.sin(time.time()))
     else:
         def get_setpoint():
             return int(args.speed_setpoint)
 
     # Initialize driver
     if args.com_type == 'modbus':
-        edrive = EDriveModbus(args.ip_address, flavour=args.flavour)
+        edrive = EDriveModbus(args.ip_address)
     elif args.com_type == 'ethernetip':
         edrive = EDriveEthernetip(args.ip_address)
 
     edrive.assert_selected_telegram(102)
 
     # Start process data
     edrive.start_io()
```

## edcon_tools/test_tg111.py

```diff
@@ -12,15 +12,15 @@
     """Parses command line arguments and run the example."""
     gparser = GenericBusArgParser('Control EDrive device using telegram 111.')
 
     args = gparser.create()
 
     # Initialize driver
     if args.com_type == 'modbus':
-        edrive = EDriveModbus(args.ip_address, flavour=args.flavour)
+        edrive = EDriveModbus(args.ip_address)
     elif args.com_type == 'ethernetip':
         edrive = EDriveEthernetip(args.ip_address)
 
     edrive.assert_selected_telegram(111)
     # Start process data
     edrive.start_io()
```

## edcon_tools/test_tg9.py

```diff
@@ -11,15 +11,15 @@
 def main():
     """Parses command line arguments and run the example."""
     gparser = GenericBusArgParser('Control EDrive device using telegram 9.')
     args = gparser.create()
 
     # Initialize driver
     if args.com_type == 'modbus':
-        edrive = EDriveModbus(args.ip_address, flavour=args.flavour)
+        edrive = EDriveModbus(args.ip_address)
     elif args.com_type == 'ethernetip':
         edrive = EDriveEthernetip(args.ip_address)
 
     edrive.assert_selected_telegram(9)
     # Start process data
     edrive.start_io()
```

## edrive/edrive_base.py

```diff
@@ -1,10 +1,10 @@
 """Contains EDriveBase class which contains common code for EDrive communication drivers."""
 import logging
-import struct
+from edrive.edrive_pnu_packing import pnu_pack, pnu_unpack
 
 
 class EDriveBase:
     """Class that contains common functions for EDrive communication drivers."""
 
     def assert_selected_telegram(self, telegram_id: int):
         """Asserts that the selected telegram is actually configured on the EDrive"""
@@ -21,44 +21,35 @@
             f"Correct telegram selected: {configured_telegram_id}")
         return True
 
     def read_pnu_raw(self, pnu: int, subindex: int = 0, num_elements: int = 1) -> bytes:
         """Reads a PNU from the EDrive without interpreting the data"""
         raise NotImplementedError
 
-    def read_pnu(self, pnu: int, subindex: int = 0, format_char='h'):
+    def read_pnu(self, pnu: int, subindex: int = 0, forced_format=None):
         """Reads a PNU from the EDrive"""
         raw = self.read_pnu_raw(pnu, subindex)
         if raw:
-            if format_char == 's':
-                param = struct.unpack(f"{len(raw)}s", raw)[0]
-            elif format_char == '?':
-                param = struct.unpack('b', raw[0:1])[0]
-            elif format_char == 'B':
-                param = struct.unpack('B', raw[0:1])[0]
-            elif format_char == 'b':
-                param = struct.unpack('b', raw[0:1])[0]
-            else:
-                param = struct.unpack(format_char, raw)[0]
+            param = pnu_unpack(pnu, raw, forced_format)
             logging.info(
                 f"Read PNU {pnu} (subindex: {subindex}): {param} "
                 f"(raw: {raw})")
             return param
 
         logging.error(f"PNU {pnu} read failed")
         return None
 
     def write_pnu_raw(self, pnu: int, subindex: int = 0, num_elements: int = 1,
                       value: bytes = b'\x00') -> bool:
         """Writes raw bytes to a PNU on the EDrive"""
         raise NotImplementedError
 
-    def write_pnu(self, pnu: int, subindex: int = 0, value=0, format_char='h') -> bool:
+    def write_pnu(self, pnu: int, subindex: int = 0, value=0, forced_format=None) -> bool:
         """Writes a value to a PNU to the EDrive"""
-        raw = struct.pack(format_char, value)
+        raw = pnu_pack(pnu, value, forced_format)
         if self.write_pnu_raw(pnu, subindex, value=raw):
             logging.info(
                 f"Written PNU {pnu} (subindex: {subindex}): {value} "
                 f"(raw: {raw})")
             return True
         logging.error(f"PNU {pnu} write failed")
         return False
```

## edrive/edrive_modbus.py

```diff
@@ -5,16 +5,34 @@
 https://pymodbus.readthedocs.io/en/latest/index.html
 """
 import threading
 import logging
 import time
 
 from pymodbus.client.sync import ModbusTcpClient as ModbusClient
+from pymodbus.mei_message import ReadDeviceInformationRequest
 from edrive.edrive_base import EDriveBase
-from edrive.modbus_flavours.modbus_flavours import modbus_flavours
+
+REG_OUTPUT_DATA = 0
+REG_INPUT_DATA = 100
+REG_TIMEOUT = 400
+
+IO_DATA_SIZE = 56
+
+REG_PNU_MAILBOX_PNU = 500
+REG_PNU_MAILBOX_SUBINDEX = 501
+REG_PNU_MAILBOX_NUM_ELEMENTS = 502
+REG_PNU_MAILBOX_EXEC = 503
+REG_PNU_MAILBOX_DATA_LEN = 504
+REG_PNU_MAILBOX_DATA = 510
+
+PNU_MAILBOX_EXEC_READ = 0x01
+PNU_MAILBOX_EXEC_WRITE = 0x02
+PNU_MAILBOX_EXEC_ERROR = 0x03
+PNU_MAILBOX_EXEC_DONE = 0x10
 
 
 class IOThread(threading.Thread):
     """Class to handle I/O transfers in a separate thread."""
 
     def __init__(self, perform_io=None, cycle_time: int = 10):
         """Constructor of the IOThread class.
@@ -51,100 +69,164 @@
         """Stops the thread."""
         self.active = False
 
 
 class EDriveModbus(EDriveBase):
     """Class to configure and communicate with EDrive devices via Modbus."""
 
-    def __init__(self, ip_address, cycle_time: int = 10, timeout_ms: int = 1000, flavour="CMMT-AS"):
+    def __init__(self, ip_address, cycle_time: int = 10, timeout_ms: int = 1000):
         """Constructor of the EDriveModbus class.
 
         Parameters:
             ip_address (str): Required IP address as string e.g. ('192.168.0.1')
             cycle_time (int): Cycle time (in ms) that should be used for I/O transfers
             timeout_ms (int): Modbus timeout (in ms) that should be configured on the slave
-            flavour (str/dict/FlavourBase): May either be one of the built-in flavours as ``str``,
-                a custom flavour as ``dict`` or ``FlavourBase`` deduced object.
-                See :mod:`ModbusFlavours <edrive.modbus_flavours.modbus_flavours>`
-                for built-in flavours
         """
         self.io_thread = IOThread(self.perform_io, cycle_time)
 
         logging.info(f"Starting Modbus connection on {ip_address}")
-        self.client = ModbusClient(ip_address)
-        self.client.connect()
-
-        if isinstance(flavour, str):
-            flavour = modbus_flavours()[flavour]
-            self.flavour = flavour(self.client)
-            self.device_info = self.flavour.device_info()
-
-        elif isinstance(flavour, dict):
-            self.device_info = flavour
+        self.modbus_client = ModbusClient(ip_address)
+        self.modbus_client.connect()
 
-        else:
-            self.flavour = flavour(self.client)
+        self.device_info = self.read_device_info()
 
-        self.in_data = b'\x00' * self.device_info["pd_size"]
-        self.out_data = b'\x00' * self.device_info["pd_size"]
+        self.in_data = b'\x00' * IO_DATA_SIZE
+        self.out_data = b'\x00' * IO_DATA_SIZE
 
         self.set_timeout(timeout_ms)
 
     def __del__(self):
         if hasattr(self, "client"):
-            self.client.close()
+            self.modbus_client.close()
+
+    def read_device_info(self) -> dict:
+        """Reads device info from the CMMT and returns dict with containing values
+
+        Returns:
+            dict: Contains device information values 
+        """
+        dev_info = {}
+
+        # Read device information
+        rreq = ReadDeviceInformationRequest(0x1, 0)
+        rres = self.modbus_client.execute(rreq)
+        dev_info["vendor_name"] = rres.information[0].decode('ascii')
+        dev_info["product_code"] = rres.information[1].decode('ascii')
+        dev_info["revision"] = rres.information[2].decode('ascii')
+
+        rreq = ReadDeviceInformationRequest(0x2, 0)
+        rres = self.modbus_client.execute(rreq)
+        dev_info["vendor_url"] = rres.information[3].decode('ascii')
+        dev_info["product_name"] = rres.information[4].decode('ascii')
+        dev_info["model_name"] = rres.information[5].decode('ascii')
+
+        for key, value in dev_info.items():
+            logging.info(f"{key.replace('_',' ').title()}: {value}")
+
+        return dev_info
 
     def set_timeout(self, timeout_ms) -> bool:
         """Sets the modbus timeout to the provided value"""
         logging.info(f"Setting modbus timeout to {timeout_ms} ms")
-        self.client.write_registers(
-            self.device_info["timeout_addr"], [timeout_ms, 0])
+        self.modbus_client.write_registers(REG_TIMEOUT, [timeout_ms, 0])
         # Check if it actually succeeded
-        indata = self.client.read_holding_registers(
-            self.device_info["timeout_addr"], 1)
+        indata = self.modbus_client.read_holding_registers(REG_TIMEOUT, 1)
         if indata.registers[0] != timeout_ms:
             logging.error("Setting of modbus timeout was not successful")
             return False
         return True
 
     def perform_io(self):
         """Reads input data from and writes output data to according modbus registers."""
         # Inputs, convert to bytes
-        indata = self.client.read_holding_registers(
-            self.device_info["pd_in_addr"], int(self.device_info["pd_size"]/2))
-        #
+        indata = self.modbus_client.read_holding_registers(
+            REG_INPUT_DATA, int(IO_DATA_SIZE/2))
         self.in_data = b''.join(reg.to_bytes(2, 'little')
                                 for reg in indata.registers)
 
         # Outputs, convert to list of modbus words
         word_list = [int.from_bytes(self.out_data[i:i+2], 'little')
                      for i in range(0, len(self.out_data), 2)]
-        self.client.write_registers(self.device_info[
-            "pd_out_addr"], word_list)
+        self.modbus_client.write_registers(REG_OUTPUT_DATA, word_list)
 
     def read_pnu_raw(self, pnu: int, subindex: int = 0, num_elements: int = 1) -> bytes:
         """Reads a PNU from the EDrive without interpreting the data"""
-        if hasattr(self, 'flavour'):
-            return self.flavour.read_pnu(pnu, subindex, num_elements)
-        return None
+        try:
+            self.modbus_client.write_register(REG_PNU_MAILBOX_PNU, pnu)
+            self.modbus_client.write_register(
+                REG_PNU_MAILBOX_SUBINDEX, subindex)
+            self.modbus_client.write_register(
+                REG_PNU_MAILBOX_NUM_ELEMENTS, num_elements)
+
+            # Execute
+            self.modbus_client.write_register(
+                REG_PNU_MAILBOX_EXEC, PNU_MAILBOX_EXEC_READ)
+            status = self.modbus_client.read_holding_registers(
+                REG_PNU_MAILBOX_EXEC, 1).registers[0]
+
+            if status != PNU_MAILBOX_EXEC_DONE:
+                logging.error(f"Error reading PNU {pnu}, status: {status}")
+                return None
+
+            # Read available data length
+            length = self.modbus_client.read_holding_registers(
+                REG_PNU_MAILBOX_DATA_LEN, 1).registers[0]
+
+            # Divide length by 2 because each register is 2 bytes
+            indata = self.modbus_client.read_holding_registers(
+                510, int((length+1)/2))
+
+            # Convert to integer
+            data = b''.join(reg.to_bytes(2, 'little')
+                            for reg in indata.registers)
+            return data
+
+        except AttributeError:
+            logging.error("Could not access PNU register")
+            return None
 
     def write_pnu_raw(self, pnu: int, subindex: int = 0, num_elements: int = 1,
                       value: bytes = b'\x00') -> bool:
         """Writes raw bytes to a PNU on the EDrive"""
-        if hasattr(self, 'flavour'):
-            return self.flavour.write_pnu(pnu, subindex, num_elements, value)
-        return False
+        try:
+            self.modbus_client.write_register(REG_PNU_MAILBOX_PNU, pnu)
+            self.modbus_client.write_register(
+                REG_PNU_MAILBOX_SUBINDEX, subindex)
+            self.modbus_client.write_register(
+                REG_PNU_MAILBOX_NUM_ELEMENTS, num_elements)
+            self.modbus_client.write_register(
+                REG_PNU_MAILBOX_DATA_LEN, len(value))
+
+            # Convert to list of words
+            word_list = [int.from_bytes(value[i:i+2], 'little')
+                         for i in range(0, len(value), 2)]
+            # Write data
+            self.modbus_client.write_registers(510, word_list)
+
+            # Execute
+            self.modbus_client.write_register(
+                REG_PNU_MAILBOX_EXEC, PNU_MAILBOX_EXEC_WRITE)
+            status = self.modbus_client.read_holding_registers(
+                REG_PNU_MAILBOX_EXEC, 1).registers[0]
+            if status != PNU_MAILBOX_EXEC_DONE:
+                logging.error(f"Error writing PNU {pnu}, status: {status}")
+                return False
+            return True
+
+        except AttributeError:
+            logging.error("Could not access PNU register")
+            return False
 
     def start_io(self):
         """Starts i/o data process"""
         self.io_thread.start()
 
     def stop_io(self):
         """Stops i/o data process"""
-        self.send_io(b'\x00' * self.device_info["pd_size"])
+        self.send_io(b'\x00' * IO_DATA_SIZE)
         self.io_thread.stop()
 
     def send_io(self, data: bytes, nonblocking: bool = False):
         """Sends data to the output
 
         Parameters:
             nonblocking (bool): If True, function returns immediately.
```

## edrive/edrive_motion.py

```diff
@@ -283,14 +283,15 @@
                            info_string: Callable[[], str] = None) -> bool:
         """Waits for provided condition to be satisfied
 
         Parameter:
             condition (Callable): boolean condition function
             timeout (float): Time that should be waited for condition to be satisfied (in seconds)
             info_string (Callable): optional callback for string to print during wait process
+
         Returns:
             bool: True if succesful, False otherwise
         """
         start_time = time.time()
         while timeout == 0.0 or not time.time() - start_time > timeout:
             self.update_inputs()
             if condition and condition():
@@ -306,14 +307,15 @@
 
     def wait_for_duration(self, duration: float, info_string: Callable[[], str] = None) -> bool:
         """Waits for provided duration
 
         Parameter:
             duration (float): time that should be waited for
             info_string (Callable): optional callback for string to print during wait process
+
         Returns:
             bool: True if succesful, False otherwise
         """
         start_time = time.time()
         while duration == 0.0 or not time.time() - start_time > duration:
             self.update_inputs()
             if self.tg111.zsw1.fault_present:
@@ -429,14 +431,15 @@
         logging.info("Finished record change")
 
     def acknowledge_faults(self, timeout: float = 5.0) -> bool:
         """Send telegram to request the control of the EDrive
 
         Parameter:
             timeout (float): time that should be waited for acknowledgement
+
         Returns:
             bool: True if succesful, False otherwise
         """
         logging.info("Acknowledge any present faults")
 
         def toggle_func(value):
             self.tg111.stw1.fault_ack = value
@@ -455,20 +458,21 @@
         return True
 
     def enable_powerstage(self, timeout: float = 1.0) -> bool:
         """Send telegram to enable the power stage
 
         Parameter:
             timeout (float): time that should be waited for enabling
+
         Returns:
             bool: True if succesful, False otherwise
         """
         if not self.plc_control_granted():
             return False
-        logging.info("Enable Powerstage")
+        logging.info("Enable powerstage")
 
         # Toggle to low (in case it is already True)
         def toggle_func(value):
             self.tg111.stw1.on = value
 
         self.pulse_bit(toggle_func, active_high=False)
 
@@ -478,14 +482,20 @@
         if not self.wait_for_condition(cond, timeout):
             logging.error("Operation inhibited")
             return False
 
         logging.info("[bold green]    -> success!", extra={"markup": True})
         return True
 
+    def disable_powerstage(self) -> bool:
+        """Send telegram to disable the power stage"""
+        logging.info("Disable powerstage")
+        self.tg111.stw1.on = False
+        self.update_outputs()
+
     def stop_motion_task(self):
         """Stops any currently active motion task"""
         logging.info("Stopping motion")
         # Reset activate_traversing_task bit to prepare for next time
         self.tg111.stw1.activate_traversing_task = False
 
         # Reset jog bits (in case jogging motion was performed)
```

## Comparing `festo_edcon-0.8.0.dist-info/LICENSE` & `festo_edcon-0.9.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `festo_edcon-0.8.0.dist-info/RECORD` & `festo_edcon-0.9.0.dist-info/RECORD`

 * *Files 22% similar despite different names*

```diff
@@ -1,34 +1,31 @@
 boollist/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 boollist/boollist.py,sha256=wfl_WRNMFDuCyjfghMRFir2fPaE6ReAtc3BQyQ_uOZg,1086
 edcon_tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-edcon_tools/generic_bus_argparser.py,sha256=JF7dxB8-N72FdiQqHPt_Br7MArFPAFAFIAMRHuYNPRQ,1741
-edcon_tools/pnu.py,sha256=WLvsQwd6GytHLFenWz6dXhrkrGuy09nBIaOOCcBLDmk,4187
-edcon_tools/position.py,sha256=qWdnBDSpgsiHcDT_YPiPiQJbUg3LIskP17NFKX1Poxw,1784
-edcon_tools/test_tg1.py,sha256=tFwSGQXmt7g9BzZG16VRJfWBSU1Etl0WuFwqkjgJcNw,2675
-edcon_tools/test_tg102.py,sha256=VUcbcjX_R8dpu1x-nzJGwcNcPT7N-OaRHSTTAEQvrw4,2981
-edcon_tools/test_tg111.py,sha256=XE_ZbMIeGyuFcbmCTEFVHOg7U8_dvcYJ9-oC8vt_pl0,3786
-edcon_tools/test_tg9.py,sha256=QP46h6npPURwRwVxcNaKUIO5c2rVW3Ezma06-SIMzqQ,3657
+edcon_tools/generic_bus_argparser.py,sha256=DAf7KN0-vo1tuH_uyRirEA1Aeja1aTynzBm1dV8_Kz8,1614
+edcon_tools/pnu.py,sha256=no_meFi-FUpxHNwhVRJTRJTQSXbGJKHYKdcQcXxtEuM,1939
+edcon_tools/position.py,sha256=NToEowHU7aib0tk_X0dXU0HG4IGP6WrpQeUSrIm_yEk,1749
+edcon_tools/test_tg1.py,sha256=OfGX_pxhy-zxR_wtdi00rMFnLuH9YY05K4w1zYqF-7E,2653
+edcon_tools/test_tg102.py,sha256=gsJ-xL-XoUnEuFdh2x42JH_UbX45u-fT7P1_DsQ5nFM,2959
+edcon_tools/test_tg111.py,sha256=kJzGEl26RbgL_YgO_8a3atUqKUiAV3MoUZJ-HPtMNpg,3764
+edcon_tools/test_tg9.py,sha256=QzdiSpm6kktoZ8HGnyhoo8BiaBy6mEHoQK9ZokKwJSg,3635
 edrive/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-edrive/edrive_base.py,sha256=_kPVDuAbNyjA9690K__psi1iUuuiuyUnSDlbda8_vbQ,3447
+edrive/edrive_base.py,sha256=Lk7VPRzXlFrZVgNhZemLX9H6F_sXvp8i8CBwKpDwbVY,3105
 edrive/edrive_ethernetip.py,sha256=PQZlUUsmNUkL9KC3iH9yOSAAA6RXYBQ2jggJXrQjSm4,6455
 edrive/edrive_logging.py,sha256=P29y2utf3r16NLvVr99ZqRPiRvQ__mw461Grb0zBjhs,1140
-edrive/edrive_modbus.py,sha256=D8HZUreQENUKPqn1Dtx9aQb8ZUACXXkVKaH6A81Vb3o,6312
-edrive/edrive_motion.py,sha256=zuS363fSGOEPcNaTNa86Rij5QIJpnGvVdt48vhT-yAs,25508
-edrive/modbus_flavours/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-edrive/modbus_flavours/flavour_base.py,sha256=6lWcH14aa32DXMStkabZJMppe5OvYB9sMJpukPfVYCs,856
-edrive/modbus_flavours/flavour_cmmt_as.py,sha256=KaJr_YKzcGmBXquA5pwlODT-UTsCIeSdq5sl1UsIwnk,4904
-edrive/modbus_flavours/flavour_cpx_ap.py,sha256=tZokywXrWW9f7IYn_aOXglhO56ZAUmsrjCxm9uiHIXM,1057
-edrive/modbus_flavours/modbus_flavours.py,sha256=ycqyOgfHS7hfYDJVWMRysSu6o8khQijkbVJnXMTTeew,453
+edrive/edrive_modbus.py,sha256=P-CWCAeWhvmZTpKE7L6nMtZNzUCbTEqkP5Od3DB_90A,9203
+edrive/edrive_motion.py,sha256=jRLyIVvOF1IzsLIDXNUT7kYXHfU_5Ys-HF9pcIQpqeY,25718
+edrive/edrive_pnu_packing.py,sha256=ba5nl90FnpyH0KR5NETKYHucN1iTt53d6hb4tvPh1-M,4525
+edrive/data/pnu_type_map.csv,sha256=xHY3_Bi2GARDwdv8exJTjNqGwWQ19ouoUBO7NzcWtPY,150174
 profidrive/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 profidrive/telegram1.py,sha256=_epu3EKMI8hOozPmgWao9SDsjKuF1OZ4MsRl9zlo6Us,906
 profidrive/telegram102.py,sha256=BqwW7UHS9YzbrOM-TchjMAyRWp1_ykdmYi33oPMMyO4,1822
 profidrive/telegram111.py,sha256=ZNg0YSgyHgmzRi4sz_iex0V3SzRM50C26NWHkis2ChM,2677
 profidrive/telegram9.py,sha256=Bb0UD89S8v5IRUHI_uhgbTSELX-3jpzG0BetT6rISbo,1934
 profidrive/telegram_base.py,sha256=ToJr00dOLPSqxu_q-bu4PyCTMarhR8wXV-h7gkKLZfg,1163
 profidrive/words.py,sha256=b9p3laKrhQuQO1EQgb-TC8nrunWJpfWXGIr-S6-j8BI,17259
-festo_edcon-0.8.0.dist-info/LICENSE,sha256=UzPepLbqzfErrSZ0r_C83CSagmFHsP9HaXrSAZt1ZoY,1074
-festo_edcon-0.8.0.dist-info/METADATA,sha256=cXMLucLF3N4Q2Y3ZrymsLEfBTzDmQLRSqVniaw1nVzA,2107
-festo_edcon-0.8.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-festo_edcon-0.8.0.dist-info/entry_points.txt,sha256=DxdO4lQcP_0KPdOeVVQ0cvOt9__yx0vGx5hREJNsPXA,310
-festo_edcon-0.8.0.dist-info/top_level.txt,sha256=-FWdpV_T2xlPTCUV8hF_72QZ1w-UUhXY5bJ7wxcgSHQ,39
-festo_edcon-0.8.0.dist-info/RECORD,,
+festo_edcon-0.9.0.dist-info/LICENSE,sha256=UzPepLbqzfErrSZ0r_C83CSagmFHsP9HaXrSAZt1ZoY,1074
+festo_edcon-0.9.0.dist-info/METADATA,sha256=JgthSjHdA0J21a_AEgPhV5xu_CaMN6BL17V3_2xHF_E,3537
+festo_edcon-0.9.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+festo_edcon-0.9.0.dist-info/entry_points.txt,sha256=DxdO4lQcP_0KPdOeVVQ0cvOt9__yx0vGx5hREJNsPXA,310
+festo_edcon-0.9.0.dist-info/top_level.txt,sha256=-FWdpV_T2xlPTCUV8hF_72QZ1w-UUhXY5bJ7wxcgSHQ,39
+festo_edcon-0.9.0.dist-info/RECORD,,
```

