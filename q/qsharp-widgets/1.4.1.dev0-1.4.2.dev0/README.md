# Comparing `tmp/qsharp_widgets-1.4.1.dev0-py2.py3-none-any.whl.zip` & `tmp/qsharp_widgets-1.4.2.dev0-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,8 +1,8 @@
-Zip file size: 150269 bytes, number of entries: 6
+Zip file size: 167928 bytes, number of entries: 6
 -rw-r--r--  2.0 unx     7449 b- defN 20-Feb-02 00:00 qsharp_widgets/__init__.py
 -rw-r--r--  2.0 unx    12078 b- defN 20-Feb-02 00:00 qsharp_widgets/static/index.css
--rw-r--r--  2.0 unx   485817 b- defN 20-Feb-02 00:00 qsharp_widgets/static/index.js
-?rw-r--r--  2.0 unx      192 b- defN 20-Feb-02 00:00 qsharp_widgets-1.4.1.dev0.dist-info/METADATA
-?rw-r--r--  2.0 unx      105 b- defN 20-Feb-02 00:00 qsharp_widgets-1.4.1.dev0.dist-info/WHEEL
-?rw-r--r--  2.0 unx      503 b- defN 20-Feb-02 00:00 qsharp_widgets-1.4.1.dev0.dist-info/RECORD
-6 files, 506144 bytes uncompressed, 149363 bytes compressed:  70.5%
+-rw-r--r--  2.0 unx   527531 b- defN 20-Feb-02 00:00 qsharp_widgets/static/index.js
+?rw-r--r--  2.0 unx      192 b- defN 20-Feb-02 00:00 qsharp_widgets-1.4.2.dev0.dist-info/METADATA
+?rw-r--r--  2.0 unx      105 b- defN 20-Feb-02 00:00 qsharp_widgets-1.4.2.dev0.dist-info/WHEEL
+?rw-r--r--  2.0 unx      503 b- defN 20-Feb-02 00:00 qsharp_widgets-1.4.2.dev0.dist-info/RECORD
+6 files, 547858 bytes uncompressed, 167022 bytes compressed:  69.5%
```

## zipnote {}

```diff
@@ -3,17 +3,17 @@
 
 Filename: qsharp_widgets/static/index.css
 Comment: 
 
 Filename: qsharp_widgets/static/index.js
 Comment: 
 
-Filename: qsharp_widgets-1.4.1.dev0.dist-info/METADATA
+Filename: qsharp_widgets-1.4.2.dev0.dist-info/METADATA
 Comment: 
 
-Filename: qsharp_widgets-1.4.1.dev0.dist-info/WHEEL
+Filename: qsharp_widgets-1.4.2.dev0.dist-info/WHEEL
 Comment: 
 
-Filename: qsharp_widgets-1.4.1.dev0.dist-info/RECORD
+Filename: qsharp_widgets-1.4.2.dev0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qsharp_widgets/static/index.js

### js-beautify {}

```diff
@@ -1,1031 +1,1037 @@
-var ih = Object.create;
-var oa = Object.defineProperty;
-var oh = Object.getOwnPropertyDescriptor;
-var ah = Object.getOwnPropertyNames;
-var sh = Object.getPrototypeOf,
-    lh = Object.prototype.hasOwnProperty;
-var W = (r, e) => () => (e || r((e = {
-    exports: {}
-}).exports, e), e.exports);
-var ch = (r, e, i, a) => {
-    if (e && typeof e == "object" || typeof e == "function")
-        for (let l of ah(e)) !lh.call(r, l) && l !== i && oa(r, l, {
-            get: () => e[l],
-            enumerable: !(a = oh(e, l)) || a.enumerable
-        });
-    return r
-};
-var En = (r, e, i) => (i = r != null ? ih(sh(r)) : {}, ch(e || !r || !r.__esModule ? oa(i, "default", {
-    value: r,
+var Xc = Object.create;
+var Yn = Object.defineProperty;
+var Qc = Object.getOwnPropertyDescriptor;
+var Jc = Object.getOwnPropertyNames;
+var Kc = Object.getPrototypeOf,
+    e1 = Object.prototype.hasOwnProperty;
+var rt = (e, r) => () => (r || e((r = {
+        exports: {}
+    }).exports, r), r.exports),
+    wr = (e, r) => {
+        for (var i in r) Yn(e, i, {
+            get: r[i],
+            enumerable: !0
+        })
+    },
+    t1 = (e, r, i, o) => {
+        if (r && typeof r == "object" || typeof r == "function")
+            for (let s of Jc(r)) !e1.call(e, s) && s !== i && Yn(e, s, {
+                get: () => r[s],
+                enumerable: !(o = Qc(r, s)) || o.enumerable
+            });
+        return e
+    };
+var ea = (e, r, i) => (i = e != null ? Xc(Kc(e)) : {}, t1(r || !e || !e.__esModule ? Yn(i, "default", {
+    value: e,
     enumerable: !0
-}) : i, r));
-var Vn = W(Dr => {
+}) : i, e));
+var su = rt(G0 => {
     "use strict";
-    Object.defineProperty(Dr, "__esModule", {
+    Object.defineProperty(G0, "__esModule", {
         value: !0
     });
-    Dr.RegisterType = void 0;
-    var Lh;
-    (function(r) {
-        r[r.Qubit = 0] = "Qubit", r[r.Classical = 1] = "Classical"
-    })(Lh = Dr.RegisterType || (Dr.RegisterType = {}))
+    G0.RegisterType = void 0;
+    var E1;
+    (function(e) {
+        e[e.Qubit = 0] = "Qubit", e[e.Classical = 1] = "Classical"
+    })(E1 = G0.RegisterType || (G0.RegisterType = {}))
 });
-var Wt = W(me => {
+var Jt = rt(le => {
     "use strict";
-    Object.defineProperty(me, "__esModule", {
+    Object.defineProperty(le, "__esModule", {
         value: !0
     });
-    me.regLineStart = me.argsFontSize = me.labelFontSize = me.controlBtnRadius = me.controlBtnOffset = me.nestedGroupPadding = me.groupBoxPadding = me.classicalRegHeight = me.registerHeight = me.labelPadding = me.gatePadding = me.gateHeight = me.minGateWidth = me.startY = me.startX = me.leftPadding = me.svgNS = void 0;
-    me.svgNS = "http://www.w3.org/2000/svg";
-    me.leftPadding = 20;
-    me.startX = 80;
-    me.startY = 40;
-    me.minGateWidth = 40;
-    me.gateHeight = 40;
-    me.gatePadding = 10;
-    me.labelPadding = 10;
-    me.registerHeight = me.gateHeight + me.gatePadding * 2;
-    me.classicalRegHeight = me.gateHeight;
-    me.groupBoxPadding = me.gatePadding;
-    me.nestedGroupPadding = 2;
-    me.controlBtnOffset = 40;
-    me.controlBtnRadius = 15;
-    me.labelFontSize = 14;
-    me.argsFontSize = 12;
-    me.regLineStart = 40
+    le.regLineStart = le.argsFontSize = le.labelFontSize = le.controlBtnRadius = le.controlBtnOffset = le.nestedGroupPadding = le.groupBoxPadding = le.classicalRegHeight = le.registerHeight = le.labelPadding = le.gatePadding = le.gateHeight = le.minGateWidth = le.startY = le.startX = le.leftPadding = le.svgNS = void 0;
+    le.svgNS = "http://www.w3.org/2000/svg";
+    le.leftPadding = 20;
+    le.startX = 80;
+    le.startY = 40;
+    le.minGateWidth = 40;
+    le.gateHeight = 40;
+    le.gatePadding = 10;
+    le.labelPadding = 10;
+    le.registerHeight = le.gateHeight + le.gatePadding * 2;
+    le.classicalRegHeight = le.gateHeight;
+    le.groupBoxPadding = le.gatePadding;
+    le.nestedGroupPadding = 2;
+    le.controlBtnOffset = 40;
+    le.controlBtnRadius = 15;
+    le.labelFontSize = 14;
+    le.argsFontSize = 12;
+    le.regLineStart = 40
 });
-var x0 = W(_e => {
+var zr = rt(we => {
     "use strict";
-    Object.defineProperty(_e, "__esModule", {
+    Object.defineProperty(we, "__esModule", {
         value: !0
     });
-    _e.dashedBox = _e.dashedLine = _e.arc = _e.text = _e.box = _e.controlDot = _e.circle = _e.line = _e.group = _e.createSvgElement = void 0;
-    var Ha = Wt(),
-        Ph = function(r, e) {
-            e === void 0 && (e = {});
-            var i = document.createElementNS(Ha.svgNS, r);
-            return Object.entries(e).forEach(function(a) {
-                var l = a[0],
-                    c = a[1];
-                return i.setAttribute(l, c)
+    we.dashedBox = we.dashedLine = we.arc = we.text = we.box = we.controlDot = we.circle = we.line = we.group = we.createSvgElement = void 0;
+    var Na = Jt(),
+        M1 = function(e, r) {
+            r === void 0 && (r = {});
+            var i = document.createElementNS(Na.svgNS, e);
+            return Object.entries(r).forEach(function(o) {
+                var s = o[0],
+                    l = o[1];
+                return i.setAttribute(s, l)
             }), i
         };
-    _e.createSvgElement = Ph;
-    var Ih = function(r, e) {
-        e === void 0 && (e = {});
-        var i = (0, _e.createSvgElement)("g", e);
-        return r.forEach(function(a) {
-            return i.appendChild(a)
+    we.createSvgElement = M1;
+    var q1 = function(e, r) {
+        r === void 0 && (r = {});
+        var i = (0, we.createSvgElement)("g", r);
+        return e.forEach(function(o) {
+            return i.appendChild(o)
         }), i
     };
-    _e.group = Ih;
-    var Oh = function(r, e, i, a, l) {
-        var c = {
-            x1: r.toString(),
+    we.group = q1;
+    var F1 = function(e, r, i, o, s) {
+        var l = {
+            x1: e.toString(),
             x2: i.toString(),
-            y1: e.toString(),
-            y2: a.toString()
+            y1: r.toString(),
+            y2: o.toString()
         };
-        return l != null && (c.class = l), (0, _e.createSvgElement)("line", c)
+        return s != null && (l.class = s), (0, we.createSvgElement)("line", l)
     };
-    _e.line = Oh;
-    var Hh = function(r, e, i, a) {
-        var l = {
-            cx: r.toString(),
-            cy: e.toString(),
+    we.line = F1;
+    var z1 = function(e, r, i, o) {
+        var s = {
+            cx: e.toString(),
+            cy: r.toString(),
             r: i.toString()
         };
-        return a != null && (l.class = a), (0, _e.createSvgElement)("circle", l)
+        return o != null && (s.class = o), (0, we.createSvgElement)("circle", s)
     };
-    _e.circle = Hh;
-    var $h = function(r, e, i) {
-        return i === void 0 && (i = 5), (0, _e.circle)(r, e, i, "control-dot")
-    };
-    _e.controlDot = $h;
-    var Gh = function(r, e, i, a, l) {
-        return l === void 0 && (l = "gate-unitary"), (0, _e.createSvgElement)("rect", {
-            class: l,
-            x: r.toString(),
-            y: e.toString(),
+    we.circle = z1;
+    var R1 = function(e, r, i) {
+        return i === void 0 && (i = 5), (0, we.circle)(e, r, i, "control-dot")
+    };
+    we.controlDot = R1;
+    var B1 = function(e, r, i, o, s) {
+        return s === void 0 && (s = "gate-unitary"), (0, we.createSvgElement)("rect", {
+            class: s,
+            x: e.toString(),
+            y: r.toString(),
             width: i.toString(),
-            height: a.toString()
+            height: o.toString()
         })
     };
-    _e.box = Gh;
-    var Vh = function(r, e, i, a) {
-        a === void 0 && (a = Ha.labelFontSize);
-        var l = (0, _e.createSvgElement)("text", {
-            "font-size": a.toString(),
-            x: e.toString(),
+    we.box = B1;
+    var N1 = function(e, r, i, o) {
+        o === void 0 && (o = Na.labelFontSize);
+        var s = (0, we.createSvgElement)("text", {
+            "font-size": o.toString(),
+            x: r.toString(),
             y: i.toString()
         });
-        return l.textContent = r, l
+        return s.textContent = e, s
     };
-    _e.text = Vh;
-    var jh = function(r, e, i, a) {
-        return (0, _e.createSvgElement)("path", {
+    we.text = N1;
+    var L1 = function(e, r, i, o) {
+        return (0, we.createSvgElement)("path", {
             class: "arc-measure",
-            d: "M ".concat(r + 2 * i, " ").concat(e, " A ").concat(i, " ").concat(a, " 0 0 0 ").concat(r, " ").concat(e)
+            d: "M ".concat(e + 2 * i, " ").concat(r, " A ").concat(i, " ").concat(o, " 0 0 0 ").concat(e, " ").concat(r)
         })
     };
-    _e.arc = jh;
-    var Uh = function(r, e, i, a, l) {
-        var c = (0, _e.line)(r, e, i, a, l);
-        return c.setAttribute("stroke-dasharray", "8, 8"), c
-    };
-    _e.dashedLine = Uh;
-    var Wh = function(r, e, i, a, l) {
-        var c = (0, _e.box)(r, e, i, a, l);
-        return c.setAttribute("fill-opacity", "0"), c.setAttribute("stroke-dasharray", "8, 8"), c
+    we.arc = L1;
+    var P1 = function(e, r, i, o, s) {
+        var l = (0, we.line)(e, r, i, o, s);
+        return l.setAttribute("stroke-dasharray", "8, 8"), l
+    };
+    we.dashedLine = P1;
+    var I1 = function(e, r, i, o, s) {
+        var l = (0, we.box)(e, r, i, o, s);
+        return l.setAttribute("fill-opacity", "0"), l.setAttribute("stroke-dasharray", "8, 8"), l
     };
-    _e.dashedBox = Wh
+    we.dashedBox = I1
 });
-var ja = W(ur => {
+var Oa = rt(v0 => {
     "use strict";
-    Object.defineProperty(ur, "__esModule", {
+    Object.defineProperty(v0, "__esModule", {
         value: !0
     });
-    ur._qubitInput = ur.formatInputs = void 0;
-    var $a = Vn(),
-        zr = Wt(),
-        Ga = x0(),
-        Yh = function(r) {
-            var e = [],
+    v0._qubitInput = v0.formatInputs = void 0;
+    var La = su(),
+        V0 = Jt(),
+        Pa = zr(),
+        O1 = function(e) {
+            var r = [],
                 i = {},
-                a = zr.startY;
-            return r.forEach(function(l) {
-                var c = l.id,
-                    d = l.numChildren;
-                if (e.push(Va(a)), i[c] = {
-                        type: $a.RegisterType.Qubit,
-                        y: a
-                    }, d == null || d === 0) {
-                    a += zr.registerHeight;
+                o = V0.startY;
+            return e.forEach(function(s) {
+                var l = s.id,
+                    h = s.numChildren;
+                if (r.push(Ia(o)), i[l] = {
+                        type: La.RegisterType.Qubit,
+                        y: o
+                    }, h == null || h === 0) {
+                    o += V0.registerHeight;
                     return
                 }
-                a += zr.classicalRegHeight, i[c].children = Array.from(Array(d), function() {
-                    var f = {
-                        type: $a.RegisterType.Classical,
-                        y: a
+                o += V0.classicalRegHeight, i[l].children = Array.from(Array(h), function() {
+                    var p = {
+                        type: La.RegisterType.Classical,
+                        y: o
                     };
-                    return a += zr.classicalRegHeight, f
+                    return o += V0.classicalRegHeight, p
                 })
             }), {
-                qubitWires: (0, Ga.group)(e),
+                qubitWires: (0, Pa.group)(r),
                 registers: i,
-                svgHeight: a
+                svgHeight: o
             }
         };
-    ur.formatInputs = Yh;
-    var Va = function(r) {
-        var e = (0, Ga.text)("|0\u27E9", zr.leftPadding, r, 16);
-        return e.setAttribute("text-anchor", "start"), e.setAttribute("dominant-baseline", "middle"), e
+    v0.formatInputs = O1;
+    var Ia = function(e) {
+        var r = (0, Pa.text)("|0\u27E9", V0.leftPadding, e, 16);
+        return r.setAttribute("text-anchor", "start"), r.setAttribute("dominant-baseline", "middle"), r
     };
-    ur._qubitInput = Va
+    v0._qubitInput = Ia
 });
-var hr = W(Rr => {
+var w0 = rt(U0 => {
     "use strict";
-    Object.defineProperty(Rr, "__esModule", {
+    Object.defineProperty(U0, "__esModule", {
         value: !0
     });
-    Rr.GateType = void 0;
-    var Zh;
-    (function(r) {
-        r[r.Measure = 0] = "Measure", r[r.Cnot = 1] = "Cnot", r[r.Swap = 2] = "Swap", r[r.X = 3] = "X", r[r.Unitary = 4] = "Unitary", r[r.ControlledUnitary = 5] = "ControlledUnitary", r[r.ClassicalControlled = 6] = "ClassicalControlled", r[r.Group = 7] = "Group", r[r.Invalid = 8] = "Invalid"
-    })(Zh = Rr.GateType || (Rr.GateType = {}))
+    U0.GateType = void 0;
+    var H1;
+    (function(e) {
+        e[e.Measure = 0] = "Measure", e[e.Cnot = 1] = "Cnot", e[e.Swap = 2] = "Swap", e[e.X = 3] = "X", e[e.Unitary = 4] = "Unitary", e[e.ControlledUnitary = 5] = "ControlledUnitary", e[e.ClassicalControlled = 6] = "ClassicalControlled", e[e.Group = 7] = "Group", e[e.Invalid = 8] = "Invalid"
+    })(H1 = U0.GateType || (U0.GateType = {}))
 });
-var es = W(Le => {
+var Za = rt(Re => {
     "use strict";
-    var Nt = Le && Le.__spreadArray || function(r, e, i) {
+    var Pt = Re && Re.__spreadArray || function(e, r, i) {
         if (i || arguments.length === 2)
-            for (var a = 0, l = e.length, c; a < l; a++)(c || !(a in e)) && (c || (c = Array.prototype.slice.call(e, 0, a)), c[a] = e[a]);
-        return r.concat(c || Array.prototype.slice.call(e))
+            for (var o = 0, s = r.length, l; o < s; o++)(l || !(o in r)) && (l || (l = Array.prototype.slice.call(r, 0, o)), l[o] = r[o]);
+        return e.concat(l || Array.prototype.slice.call(r))
     };
-    Object.defineProperty(Le, "__esModule", {
+    Object.defineProperty(Re, "__esModule", {
         value: !0
     });
-    Le._classicalControlled = Le._groupedOperations = Le._controlledGate = Le._swap = Le._unitary = Le._measure = Le._zoomButton = Le._createGate = Le._formatGate = Le.formatGates = void 0;
-    var gt = hr(),
-        Re = Wt(),
-        be = x0(),
-        v0 = function(r, e) {
-            e === void 0 && (e = 0);
-            var i = r.map(function(a) {
-                return Ua(a, e)
+    Re._classicalControlled = Re._groupedOperations = Re._controlledGate = Re._swap = Re._unitary = Re._measure = Re._zoomButton = Re._createGate = Re._formatGate = Re.formatGates = void 0;
+    var gt = w0(),
+        De = Jt(),
+        he = zr(),
+        Rr = function(e, r) {
+            r === void 0 && (r = 0);
+            var i = e.map(function(o) {
+                return Ha(o, r)
             });
-            return (0, be.group)(i)
+            return (0, he.group)(i)
         };
-    Le.formatGates = v0;
-    var Ua = function(r, e) {
-        e === void 0 && (e = 0);
-        var i = r.type,
-            a = r.x,
-            l = r.controlsY,
-            c = r.targetsY,
-            d = r.label,
-            f = r.displayArgs,
-            g = r.width;
+    Re.formatGates = Rr;
+    var Ha = function(e, r) {
+        r === void 0 && (r = 0);
+        var i = e.type,
+            o = e.x,
+            s = e.controlsY,
+            l = e.targetsY,
+            h = e.label,
+            p = e.displayArgs,
+            b = e.width;
         switch (i) {
             case gt.GateType.Measure:
-                return nr([Ya(a, l[0])], r, e);
+                return c0([Ga(o, s[0])], e, r);
             case gt.GateType.Unitary:
-                return nr([Wn(d, a, c, g, f)], r, e);
+                return c0([du(h, o, l, b, p)], e, r);
             case gt.GateType.X:
-                return nr([Xh(r, e)], r, e);
+                return c0([G1(e, r)], e, r);
             case gt.GateType.Swap:
-                return l.length > 0 ? jn(r, e) : nr([Za(r, e)], r, e);
+                return s.length > 0 ? lu(e, r) : c0([Va(e, r)], e, r);
             case gt.GateType.Cnot:
             case gt.GateType.ControlledUnitary:
-                return jn(r, e);
+                return lu(e, r);
             case gt.GateType.Group:
-                return Ja(r, e);
+                return Wa(e, r);
             case gt.GateType.ClassicalControlled:
-                return Ka(r);
+                return Ya(e);
             default:
-                throw new Error("ERROR: unknown gate (".concat(d, ") of type ").concat(i, "."))
+                throw new Error("ERROR: unknown gate (".concat(h, ") of type ").concat(i, "."))
         }
     };
-    Le._formatGate = Ua;
-    var nr = function(r, e, i) {
-        var a = (e || {}).dataAttributes,
-            l = {
+    Re._formatGate = Ha;
+    var c0 = function(e, r, i) {
+        var o = (r || {}).dataAttributes,
+            s = {
                 class: "gate"
             };
-        Object.entries(a || {}).forEach(function(d) {
-            var f = d[0],
-                g = d[1];
-            return l["data-".concat(f)] = g
+        Object.entries(o || {}).forEach(function(h) {
+            var p = h[0],
+                b = h[1];
+            return s["data-".concat(p)] = b
         });
-        var c = Wa(e, i);
-        return c != null && (r = r.concat([c])), (0, be.group)(r, l)
+        var l = $a(r, i);
+        return l != null && (e = e.concat([l])), (0, he.group)(e, s)
     };
-    Le._createGate = nr;
-    var Wa = function(r, e) {
-        if (r == null) return null;
-        var i = Un(r, e),
-            a = i[0],
-            l = i[1],
-            c = r.dataAttributes;
-        c = c || {};
-        var d = "expanded" in c,
-            f = a + 2,
-            g = l + 2,
-            y = (0, be.circle)(f, g, 10);
-        if (d) {
-            var _ = (0, be.createSvgElement)("path", {
-                    d: "M".concat(f - 7, ",").concat(g, " h14")
+    Re._createGate = c0;
+    var $a = function(e, r) {
+        if (e == null) return null;
+        var i = cu(e, r),
+            o = i[0],
+            s = i[1],
+            l = e.dataAttributes;
+        l = l || {};
+        var h = "expanded" in l,
+            p = o + 2,
+            b = s + 2,
+            x = (0, he.circle)(p, b, 10);
+        if (h) {
+            var C = (0, he.createSvgElement)("path", {
+                    d: "M".concat(p - 7, ",").concat(b, " h14")
                 }),
-                w = [y, _];
-            return (0, be.group)(w, {
+                k = [x, C];
+            return (0, he.group)(k, {
                 class: "gate-control gate-collapse"
             })
-        } else if (c["zoom-in"] == "true") {
-            var T = (0, be.createSvgElement)("path", {
-                    d: "M".concat(f, ",").concat(g - 7, " v14 M").concat(f - 7, ",").concat(g, " h14")
+        } else if (l["zoom-in"] == "true") {
+            var F = (0, he.createSvgElement)("path", {
+                    d: "M".concat(p, ",").concat(b - 7, " v14 M").concat(p - 7, ",").concat(b, " h14")
                 }),
-                w = [y, T];
-            return (0, be.group)(w, {
+                k = [x, F];
+            return (0, he.group)(k, {
                 class: "gate-control gate-expand"
             })
         }
         return null
     };
-    Le._zoomButton = Wa;
-    var Un = function(r, e) {
-            var i = r.x,
-                a = r.width,
-                l = r.type,
-                c = r.targetsY,
-                d = c?.flatMap(function(L) {
-                    return L
+    Re._zoomButton = $a;
+    var cu = function(e, r) {
+            var i = e.x,
+                o = e.width,
+                s = e.type,
+                l = e.targetsY,
+                h = l?.flatMap(function(M) {
+                    return M
                 }) || [],
-                f = Math.max.apply(Math, d),
-                g = Math.min.apply(Math, d),
-                y, _, w, T;
-            switch (l) {
+                p = Math.max.apply(Math, h),
+                b = Math.min.apply(Math, h),
+                x, C, k, F;
+            switch (s) {
                 case gt.GateType.Group:
-                    var A = Re.groupBoxPadding - e * Re.nestedGroupPadding;
-                    return y = i - 2 * A, _ = g - Re.gateHeight / 2 - A, w = a + 2 * A, T = f + +Re.gateHeight / 2 + A - (g - Re.gateHeight / 2 - A), [y, _, w, T];
+                    var E = De.groupBoxPadding - r * De.nestedGroupPadding;
+                    return x = i - 2 * E, C = b - De.gateHeight / 2 - E, k = o + 2 * E, F = p + +De.gateHeight / 2 + E - (b - De.gateHeight / 2 - E), [x, C, k, F];
                 default:
-                    y = i - a / 2, _ = g - Re.gateHeight / 2, w = i + a, T = f + Re.gateHeight / 2
+                    x = i - o / 2, C = b - De.gateHeight / 2, k = i + o, F = p + De.gateHeight / 2
             }
-            return [y, _, w, T]
+            return [x, C, k, F]
         },
-        Ya = function(r, e) {
-            r -= Re.minGateWidth / 2;
-            var i = Re.minGateWidth,
-                a = Re.gateHeight,
-                l = (0, be.box)(r, e - a / 2, i, a, "gate-measure"),
-                c = (0, be.arc)(r + 5, e + 2, i / 2 - 5, a / 2 - 8),
-                d = (0, be.line)(r + i / 2, e + 8, r + i - 8, e - a / 2 + 8);
-            return (0, be.group)([l, c, d])
+        Ga = function(e, r) {
+            e -= De.minGateWidth / 2;
+            var i = De.minGateWidth,
+                o = De.gateHeight,
+                s = (0, he.box)(e, r - o / 2, i, o, "gate-measure"),
+                l = (0, he.arc)(e + 5, r + 2, i / 2 - 5, o / 2 - 8),
+                h = (0, he.line)(e + i / 2, r + 8, e + i - 8, r - o / 2 + 8);
+            return (0, he.group)([s, l, h])
         };
-    Le._measure = Ya;
-    var Wn = function(r, e, i, a, l, c) {
-        if (c === void 0 && (c = !0), i.length === 0) throw new Error("Failed to render unitary gate (".concat(r, "): has no y-values"));
-        var d = i.map(function(T) {
-            var A = T[T.length - 1],
-                L = T[0],
-                R = A - L + Re.gateHeight;
-            return Qh(r, e, L, a, R, l)
+    Re._measure = Ga;
+    var du = function(e, r, i, o, s, l) {
+        if (l === void 0 && (l = !0), i.length === 0) throw new Error("Failed to render unitary gate (".concat(e, "): has no y-values"));
+        var h = i.map(function(F) {
+            var E = F[F.length - 1],
+                M = F[0],
+                N = E - M + De.gateHeight;
+            return $1(e, r, M, o, N, s)
         });
-        if (c && d.length > 1) {
-            var f = i[i.length - 1],
-                g = i[0],
-                y = f[f.length - 1],
-                _ = g[0],
-                w = (0, be.dashedLine)(e, _, e, y);
-            return (0, be.group)(Nt([w], d, !0))
-        }
-        return (0, be.group)(d)
-    };
-    Le._unitary = Wn;
-    var Qh = function(r, e, i, a, l, c) {
-            l === void 0 && (l = Re.gateHeight), i -= Re.gateHeight / 2;
-            var d = (0, be.box)(e - a / 2, i, a, l),
-                f = i + l / 2 - (c == null ? 0 : 7),
-                g = (0, be.text)(r, e, f),
-                y = [d, g];
-            if (c != null) {
-                var _ = i + l / 2 + 8,
-                    w = (0, be.text)(c, e, _, Re.argsFontSize);
-                y.push(w)
+        if (l && h.length > 1) {
+            var p = i[i.length - 1],
+                b = i[0],
+                x = p[p.length - 1],
+                C = b[0],
+                k = (0, he.dashedLine)(r, C, r, x);
+            return (0, he.group)(Pt([k], h, !0))
+        }
+        return (0, he.group)(h)
+    };
+    Re._unitary = du;
+    var $1 = function(e, r, i, o, s, l) {
+            s === void 0 && (s = De.gateHeight), i -= De.gateHeight / 2;
+            var h = (0, he.box)(r - o / 2, i, o, s),
+                p = i + s / 2 - (l == null ? 0 : 7),
+                b = (0, he.text)(e, r, p),
+                x = [h, b];
+            if (l != null) {
+                var C = i + s / 2 + 8,
+                    k = (0, he.text)(l, r, C, De.argsFontSize);
+                x.push(k)
             }
-            return (0, be.group)(y)
+            return (0, he.group)(x)
         },
-        Za = function(r, e) {
-            var i = r.x,
-                a = r.targetsY,
-                l = Un(r, e),
-                c = l[0],
-                d = l[1],
-                f = l[2],
-                g = l[3],
-                y = a?.flatMap(function(A) {
-                    return A
+        Va = function(e, r) {
+            var i = e.x,
+                o = e.targetsY,
+                s = cu(e, r),
+                l = s[0],
+                h = s[1],
+                p = s[2],
+                b = s[3],
+                x = o?.flatMap(function(E) {
+                    return E
                 }) || [],
-                _ = (0, be.box)(c, d, f, g, "gate-swap"),
-                w = y.map(function(A) {
-                    return Qa(i, A)
+                C = (0, he.box)(l, h, p, b, "gate-swap"),
+                k = x.map(function(E) {
+                    return Ua(i, E)
                 }),
-                T = (0, be.line)(i, y[0], i, y[1]);
-            return (0, be.group)(Nt(Nt([_], w, !0), [T], !1))
+                F = (0, he.line)(i, x[0], i, x[1]);
+            return (0, he.group)(Pt(Pt([C], k, !0), [F], !1))
         };
-    Le._swap = Za;
-    var Xh = function(r, e) {
-            var i = r.x,
-                a = r.targetsY,
-                l = a.flatMap(function(c) {
-                    return c
+    Re._swap = Va;
+    var G1 = function(e, r) {
+            var i = e.x,
+                o = e.targetsY,
+                s = o.flatMap(function(l) {
+                    return l
                 });
-            return Xa(i, l[0])
+            return ja(i, s[0])
         },
-        Qa = function(r, e) {
+        Ua = function(e, r) {
             var i = 8,
-                a = (0, be.line)(r - i, e - i, r + i, e + i),
-                l = (0, be.line)(r - i, e + i, r + i, e - i);
-            return (0, be.group)([a, l])
+                o = (0, he.line)(e - i, r - i, e + i, r + i),
+                s = (0, he.line)(e - i, r + i, e + i, r - i);
+            return (0, he.group)([o, s])
         },
-        jn = function(r, e) {
+        lu = function(e, r) {
             var i = [],
-                a = r.type,
-                l = r.x,
-                c = r.controlsY,
-                d = r.label,
-                f = r.displayArgs,
-                g = r.width,
-                y = r.targetsY;
-            switch (a) {
+                o = e.type,
+                s = e.x,
+                l = e.controlsY,
+                h = e.label,
+                p = e.displayArgs,
+                b = e.width,
+                x = e.targetsY;
+            switch (o) {
                 case gt.GateType.Cnot:
-                    y.forEach(function(O) {
-                        return i.push(Xa(l, O))
+                    x.forEach(function(G) {
+                        return i.push(ja(s, G))
                     });
                     break;
                 case gt.GateType.Swap:
-                    y.forEach(function(O) {
-                        return i.push(Qa(l, O))
+                    x.forEach(function(G) {
+                        return i.push(Ua(s, G))
                     });
                     break;
                 case gt.GateType.ControlledUnitary:
-                    var _ = y;
-                    i.push(Wn(d, l, _, g, f, !1)), y = y.flat();
+                    var C = x;
+                    i.push(du(h, s, C, b, p, !1)), x = x.flat();
                     break;
                 default:
-                    throw new Error("ERROR: Unrecognized gate: ".concat(d, " of type ").concat(a))
+                    throw new Error("ERROR: Unrecognized gate: ".concat(h, " of type ").concat(o))
             }
-            var w = c.map(function(O) {
-                    return (0, be.controlDot)(l, O)
+            var k = l.map(function(G) {
+                    return (0, he.controlDot)(s, G)
                 }),
-                T = Math.max.apply(Math, Nt(Nt([], c, !1), y, !1)),
-                A = Math.min.apply(Math, Nt(Nt([], c, !1), y, !1)),
-                L = (0, be.line)(l, A, l, T),
-                R = nr(Nt(Nt([L], w, !0), i, !0), r, e);
-            return R
+                F = Math.max.apply(Math, Pt(Pt([], l, !1), x, !1)),
+                E = Math.min.apply(Math, Pt(Pt([], l, !1), x, !1)),
+                M = (0, he.line)(s, E, s, F),
+                N = c0(Pt(Pt([M], k, !0), i, !0), e, r);
+            return N
         };
-    Le._controlledGate = jn;
-    var Xa = function(r, e, i) {
+    Re._controlledGate = lu;
+    var ja = function(e, r, i) {
             i === void 0 && (i = 15);
-            var a = (0, be.circle)(r, e, i),
-                l = (0, be.line)(r, e - i, r, e + i),
-                c = (0, be.line)(r - i, e, r + i, e);
-            return (0, be.group)([a, l, c], {
+            var o = (0, he.circle)(e, r, i),
+                s = (0, he.line)(e, r - i, e, r + i),
+                l = (0, he.line)(e - i, r, e + i, r);
+            return (0, he.group)([o, s, l], {
                 class: "oplus"
             })
         },
-        Ja = function(r, e) {
-            var i = r.children,
-                a = Un(r, e),
-                l = a[0],
-                c = a[1],
-                d = a[2],
-                f = a[3],
-                g = (0, be.dashedBox)(l, c, d, f),
-                y = [g];
-            return i != null && y.push(v0(i, e + 1)), nr(y, r, e)
+        Wa = function(e, r) {
+            var i = e.children,
+                o = cu(e, r),
+                s = o[0],
+                l = o[1],
+                h = o[2],
+                p = o[3],
+                b = (0, he.dashedBox)(s, l, h, p),
+                x = [b];
+            return i != null && x.push(Rr(i, r + 1)), c0(x, e, r)
         };
-    Le._groupedOperations = Ja;
-    var Ka = function(r, e) {
-        e === void 0 && (e = Re.groupBoxPadding);
-        var i = r.controlsY,
-            a = r.dataAttributes,
-            l = r.targetsY,
-            c = r.children,
-            d = r.x,
-            f = r.width,
-            g = i[0],
-            y = [];
-        if (c != null) {
-            if (c.length !== 2) throw new Error("Invalid number of children found for classically-controlled gate: ".concat(c.length));
-            var _ = v0(c[0]);
-            _.setAttribute("class", "gates-zero"), y.push(_);
-            var w = v0(c[1]);
-            w.setAttribute("class", "gates-one"), y.push(w)
-        }
-        var T = d + Re.controlBtnRadius,
-            A = Jh(T, g),
-            L = g + Re.controlBtnRadius,
-            R = g + Re.classicalRegHeight / 2,
-            O = (0, be.dashedLine)(T, L, T, R, "classical-line");
-        d += Re.controlBtnOffset;
-        var P = (0, be.dashedLine)(T, R, d, R, "classical-line");
-        f = f - Re.controlBtnOffset + (e - Re.groupBoxPadding) * 2, d += Re.groupBoxPadding - e;
-        var I = l[0] - Re.gateHeight / 2 - e,
-            Y = l[1] - l[0] + Re.gateHeight + e * 2,
-            re = (0, be.dashedBox)(d, I, f, Y, "classical-container");
-        y.push.apply(y, [P, O, A, re]);
-        var te = {
+    Re._groupedOperations = Wa;
+    var Ya = function(e, r) {
+        r === void 0 && (r = De.groupBoxPadding);
+        var i = e.controlsY,
+            o = e.dataAttributes,
+            s = e.targetsY,
+            l = e.children,
+            h = e.x,
+            p = e.width,
+            b = i[0],
+            x = [];
+        if (l != null) {
+            if (l.length !== 2) throw new Error("Invalid number of children found for classically-controlled gate: ".concat(l.length));
+            var C = Rr(l[0]);
+            C.setAttribute("class", "gates-zero"), x.push(C);
+            var k = Rr(l[1]);
+            k.setAttribute("class", "gates-one"), x.push(k)
+        }
+        var F = h + De.controlBtnRadius,
+            E = V1(F, b),
+            M = b + De.controlBtnRadius,
+            N = b + De.classicalRegHeight / 2,
+            G = (0, he.dashedLine)(F, M, F, N, "classical-line");
+        h += De.controlBtnOffset;
+        var U = (0, he.dashedLine)(F, N, h, N, "classical-line");
+        p = p - De.controlBtnOffset + (r - De.groupBoxPadding) * 2, h += De.groupBoxPadding - r;
+        var $ = s[0] - De.gateHeight / 2 - r,
+            V = s[1] - s[0] + De.gateHeight + r * 2,
+            Y = (0, he.dashedBox)(h, $, p, V, "classical-container");
+        x.push.apply(x, [U, G, E, Y]);
+        var X = {
             class: "classically-controlled-group classically-controlled-unknown"
         };
-        return a != null && Object.entries(a).forEach(function(j) {
-            var ne = j[0],
-                pe = j[1];
-            return te["data-".concat(ne)] = pe
-        }), (0, be.group)(y, te)
-    };
-    Le._classicalControlled = Ka;
-    var Jh = function(r, e, i) {
-        return i === void 0 && (i = Re.controlBtnRadius), (0, be.group)([(0, be.circle)(r, e, i), (0, be.text)("?", r, e, Re.labelFontSize)], {
+        return o != null && Object.entries(o).forEach(function(te) {
+            var ie = te[0],
+                ge = te[1];
+            return X["data-".concat(ie)] = ge
+        }), (0, he.group)(x, X)
+    };
+    Re._classicalControlled = Ya;
+    var V1 = function(e, r, i) {
+        return i === void 0 && (i = De.controlBtnRadius), (0, he.group)([(0, he.circle)(e, r, i), (0, he.text)("?", e, r, De.labelFontSize)], {
             class: "classically-controlled-btn"
         })
     }
 });
-var is = W(Yt => {
+var Ka = rt(Kt => {
     "use strict";
-    Object.defineProperty(Yt, "__esModule", {
+    Object.defineProperty(Kt, "__esModule", {
         value: !0
     });
-    Yt._qubitRegister = Yt._classicalRegister = Yt.formatRegisters = void 0;
-    var ts = Wt(),
-        Kh = hr(),
-        Lt = x0(),
-        ed = function(r, e, i) {
-            var a = [];
-            for (var l in r) a.push(ns(Number(l), i, r[l].y));
-            return e.forEach(function(c) {
-                var d = c.type,
-                    f = c.x,
-                    g = c.targetsY,
-                    y = c.controlsY;
-                if (d === Kh.GateType.Measure) {
-                    var _ = y[0];
-                    g.forEach(function(w) {
-                        a.push(rs(f, _, i, w))
+    Kt._qubitRegister = Kt._classicalRegister = Kt.formatRegisters = void 0;
+    var Xa = Jt(),
+        U1 = w0(),
+        It = zr(),
+        j1 = function(e, r, i) {
+            var o = [];
+            for (var s in e) o.push(Ja(Number(s), i, e[s].y));
+            return r.forEach(function(l) {
+                var h = l.type,
+                    p = l.x,
+                    b = l.targetsY,
+                    x = l.controlsY;
+                if (h === U1.GateType.Measure) {
+                    var C = x[0];
+                    b.forEach(function(k) {
+                        o.push(Qa(p, C, i, k))
                     })
                 }
-            }), (0, Lt.group)(a)
+            }), (0, It.group)(o)
         };
-    Yt.formatRegisters = ed;
-    var rs = function(r, e, i, a) {
-        var l = 1,
-            c = (0, Lt.line)(r + l, e, r + l, a - l, "register-classical"),
-            d = (0, Lt.line)(r - l, e, r - l, a + l, "register-classical"),
-            f = (0, Lt.line)(r + l, a - l, i, a - l, "register-classical"),
-            g = (0, Lt.line)(r - l, a + l, i, a + l, "register-classical");
-        return (0, Lt.group)([c, d, f, g])
-    };
-    Yt._classicalRegister = rs;
-    var ns = function(r, e, i, a) {
-        a === void 0 && (a = 16);
-        var l = (0, Lt.line)(ts.regLineStart, i, e, i),
-            c = (0, Lt.text)("q".concat(r), ts.regLineStart, i - a);
-        return c.setAttribute("dominant-baseline", "hanging"), c.setAttribute("text-anchor", "start"), c.setAttribute("font-size", "75%"), (0, Lt.group)([l, c])
+    Kt.formatRegisters = j1;
+    var Qa = function(e, r, i, o) {
+        var s = 1,
+            l = (0, It.line)(e + s, r, e + s, o - s, "register-classical"),
+            h = (0, It.line)(e - s, r, e - s, o + s, "register-classical"),
+            p = (0, It.line)(e + s, o - s, i, o - s, "register-classical"),
+            b = (0, It.line)(e - s, o + s, i, o + s, "register-classical");
+        return (0, It.group)([l, h, p, b])
+    };
+    Kt._classicalRegister = Qa;
+    var Ja = function(e, r, i, o) {
+        o === void 0 && (o = 16);
+        var s = (0, It.line)(Xa.regLineStart, i, r, i),
+            l = (0, It.text)("q".concat(e), Xa.regLineStart, i - o);
+        return l.setAttribute("dominant-baseline", "hanging"), l.setAttribute("text-anchor", "start"), l.setAttribute("font-size", "75%"), (0, It.group)([s, l])
     };
-    Yt._qubitRegister = ns
+    Kt._qubitRegister = Ja
 });
-var Yn = W(Fr => {
+var hu = rt(j0 => {
     "use strict";
-    Object.defineProperty(Fr, "__esModule", {
+    Object.defineProperty(j0, "__esModule", {
         value: !0
     });
-    Fr.ConditionalRender = void 0;
-    var td;
-    (function(r) {
-        r[r.Always = 0] = "Always", r[r.OnZero = 1] = "OnZero", r[r.OnOne = 2] = "OnOne", r[r.AsGroup = 3] = "AsGroup"
-    })(td = Fr.ConditionalRender || (Fr.ConditionalRender = {}))
+    j0.ConditionalRender = void 0;
+    var W1;
+    (function(e) {
+        e[e.Always = 0] = "Always", e[e.OnZero = 1] = "OnZero", e[e.OnOne = 2] = "OnOne", e[e.AsGroup = 3] = "AsGroup"
+    })(W1 = j0.ConditionalRender || (j0.ConditionalRender = {}))
 });
-var Xn = W(Zt => {
+var pu = rt(e0 => {
     "use strict";
-    Object.defineProperty(Zt, "__esModule", {
+    Object.defineProperty(e0, "__esModule", {
         value: !0
     });
-    Zt._getStringWidth = Zt.getGateWidth = Zt.createUUID = void 0;
-    var Zn = hr(),
-        Br = Wt(),
-        rd = function() {
-            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r) {
-                var e = Math.random() * 16 | 0,
-                    i = r == "x" ? e : e & 3 | 8;
+    e0._getStringWidth = e0.getGateWidth = e0.createUUID = void 0;
+    var fu = w0(),
+        W0 = Jt(),
+        Y1 = function() {
+            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
+                var r = Math.random() * 16 | 0,
+                    i = e == "x" ? r : r & 3 | 8;
                 return i.toString(16)
             })
         };
-    Zt.createUUID = rd;
-    var nd = function(r) {
-        var e = r.type,
-            i = r.label,
-            a = r.displayArgs,
-            l = r.width;
-        if (l > 0) return l;
-        switch (e) {
-            case Zn.GateType.Measure:
-            case Zn.GateType.Cnot:
-            case Zn.GateType.Swap:
-                return Br.minGateWidth;
+    e0.createUUID = Y1;
+    var Z1 = function(e) {
+        var r = e.type,
+            i = e.label,
+            o = e.displayArgs,
+            s = e.width;
+        if (s > 0) return s;
+        switch (r) {
+            case fu.GateType.Measure:
+            case fu.GateType.Cnot:
+            case fu.GateType.Swap:
+                return W0.minGateWidth;
             default:
-                var c = Qn(i),
-                    d = a != null ? Qn(a, Br.argsFontSize) : 0,
-                    f = Math.max(c, d) + Br.labelPadding * 2;
-                return Math.max(Br.minGateWidth, f)
+                var l = mu(i),
+                    h = o != null ? mu(o, W0.argsFontSize) : 0,
+                    p = Math.max(l, h) + W0.labelPadding * 2;
+                return Math.max(W0.minGateWidth, p)
         }
     };
-    Zt.getGateWidth = nd;
-    var Qn = function(r, e) {
-        e === void 0 && (e = Br.labelFontSize);
+    e0.getGateWidth = Z1;
+    var mu = function(e, r) {
+        r === void 0 && (r = W0.labelFontSize);
         var i = document.createElement("canvas"),
-            a = i.getContext("2d");
-        if (a == null) throw new Error("Null canvas");
-        a.font = "".concat(e, "px Arial");
-        var l = a.measureText(r);
-        return l.width
+            o = i.getContext("2d");
+        if (o == null) throw new Error("Null canvas");
+        o.font = "".concat(r, "px Arial");
+        var s = o.measureText(e);
+        return s.width
     };
-    Zt._getStringWidth = Qn
+    e0._getStringWidth = mu
 });
-var hs = W(Pe => {
+var os = rt(Be => {
     "use strict";
-    var k0 = Pe && Pe.__assign || function() {
-            return k0 = Object.assign || function(r) {
-                for (var e, i = 1, a = arguments.length; i < a; i++) {
-                    e = arguments[i];
-                    for (var l in e) Object.prototype.hasOwnProperty.call(e, l) && (r[l] = e[l])
+    var Nr = Be && Be.__assign || function() {
+            return Nr = Object.assign || function(e) {
+                for (var r, i = 1, o = arguments.length; i < o; i++) {
+                    r = arguments[i];
+                    for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s])
                 }
-                return r
-            }, k0.apply(this, arguments)
+                return e
+            }, Nr.apply(this, arguments)
         },
-        dr = Pe && Pe.__spreadArray || function(r, e, i) {
+        k0 = Be && Be.__spreadArray || function(e, r, i) {
             if (i || arguments.length === 2)
-                for (var a = 0, l = e.length, c; a < l; a++)(c || !(a in e)) && (c || (c = Array.prototype.slice.call(e, 0, a)), c[a] = e[a]);
-            return r.concat(c || Array.prototype.slice.call(e))
+                for (var o = 0, s = r.length, l; o < s; o++)(l || !(o in r)) && (l || (l = Array.prototype.slice.call(r, 0, o)), l[o] = r[o]);
+            return e.concat(l || Array.prototype.slice.call(r))
         };
-    Object.defineProperty(Pe, "__esModule", {
+    Object.defineProperty(Be, "__esModule", {
         value: !0
     });
-    Pe._offsetChildrenX = Pe._fillMetadataX = Pe._splitTargetsY = Pe._getRegY = Pe._opToMetadata = Pe._getClassicalRegStart = Pe._alignOps = Pe._groupOperations = Pe.processOperations = void 0;
-    var ot = Wt(),
-        Jn = Yn(),
-        rt = hr(),
-        ir = Vn(),
-        id = Xn(),
-        w0 = function(r, e) {
-            if (r.length === 0) return {
+    Be._offsetChildrenX = Be._fillMetadataX = Be._splitTargetsY = Be._getRegY = Be._opToMetadata = Be._getClassicalRegStart = Be._alignOps = Be._groupOperations = Be.processOperations = void 0;
+    var ot = Jt(),
+        bu = hu(),
+        nt = w0(),
+        d0 = su(),
+        X1 = pu(),
+        Br = function(e, r) {
+            if (e.length === 0) return {
                 metadataList: [],
                 svgWidth: ot.startX
             };
-            var i = os(r, e),
-                a = as(i),
-                l = Math.max.apply(Math, dr([0], a.map(function(w) {
-                    return w.length
+            var i = es(e, r),
+                o = ts(i),
+                s = Math.max.apply(Math, k0([0], o.map(function(k) {
+                    return k.length
                 }), !1)),
-                c = new Array(l).fill(ot.minGateWidth),
-                d = ss(r, a),
-                f = {},
-                g = a.map(function(w) {
-                    return w.map(function(T, A) {
-                        var L = null;
-                        T != null && !f.hasOwnProperty(T) && (L = r[T], f[T] = !0);
-                        var R = ls(L, e);
-                        if (L != null && [rt.GateType.Unitary, rt.GateType.ControlledUnitary].includes(R.type)) {
-                            var O = d.filter(function(P) {
-                                var I = P[0],
-                                    Y = P[1];
-                                return I <= A
-                            }).map(function(P) {
-                                var I = P[0],
-                                    Y = P[1];
-                                if (Y.cId == null) throw new Error("Could not find cId for classical register.");
-                                var re = e[Y.qId].children;
-                                if (re == null) throw new Error("Failed to find classical registers for qubit ID ".concat(Y.qId, "."));
-                                return re[Y.cId].y
+                l = new Array(s).fill(ot.minGateWidth),
+                h = rs(e, o),
+                p = {},
+                b = o.map(function(k) {
+                    return k.map(function(F, E) {
+                        var M = null;
+                        F != null && !p.hasOwnProperty(F) && (M = e[F], p[F] = !0);
+                        var N = ns(M, r);
+                        if (M != null && [nt.GateType.Unitary, nt.GateType.ControlledUnitary].includes(N.type)) {
+                            var G = h.filter(function(U) {
+                                var $ = U[0],
+                                    V = U[1];
+                                return $ <= E
+                            }).map(function(U) {
+                                var $ = U[0],
+                                    V = U[1];
+                                if (V.cId == null) throw new Error("Could not find cId for classical register.");
+                                var Y = r[V.qId].children;
+                                if (Y == null) throw new Error("Failed to find classical registers for qubit ID ".concat(V.qId, "."));
+                                return Y[V.cId].y
                             });
-                            R.targetsY = cs(L.targets, O, e)
+                            N.targetsY = us(M.targets, G, r)
                         }
-                        return R.width > c[A] && (c[A] = R.width), R
+                        return N.width > l[E] && (l[E] = N.width), N
                     })
                 }),
-                y = us(g, c),
-                _ = g.flat().filter(function(w) {
-                    var T = w.type;
-                    return T != rt.GateType.Invalid
+                x = is(b, l),
+                C = b.flat().filter(function(k) {
+                    var F = k.type;
+                    return F != nt.GateType.Invalid
                 });
             return {
-                metadataList: _,
-                svgWidth: y
+                metadataList: C,
+                svgWidth: x
             }
         };
-    Pe.processOperations = w0;
-    var os = function(r, e) {
-        var i = Math.max.apply(Math, dr([-1], Object.keys(e).map(Number), !1)) + 1,
-            a = Array.from(Array(i), function() {
+    Be.processOperations = Br;
+    var es = function(e, r) {
+        var i = Math.max.apply(Math, k0([-1], Object.keys(r).map(Number), !1)) + 1,
+            o = Array.from(Array(i), function() {
                 return new Array(0)
             });
-        return r.forEach(function(l, c) {
-            var d = l.targets,
-                f = l.controls,
-                g = f || [],
-                y = dr(dr([], g, !0), d, !0).filter(function(O) {
-                    var P = O.type;
-                    return (P || ir.RegisterType.Qubit) === ir.RegisterType.Qubit
+        return e.forEach(function(s, l) {
+            var h = s.targets,
+                p = s.controls,
+                b = p || [],
+                x = k0(k0([], b, !0), h, !0).filter(function(G) {
+                    var U = G.type;
+                    return (U || d0.RegisterType.Qubit) === d0.RegisterType.Qubit
                 }),
-                _ = y.map(function(O) {
-                    var P = O.qId;
-                    return P
+                C = x.map(function(G) {
+                    var U = G.qId;
+                    return U
                 }),
-                w = g.filter(function(O) {
-                    var P = O.type;
-                    return (P || ir.RegisterType.Qubit) === ir.RegisterType.Classical
+                k = b.filter(function(G) {
+                    var U = G.type;
+                    return (U || d0.RegisterType.Qubit) === d0.RegisterType.Classical
                 }),
-                T = w.length > 0;
-            if (!(!T && y.length === 0))
-                for (var A = T ? 0 : Math.min.apply(Math, _), L = T ? i - 1 : Math.max.apply(Math, _), R = A; R <= L; R++) a[R].push(c)
-        }), a
-    };
-    Pe._groupOperations = os;
-    var as = function(r) {
-        for (var e = Math.max.apply(Math, dr([0], r.map(function(d) {
-                return d.length
-            }), !1)), i = 0, a = JSON.parse(JSON.stringify(r)); i < e;) {
-            for (var l = function(d) {
-                    var f = a[d];
-                    if (f.length <= i) return "continue";
-                    var g = f[i],
-                        y = a.map(function(w) {
-                            return w.indexOf(g)
+                F = k.length > 0;
+            if (!(!F && x.length === 0))
+                for (var E = F ? 0 : Math.min.apply(Math, C), M = F ? i - 1 : Math.max.apply(Math, C), N = E; N <= M; N++) o[N].push(l)
+        }), o
+    };
+    Be._groupOperations = es;
+    var ts = function(e) {
+        for (var r = Math.max.apply(Math, k0([0], e.map(function(h) {
+                return h.length
+            }), !1)), i = 0, o = JSON.parse(JSON.stringify(e)); i < r;) {
+            for (var s = function(h) {
+                    var p = o[h];
+                    if (p.length <= i) return "continue";
+                    var b = p[i],
+                        x = o.map(function(k) {
+                            return k.indexOf(b)
                         }),
-                        _ = Math.max.apply(Math, dr([-1], y, !1));
-                    i < _ && (a[d].splice(i, 0, null), e = Math.max(e, a[d].length))
-                }, c = 0; c < a.length; c++) l(c);
+                        C = Math.max.apply(Math, k0([-1], x, !1));
+                    i < C && (o[h].splice(i, 0, null), r = Math.max(r, o[h].length))
+                }, l = 0; l < o.length; l++) s(l);
             i++
         }
-        return a
+        return o
     };
-    Pe._alignOps = as;
-    var ss = function(r, e) {
+    Be._alignOps = ts;
+    var rs = function(e, r) {
         var i = [];
-        return e.forEach(function(a) {
-            for (var l = function(d) {
-                    var f = a[d];
-                    if (f != null && r[f].isMeasurement) {
-                        var g = r[f].targets.filter(function(y) {
-                            return y.type === ir.RegisterType.Classical
+        return r.forEach(function(o) {
+            for (var s = function(h) {
+                    var p = o[h];
+                    if (p != null && e[p].isMeasurement) {
+                        var b = e[p].targets.filter(function(x) {
+                            return x.type === d0.RegisterType.Classical
                         });
-                        g.forEach(function(y) {
-                            return i.push([d, y])
+                        b.forEach(function(x) {
+                            return i.push([h, x])
                         })
                     }
-                }, c = 0; c < a.length; c++) l(c)
+                }, l = 0; l < o.length; l++) s(l)
         }), i
     };
-    Pe._getClassicalRegStart = ss;
-    var ls = function(r, e) {
+    Be._getClassicalRegStart = rs;
+    var ns = function(e, r) {
         var i = {
-            type: rt.GateType.Invalid,
+            type: nt.GateType.Invalid,
             x: 0,
             controlsY: [],
             targetsY: [],
             label: "",
             width: -1
         };
-        if (r == null) return i;
-        var a = r.gate,
-            l = r.dataAttributes,
-            c = r.displayArgs,
-            d = r.isMeasurement,
-            f = r.isConditional,
-            g = r.isControlled,
-            y = r.isAdjoint,
-            _ = r.controls,
-            w = r.targets,
-            T = r.children,
-            A = r.conditionalRender;
-        if (i.controlsY = _?.map(function(ne) {
-                return _0(ne, e)
-            }) || [], i.targetsY = w.map(function(ne) {
-                return _0(ne, e)
-            }), f) {
-            if (T == null || T.length == 0) throw new Error("No children operations found for classically-controlled operation.");
-            var L = T.filter(function(ne) {
-                    return ne.conditionalRender !== Jn.ConditionalRender.OnOne
+        if (e == null) return i;
+        var o = e.gate,
+            s = e.dataAttributes,
+            l = e.displayArgs,
+            h = e.isMeasurement,
+            p = e.isConditional,
+            b = e.isControlled,
+            x = e.isAdjoint,
+            C = e.controls,
+            k = e.targets,
+            F = e.children,
+            E = e.conditionalRender;
+        if (i.controlsY = C?.map(function(ie) {
+                return Lr(ie, r)
+            }) || [], i.targetsY = k.map(function(ie) {
+                return Lr(ie, r)
+            }), p) {
+            if (F == null || F.length == 0) throw new Error("No children operations found for classically-controlled operation.");
+            var M = F.filter(function(ie) {
+                    return ie.conditionalRender !== bu.ConditionalRender.OnOne
                 }),
-                R = w0(L, e),
-                O = R.metadataList,
-                P = R.svgWidth,
-                I = T.filter(function(ne) {
-                    return ne.conditionalRender !== Jn.ConditionalRender.OnZero
+                N = Br(M, r),
+                G = N.metadataList,
+                U = N.svgWidth,
+                $ = F.filter(function(ie) {
+                    return ie.conditionalRender !== bu.ConditionalRender.OnZero
                 });
-            R = w0(I, e);
-            var Y = R.metadataList,
-                re = R.svgWidth,
-                te = Math.max(P, re) - ot.startX - ot.gatePadding * 2;
-            i.type = rt.GateType.ClassicalControlled, i.children = [O, Y], i.width = te + ot.controlBtnOffset + ot.groupBoxPadding * 2;
-            var j = Object.values(e).map(function(ne) {
-                var pe = ne.y;
-                return pe
+            N = Br($, r);
+            var V = N.metadataList,
+                Y = N.svgWidth,
+                X = Math.max(U, Y) - ot.startX - ot.gatePadding * 2;
+            i.type = nt.GateType.ClassicalControlled, i.children = [G, V], i.width = X + ot.controlBtnOffset + ot.groupBoxPadding * 2;
+            var te = Object.values(r).map(function(ie) {
+                var ge = ie.y;
+                return ge
             });
-            j.length > 0 && (i.targetsY = [Math.min.apply(Math, j), Math.max.apply(Math, j)])
-        } else if (A == Jn.ConditionalRender.AsGroup && (T?.length || 0) > 0) {
-            var R = w0(T, e);
-            i.type = rt.GateType.Group, i.children = R.metadataList, i.dataAttributes = {
+            te.length > 0 && (i.targetsY = [Math.min.apply(Math, te), Math.max.apply(Math, te)])
+        } else if (E == bu.ConditionalRender.AsGroup && (F?.length || 0) > 0) {
+            var N = Br(F, r);
+            i.type = nt.GateType.Group, i.children = N.metadataList, i.dataAttributes = {
                 expanded: "true"
-            }, i.width = R.svgWidth - ot.startX + (ot.groupBoxPadding - ot.gatePadding) * 2
-        } else d ? i.type = rt.GateType.Measure : a === "SWAP" ? i.type = rt.GateType.Swap : g ? (i.type = a === "X" ? rt.GateType.Cnot : rt.GateType.ControlledUnitary, i.label = a) : a === "X" ? (i.type = rt.GateType.X, i.label = a) : (i.type = rt.GateType.Unitary, i.label = a);
-        return y && i.label.length > 0 && (i.label += "'"), c != null && (i.displayArgs = c), i.width = (0, id.getGateWidth)(i), l != null && (i.dataAttributes = k0(k0({}, i.dataAttributes), l)), i
-    };
-    Pe._opToMetadata = ls;
-    var _0 = function(r, e) {
-        var i = r.type,
-            a = r.qId,
-            l = r.cId;
-        if (!e.hasOwnProperty(a)) throw new Error("ERROR: Qubit register with ID ".concat(a, " not found."));
-        var c = e[a],
-            d = c.y,
-            f = c.children;
+            }, i.width = N.svgWidth - ot.startX + (ot.groupBoxPadding - ot.gatePadding) * 2
+        } else h ? i.type = nt.GateType.Measure : o === "SWAP" ? i.type = nt.GateType.Swap : b ? (i.type = o === "X" ? nt.GateType.Cnot : nt.GateType.ControlledUnitary, i.label = o) : o === "X" ? (i.type = nt.GateType.X, i.label = o) : (i.type = nt.GateType.Unitary, i.label = o);
+        return x && i.label.length > 0 && (i.label += "'"), l != null && (i.displayArgs = l), i.width = (0, X1.getGateWidth)(i), s != null && (i.dataAttributes = Nr(Nr({}, i.dataAttributes), s)), i
+    };
+    Be._opToMetadata = ns;
+    var Lr = function(e, r) {
+        var i = e.type,
+            o = e.qId,
+            s = e.cId;
+        if (!r.hasOwnProperty(o)) throw new Error("ERROR: Qubit register with ID ".concat(o, " not found."));
+        var l = r[o],
+            h = l.y,
+            p = l.children;
         switch (i) {
             case void 0:
-            case ir.RegisterType.Qubit:
-                return d;
-            case ir.RegisterType.Classical:
-                if (f == null) throw new Error("ERROR: No classical registers found for qubit ID ".concat(a, "."));
-                if (l == null) throw new Error("ERROR: No ID defined for classical register associated with qubit ID ".concat(a, "."));
-                if (f.length <= l) throw new Error("ERROR: Classical register ID ".concat(l, " invalid for qubit ID ").concat(a, " with ").concat(f.length, " classical register(s)."));
-                return f[l].y;
+            case d0.RegisterType.Qubit:
+                return h;
+            case d0.RegisterType.Classical:
+                if (p == null) throw new Error("ERROR: No classical registers found for qubit ID ".concat(o, "."));
+                if (s == null) throw new Error("ERROR: No ID defined for classical register associated with qubit ID ".concat(o, "."));
+                if (p.length <= s) throw new Error("ERROR: Classical register ID ".concat(s, " invalid for qubit ID ").concat(o, " with ").concat(p.length, " classical register(s)."));
+                return p[s].y;
             default:
                 throw new Error("ERROR: Unknown register type ".concat(i, "."))
         }
     };
-    Pe._getRegY = _0;
-    var cs = function(r, e, i) {
-        if (r.length === 0) return [];
-        var a = Object.keys(i).map(Number);
-        a.sort(function(f, g) {
-            return i[f].y - i[g].y
+    Be._getRegY = Lr;
+    var us = function(e, r, i) {
+        if (e.length === 0) return [];
+        var o = Object.keys(i).map(Number);
+        o.sort(function(p, b) {
+            return i[p].y - i[b].y
         });
-        var l = {};
-        a.forEach(function(f, g) {
-            return l[f] = g
-        }), r = r.slice(), r.sort(function(f, g) {
-            var y = l[f.qId] - l[g.qId];
-            return y === 0 && f.cId != null && g.cId != null ? f.cId - g.cId : y
-        }), e = e.slice(), e.sort(function(f, g) {
-            return f - g
+        var s = {};
+        o.forEach(function(p, b) {
+            return s[p] = b
+        }), e = e.slice(), e.sort(function(p, b) {
+            var x = s[p.qId] - s[b.qId];
+            return x === 0 && p.cId != null && b.cId != null ? p.cId - b.cId : x
+        }), r = r.slice(), r.sort(function(p, b) {
+            return p - b
         });
-        var c = 0,
-            d = 0;
-        return r.reduce(function(f, g) {
-            var y = _0(g, i),
-                _ = l[g.qId];
-            for (f.length === 0 || _ > c + 1 || e[0] > d && e[0] < y ? f.push([y]) : f[f.length - 1].push(y), c = _, d = y; e.length > 0 && e[0] <= y;) e.shift();
-            return f
+        var l = 0,
+            h = 0;
+        return e.reduce(function(p, b) {
+            var x = Lr(b, i),
+                C = s[b.qId];
+            for (p.length === 0 || C > l + 1 || r[0] > h && r[0] < x ? p.push([x]) : p[p.length - 1].push(x), l = C, h = x; r.length > 0 && r[0] <= x;) r.shift();
+            return p
         }, [])
     };
-    Pe._splitTargetsY = cs;
-    var us = function(r, e) {
+    Be._splitTargetsY = us;
+    var is = function(e, r) {
         var i = ot.startX,
-            a = e.map(function(c) {
-                var d = i;
-                return i += c + ot.gatePadding * 2, d
+            o = r.map(function(l) {
+                var h = i;
+                return i += l + ot.gatePadding * 2, h
             }),
-            l = i;
-        return r.forEach(function(c) {
-            return c.forEach(function(d, f) {
-                var g = a[f];
-                switch (d.type) {
-                    case rt.GateType.ClassicalControlled:
-                    case rt.GateType.Group:
-                        var y = g - ot.startX + ot.groupBoxPadding;
-                        d.type === rt.GateType.ClassicalControlled && (y += ot.controlBtnOffset), Kn(d.children, y), d.x = g;
+            s = i;
+        return e.forEach(function(l) {
+            return l.forEach(function(h, p) {
+                var b = o[p];
+                switch (h.type) {
+                    case nt.GateType.ClassicalControlled:
+                    case nt.GateType.Group:
+                        var x = b - ot.startX + ot.groupBoxPadding;
+                        h.type === nt.GateType.ClassicalControlled && (x += ot.controlBtnOffset), gu(h.children, x), h.x = b;
                         break;
                     default:
-                        d.x = g + e[f] / 2;
+                        h.x = b + r[p] / 2;
                         break
                 }
             })
-        }), l
+        }), s
     };
-    Pe._fillMetadataX = us;
-    var Kn = function(r, e) {
-        r?.flat().forEach(function(i) {
-            i.x += e, Kn(i.children, e)
+    Be._fillMetadataX = is;
+    var gu = function(e, r) {
+        e?.flat().forEach(function(i) {
+            i.x += r, gu(i.children, r)
         })
     };
-    Pe._offsetChildrenX = Kn
+    Be._offsetChildrenX = gu
 });
-var ei = W(Qt => {
+var xu = rt(t0 => {
     "use strict";
-    var S0 = Qt && Qt.__assign || function() {
-        return S0 = Object.assign || function(r) {
-            for (var e, i = 1, a = arguments.length; i < a; i++) {
-                e = arguments[i];
-                for (var l in e) Object.prototype.hasOwnProperty.call(e, l) && (r[l] = e[l])
+    var Pr = t0 && t0.__assign || function() {
+        return Pr = Object.assign || function(e) {
+            for (var r, i = 1, o = arguments.length; i < o; i++) {
+                r = arguments[i];
+                for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s])
             }
-            return r
-        }, S0.apply(this, arguments)
+            return e
+        }, Pr.apply(this, arguments)
     };
-    Object.defineProperty(Qt, "__esModule", {
+    Object.defineProperty(t0, "__esModule", {
         value: !0
     });
-    Qt.style = Qt.STYLES = void 0;
-    var ds = {
+    t0.style = t0.STYLES = void 0;
+    var as = {
             lineStroke: "#000000",
             lineWidth: 1,
             textColour: "#000000",
             unitary: "#D9F1FA",
             oplus: "#FFFFFF",
             measure: "#FFDE86",
             classicalUnknown: "#E5E5E5",
             classicalZero: "#C40000",
             classicalOne: "#4059BD",
             classicalZeroText: "#FFFFFF",
             classicalOneText: "#FFFFFF"
         },
-        od = {
+        Q1 = {
             lineStroke: "#000000",
             lineWidth: 1,
             textColour: "#000000",
             unitary: "#FFFFFF",
             oplus: "#FFFFFF",
             measure: "#FFFFFF",
             classicalUnknown: "#FFFFFF",
             classicalZero: "#000000",
             classicalOne: "#000000",
             classicalZeroText: "#FFFFFF",
             classicalOneText: "#FFFFFF"
         },
-        ad = {
+        J1 = {
             lineStroke: "#FFFFFF",
             lineWidth: 1,
             textColour: "#FFFFFF",
             unitary: "#000000",
             oplus: "#000000",
             measure: "#000000",
             classicalUnknown: "#000000",
             classicalZero: "#FFFFFF",
             classicalOne: "#FFFFFF",
             classicalZeroText: "#000000",
             classicalOneText: "#000000"
         };
-    Qt.STYLES = {
-        Default: ds,
-        BlackAndWhite: od,
-        Inverted: ad
+    t0.STYLES = {
+        Default: as,
+        BlackAndWhite: Q1,
+        Inverted: J1
     };
-    var sd = function(r) {
-        r === void 0 && (r = {});
-        var e = S0(S0({}, ds), r);
-        return "".concat(ld(e), `
-    `).concat(cd(e), `
-    `).concat(ud)
+    var K1 = function(e) {
+        e === void 0 && (e = {});
+        var r = Pr(Pr({}, as), e);
+        return "".concat(ed(r), `
+    `).concat(td(r), `
+    `).concat(rd)
     };
-    Qt.style = sd;
-    var ld = function(r) {
+    t0.style = K1;
+    var ed = function(e) {
             return `
     line,
     circle,
     rect {
-        stroke: `.concat(r.lineStroke, `;
-        stroke-width: `).concat(r.lineWidth, `;
+        stroke: `.concat(e.lineStroke, `;
+        stroke-width: `).concat(e.lineWidth, `;
     }
     text {
-        fill: `).concat(r.textColour, `;
+        fill: `).concat(e.textColour, `;
         dominant-baseline: middle;
         text-anchor: middle;
         font-family: Arial;
     }
     .control-dot {
-        fill: `).concat(r.lineStroke, `;
+        fill: `).concat(e.lineStroke, `;
     }
     .oplus line, .oplus circle {
-        fill: `).concat(r.oplus, `;
+        fill: `).concat(e.oplus, `;
         stroke-width: 2;
     }
     .gate-unitary {
-        fill: `).concat(r.unitary, `;
+        fill: `).concat(e.unitary, `;
     }
     .gate-measure {
-        fill: `).concat(r.measure, `;
+        fill: `).concat(e.measure, `;
     }
     rect.gate-swap {
         fill: transparent;
         stroke: transparent;
     }
     .arc-measure {
-        stroke: `).concat(r.lineStroke, `;
+        stroke: `).concat(e.lineStroke, `;
         fill: none;
-        stroke-width: `).concat(r.lineWidth, `;
+        stroke-width: `).concat(e.lineWidth, `;
     }
     .register-classical {
-        stroke-width: `).concat((r.lineWidth || 0) / 2, `;
+        stroke-width: `).concat((e.lineWidth || 0) / 2, `;
     }`)
         },
-        cd = function(r) {
-            var e = `
+        td = function(e) {
+            var r = `
     .classically-controlled-one .classical-container,
     .classically-controlled-one .classical-line {
-        stroke: `.concat(r.classicalOne, `;
-        stroke-width: `).concat((r.lineWidth || 0) + .3, `;
-        fill: `).concat(r.classicalOne, `;
+        stroke: `.concat(e.classicalOne, `;
+        stroke-width: `).concat((e.lineWidth || 0) + .3, `;
+        fill: `).concat(e.classicalOne, `;
         fill-opacity: 0.1;
     }
     .classically-controlled-zero .classical-container,
     .classically-controlled-zero .classical-line {
-        stroke: `).concat(r.classicalZero, `;
-        stroke-width: `).concat((r.lineWidth || 0) + .3, `;
-        fill: `).concat(r.classicalZero, `;
+        stroke: `).concat(e.classicalZero, `;
+        stroke-width: `).concat((e.lineWidth || 0) + .3, `;
+        fill: `).concat(e.classicalZero, `;
         fill-opacity: 0.1;
     }`),
                 i = `
     .classically-controlled-btn {
         cursor: pointer;
     }
     .classically-controlled-unknown .classically-controlled-btn {
-        fill: `.concat(r.classicalUnknown, `;
+        fill: `.concat(e.classicalUnknown, `;
     }
     .classically-controlled-one .classically-controlled-btn {
-        fill: `).concat(r.classicalOne, `;
+        fill: `).concat(e.classicalOne, `;
     }
     .classically-controlled-zero .classically-controlled-btn {
-        fill: `).concat(r.classicalZero, `;
+        fill: `).concat(e.classicalZero, `;
     }`),
-                a = `
+                o = `
     .classically-controlled-btn text {
         dominant-baseline: middle;
         text-anchor: middle;
         stroke: none;
         font-family: Arial;
     }
     .classically-controlled-unknown .classically-controlled-btn text {
-        fill: `.concat(r.textColour, `;
+        fill: `.concat(e.textColour, `;
     }
     .classically-controlled-one .classically-controlled-btn text {
-        fill: `).concat(r.classicalOneText, `;
+        fill: `).concat(e.classicalOneText, `;
     }
     .classically-controlled-zero .classically-controlled-btn text {
-        fill: `).concat(r.classicalZeroText, `;
+        fill: `).concat(e.classicalZeroText, `;
     }`);
             return `
     .hidden {
         display: none;
     }
     .classically-controlled-unknown {
         opacity: 0.25;
     }
 
-    `.concat(e, `
+    `.concat(r, `
     `).concat(i, `
-    `).concat(a)
+    `).concat(o)
         },
-        ud = `
+        rd = `
     .qviz .gate-collapse,
     .qviz .gate-expand {
         opacity: 0;
         transition: opacity 1s;
     }
 
     .qviz:hover .gate-collapse,
@@ -1055,4693 +1061,277 @@
     .gate:hover > .gate-collapse,
     .gate:hover > .gate-expand {
         visibility: visible;
         opacity: 1;
         transition: opacity 1s;
     }`
 });
-var ms = W(T0 => {
+var ss = rt(Or => {
     "use strict";
-    Object.defineProperty(T0, "__esModule", {
+    Object.defineProperty(Or, "__esModule", {
         value: !0
     });
-    T0.Sqore = void 0;
-    var hd = ja(),
-        dd = es(),
-        md = is(),
-        pd = hs(),
-        C0 = Yn(),
-        fd = hr(),
-        ti = ei(),
-        gd = Xn(),
-        bd = Wt(),
-        yd = function() {
-            function r(e, i) {
-                i === void 0 && (i = {}), this.style = {}, this.gateRegistry = {}, this.circuit = e, this.style = this.getStyle(i)
-            }
-            return r.prototype.draw = function(e, i) {
-                var a = this;
-                if (i === void 0 && (i = 0), e == null) throw new Error("Container not provided.");
-                var l = JSON.parse(JSON.stringify(this.circuit));
-                if (l.operations.forEach(function(d, f) {
-                        return a.fillGateRegistry(d, f.toString())
-                    }), l.operations = this.selectOpsAtDepth(l.operations, i), l.operations.length == 1 && l.operations[0].dataAttributes != null && l.operations[0].dataAttributes.hasOwnProperty("id")) {
-                    var c = l.operations[0].dataAttributes.id;
-                    this.expandOperation(l.operations, c)
-                }
-                this.renderCircuit(e, l)
-            }, r.prototype.getStyle = function(e) {
-                if (e === void 0 && (e = {}), typeof e == "string" || e instanceof String) {
-                    var i = e;
-                    if (!ti.STYLES.hasOwnProperty(i)) return console.error("No style ".concat(i, " found in STYLES.")), {};
-                    e = ti.STYLES[i]
+    Or.Sqore = void 0;
+    var nd = Oa(),
+        ud = Za(),
+        id = Ka(),
+        od = os(),
+        Ir = hu(),
+        ad = w0(),
+        yu = xu(),
+        sd = pu(),
+        ld = Jt(),
+        cd = function() {
+            function e(r, i) {
+                i === void 0 && (i = {}), this.style = {}, this.gateRegistry = {}, this.circuit = r, this.style = this.getStyle(i)
+            }
+            return e.prototype.draw = function(r, i) {
+                var o = this;
+                if (i === void 0 && (i = 0), r == null) throw new Error("Container not provided.");
+                var s = JSON.parse(JSON.stringify(this.circuit));
+                if (s.operations.forEach(function(h, p) {
+                        return o.fillGateRegistry(h, p.toString())
+                    }), s.operations = this.selectOpsAtDepth(s.operations, i), s.operations.length == 1 && s.operations[0].dataAttributes != null && s.operations[0].dataAttributes.hasOwnProperty("id")) {
+                    var l = s.operations[0].dataAttributes.id;
+                    this.expandOperation(s.operations, l)
+                }
+                this.renderCircuit(r, s)
+            }, e.prototype.getStyle = function(r) {
+                if (r === void 0 && (r = {}), typeof r == "string" || r instanceof String) {
+                    var i = r;
+                    if (!yu.STYLES.hasOwnProperty(i)) return console.error("No style ".concat(i, " found in STYLES.")), {};
+                    r = yu.STYLES[i]
                 }
-                return e
-            }, r.prototype.renderCircuit = function(e, i) {
-                var a = this.compose(i),
-                    l = this.generateSvg(a);
-                e.innerHTML = "", e.appendChild(l), this.addGateClickHandlers(e, i)
-            }, r.prototype.compose = function(e) {
-                var i = function(P, I) {
-                        var Y;
-                        Array.isArray(I) ? I.forEach(function(re) {
-                            return i(P, re)
-                        }) : (P.push(I), (Y = I.children) === null || Y === void 0 || Y.forEach(function(re) {
-                            return i(P, re)
+                return r
+            }, e.prototype.renderCircuit = function(r, i) {
+                var o = this.compose(i),
+                    s = this.generateSvg(o);
+                r.innerHTML = "", r.appendChild(s), this.addGateClickHandlers(r, i)
+            }, e.prototype.compose = function(r) {
+                var i = function(U, $) {
+                        var V;
+                        Array.isArray($) ? $.forEach(function(Y) {
+                            return i(U, Y)
+                        }) : (U.push($), (V = $.children) === null || V === void 0 || V.forEach(function(Y) {
+                            return i(U, Y)
                         }))
                     },
-                    a = function(P) {
-                        var I = [];
-                        return i(I, P), I
+                    o = function(U) {
+                        var $ = [];
+                        return i($, U), $
                     },
-                    l = e.qubits,
-                    c = e.operations,
-                    d = (0, hd.formatInputs)(l),
-                    f = d.qubitWires,
-                    g = d.registers,
-                    y = d.svgHeight,
-                    _ = (0, pd.processOperations)(c, g),
-                    w = _.metadataList,
-                    T = _.svgWidth,
-                    A = (0, dd.formatGates)(w),
-                    L = a(w).filter(function(P) {
-                        var I = P.type;
-                        return I === fd.GateType.Measure
+                    s = r.qubits,
+                    l = r.operations,
+                    h = (0, nd.formatInputs)(s),
+                    p = h.qubitWires,
+                    b = h.registers,
+                    x = h.svgHeight,
+                    C = (0, od.processOperations)(l, b),
+                    k = C.metadataList,
+                    F = C.svgWidth,
+                    E = (0, ud.formatGates)(k),
+                    M = o(k).filter(function(U) {
+                        var $ = U.type;
+                        return $ === ad.GateType.Measure
                     }),
-                    R = (0, md.formatRegisters)(g, L, T),
-                    O = {
-                        width: T,
-                        height: y,
-                        elements: [f, R, A]
+                    N = (0, id.formatRegisters)(b, M, F),
+                    G = {
+                        width: F,
+                        height: x,
+                        elements: [p, N, E]
                     };
-                return O
-            }, r.prototype.generateSvg = function(e) {
-                var i = e.width,
-                    a = e.height,
-                    l = e.elements,
-                    c = (0, gd.createUUID)(),
-                    d = document.createElementNS(bd.svgNS, "svg");
-                d.setAttribute("id", c), d.setAttribute("class", "qviz"), d.setAttribute("width", i.toString()), d.setAttribute("height", a.toString()), d.style.setProperty("max-width", "fit-content");
-                var f = document.createElement("style");
-                return f.innerHTML = (0, ti.style)(this.style), d.appendChild(f), l.forEach(function(g) {
-                    return d.appendChild(g)
-                }), d
-            }, r.prototype.fillGateRegistry = function(e, i) {
-                var a = this,
-                    l;
-                e.dataAttributes == null && (e.dataAttributes = {}), e.dataAttributes.id = i, e.dataAttributes["zoom-out"] = "false", this.gateRegistry[i] = e, (l = e.children) === null || l === void 0 || l.forEach(function(c, d) {
-                    a.fillGateRegistry(c, "".concat(i, "-").concat(d)), c.dataAttributes == null && (c.dataAttributes = {}), c.dataAttributes["zoom-out"] = "true"
-                }), e.dataAttributes["zoom-in"] = (e.children != null).toString()
-            }, r.prototype.selectOpsAtDepth = function(e, i) {
-                var a = this;
+                return G
+            }, e.prototype.generateSvg = function(r) {
+                var i = r.width,
+                    o = r.height,
+                    s = r.elements,
+                    l = (0, sd.createUUID)(),
+                    h = document.createElementNS(ld.svgNS, "svg");
+                h.setAttribute("id", l), h.setAttribute("class", "qviz"), h.setAttribute("width", i.toString()), h.setAttribute("height", o.toString()), h.style.setProperty("max-width", "fit-content");
+                var p = document.createElement("style");
+                return p.innerHTML = (0, yu.style)(this.style), h.appendChild(p), s.forEach(function(b) {
+                    return h.appendChild(b)
+                }), h
+            }, e.prototype.fillGateRegistry = function(r, i) {
+                var o = this,
+                    s;
+                r.dataAttributes == null && (r.dataAttributes = {}), r.dataAttributes.id = i, r.dataAttributes["zoom-out"] = "false", this.gateRegistry[i] = r, (s = r.children) === null || s === void 0 || s.forEach(function(l, h) {
+                    o.fillGateRegistry(l, "".concat(i, "-").concat(h)), l.dataAttributes == null && (l.dataAttributes = {}), l.dataAttributes["zoom-out"] = "true"
+                }), r.dataAttributes["zoom-in"] = (r.children != null).toString()
+            }, e.prototype.selectOpsAtDepth = function(r, i) {
+                var o = this;
                 if (i < 0) throw new Error("Invalid renderDepth of ".concat(i, ". Needs to be >= 0."));
-                return i === 0 ? e : e.map(function(l) {
-                    return l.children != null ? a.selectOpsAtDepth(l.children, i - 1) : l
+                return i === 0 ? r : r.map(function(s) {
+                    return s.children != null ? o.selectOpsAtDepth(s.children, i - 1) : s
                 }).flat()
-            }, r.prototype.addGateClickHandlers = function(e, i) {
-                this.addClassicalControlHandlers(e), this.addZoomHandlers(e, i)
-            }, r.prototype.addClassicalControlHandlers = function(e) {
-                e.querySelectorAll(".classically-controlled-btn").forEach(function(i) {
-                    i.addEventListener("click", function(a) {
-                        var l, c = i.querySelector("text"),
-                            d = i.parentElement;
-                        if (!(c == null || d == null)) {
-                            var f = (l = c.firstChild) === null || l === void 0 ? void 0 : l.nodeValue,
-                                g = d?.querySelector(".gates-zero"),
-                                y = d?.querySelector(".gates-one");
-                            switch (f) {
+            }, e.prototype.addGateClickHandlers = function(r, i) {
+                this.addClassicalControlHandlers(r), this.addZoomHandlers(r, i)
+            }, e.prototype.addClassicalControlHandlers = function(r) {
+                r.querySelectorAll(".classically-controlled-btn").forEach(function(i) {
+                    i.addEventListener("click", function(o) {
+                        var s, l = i.querySelector("text"),
+                            h = i.parentElement;
+                        if (!(l == null || h == null)) {
+                            var p = (s = l.firstChild) === null || s === void 0 ? void 0 : s.nodeValue,
+                                b = h?.querySelector(".gates-zero"),
+                                x = h?.querySelector(".gates-one");
+                            switch (p) {
                                 case "?":
-                                    c.childNodes[0].nodeValue = "1", d.classList.remove("classically-controlled-unknown"), d.classList.remove("classically-controlled-zero"), d.classList.add("classically-controlled-one"), g?.classList.add("hidden"), y?.classList.remove("hidden");
+                                    l.childNodes[0].nodeValue = "1", h.classList.remove("classically-controlled-unknown"), h.classList.remove("classically-controlled-zero"), h.classList.add("classically-controlled-one"), b?.classList.add("hidden"), x?.classList.remove("hidden");
                                     break;
                                 case "1":
-                                    c.childNodes[0].nodeValue = "0", d.classList.remove("classically-controlled-unknown"), d.classList.add("classically-controlled-zero"), d.classList.remove("classically-controlled-one"), g?.classList.remove("hidden"), y?.classList.add("hidden");
+                                    l.childNodes[0].nodeValue = "0", h.classList.remove("classically-controlled-unknown"), h.classList.add("classically-controlled-zero"), h.classList.remove("classically-controlled-one"), b?.classList.remove("hidden"), x?.classList.add("hidden");
                                     break;
                                 case "0":
-                                    c.childNodes[0].nodeValue = "?", d.classList.add("classically-controlled-unknown"), d.classList.remove("classically-controlled-zero"), d.classList.remove("classically-controlled-one"), g?.classList.remove("hidden"), y?.classList.remove("hidden");
+                                    l.childNodes[0].nodeValue = "?", h.classList.add("classically-controlled-unknown"), h.classList.remove("classically-controlled-zero"), h.classList.remove("classically-controlled-one"), b?.classList.remove("hidden"), x?.classList.remove("hidden");
                                     break
                             }
-                            a.stopPropagation()
+                            o.stopPropagation()
                         }
                     })
                 })
-            }, r.prototype.addZoomHandlers = function(e, i) {
-                var a = this;
-                e.querySelectorAll(".gate .gate-control").forEach(function(l) {
-                    l.addEventListener("click", function(c) {
-                        var d, f = (d = l.parentElement) === null || d === void 0 ? void 0 : d.getAttribute("data-id");
-                        typeof f == "string" && (l.classList.contains("gate-collapse") ? a.collapseOperation(i.operations, f) : l.classList.contains("gate-expand") && a.expandOperation(i.operations, f), a.renderCircuit(e, i), c.stopPropagation())
+            }, e.prototype.addZoomHandlers = function(r, i) {
+                var o = this;
+                r.querySelectorAll(".gate .gate-control").forEach(function(s) {
+                    s.addEventListener("click", function(l) {
+                        var h, p = (h = s.parentElement) === null || h === void 0 ? void 0 : h.getAttribute("data-id");
+                        typeof p == "string" && (s.classList.contains("gate-collapse") ? o.collapseOperation(i.operations, p) : s.classList.contains("gate-expand") && o.expandOperation(i.operations, p), o.renderCircuit(r, i), l.stopPropagation())
                     })
                 })
-            }, r.prototype.expandOperation = function(e, i) {
-                var a = this;
-                e.forEach(function(l) {
-                    if (l.conditionalRender === C0.ConditionalRender.AsGroup && a.expandOperation(l.children || [], i), l.dataAttributes == null) return l;
-                    var c = l.dataAttributes.id;
-                    c === i && l.children != null && (l.conditionalRender = C0.ConditionalRender.AsGroup, l.dataAttributes.expanded = "true")
+            }, e.prototype.expandOperation = function(r, i) {
+                var o = this;
+                r.forEach(function(s) {
+                    if (s.conditionalRender === Ir.ConditionalRender.AsGroup && o.expandOperation(s.children || [], i), s.dataAttributes == null) return s;
+                    var l = s.dataAttributes.id;
+                    l === i && s.children != null && (s.conditionalRender = Ir.ConditionalRender.AsGroup, s.dataAttributes.expanded = "true")
                 })
-            }, r.prototype.collapseOperation = function(e, i) {
-                var a = this;
-                e.forEach(function(l) {
-                    if (l.conditionalRender === C0.ConditionalRender.AsGroup && a.collapseOperation(l.children || [], i), l.dataAttributes == null) return l;
-                    var c = l.dataAttributes.id;
-                    c.startsWith(i) && (l.conditionalRender = C0.ConditionalRender.Always, delete l.dataAttributes.expanded)
+            }, e.prototype.collapseOperation = function(r, i) {
+                var o = this;
+                r.forEach(function(s) {
+                    if (s.conditionalRender === Ir.ConditionalRender.AsGroup && o.collapseOperation(s.children || [], i), s.dataAttributes == null) return s;
+                    var l = s.dataAttributes.id;
+                    l.startsWith(i) && (s.conditionalRender = Ir.ConditionalRender.Always, delete s.dataAttributes.expanded)
                 })
-            }, r
+            }, e
         }();
-    T0.Sqore = yd
+    Or.Sqore = cd
 });
-var ps = W(mr => {
+var ls = rt(_0 => {
     "use strict";
-    Object.defineProperty(mr, "__esModule", {
+    Object.defineProperty(_0, "__esModule", {
         value: !0
     });
-    mr.STYLES = mr.draw = void 0;
-    var xd = ms(),
-        vd = function(r, e, i, a) {
-            i === void 0 && (i = {}), a === void 0 && (a = 0);
-            var l = new xd.Sqore(r, i);
-            l.draw(e, a)
+    _0.STYLES = _0.draw = void 0;
+    var dd = ss(),
+        hd = function(e, r, i, o) {
+            i === void 0 && (i = {}), o === void 0 && (o = 0);
+            var s = new dd.Sqore(e, i);
+            s.draw(r, o)
         };
-    mr.draw = vd;
-    var wd = ei();
-    Object.defineProperty(mr, "STYLES", {
+    _0.draw = hd;
+    var fd = xu();
+    Object.defineProperty(_0, "STYLES", {
         enumerable: !0,
         get: function() {
-            return wd.STYLES
+            return fd.STYLES
         }
     })
 });
-var gs = W((j4, Cd) => {
-    Cd.exports = {
-        Aacute: "\xC1",
-        aacute: "\xE1",
-        Abreve: "\u0102",
-        abreve: "\u0103",
-        ac: "\u223E",
-        acd: "\u223F",
-        acE: "\u223E\u0333",
-        Acirc: "\xC2",
-        acirc: "\xE2",
-        acute: "\xB4",
-        Acy: "\u0410",
-        acy: "\u0430",
-        AElig: "\xC6",
-        aelig: "\xE6",
-        af: "\u2061",
-        Afr: "\u{1D504}",
-        afr: "\u{1D51E}",
-        Agrave: "\xC0",
-        agrave: "\xE0",
-        alefsym: "\u2135",
-        aleph: "\u2135",
-        Alpha: "\u0391",
-        alpha: "\u03B1",
-        Amacr: "\u0100",
-        amacr: "\u0101",
-        amalg: "\u2A3F",
-        amp: "&",
-        AMP: "&",
-        andand: "\u2A55",
-        And: "\u2A53",
-        and: "\u2227",
-        andd: "\u2A5C",
-        andslope: "\u2A58",
-        andv: "\u2A5A",
-        ang: "\u2220",
-        ange: "\u29A4",
-        angle: "\u2220",
-        angmsdaa: "\u29A8",
-        angmsdab: "\u29A9",
-        angmsdac: "\u29AA",
-        angmsdad: "\u29AB",
-        angmsdae: "\u29AC",
-        angmsdaf: "\u29AD",
-        angmsdag: "\u29AE",
-        angmsdah: "\u29AF",
-        angmsd: "\u2221",
-        angrt: "\u221F",
-        angrtvb: "\u22BE",
-        angrtvbd: "\u299D",
-        angsph: "\u2222",
-        angst: "\xC5",
-        angzarr: "\u237C",
-        Aogon: "\u0104",
-        aogon: "\u0105",
-        Aopf: "\u{1D538}",
-        aopf: "\u{1D552}",
-        apacir: "\u2A6F",
-        ap: "\u2248",
-        apE: "\u2A70",
-        ape: "\u224A",
-        apid: "\u224B",
-        apos: "'",
-        ApplyFunction: "\u2061",
-        approx: "\u2248",
-        approxeq: "\u224A",
-        Aring: "\xC5",
-        aring: "\xE5",
-        Ascr: "\u{1D49C}",
-        ascr: "\u{1D4B6}",
-        Assign: "\u2254",
-        ast: "*",
-        asymp: "\u2248",
-        asympeq: "\u224D",
-        Atilde: "\xC3",
-        atilde: "\xE3",
-        Auml: "\xC4",
-        auml: "\xE4",
-        awconint: "\u2233",
-        awint: "\u2A11",
-        backcong: "\u224C",
-        backepsilon: "\u03F6",
-        backprime: "\u2035",
-        backsim: "\u223D",
-        backsimeq: "\u22CD",
-        Backslash: "\u2216",
-        Barv: "\u2AE7",
-        barvee: "\u22BD",
-        barwed: "\u2305",
-        Barwed: "\u2306",
-        barwedge: "\u2305",
-        bbrk: "\u23B5",
-        bbrktbrk: "\u23B6",
-        bcong: "\u224C",
-        Bcy: "\u0411",
-        bcy: "\u0431",
-        bdquo: "\u201E",
-        becaus: "\u2235",
-        because: "\u2235",
-        Because: "\u2235",
-        bemptyv: "\u29B0",
-        bepsi: "\u03F6",
-        bernou: "\u212C",
-        Bernoullis: "\u212C",
-        Beta: "\u0392",
-        beta: "\u03B2",
-        beth: "\u2136",
-        between: "\u226C",
-        Bfr: "\u{1D505}",
-        bfr: "\u{1D51F}",
-        bigcap: "\u22C2",
-        bigcirc: "\u25EF",
-        bigcup: "\u22C3",
-        bigodot: "\u2A00",
-        bigoplus: "\u2A01",
-        bigotimes: "\u2A02",
-        bigsqcup: "\u2A06",
-        bigstar: "\u2605",
-        bigtriangledown: "\u25BD",
-        bigtriangleup: "\u25B3",
-        biguplus: "\u2A04",
-        bigvee: "\u22C1",
-        bigwedge: "\u22C0",
-        bkarow: "\u290D",
-        blacklozenge: "\u29EB",
-        blacksquare: "\u25AA",
-        blacktriangle: "\u25B4",
-        blacktriangledown: "\u25BE",
-        blacktriangleleft: "\u25C2",
-        blacktriangleright: "\u25B8",
-        blank: "\u2423",
-        blk12: "\u2592",
-        blk14: "\u2591",
-        blk34: "\u2593",
-        block: "\u2588",
-        bne: "=\u20E5",
-        bnequiv: "\u2261\u20E5",
-        bNot: "\u2AED",
-        bnot: "\u2310",
-        Bopf: "\u{1D539}",
-        bopf: "\u{1D553}",
-        bot: "\u22A5",
-        bottom: "\u22A5",
-        bowtie: "\u22C8",
-        boxbox: "\u29C9",
-        boxdl: "\u2510",
-        boxdL: "\u2555",
-        boxDl: "\u2556",
-        boxDL: "\u2557",
-        boxdr: "\u250C",
-        boxdR: "\u2552",
-        boxDr: "\u2553",
-        boxDR: "\u2554",
-        boxh: "\u2500",
-        boxH: "\u2550",
-        boxhd: "\u252C",
-        boxHd: "\u2564",
-        boxhD: "\u2565",
-        boxHD: "\u2566",
-        boxhu: "\u2534",
-        boxHu: "\u2567",
-        boxhU: "\u2568",
-        boxHU: "\u2569",
-        boxminus: "\u229F",
-        boxplus: "\u229E",
-        boxtimes: "\u22A0",
-        boxul: "\u2518",
-        boxuL: "\u255B",
-        boxUl: "\u255C",
-        boxUL: "\u255D",
-        boxur: "\u2514",
-        boxuR: "\u2558",
-        boxUr: "\u2559",
-        boxUR: "\u255A",
-        boxv: "\u2502",
-        boxV: "\u2551",
-        boxvh: "\u253C",
-        boxvH: "\u256A",
-        boxVh: "\u256B",
-        boxVH: "\u256C",
-        boxvl: "\u2524",
-        boxvL: "\u2561",
-        boxVl: "\u2562",
-        boxVL: "\u2563",
-        boxvr: "\u251C",
-        boxvR: "\u255E",
-        boxVr: "\u255F",
-        boxVR: "\u2560",
-        bprime: "\u2035",
-        breve: "\u02D8",
-        Breve: "\u02D8",
-        brvbar: "\xA6",
-        bscr: "\u{1D4B7}",
-        Bscr: "\u212C",
-        bsemi: "\u204F",
-        bsim: "\u223D",
-        bsime: "\u22CD",
-        bsolb: "\u29C5",
-        bsol: "\\",
-        bsolhsub: "\u27C8",
-        bull: "\u2022",
-        bullet: "\u2022",
-        bump: "\u224E",
-        bumpE: "\u2AAE",
-        bumpe: "\u224F",
-        Bumpeq: "\u224E",
-        bumpeq: "\u224F",
-        Cacute: "\u0106",
-        cacute: "\u0107",
-        capand: "\u2A44",
-        capbrcup: "\u2A49",
-        capcap: "\u2A4B",
-        cap: "\u2229",
-        Cap: "\u22D2",
-        capcup: "\u2A47",
-        capdot: "\u2A40",
-        CapitalDifferentialD: "\u2145",
-        caps: "\u2229\uFE00",
-        caret: "\u2041",
-        caron: "\u02C7",
-        Cayleys: "\u212D",
-        ccaps: "\u2A4D",
-        Ccaron: "\u010C",
-        ccaron: "\u010D",
-        Ccedil: "\xC7",
-        ccedil: "\xE7",
-        Ccirc: "\u0108",
-        ccirc: "\u0109",
-        Cconint: "\u2230",
-        ccups: "\u2A4C",
-        ccupssm: "\u2A50",
-        Cdot: "\u010A",
-        cdot: "\u010B",
-        cedil: "\xB8",
-        Cedilla: "\xB8",
-        cemptyv: "\u29B2",
-        cent: "\xA2",
-        centerdot: "\xB7",
-        CenterDot: "\xB7",
-        cfr: "\u{1D520}",
-        Cfr: "\u212D",
-        CHcy: "\u0427",
-        chcy: "\u0447",
-        check: "\u2713",
-        checkmark: "\u2713",
-        Chi: "\u03A7",
-        chi: "\u03C7",
-        circ: "\u02C6",
-        circeq: "\u2257",
-        circlearrowleft: "\u21BA",
-        circlearrowright: "\u21BB",
-        circledast: "\u229B",
-        circledcirc: "\u229A",
-        circleddash: "\u229D",
-        CircleDot: "\u2299",
-        circledR: "\xAE",
-        circledS: "\u24C8",
-        CircleMinus: "\u2296",
-        CirclePlus: "\u2295",
-        CircleTimes: "\u2297",
-        cir: "\u25CB",
-        cirE: "\u29C3",
-        cire: "\u2257",
-        cirfnint: "\u2A10",
-        cirmid: "\u2AEF",
-        cirscir: "\u29C2",
-        ClockwiseContourIntegral: "\u2232",
-        CloseCurlyDoubleQuote: "\u201D",
-        CloseCurlyQuote: "\u2019",
-        clubs: "\u2663",
-        clubsuit: "\u2663",
-        colon: ":",
-        Colon: "\u2237",
-        Colone: "\u2A74",
-        colone: "\u2254",
-        coloneq: "\u2254",
-        comma: ",",
-        commat: "@",
-        comp: "\u2201",
-        compfn: "\u2218",
-        complement: "\u2201",
-        complexes: "\u2102",
-        cong: "\u2245",
-        congdot: "\u2A6D",
-        Congruent: "\u2261",
-        conint: "\u222E",
-        Conint: "\u222F",
-        ContourIntegral: "\u222E",
-        copf: "\u{1D554}",
-        Copf: "\u2102",
-        coprod: "\u2210",
-        Coproduct: "\u2210",
-        copy: "\xA9",
-        COPY: "\xA9",
-        copysr: "\u2117",
-        CounterClockwiseContourIntegral: "\u2233",
-        crarr: "\u21B5",
-        cross: "\u2717",
-        Cross: "\u2A2F",
-        Cscr: "\u{1D49E}",
-        cscr: "\u{1D4B8}",
-        csub: "\u2ACF",
-        csube: "\u2AD1",
-        csup: "\u2AD0",
-        csupe: "\u2AD2",
-        ctdot: "\u22EF",
-        cudarrl: "\u2938",
-        cudarrr: "\u2935",
-        cuepr: "\u22DE",
-        cuesc: "\u22DF",
-        cularr: "\u21B6",
-        cularrp: "\u293D",
-        cupbrcap: "\u2A48",
-        cupcap: "\u2A46",
-        CupCap: "\u224D",
-        cup: "\u222A",
-        Cup: "\u22D3",
-        cupcup: "\u2A4A",
-        cupdot: "\u228D",
-        cupor: "\u2A45",
-        cups: "\u222A\uFE00",
-        curarr: "\u21B7",
-        curarrm: "\u293C",
-        curlyeqprec: "\u22DE",
-        curlyeqsucc: "\u22DF",
-        curlyvee: "\u22CE",
-        curlywedge: "\u22CF",
-        curren: "\xA4",
-        curvearrowleft: "\u21B6",
-        curvearrowright: "\u21B7",
-        cuvee: "\u22CE",
-        cuwed: "\u22CF",
-        cwconint: "\u2232",
-        cwint: "\u2231",
-        cylcty: "\u232D",
-        dagger: "\u2020",
-        Dagger: "\u2021",
-        daleth: "\u2138",
-        darr: "\u2193",
-        Darr: "\u21A1",
-        dArr: "\u21D3",
-        dash: "\u2010",
-        Dashv: "\u2AE4",
-        dashv: "\u22A3",
-        dbkarow: "\u290F",
-        dblac: "\u02DD",
-        Dcaron: "\u010E",
-        dcaron: "\u010F",
-        Dcy: "\u0414",
-        dcy: "\u0434",
-        ddagger: "\u2021",
-        ddarr: "\u21CA",
-        DD: "\u2145",
-        dd: "\u2146",
-        DDotrahd: "\u2911",
-        ddotseq: "\u2A77",
-        deg: "\xB0",
-        Del: "\u2207",
-        Delta: "\u0394",
-        delta: "\u03B4",
-        demptyv: "\u29B1",
-        dfisht: "\u297F",
-        Dfr: "\u{1D507}",
-        dfr: "\u{1D521}",
-        dHar: "\u2965",
-        dharl: "\u21C3",
-        dharr: "\u21C2",
-        DiacriticalAcute: "\xB4",
-        DiacriticalDot: "\u02D9",
-        DiacriticalDoubleAcute: "\u02DD",
-        DiacriticalGrave: "`",
-        DiacriticalTilde: "\u02DC",
-        diam: "\u22C4",
-        diamond: "\u22C4",
-        Diamond: "\u22C4",
-        diamondsuit: "\u2666",
-        diams: "\u2666",
-        die: "\xA8",
-        DifferentialD: "\u2146",
-        digamma: "\u03DD",
-        disin: "\u22F2",
-        div: "\xF7",
-        divide: "\xF7",
-        divideontimes: "\u22C7",
-        divonx: "\u22C7",
-        DJcy: "\u0402",
-        djcy: "\u0452",
-        dlcorn: "\u231E",
-        dlcrop: "\u230D",
-        dollar: "$",
-        Dopf: "\u{1D53B}",
-        dopf: "\u{1D555}",
-        Dot: "\xA8",
-        dot: "\u02D9",
-        DotDot: "\u20DC",
-        doteq: "\u2250",
-        doteqdot: "\u2251",
-        DotEqual: "\u2250",
-        dotminus: "\u2238",
-        dotplus: "\u2214",
-        dotsquare: "\u22A1",
-        doublebarwedge: "\u2306",
-        DoubleContourIntegral: "\u222F",
-        DoubleDot: "\xA8",
-        DoubleDownArrow: "\u21D3",
-        DoubleLeftArrow: "\u21D0",
-        DoubleLeftRightArrow: "\u21D4",
-        DoubleLeftTee: "\u2AE4",
-        DoubleLongLeftArrow: "\u27F8",
-        DoubleLongLeftRightArrow: "\u27FA",
-        DoubleLongRightArrow: "\u27F9",
-        DoubleRightArrow: "\u21D2",
-        DoubleRightTee: "\u22A8",
-        DoubleUpArrow: "\u21D1",
-        DoubleUpDownArrow: "\u21D5",
-        DoubleVerticalBar: "\u2225",
-        DownArrowBar: "\u2913",
-        downarrow: "\u2193",
-        DownArrow: "\u2193",
-        Downarrow: "\u21D3",
-        DownArrowUpArrow: "\u21F5",
-        DownBreve: "\u0311",
-        downdownarrows: "\u21CA",
-        downharpoonleft: "\u21C3",
-        downharpoonright: "\u21C2",
-        DownLeftRightVector: "\u2950",
-        DownLeftTeeVector: "\u295E",
-        DownLeftVectorBar: "\u2956",
-        DownLeftVector: "\u21BD",
-        DownRightTeeVector: "\u295F",
-        DownRightVectorBar: "\u2957",
-        DownRightVector: "\u21C1",
-        DownTeeArrow: "\u21A7",
-        DownTee: "\u22A4",
-        drbkarow: "\u2910",
-        drcorn: "\u231F",
-        drcrop: "\u230C",
-        Dscr: "\u{1D49F}",
-        dscr: "\u{1D4B9}",
-        DScy: "\u0405",
-        dscy: "\u0455",
-        dsol: "\u29F6",
-        Dstrok: "\u0110",
-        dstrok: "\u0111",
-        dtdot: "\u22F1",
-        dtri: "\u25BF",
-        dtrif: "\u25BE",
-        duarr: "\u21F5",
-        duhar: "\u296F",
-        dwangle: "\u29A6",
-        DZcy: "\u040F",
-        dzcy: "\u045F",
-        dzigrarr: "\u27FF",
-        Eacute: "\xC9",
-        eacute: "\xE9",
-        easter: "\u2A6E",
-        Ecaron: "\u011A",
-        ecaron: "\u011B",
-        Ecirc: "\xCA",
-        ecirc: "\xEA",
-        ecir: "\u2256",
-        ecolon: "\u2255",
-        Ecy: "\u042D",
-        ecy: "\u044D",
-        eDDot: "\u2A77",
-        Edot: "\u0116",
-        edot: "\u0117",
-        eDot: "\u2251",
-        ee: "\u2147",
-        efDot: "\u2252",
-        Efr: "\u{1D508}",
-        efr: "\u{1D522}",
-        eg: "\u2A9A",
-        Egrave: "\xC8",
-        egrave: "\xE8",
-        egs: "\u2A96",
-        egsdot: "\u2A98",
-        el: "\u2A99",
-        Element: "\u2208",
-        elinters: "\u23E7",
-        ell: "\u2113",
-        els: "\u2A95",
-        elsdot: "\u2A97",
-        Emacr: "\u0112",
-        emacr: "\u0113",
-        empty: "\u2205",
-        emptyset: "\u2205",
-        EmptySmallSquare: "\u25FB",
-        emptyv: "\u2205",
-        EmptyVerySmallSquare: "\u25AB",
-        emsp13: "\u2004",
-        emsp14: "\u2005",
-        emsp: "\u2003",
-        ENG: "\u014A",
-        eng: "\u014B",
-        ensp: "\u2002",
-        Eogon: "\u0118",
-        eogon: "\u0119",
-        Eopf: "\u{1D53C}",
-        eopf: "\u{1D556}",
-        epar: "\u22D5",
-        eparsl: "\u29E3",
-        eplus: "\u2A71",
-        epsi: "\u03B5",
-        Epsilon: "\u0395",
-        epsilon: "\u03B5",
-        epsiv: "\u03F5",
-        eqcirc: "\u2256",
-        eqcolon: "\u2255",
-        eqsim: "\u2242",
-        eqslantgtr: "\u2A96",
-        eqslantless: "\u2A95",
-        Equal: "\u2A75",
-        equals: "=",
-        EqualTilde: "\u2242",
-        equest: "\u225F",
-        Equilibrium: "\u21CC",
-        equiv: "\u2261",
-        equivDD: "\u2A78",
-        eqvparsl: "\u29E5",
-        erarr: "\u2971",
-        erDot: "\u2253",
-        escr: "\u212F",
-        Escr: "\u2130",
-        esdot: "\u2250",
-        Esim: "\u2A73",
-        esim: "\u2242",
-        Eta: "\u0397",
-        eta: "\u03B7",
-        ETH: "\xD0",
-        eth: "\xF0",
-        Euml: "\xCB",
-        euml: "\xEB",
-        euro: "\u20AC",
-        excl: "!",
-        exist: "\u2203",
-        Exists: "\u2203",
-        expectation: "\u2130",
-        exponentiale: "\u2147",
-        ExponentialE: "\u2147",
-        fallingdotseq: "\u2252",
-        Fcy: "\u0424",
-        fcy: "\u0444",
-        female: "\u2640",
-        ffilig: "\uFB03",
-        fflig: "\uFB00",
-        ffllig: "\uFB04",
-        Ffr: "\u{1D509}",
-        ffr: "\u{1D523}",
-        filig: "\uFB01",
-        FilledSmallSquare: "\u25FC",
-        FilledVerySmallSquare: "\u25AA",
-        fjlig: "fj",
-        flat: "\u266D",
-        fllig: "\uFB02",
-        fltns: "\u25B1",
-        fnof: "\u0192",
-        Fopf: "\u{1D53D}",
-        fopf: "\u{1D557}",
-        forall: "\u2200",
-        ForAll: "\u2200",
-        fork: "\u22D4",
-        forkv: "\u2AD9",
-        Fouriertrf: "\u2131",
-        fpartint: "\u2A0D",
-        frac12: "\xBD",
-        frac13: "\u2153",
-        frac14: "\xBC",
-        frac15: "\u2155",
-        frac16: "\u2159",
-        frac18: "\u215B",
-        frac23: "\u2154",
-        frac25: "\u2156",
-        frac34: "\xBE",
-        frac35: "\u2157",
-        frac38: "\u215C",
-        frac45: "\u2158",
-        frac56: "\u215A",
-        frac58: "\u215D",
-        frac78: "\u215E",
-        frasl: "\u2044",
-        frown: "\u2322",
-        fscr: "\u{1D4BB}",
-        Fscr: "\u2131",
-        gacute: "\u01F5",
-        Gamma: "\u0393",
-        gamma: "\u03B3",
-        Gammad: "\u03DC",
-        gammad: "\u03DD",
-        gap: "\u2A86",
-        Gbreve: "\u011E",
-        gbreve: "\u011F",
-        Gcedil: "\u0122",
-        Gcirc: "\u011C",
-        gcirc: "\u011D",
-        Gcy: "\u0413",
-        gcy: "\u0433",
-        Gdot: "\u0120",
-        gdot: "\u0121",
-        ge: "\u2265",
-        gE: "\u2267",
-        gEl: "\u2A8C",
-        gel: "\u22DB",
-        geq: "\u2265",
-        geqq: "\u2267",
-        geqslant: "\u2A7E",
-        gescc: "\u2AA9",
-        ges: "\u2A7E",
-        gesdot: "\u2A80",
-        gesdoto: "\u2A82",
-        gesdotol: "\u2A84",
-        gesl: "\u22DB\uFE00",
-        gesles: "\u2A94",
-        Gfr: "\u{1D50A}",
-        gfr: "\u{1D524}",
-        gg: "\u226B",
-        Gg: "\u22D9",
-        ggg: "\u22D9",
-        gimel: "\u2137",
-        GJcy: "\u0403",
-        gjcy: "\u0453",
-        gla: "\u2AA5",
-        gl: "\u2277",
-        glE: "\u2A92",
-        glj: "\u2AA4",
-        gnap: "\u2A8A",
-        gnapprox: "\u2A8A",
-        gne: "\u2A88",
-        gnE: "\u2269",
-        gneq: "\u2A88",
-        gneqq: "\u2269",
-        gnsim: "\u22E7",
-        Gopf: "\u{1D53E}",
-        gopf: "\u{1D558}",
-        grave: "`",
-        GreaterEqual: "\u2265",
-        GreaterEqualLess: "\u22DB",
-        GreaterFullEqual: "\u2267",
-        GreaterGreater: "\u2AA2",
-        GreaterLess: "\u2277",
-        GreaterSlantEqual: "\u2A7E",
-        GreaterTilde: "\u2273",
-        Gscr: "\u{1D4A2}",
-        gscr: "\u210A",
-        gsim: "\u2273",
-        gsime: "\u2A8E",
-        gsiml: "\u2A90",
-        gtcc: "\u2AA7",
-        gtcir: "\u2A7A",
-        gt: ">",
-        GT: ">",
-        Gt: "\u226B",
-        gtdot: "\u22D7",
-        gtlPar: "\u2995",
-        gtquest: "\u2A7C",
-        gtrapprox: "\u2A86",
-        gtrarr: "\u2978",
-        gtrdot: "\u22D7",
-        gtreqless: "\u22DB",
-        gtreqqless: "\u2A8C",
-        gtrless: "\u2277",
-        gtrsim: "\u2273",
-        gvertneqq: "\u2269\uFE00",
-        gvnE: "\u2269\uFE00",
-        Hacek: "\u02C7",
-        hairsp: "\u200A",
-        half: "\xBD",
-        hamilt: "\u210B",
-        HARDcy: "\u042A",
-        hardcy: "\u044A",
-        harrcir: "\u2948",
-        harr: "\u2194",
-        hArr: "\u21D4",
-        harrw: "\u21AD",
-        Hat: "^",
-        hbar: "\u210F",
-        Hcirc: "\u0124",
-        hcirc: "\u0125",
-        hearts: "\u2665",
-        heartsuit: "\u2665",
-        hellip: "\u2026",
-        hercon: "\u22B9",
-        hfr: "\u{1D525}",
-        Hfr: "\u210C",
-        HilbertSpace: "\u210B",
-        hksearow: "\u2925",
-        hkswarow: "\u2926",
-        hoarr: "\u21FF",
-        homtht: "\u223B",
-        hookleftarrow: "\u21A9",
-        hookrightarrow: "\u21AA",
-        hopf: "\u{1D559}",
-        Hopf: "\u210D",
-        horbar: "\u2015",
-        HorizontalLine: "\u2500",
-        hscr: "\u{1D4BD}",
-        Hscr: "\u210B",
-        hslash: "\u210F",
-        Hstrok: "\u0126",
-        hstrok: "\u0127",
-        HumpDownHump: "\u224E",
-        HumpEqual: "\u224F",
-        hybull: "\u2043",
-        hyphen: "\u2010",
-        Iacute: "\xCD",
-        iacute: "\xED",
-        ic: "\u2063",
-        Icirc: "\xCE",
-        icirc: "\xEE",
-        Icy: "\u0418",
-        icy: "\u0438",
-        Idot: "\u0130",
-        IEcy: "\u0415",
-        iecy: "\u0435",
-        iexcl: "\xA1",
-        iff: "\u21D4",
-        ifr: "\u{1D526}",
-        Ifr: "\u2111",
-        Igrave: "\xCC",
-        igrave: "\xEC",
-        ii: "\u2148",
-        iiiint: "\u2A0C",
-        iiint: "\u222D",
-        iinfin: "\u29DC",
-        iiota: "\u2129",
-        IJlig: "\u0132",
-        ijlig: "\u0133",
-        Imacr: "\u012A",
-        imacr: "\u012B",
-        image: "\u2111",
-        ImaginaryI: "\u2148",
-        imagline: "\u2110",
-        imagpart: "\u2111",
-        imath: "\u0131",
-        Im: "\u2111",
-        imof: "\u22B7",
-        imped: "\u01B5",
-        Implies: "\u21D2",
-        incare: "\u2105",
-        in: "\u2208",
-        infin: "\u221E",
-        infintie: "\u29DD",
-        inodot: "\u0131",
-        intcal: "\u22BA",
-        int: "\u222B",
-        Int: "\u222C",
-        integers: "\u2124",
-        Integral: "\u222B",
-        intercal: "\u22BA",
-        Intersection: "\u22C2",
-        intlarhk: "\u2A17",
-        intprod: "\u2A3C",
-        InvisibleComma: "\u2063",
-        InvisibleTimes: "\u2062",
-        IOcy: "\u0401",
-        iocy: "\u0451",
-        Iogon: "\u012E",
-        iogon: "\u012F",
-        Iopf: "\u{1D540}",
-        iopf: "\u{1D55A}",
-        Iota: "\u0399",
-        iota: "\u03B9",
-        iprod: "\u2A3C",
-        iquest: "\xBF",
-        iscr: "\u{1D4BE}",
-        Iscr: "\u2110",
-        isin: "\u2208",
-        isindot: "\u22F5",
-        isinE: "\u22F9",
-        isins: "\u22F4",
-        isinsv: "\u22F3",
-        isinv: "\u2208",
-        it: "\u2062",
-        Itilde: "\u0128",
-        itilde: "\u0129",
-        Iukcy: "\u0406",
-        iukcy: "\u0456",
-        Iuml: "\xCF",
-        iuml: "\xEF",
-        Jcirc: "\u0134",
-        jcirc: "\u0135",
-        Jcy: "\u0419",
-        jcy: "\u0439",
-        Jfr: "\u{1D50D}",
-        jfr: "\u{1D527}",
-        jmath: "\u0237",
-        Jopf: "\u{1D541}",
-        jopf: "\u{1D55B}",
-        Jscr: "\u{1D4A5}",
-        jscr: "\u{1D4BF}",
-        Jsercy: "\u0408",
-        jsercy: "\u0458",
-        Jukcy: "\u0404",
-        jukcy: "\u0454",
-        Kappa: "\u039A",
-        kappa: "\u03BA",
-        kappav: "\u03F0",
-        Kcedil: "\u0136",
-        kcedil: "\u0137",
-        Kcy: "\u041A",
-        kcy: "\u043A",
-        Kfr: "\u{1D50E}",
-        kfr: "\u{1D528}",
-        kgreen: "\u0138",
-        KHcy: "\u0425",
-        khcy: "\u0445",
-        KJcy: "\u040C",
-        kjcy: "\u045C",
-        Kopf: "\u{1D542}",
-        kopf: "\u{1D55C}",
-        Kscr: "\u{1D4A6}",
-        kscr: "\u{1D4C0}",
-        lAarr: "\u21DA",
-        Lacute: "\u0139",
-        lacute: "\u013A",
-        laemptyv: "\u29B4",
-        lagran: "\u2112",
-        Lambda: "\u039B",
-        lambda: "\u03BB",
-        lang: "\u27E8",
-        Lang: "\u27EA",
-        langd: "\u2991",
-        langle: "\u27E8",
-        lap: "\u2A85",
-        Laplacetrf: "\u2112",
-        laquo: "\xAB",
-        larrb: "\u21E4",
-        larrbfs: "\u291F",
-        larr: "\u2190",
-        Larr: "\u219E",
-        lArr: "\u21D0",
-        larrfs: "\u291D",
-        larrhk: "\u21A9",
-        larrlp: "\u21AB",
-        larrpl: "\u2939",
-        larrsim: "\u2973",
-        larrtl: "\u21A2",
-        latail: "\u2919",
-        lAtail: "\u291B",
-        lat: "\u2AAB",
-        late: "\u2AAD",
-        lates: "\u2AAD\uFE00",
-        lbarr: "\u290C",
-        lBarr: "\u290E",
-        lbbrk: "\u2772",
-        lbrace: "{",
-        lbrack: "[",
-        lbrke: "\u298B",
-        lbrksld: "\u298F",
-        lbrkslu: "\u298D",
-        Lcaron: "\u013D",
-        lcaron: "\u013E",
-        Lcedil: "\u013B",
-        lcedil: "\u013C",
-        lceil: "\u2308",
-        lcub: "{",
-        Lcy: "\u041B",
-        lcy: "\u043B",
-        ldca: "\u2936",
-        ldquo: "\u201C",
-        ldquor: "\u201E",
-        ldrdhar: "\u2967",
-        ldrushar: "\u294B",
-        ldsh: "\u21B2",
-        le: "\u2264",
-        lE: "\u2266",
-        LeftAngleBracket: "\u27E8",
-        LeftArrowBar: "\u21E4",
-        leftarrow: "\u2190",
-        LeftArrow: "\u2190",
-        Leftarrow: "\u21D0",
-        LeftArrowRightArrow: "\u21C6",
-        leftarrowtail: "\u21A2",
-        LeftCeiling: "\u2308",
-        LeftDoubleBracket: "\u27E6",
-        LeftDownTeeVector: "\u2961",
-        LeftDownVectorBar: "\u2959",
-        LeftDownVector: "\u21C3",
-        LeftFloor: "\u230A",
-        leftharpoondown: "\u21BD",
-        leftharpoonup: "\u21BC",
-        leftleftarrows: "\u21C7",
-        leftrightarrow: "\u2194",
-        LeftRightArrow: "\u2194",
-        Leftrightarrow: "\u21D4",
-        leftrightarrows: "\u21C6",
-        leftrightharpoons: "\u21CB",
-        leftrightsquigarrow: "\u21AD",
-        LeftRightVector: "\u294E",
-        LeftTeeArrow: "\u21A4",
-        LeftTee: "\u22A3",
-        LeftTeeVector: "\u295A",
-        leftthreetimes: "\u22CB",
-        LeftTriangleBar: "\u29CF",
-        LeftTriangle: "\u22B2",
-        LeftTriangleEqual: "\u22B4",
-        LeftUpDownVector: "\u2951",
-        LeftUpTeeVector: "\u2960",
-        LeftUpVectorBar: "\u2958",
-        LeftUpVector: "\u21BF",
-        LeftVectorBar: "\u2952",
-        LeftVector: "\u21BC",
-        lEg: "\u2A8B",
-        leg: "\u22DA",
-        leq: "\u2264",
-        leqq: "\u2266",
-        leqslant: "\u2A7D",
-        lescc: "\u2AA8",
-        les: "\u2A7D",
-        lesdot: "\u2A7F",
-        lesdoto: "\u2A81",
-        lesdotor: "\u2A83",
-        lesg: "\u22DA\uFE00",
-        lesges: "\u2A93",
-        lessapprox: "\u2A85",
-        lessdot: "\u22D6",
-        lesseqgtr: "\u22DA",
-        lesseqqgtr: "\u2A8B",
-        LessEqualGreater: "\u22DA",
-        LessFullEqual: "\u2266",
-        LessGreater: "\u2276",
-        lessgtr: "\u2276",
-        LessLess: "\u2AA1",
-        lesssim: "\u2272",
-        LessSlantEqual: "\u2A7D",
-        LessTilde: "\u2272",
-        lfisht: "\u297C",
-        lfloor: "\u230A",
-        Lfr: "\u{1D50F}",
-        lfr: "\u{1D529}",
-        lg: "\u2276",
-        lgE: "\u2A91",
-        lHar: "\u2962",
-        lhard: "\u21BD",
-        lharu: "\u21BC",
-        lharul: "\u296A",
-        lhblk: "\u2584",
-        LJcy: "\u0409",
-        ljcy: "\u0459",
-        llarr: "\u21C7",
-        ll: "\u226A",
-        Ll: "\u22D8",
-        llcorner: "\u231E",
-        Lleftarrow: "\u21DA",
-        llhard: "\u296B",
-        lltri: "\u25FA",
-        Lmidot: "\u013F",
-        lmidot: "\u0140",
-        lmoustache: "\u23B0",
-        lmoust: "\u23B0",
-        lnap: "\u2A89",
-        lnapprox: "\u2A89",
-        lne: "\u2A87",
-        lnE: "\u2268",
-        lneq: "\u2A87",
-        lneqq: "\u2268",
-        lnsim: "\u22E6",
-        loang: "\u27EC",
-        loarr: "\u21FD",
-        lobrk: "\u27E6",
-        longleftarrow: "\u27F5",
-        LongLeftArrow: "\u27F5",
-        Longleftarrow: "\u27F8",
-        longleftrightarrow: "\u27F7",
-        LongLeftRightArrow: "\u27F7",
-        Longleftrightarrow: "\u27FA",
-        longmapsto: "\u27FC",
-        longrightarrow: "\u27F6",
-        LongRightArrow: "\u27F6",
-        Longrightarrow: "\u27F9",
-        looparrowleft: "\u21AB",
-        looparrowright: "\u21AC",
-        lopar: "\u2985",
-        Lopf: "\u{1D543}",
-        lopf: "\u{1D55D}",
-        loplus: "\u2A2D",
-        lotimes: "\u2A34",
-        lowast: "\u2217",
-        lowbar: "_",
-        LowerLeftArrow: "\u2199",
-        LowerRightArrow: "\u2198",
-        loz: "\u25CA",
-        lozenge: "\u25CA",
-        lozf: "\u29EB",
-        lpar: "(",
-        lparlt: "\u2993",
-        lrarr: "\u21C6",
-        lrcorner: "\u231F",
-        lrhar: "\u21CB",
-        lrhard: "\u296D",
-        lrm: "\u200E",
-        lrtri: "\u22BF",
-        lsaquo: "\u2039",
-        lscr: "\u{1D4C1}",
-        Lscr: "\u2112",
-        lsh: "\u21B0",
-        Lsh: "\u21B0",
-        lsim: "\u2272",
-        lsime: "\u2A8D",
-        lsimg: "\u2A8F",
-        lsqb: "[",
-        lsquo: "\u2018",
-        lsquor: "\u201A",
-        Lstrok: "\u0141",
-        lstrok: "\u0142",
-        ltcc: "\u2AA6",
-        ltcir: "\u2A79",
-        lt: "<",
-        LT: "<",
-        Lt: "\u226A",
-        ltdot: "\u22D6",
-        lthree: "\u22CB",
-        ltimes: "\u22C9",
-        ltlarr: "\u2976",
-        ltquest: "\u2A7B",
-        ltri: "\u25C3",
-        ltrie: "\u22B4",
-        ltrif: "\u25C2",
-        ltrPar: "\u2996",
-        lurdshar: "\u294A",
-        luruhar: "\u2966",
-        lvertneqq: "\u2268\uFE00",
-        lvnE: "\u2268\uFE00",
-        macr: "\xAF",
-        male: "\u2642",
-        malt: "\u2720",
-        maltese: "\u2720",
-        Map: "\u2905",
-        map: "\u21A6",
-        mapsto: "\u21A6",
-        mapstodown: "\u21A7",
-        mapstoleft: "\u21A4",
-        mapstoup: "\u21A5",
-        marker: "\u25AE",
-        mcomma: "\u2A29",
-        Mcy: "\u041C",
-        mcy: "\u043C",
-        mdash: "\u2014",
-        mDDot: "\u223A",
-        measuredangle: "\u2221",
-        MediumSpace: "\u205F",
-        Mellintrf: "\u2133",
-        Mfr: "\u{1D510}",
-        mfr: "\u{1D52A}",
-        mho: "\u2127",
-        micro: "\xB5",
-        midast: "*",
-        midcir: "\u2AF0",
-        mid: "\u2223",
-        middot: "\xB7",
-        minusb: "\u229F",
-        minus: "\u2212",
-        minusd: "\u2238",
-        minusdu: "\u2A2A",
-        MinusPlus: "\u2213",
-        mlcp: "\u2ADB",
-        mldr: "\u2026",
-        mnplus: "\u2213",
-        models: "\u22A7",
-        Mopf: "\u{1D544}",
-        mopf: "\u{1D55E}",
-        mp: "\u2213",
-        mscr: "\u{1D4C2}",
-        Mscr: "\u2133",
-        mstpos: "\u223E",
-        Mu: "\u039C",
-        mu: "\u03BC",
-        multimap: "\u22B8",
-        mumap: "\u22B8",
-        nabla: "\u2207",
-        Nacute: "\u0143",
-        nacute: "\u0144",
-        nang: "\u2220\u20D2",
-        nap: "\u2249",
-        napE: "\u2A70\u0338",
-        napid: "\u224B\u0338",
-        napos: "\u0149",
-        napprox: "\u2249",
-        natural: "\u266E",
-        naturals: "\u2115",
-        natur: "\u266E",
-        nbsp: "\xA0",
-        nbump: "\u224E\u0338",
-        nbumpe: "\u224F\u0338",
-        ncap: "\u2A43",
-        Ncaron: "\u0147",
-        ncaron: "\u0148",
-        Ncedil: "\u0145",
-        ncedil: "\u0146",
-        ncong: "\u2247",
-        ncongdot: "\u2A6D\u0338",
-        ncup: "\u2A42",
-        Ncy: "\u041D",
-        ncy: "\u043D",
-        ndash: "\u2013",
-        nearhk: "\u2924",
-        nearr: "\u2197",
-        neArr: "\u21D7",
-        nearrow: "\u2197",
-        ne: "\u2260",
-        nedot: "\u2250\u0338",
-        NegativeMediumSpace: "\u200B",
-        NegativeThickSpace: "\u200B",
-        NegativeThinSpace: "\u200B",
-        NegativeVeryThinSpace: "\u200B",
-        nequiv: "\u2262",
-        nesear: "\u2928",
-        nesim: "\u2242\u0338",
-        NestedGreaterGreater: "\u226B",
-        NestedLessLess: "\u226A",
-        NewLine: `
-`,
-        nexist: "\u2204",
-        nexists: "\u2204",
-        Nfr: "\u{1D511}",
-        nfr: "\u{1D52B}",
-        ngE: "\u2267\u0338",
-        nge: "\u2271",
-        ngeq: "\u2271",
-        ngeqq: "\u2267\u0338",
-        ngeqslant: "\u2A7E\u0338",
-        nges: "\u2A7E\u0338",
-        nGg: "\u22D9\u0338",
-        ngsim: "\u2275",
-        nGt: "\u226B\u20D2",
-        ngt: "\u226F",
-        ngtr: "\u226F",
-        nGtv: "\u226B\u0338",
-        nharr: "\u21AE",
-        nhArr: "\u21CE",
-        nhpar: "\u2AF2",
-        ni: "\u220B",
-        nis: "\u22FC",
-        nisd: "\u22FA",
-        niv: "\u220B",
-        NJcy: "\u040A",
-        njcy: "\u045A",
-        nlarr: "\u219A",
-        nlArr: "\u21CD",
-        nldr: "\u2025",
-        nlE: "\u2266\u0338",
-        nle: "\u2270",
-        nleftarrow: "\u219A",
-        nLeftarrow: "\u21CD",
-        nleftrightarrow: "\u21AE",
-        nLeftrightarrow: "\u21CE",
-        nleq: "\u2270",
-        nleqq: "\u2266\u0338",
-        nleqslant: "\u2A7D\u0338",
-        nles: "\u2A7D\u0338",
-        nless: "\u226E",
-        nLl: "\u22D8\u0338",
-        nlsim: "\u2274",
-        nLt: "\u226A\u20D2",
-        nlt: "\u226E",
-        nltri: "\u22EA",
-        nltrie: "\u22EC",
-        nLtv: "\u226A\u0338",
-        nmid: "\u2224",
-        NoBreak: "\u2060",
-        NonBreakingSpace: "\xA0",
-        nopf: "\u{1D55F}",
-        Nopf: "\u2115",
-        Not: "\u2AEC",
-        not: "\xAC",
-        NotCongruent: "\u2262",
-        NotCupCap: "\u226D",
-        NotDoubleVerticalBar: "\u2226",
-        NotElement: "\u2209",
-        NotEqual: "\u2260",
-        NotEqualTilde: "\u2242\u0338",
-        NotExists: "\u2204",
-        NotGreater: "\u226F",
-        NotGreaterEqual: "\u2271",
-        NotGreaterFullEqual: "\u2267\u0338",
-        NotGreaterGreater: "\u226B\u0338",
-        NotGreaterLess: "\u2279",
-        NotGreaterSlantEqual: "\u2A7E\u0338",
-        NotGreaterTilde: "\u2275",
-        NotHumpDownHump: "\u224E\u0338",
-        NotHumpEqual: "\u224F\u0338",
-        notin: "\u2209",
-        notindot: "\u22F5\u0338",
-        notinE: "\u22F9\u0338",
-        notinva: "\u2209",
-        notinvb: "\u22F7",
-        notinvc: "\u22F6",
-        NotLeftTriangleBar: "\u29CF\u0338",
-        NotLeftTriangle: "\u22EA",
-        NotLeftTriangleEqual: "\u22EC",
-        NotLess: "\u226E",
-        NotLessEqual: "\u2270",
-        NotLessGreater: "\u2278",
-        NotLessLess: "\u226A\u0338",
-        NotLessSlantEqual: "\u2A7D\u0338",
-        NotLessTilde: "\u2274",
-        NotNestedGreaterGreater: "\u2AA2\u0338",
-        NotNestedLessLess: "\u2AA1\u0338",
-        notni: "\u220C",
-        notniva: "\u220C",
-        notnivb: "\u22FE",
-        notnivc: "\u22FD",
-        NotPrecedes: "\u2280",
-        NotPrecedesEqual: "\u2AAF\u0338",
-        NotPrecedesSlantEqual: "\u22E0",
-        NotReverseElement: "\u220C",
-        NotRightTriangleBar: "\u29D0\u0338",
-        NotRightTriangle: "\u22EB",
-        NotRightTriangleEqual: "\u22ED",
-        NotSquareSubset: "\u228F\u0338",
-        NotSquareSubsetEqual: "\u22E2",
-        NotSquareSuperset: "\u2290\u0338",
-        NotSquareSupersetEqual: "\u22E3",
-        NotSubset: "\u2282\u20D2",
-        NotSubsetEqual: "\u2288",
-        NotSucceeds: "\u2281",
-        NotSucceedsEqual: "\u2AB0\u0338",
-        NotSucceedsSlantEqual: "\u22E1",
-        NotSucceedsTilde: "\u227F\u0338",
-        NotSuperset: "\u2283\u20D2",
-        NotSupersetEqual: "\u2289",
-        NotTilde: "\u2241",
-        NotTildeEqual: "\u2244",
-        NotTildeFullEqual: "\u2247",
-        NotTildeTilde: "\u2249",
-        NotVerticalBar: "\u2224",
-        nparallel: "\u2226",
-        npar: "\u2226",
-        nparsl: "\u2AFD\u20E5",
-        npart: "\u2202\u0338",
-        npolint: "\u2A14",
-        npr: "\u2280",
-        nprcue: "\u22E0",
-        nprec: "\u2280",
-        npreceq: "\u2AAF\u0338",
-        npre: "\u2AAF\u0338",
-        nrarrc: "\u2933\u0338",
-        nrarr: "\u219B",
-        nrArr: "\u21CF",
-        nrarrw: "\u219D\u0338",
-        nrightarrow: "\u219B",
-        nRightarrow: "\u21CF",
-        nrtri: "\u22EB",
-        nrtrie: "\u22ED",
-        nsc: "\u2281",
-        nsccue: "\u22E1",
-        nsce: "\u2AB0\u0338",
-        Nscr: "\u{1D4A9}",
-        nscr: "\u{1D4C3}",
-        nshortmid: "\u2224",
-        nshortparallel: "\u2226",
-        nsim: "\u2241",
-        nsime: "\u2244",
-        nsimeq: "\u2244",
-        nsmid: "\u2224",
-        nspar: "\u2226",
-        nsqsube: "\u22E2",
-        nsqsupe: "\u22E3",
-        nsub: "\u2284",
-        nsubE: "\u2AC5\u0338",
-        nsube: "\u2288",
-        nsubset: "\u2282\u20D2",
-        nsubseteq: "\u2288",
-        nsubseteqq: "\u2AC5\u0338",
-        nsucc: "\u2281",
-        nsucceq: "\u2AB0\u0338",
-        nsup: "\u2285",
-        nsupE: "\u2AC6\u0338",
-        nsupe: "\u2289",
-        nsupset: "\u2283\u20D2",
-        nsupseteq: "\u2289",
-        nsupseteqq: "\u2AC6\u0338",
-        ntgl: "\u2279",
-        Ntilde: "\xD1",
-        ntilde: "\xF1",
-        ntlg: "\u2278",
-        ntriangleleft: "\u22EA",
-        ntrianglelefteq: "\u22EC",
-        ntriangleright: "\u22EB",
-        ntrianglerighteq: "\u22ED",
-        Nu: "\u039D",
-        nu: "\u03BD",
-        num: "#",
-        numero: "\u2116",
-        numsp: "\u2007",
-        nvap: "\u224D\u20D2",
-        nvdash: "\u22AC",
-        nvDash: "\u22AD",
-        nVdash: "\u22AE",
-        nVDash: "\u22AF",
-        nvge: "\u2265\u20D2",
-        nvgt: ">\u20D2",
-        nvHarr: "\u2904",
-        nvinfin: "\u29DE",
-        nvlArr: "\u2902",
-        nvle: "\u2264\u20D2",
-        nvlt: "<\u20D2",
-        nvltrie: "\u22B4\u20D2",
-        nvrArr: "\u2903",
-        nvrtrie: "\u22B5\u20D2",
-        nvsim: "\u223C\u20D2",
-        nwarhk: "\u2923",
-        nwarr: "\u2196",
-        nwArr: "\u21D6",
-        nwarrow: "\u2196",
-        nwnear: "\u2927",
-        Oacute: "\xD3",
-        oacute: "\xF3",
-        oast: "\u229B",
-        Ocirc: "\xD4",
-        ocirc: "\xF4",
-        ocir: "\u229A",
-        Ocy: "\u041E",
-        ocy: "\u043E",
-        odash: "\u229D",
-        Odblac: "\u0150",
-        odblac: "\u0151",
-        odiv: "\u2A38",
-        odot: "\u2299",
-        odsold: "\u29BC",
-        OElig: "\u0152",
-        oelig: "\u0153",
-        ofcir: "\u29BF",
-        Ofr: "\u{1D512}",
-        ofr: "\u{1D52C}",
-        ogon: "\u02DB",
-        Ograve: "\xD2",
-        ograve: "\xF2",
-        ogt: "\u29C1",
-        ohbar: "\u29B5",
-        ohm: "\u03A9",
-        oint: "\u222E",
-        olarr: "\u21BA",
-        olcir: "\u29BE",
-        olcross: "\u29BB",
-        oline: "\u203E",
-        olt: "\u29C0",
-        Omacr: "\u014C",
-        omacr: "\u014D",
-        Omega: "\u03A9",
-        omega: "\u03C9",
-        Omicron: "\u039F",
-        omicron: "\u03BF",
-        omid: "\u29B6",
-        ominus: "\u2296",
-        Oopf: "\u{1D546}",
-        oopf: "\u{1D560}",
-        opar: "\u29B7",
-        OpenCurlyDoubleQuote: "\u201C",
-        OpenCurlyQuote: "\u2018",
-        operp: "\u29B9",
-        oplus: "\u2295",
-        orarr: "\u21BB",
-        Or: "\u2A54",
-        or: "\u2228",
-        ord: "\u2A5D",
-        order: "\u2134",
-        orderof: "\u2134",
-        ordf: "\xAA",
-        ordm: "\xBA",
-        origof: "\u22B6",
-        oror: "\u2A56",
-        orslope: "\u2A57",
-        orv: "\u2A5B",
-        oS: "\u24C8",
-        Oscr: "\u{1D4AA}",
-        oscr: "\u2134",
-        Oslash: "\xD8",
-        oslash: "\xF8",
-        osol: "\u2298",
-        Otilde: "\xD5",
-        otilde: "\xF5",
-        otimesas: "\u2A36",
-        Otimes: "\u2A37",
-        otimes: "\u2297",
-        Ouml: "\xD6",
-        ouml: "\xF6",
-        ovbar: "\u233D",
-        OverBar: "\u203E",
-        OverBrace: "\u23DE",
-        OverBracket: "\u23B4",
-        OverParenthesis: "\u23DC",
-        para: "\xB6",
-        parallel: "\u2225",
-        par: "\u2225",
-        parsim: "\u2AF3",
-        parsl: "\u2AFD",
-        part: "\u2202",
-        PartialD: "\u2202",
-        Pcy: "\u041F",
-        pcy: "\u043F",
-        percnt: "%",
-        period: ".",
-        permil: "\u2030",
-        perp: "\u22A5",
-        pertenk: "\u2031",
-        Pfr: "\u{1D513}",
-        pfr: "\u{1D52D}",
-        Phi: "\u03A6",
-        phi: "\u03C6",
-        phiv: "\u03D5",
-        phmmat: "\u2133",
-        phone: "\u260E",
-        Pi: "\u03A0",
-        pi: "\u03C0",
-        pitchfork: "\u22D4",
-        piv: "\u03D6",
-        planck: "\u210F",
-        planckh: "\u210E",
-        plankv: "\u210F",
-        plusacir: "\u2A23",
-        plusb: "\u229E",
-        pluscir: "\u2A22",
-        plus: "+",
-        plusdo: "\u2214",
-        plusdu: "\u2A25",
-        pluse: "\u2A72",
-        PlusMinus: "\xB1",
-        plusmn: "\xB1",
-        plussim: "\u2A26",
-        plustwo: "\u2A27",
-        pm: "\xB1",
-        Poincareplane: "\u210C",
-        pointint: "\u2A15",
-        popf: "\u{1D561}",
-        Popf: "\u2119",
-        pound: "\xA3",
-        prap: "\u2AB7",
-        Pr: "\u2ABB",
-        pr: "\u227A",
-        prcue: "\u227C",
-        precapprox: "\u2AB7",
-        prec: "\u227A",
-        preccurlyeq: "\u227C",
-        Precedes: "\u227A",
-        PrecedesEqual: "\u2AAF",
-        PrecedesSlantEqual: "\u227C",
-        PrecedesTilde: "\u227E",
-        preceq: "\u2AAF",
-        precnapprox: "\u2AB9",
-        precneqq: "\u2AB5",
-        precnsim: "\u22E8",
-        pre: "\u2AAF",
-        prE: "\u2AB3",
-        precsim: "\u227E",
-        prime: "\u2032",
-        Prime: "\u2033",
-        primes: "\u2119",
-        prnap: "\u2AB9",
-        prnE: "\u2AB5",
-        prnsim: "\u22E8",
-        prod: "\u220F",
-        Product: "\u220F",
-        profalar: "\u232E",
-        profline: "\u2312",
-        profsurf: "\u2313",
-        prop: "\u221D",
-        Proportional: "\u221D",
-        Proportion: "\u2237",
-        propto: "\u221D",
-        prsim: "\u227E",
-        prurel: "\u22B0",
-        Pscr: "\u{1D4AB}",
-        pscr: "\u{1D4C5}",
-        Psi: "\u03A8",
-        psi: "\u03C8",
-        puncsp: "\u2008",
-        Qfr: "\u{1D514}",
-        qfr: "\u{1D52E}",
-        qint: "\u2A0C",
-        qopf: "\u{1D562}",
-        Qopf: "\u211A",
-        qprime: "\u2057",
-        Qscr: "\u{1D4AC}",
-        qscr: "\u{1D4C6}",
-        quaternions: "\u210D",
-        quatint: "\u2A16",
-        quest: "?",
-        questeq: "\u225F",
-        quot: '"',
-        QUOT: '"',
-        rAarr: "\u21DB",
-        race: "\u223D\u0331",
-        Racute: "\u0154",
-        racute: "\u0155",
-        radic: "\u221A",
-        raemptyv: "\u29B3",
-        rang: "\u27E9",
-        Rang: "\u27EB",
-        rangd: "\u2992",
-        range: "\u29A5",
-        rangle: "\u27E9",
-        raquo: "\xBB",
-        rarrap: "\u2975",
-        rarrb: "\u21E5",
-        rarrbfs: "\u2920",
-        rarrc: "\u2933",
-        rarr: "\u2192",
-        Rarr: "\u21A0",
-        rArr: "\u21D2",
-        rarrfs: "\u291E",
-        rarrhk: "\u21AA",
-        rarrlp: "\u21AC",
-        rarrpl: "\u2945",
-        rarrsim: "\u2974",
-        Rarrtl: "\u2916",
-        rarrtl: "\u21A3",
-        rarrw: "\u219D",
-        ratail: "\u291A",
-        rAtail: "\u291C",
-        ratio: "\u2236",
-        rationals: "\u211A",
-        rbarr: "\u290D",
-        rBarr: "\u290F",
-        RBarr: "\u2910",
-        rbbrk: "\u2773",
-        rbrace: "}",
-        rbrack: "]",
-        rbrke: "\u298C",
-        rbrksld: "\u298E",
-        rbrkslu: "\u2990",
-        Rcaron: "\u0158",
-        rcaron: "\u0159",
-        Rcedil: "\u0156",
-        rcedil: "\u0157",
-        rceil: "\u2309",
-        rcub: "}",
-        Rcy: "\u0420",
-        rcy: "\u0440",
-        rdca: "\u2937",
-        rdldhar: "\u2969",
-        rdquo: "\u201D",
-        rdquor: "\u201D",
-        rdsh: "\u21B3",
-        real: "\u211C",
-        realine: "\u211B",
-        realpart: "\u211C",
-        reals: "\u211D",
-        Re: "\u211C",
-        rect: "\u25AD",
-        reg: "\xAE",
-        REG: "\xAE",
-        ReverseElement: "\u220B",
-        ReverseEquilibrium: "\u21CB",
-        ReverseUpEquilibrium: "\u296F",
-        rfisht: "\u297D",
-        rfloor: "\u230B",
-        rfr: "\u{1D52F}",
-        Rfr: "\u211C",
-        rHar: "\u2964",
-        rhard: "\u21C1",
-        rharu: "\u21C0",
-        rharul: "\u296C",
-        Rho: "\u03A1",
-        rho: "\u03C1",
-        rhov: "\u03F1",
-        RightAngleBracket: "\u27E9",
-        RightArrowBar: "\u21E5",
-        rightarrow: "\u2192",
-        RightArrow: "\u2192",
-        Rightarrow: "\u21D2",
-        RightArrowLeftArrow: "\u21C4",
-        rightarrowtail: "\u21A3",
-        RightCeiling: "\u2309",
-        RightDoubleBracket: "\u27E7",
-        RightDownTeeVector: "\u295D",
-        RightDownVectorBar: "\u2955",
-        RightDownVector: "\u21C2",
-        RightFloor: "\u230B",
-        rightharpoondown: "\u21C1",
-        rightharpoonup: "\u21C0",
-        rightleftarrows: "\u21C4",
-        rightleftharpoons: "\u21CC",
-        rightrightarrows: "\u21C9",
-        rightsquigarrow: "\u219D",
-        RightTeeArrow: "\u21A6",
-        RightTee: "\u22A2",
-        RightTeeVector: "\u295B",
-        rightthreetimes: "\u22CC",
-        RightTriangleBar: "\u29D0",
-        RightTriangle: "\u22B3",
-        RightTriangleEqual: "\u22B5",
-        RightUpDownVector: "\u294F",
-        RightUpTeeVector: "\u295C",
-        RightUpVectorBar: "\u2954",
-        RightUpVector: "\u21BE",
-        RightVectorBar: "\u2953",
-        RightVector: "\u21C0",
-        ring: "\u02DA",
-        risingdotseq: "\u2253",
-        rlarr: "\u21C4",
-        rlhar: "\u21CC",
-        rlm: "\u200F",
-        rmoustache: "\u23B1",
-        rmoust: "\u23B1",
-        rnmid: "\u2AEE",
-        roang: "\u27ED",
-        roarr: "\u21FE",
-        robrk: "\u27E7",
-        ropar: "\u2986",
-        ropf: "\u{1D563}",
-        Ropf: "\u211D",
-        roplus: "\u2A2E",
-        rotimes: "\u2A35",
-        RoundImplies: "\u2970",
-        rpar: ")",
-        rpargt: "\u2994",
-        rppolint: "\u2A12",
-        rrarr: "\u21C9",
-        Rrightarrow: "\u21DB",
-        rsaquo: "\u203A",
-        rscr: "\u{1D4C7}",
-        Rscr: "\u211B",
-        rsh: "\u21B1",
-        Rsh: "\u21B1",
-        rsqb: "]",
-        rsquo: "\u2019",
-        rsquor: "\u2019",
-        rthree: "\u22CC",
-        rtimes: "\u22CA",
-        rtri: "\u25B9",
-        rtrie: "\u22B5",
-        rtrif: "\u25B8",
-        rtriltri: "\u29CE",
-        RuleDelayed: "\u29F4",
-        ruluhar: "\u2968",
-        rx: "\u211E",
-        Sacute: "\u015A",
-        sacute: "\u015B",
-        sbquo: "\u201A",
-        scap: "\u2AB8",
-        Scaron: "\u0160",
-        scaron: "\u0161",
-        Sc: "\u2ABC",
-        sc: "\u227B",
-        sccue: "\u227D",
-        sce: "\u2AB0",
-        scE: "\u2AB4",
-        Scedil: "\u015E",
-        scedil: "\u015F",
-        Scirc: "\u015C",
-        scirc: "\u015D",
-        scnap: "\u2ABA",
-        scnE: "\u2AB6",
-        scnsim: "\u22E9",
-        scpolint: "\u2A13",
-        scsim: "\u227F",
-        Scy: "\u0421",
-        scy: "\u0441",
-        sdotb: "\u22A1",
-        sdot: "\u22C5",
-        sdote: "\u2A66",
-        searhk: "\u2925",
-        searr: "\u2198",
-        seArr: "\u21D8",
-        searrow: "\u2198",
-        sect: "\xA7",
-        semi: ";",
-        seswar: "\u2929",
-        setminus: "\u2216",
-        setmn: "\u2216",
-        sext: "\u2736",
-        Sfr: "\u{1D516}",
-        sfr: "\u{1D530}",
-        sfrown: "\u2322",
-        sharp: "\u266F",
-        SHCHcy: "\u0429",
-        shchcy: "\u0449",
-        SHcy: "\u0428",
-        shcy: "\u0448",
-        ShortDownArrow: "\u2193",
-        ShortLeftArrow: "\u2190",
-        shortmid: "\u2223",
-        shortparallel: "\u2225",
-        ShortRightArrow: "\u2192",
-        ShortUpArrow: "\u2191",
-        shy: "\xAD",
-        Sigma: "\u03A3",
-        sigma: "\u03C3",
-        sigmaf: "\u03C2",
-        sigmav: "\u03C2",
-        sim: "\u223C",
-        simdot: "\u2A6A",
-        sime: "\u2243",
-        simeq: "\u2243",
-        simg: "\u2A9E",
-        simgE: "\u2AA0",
-        siml: "\u2A9D",
-        simlE: "\u2A9F",
-        simne: "\u2246",
-        simplus: "\u2A24",
-        simrarr: "\u2972",
-        slarr: "\u2190",
-        SmallCircle: "\u2218",
-        smallsetminus: "\u2216",
-        smashp: "\u2A33",
-        smeparsl: "\u29E4",
-        smid: "\u2223",
-        smile: "\u2323",
-        smt: "\u2AAA",
-        smte: "\u2AAC",
-        smtes: "\u2AAC\uFE00",
-        SOFTcy: "\u042C",
-        softcy: "\u044C",
-        solbar: "\u233F",
-        solb: "\u29C4",
-        sol: "/",
-        Sopf: "\u{1D54A}",
-        sopf: "\u{1D564}",
-        spades: "\u2660",
-        spadesuit: "\u2660",
-        spar: "\u2225",
-        sqcap: "\u2293",
-        sqcaps: "\u2293\uFE00",
-        sqcup: "\u2294",
-        sqcups: "\u2294\uFE00",
-        Sqrt: "\u221A",
-        sqsub: "\u228F",
-        sqsube: "\u2291",
-        sqsubset: "\u228F",
-        sqsubseteq: "\u2291",
-        sqsup: "\u2290",
-        sqsupe: "\u2292",
-        sqsupset: "\u2290",
-        sqsupseteq: "\u2292",
-        square: "\u25A1",
-        Square: "\u25A1",
-        SquareIntersection: "\u2293",
-        SquareSubset: "\u228F",
-        SquareSubsetEqual: "\u2291",
-        SquareSuperset: "\u2290",
-        SquareSupersetEqual: "\u2292",
-        SquareUnion: "\u2294",
-        squarf: "\u25AA",
-        squ: "\u25A1",
-        squf: "\u25AA",
-        srarr: "\u2192",
-        Sscr: "\u{1D4AE}",
-        sscr: "\u{1D4C8}",
-        ssetmn: "\u2216",
-        ssmile: "\u2323",
-        sstarf: "\u22C6",
-        Star: "\u22C6",
-        star: "\u2606",
-        starf: "\u2605",
-        straightepsilon: "\u03F5",
-        straightphi: "\u03D5",
-        strns: "\xAF",
-        sub: "\u2282",
-        Sub: "\u22D0",
-        subdot: "\u2ABD",
-        subE: "\u2AC5",
-        sube: "\u2286",
-        subedot: "\u2AC3",
-        submult: "\u2AC1",
-        subnE: "\u2ACB",
-        subne: "\u228A",
-        subplus: "\u2ABF",
-        subrarr: "\u2979",
-        subset: "\u2282",
-        Subset: "\u22D0",
-        subseteq: "\u2286",
-        subseteqq: "\u2AC5",
-        SubsetEqual: "\u2286",
-        subsetneq: "\u228A",
-        subsetneqq: "\u2ACB",
-        subsim: "\u2AC7",
-        subsub: "\u2AD5",
-        subsup: "\u2AD3",
-        succapprox: "\u2AB8",
-        succ: "\u227B",
-        succcurlyeq: "\u227D",
-        Succeeds: "\u227B",
-        SucceedsEqual: "\u2AB0",
-        SucceedsSlantEqual: "\u227D",
-        SucceedsTilde: "\u227F",
-        succeq: "\u2AB0",
-        succnapprox: "\u2ABA",
-        succneqq: "\u2AB6",
-        succnsim: "\u22E9",
-        succsim: "\u227F",
-        SuchThat: "\u220B",
-        sum: "\u2211",
-        Sum: "\u2211",
-        sung: "\u266A",
-        sup1: "\xB9",
-        sup2: "\xB2",
-        sup3: "\xB3",
-        sup: "\u2283",
-        Sup: "\u22D1",
-        supdot: "\u2ABE",
-        supdsub: "\u2AD8",
-        supE: "\u2AC6",
-        supe: "\u2287",
-        supedot: "\u2AC4",
-        Superset: "\u2283",
-        SupersetEqual: "\u2287",
-        suphsol: "\u27C9",
-        suphsub: "\u2AD7",
-        suplarr: "\u297B",
-        supmult: "\u2AC2",
-        supnE: "\u2ACC",
-        supne: "\u228B",
-        supplus: "\u2AC0",
-        supset: "\u2283",
-        Supset: "\u22D1",
-        supseteq: "\u2287",
-        supseteqq: "\u2AC6",
-        supsetneq: "\u228B",
-        supsetneqq: "\u2ACC",
-        supsim: "\u2AC8",
-        supsub: "\u2AD4",
-        supsup: "\u2AD6",
-        swarhk: "\u2926",
-        swarr: "\u2199",
-        swArr: "\u21D9",
-        swarrow: "\u2199",
-        swnwar: "\u292A",
-        szlig: "\xDF",
-        Tab: "	",
-        target: "\u2316",
-        Tau: "\u03A4",
-        tau: "\u03C4",
-        tbrk: "\u23B4",
-        Tcaron: "\u0164",
-        tcaron: "\u0165",
-        Tcedil: "\u0162",
-        tcedil: "\u0163",
-        Tcy: "\u0422",
-        tcy: "\u0442",
-        tdot: "\u20DB",
-        telrec: "\u2315",
-        Tfr: "\u{1D517}",
-        tfr: "\u{1D531}",
-        there4: "\u2234",
-        therefore: "\u2234",
-        Therefore: "\u2234",
-        Theta: "\u0398",
-        theta: "\u03B8",
-        thetasym: "\u03D1",
-        thetav: "\u03D1",
-        thickapprox: "\u2248",
-        thicksim: "\u223C",
-        ThickSpace: "\u205F\u200A",
-        ThinSpace: "\u2009",
-        thinsp: "\u2009",
-        thkap: "\u2248",
-        thksim: "\u223C",
-        THORN: "\xDE",
-        thorn: "\xFE",
-        tilde: "\u02DC",
-        Tilde: "\u223C",
-        TildeEqual: "\u2243",
-        TildeFullEqual: "\u2245",
-        TildeTilde: "\u2248",
-        timesbar: "\u2A31",
-        timesb: "\u22A0",
-        times: "\xD7",
-        timesd: "\u2A30",
-        tint: "\u222D",
-        toea: "\u2928",
-        topbot: "\u2336",
-        topcir: "\u2AF1",
-        top: "\u22A4",
-        Topf: "\u{1D54B}",
-        topf: "\u{1D565}",
-        topfork: "\u2ADA",
-        tosa: "\u2929",
-        tprime: "\u2034",
-        trade: "\u2122",
-        TRADE: "\u2122",
-        triangle: "\u25B5",
-        triangledown: "\u25BF",
-        triangleleft: "\u25C3",
-        trianglelefteq: "\u22B4",
-        triangleq: "\u225C",
-        triangleright: "\u25B9",
-        trianglerighteq: "\u22B5",
-        tridot: "\u25EC",
-        trie: "\u225C",
-        triminus: "\u2A3A",
-        TripleDot: "\u20DB",
-        triplus: "\u2A39",
-        trisb: "\u29CD",
-        tritime: "\u2A3B",
-        trpezium: "\u23E2",
-        Tscr: "\u{1D4AF}",
-        tscr: "\u{1D4C9}",
-        TScy: "\u0426",
-        tscy: "\u0446",
-        TSHcy: "\u040B",
-        tshcy: "\u045B",
-        Tstrok: "\u0166",
-        tstrok: "\u0167",
-        twixt: "\u226C",
-        twoheadleftarrow: "\u219E",
-        twoheadrightarrow: "\u21A0",
-        Uacute: "\xDA",
-        uacute: "\xFA",
-        uarr: "\u2191",
-        Uarr: "\u219F",
-        uArr: "\u21D1",
-        Uarrocir: "\u2949",
-        Ubrcy: "\u040E",
-        ubrcy: "\u045E",
-        Ubreve: "\u016C",
-        ubreve: "\u016D",
-        Ucirc: "\xDB",
-        ucirc: "\xFB",
-        Ucy: "\u0423",
-        ucy: "\u0443",
-        udarr: "\u21C5",
-        Udblac: "\u0170",
-        udblac: "\u0171",
-        udhar: "\u296E",
-        ufisht: "\u297E",
-        Ufr: "\u{1D518}",
-        ufr: "\u{1D532}",
-        Ugrave: "\xD9",
-        ugrave: "\xF9",
-        uHar: "\u2963",
-        uharl: "\u21BF",
-        uharr: "\u21BE",
-        uhblk: "\u2580",
-        ulcorn: "\u231C",
-        ulcorner: "\u231C",
-        ulcrop: "\u230F",
-        ultri: "\u25F8",
-        Umacr: "\u016A",
-        umacr: "\u016B",
-        uml: "\xA8",
-        UnderBar: "_",
-        UnderBrace: "\u23DF",
-        UnderBracket: "\u23B5",
-        UnderParenthesis: "\u23DD",
-        Union: "\u22C3",
-        UnionPlus: "\u228E",
-        Uogon: "\u0172",
-        uogon: "\u0173",
-        Uopf: "\u{1D54C}",
-        uopf: "\u{1D566}",
-        UpArrowBar: "\u2912",
-        uparrow: "\u2191",
-        UpArrow: "\u2191",
-        Uparrow: "\u21D1",
-        UpArrowDownArrow: "\u21C5",
-        updownarrow: "\u2195",
-        UpDownArrow: "\u2195",
-        Updownarrow: "\u21D5",
-        UpEquilibrium: "\u296E",
-        upharpoonleft: "\u21BF",
-        upharpoonright: "\u21BE",
-        uplus: "\u228E",
-        UpperLeftArrow: "\u2196",
-        UpperRightArrow: "\u2197",
-        upsi: "\u03C5",
-        Upsi: "\u03D2",
-        upsih: "\u03D2",
-        Upsilon: "\u03A5",
-        upsilon: "\u03C5",
-        UpTeeArrow: "\u21A5",
-        UpTee: "\u22A5",
-        upuparrows: "\u21C8",
-        urcorn: "\u231D",
-        urcorner: "\u231D",
-        urcrop: "\u230E",
-        Uring: "\u016E",
-        uring: "\u016F",
-        urtri: "\u25F9",
-        Uscr: "\u{1D4B0}",
-        uscr: "\u{1D4CA}",
-        utdot: "\u22F0",
-        Utilde: "\u0168",
-        utilde: "\u0169",
-        utri: "\u25B5",
-        utrif: "\u25B4",
-        uuarr: "\u21C8",
-        Uuml: "\xDC",
-        uuml: "\xFC",
-        uwangle: "\u29A7",
-        vangrt: "\u299C",
-        varepsilon: "\u03F5",
-        varkappa: "\u03F0",
-        varnothing: "\u2205",
-        varphi: "\u03D5",
-        varpi: "\u03D6",
-        varpropto: "\u221D",
-        varr: "\u2195",
-        vArr: "\u21D5",
-        varrho: "\u03F1",
-        varsigma: "\u03C2",
-        varsubsetneq: "\u228A\uFE00",
-        varsubsetneqq: "\u2ACB\uFE00",
-        varsupsetneq: "\u228B\uFE00",
-        varsupsetneqq: "\u2ACC\uFE00",
-        vartheta: "\u03D1",
-        vartriangleleft: "\u22B2",
-        vartriangleright: "\u22B3",
-        vBar: "\u2AE8",
-        Vbar: "\u2AEB",
-        vBarv: "\u2AE9",
-        Vcy: "\u0412",
-        vcy: "\u0432",
-        vdash: "\u22A2",
-        vDash: "\u22A8",
-        Vdash: "\u22A9",
-        VDash: "\u22AB",
-        Vdashl: "\u2AE6",
-        veebar: "\u22BB",
-        vee: "\u2228",
-        Vee: "\u22C1",
-        veeeq: "\u225A",
-        vellip: "\u22EE",
-        verbar: "|",
-        Verbar: "\u2016",
-        vert: "|",
-        Vert: "\u2016",
-        VerticalBar: "\u2223",
-        VerticalLine: "|",
-        VerticalSeparator: "\u2758",
-        VerticalTilde: "\u2240",
-        VeryThinSpace: "\u200A",
-        Vfr: "\u{1D519}",
-        vfr: "\u{1D533}",
-        vltri: "\u22B2",
-        vnsub: "\u2282\u20D2",
-        vnsup: "\u2283\u20D2",
-        Vopf: "\u{1D54D}",
-        vopf: "\u{1D567}",
-        vprop: "\u221D",
-        vrtri: "\u22B3",
-        Vscr: "\u{1D4B1}",
-        vscr: "\u{1D4CB}",
-        vsubnE: "\u2ACB\uFE00",
-        vsubne: "\u228A\uFE00",
-        vsupnE: "\u2ACC\uFE00",
-        vsupne: "\u228B\uFE00",
-        Vvdash: "\u22AA",
-        vzigzag: "\u299A",
-        Wcirc: "\u0174",
-        wcirc: "\u0175",
-        wedbar: "\u2A5F",
-        wedge: "\u2227",
-        Wedge: "\u22C0",
-        wedgeq: "\u2259",
-        weierp: "\u2118",
-        Wfr: "\u{1D51A}",
-        wfr: "\u{1D534}",
-        Wopf: "\u{1D54E}",
-        wopf: "\u{1D568}",
-        wp: "\u2118",
-        wr: "\u2240",
-        wreath: "\u2240",
-        Wscr: "\u{1D4B2}",
-        wscr: "\u{1D4CC}",
-        xcap: "\u22C2",
-        xcirc: "\u25EF",
-        xcup: "\u22C3",
-        xdtri: "\u25BD",
-        Xfr: "\u{1D51B}",
-        xfr: "\u{1D535}",
-        xharr: "\u27F7",
-        xhArr: "\u27FA",
-        Xi: "\u039E",
-        xi: "\u03BE",
-        xlarr: "\u27F5",
-        xlArr: "\u27F8",
-        xmap: "\u27FC",
-        xnis: "\u22FB",
-        xodot: "\u2A00",
-        Xopf: "\u{1D54F}",
-        xopf: "\u{1D569}",
-        xoplus: "\u2A01",
-        xotime: "\u2A02",
-        xrarr: "\u27F6",
-        xrArr: "\u27F9",
-        Xscr: "\u{1D4B3}",
-        xscr: "\u{1D4CD}",
-        xsqcup: "\u2A06",
-        xuplus: "\u2A04",
-        xutri: "\u25B3",
-        xvee: "\u22C1",
-        xwedge: "\u22C0",
-        Yacute: "\xDD",
-        yacute: "\xFD",
-        YAcy: "\u042F",
-        yacy: "\u044F",
-        Ycirc: "\u0176",
-        ycirc: "\u0177",
-        Ycy: "\u042B",
-        ycy: "\u044B",
-        yen: "\xA5",
-        Yfr: "\u{1D51C}",
-        yfr: "\u{1D536}",
-        YIcy: "\u0407",
-        yicy: "\u0457",
-        Yopf: "\u{1D550}",
-        yopf: "\u{1D56A}",
-        Yscr: "\u{1D4B4}",
-        yscr: "\u{1D4CE}",
-        YUcy: "\u042E",
-        yucy: "\u044E",
-        yuml: "\xFF",
-        Yuml: "\u0178",
-        Zacute: "\u0179",
-        zacute: "\u017A",
-        Zcaron: "\u017D",
-        zcaron: "\u017E",
-        Zcy: "\u0417",
-        zcy: "\u0437",
-        Zdot: "\u017B",
-        zdot: "\u017C",
-        zeetrf: "\u2128",
-        ZeroWidthSpace: "\u200B",
-        Zeta: "\u0396",
-        zeta: "\u03B6",
-        zfr: "\u{1D537}",
-        Zfr: "\u2128",
-        ZHcy: "\u0416",
-        zhcy: "\u0436",
-        zigrarr: "\u21DD",
-        zopf: "\u{1D56B}",
-        Zopf: "\u2124",
-        Zscr: "\u{1D4B5}",
-        zscr: "\u{1D4CF}",
-        zwj: "\u200D",
-        zwnj: "\u200C"
-    }
-});
-var oi = W((U4, bs) => {
-    "use strict";
-    bs.exports = gs()
-});
-var A0 = W((W4, ys) => {
-    ys.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/
-});
-var ws = W((Y4, vs) => {
-    "use strict";
-    var xs = {};
-
-    function Td(r) {
-        var e, i, a = xs[r];
-        if (a) return a;
-        for (a = xs[r] = [], e = 0; e < 128; e++) i = String.fromCharCode(e), /^[0-9a-z]$/i.test(i) ? a.push(i) : a.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
-        for (e = 0; e < r.length; e++) a[r.charCodeAt(e)] = r[e];
-        return a
-    }
-
-    function q0(r, e, i) {
-        var a, l, c, d, f, g = "";
-        for (typeof e != "string" && (i = e, e = q0.defaultChars), typeof i > "u" && (i = !0), f = Td(e), a = 0, l = r.length; a < l; a++) {
-            if (c = r.charCodeAt(a), i && c === 37 && a + 2 < l && /^[0-9a-f]{2}$/i.test(r.slice(a + 1, a + 3))) {
-                g += r.slice(a, a + 3), a += 2;
-                continue
-            }
-            if (c < 128) {
-                g += f[c];
-                continue
-            }
-            if (c >= 55296 && c <= 57343) {
-                if (c >= 55296 && c <= 56319 && a + 1 < l && (d = r.charCodeAt(a + 1), d >= 56320 && d <= 57343)) {
-                    g += encodeURIComponent(r[a] + r[a + 1]), a++;
-                    continue
-                }
-                g += "%EF%BF%BD";
-                continue
-            }
-            g += encodeURIComponent(r[a])
-        }
-        return g
-    }
-    q0.defaultChars = ";/?:@&=+$,-_.!~*'()#";
-    q0.componentChars = "-_.!~*'()";
-    vs.exports = q0
-});
-var Ss = W((Z4, _s) => {
-    "use strict";
-    var ks = {};
-
-    function Ad(r) {
-        var e, i, a = ks[r];
-        if (a) return a;
-        for (a = ks[r] = [], e = 0; e < 128; e++) i = String.fromCharCode(e), a.push(i);
-        for (e = 0; e < r.length; e++) i = r.charCodeAt(e), a[i] = "%" + ("0" + i.toString(16).toUpperCase()).slice(-2);
-        return a
-    }
-
-    function M0(r, e) {
-        var i;
-        return typeof e != "string" && (e = M0.defaultChars), i = Ad(e), r.replace(/(%[a-f0-9]{2})+/gi, function(a) {
-            var l, c, d, f, g, y, _, w = "";
-            for (l = 0, c = a.length; l < c; l += 3) {
-                if (d = parseInt(a.slice(l + 1, l + 3), 16), d < 128) {
-                    w += i[d];
-                    continue
-                }
-                if ((d & 224) === 192 && l + 3 < c && (f = parseInt(a.slice(l + 4, l + 6), 16), (f & 192) === 128)) {
-                    _ = d << 6 & 1984 | f & 63, _ < 128 ? w += "\uFFFD\uFFFD" : w += String.fromCharCode(_), l += 3;
-                    continue
-                }
-                if ((d & 240) === 224 && l + 6 < c && (f = parseInt(a.slice(l + 4, l + 6), 16), g = parseInt(a.slice(l + 7, l + 9), 16), (f & 192) === 128 && (g & 192) === 128)) {
-                    _ = d << 12 & 61440 | f << 6 & 4032 | g & 63, _ < 2048 || _ >= 55296 && _ <= 57343 ? w += "\uFFFD\uFFFD\uFFFD" : w += String.fromCharCode(_), l += 6;
-                    continue
-                }
-                if ((d & 248) === 240 && l + 9 < c && (f = parseInt(a.slice(l + 4, l + 6), 16), g = parseInt(a.slice(l + 7, l + 9), 16), y = parseInt(a.slice(l + 10, l + 12), 16), (f & 192) === 128 && (g & 192) === 128 && (y & 192) === 128)) {
-                    _ = d << 18 & 1835008 | f << 12 & 258048 | g << 6 & 4032 | y & 63, _ < 65536 || _ > 1114111 ? w += "\uFFFD\uFFFD\uFFFD\uFFFD" : (_ -= 65536, w += String.fromCharCode(55296 + (_ >> 10), 56320 + (_ & 1023))), l += 9;
-                    continue
-                }
-                w += "\uFFFD"
-            }
-            return w
-        })
-    }
-    M0.defaultChars = ";/?:@&=+$,#";
-    M0.componentChars = "";
-    _s.exports = M0
-});
-var Ts = W((Q4, Cs) => {
-    "use strict";
-    Cs.exports = function(e) {
-        var i = "";
-        return i += e.protocol || "", i += e.slashes ? "//" : "", i += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? i += "[" + e.hostname + "]" : i += e.hostname || "", i += e.port ? ":" + e.port : "", i += e.pathname || "", i += e.search || "", i += e.hash || "", i
-    }
-});
-var Rs = W((X4, zs) => {
-    "use strict";
-
-    function E0() {
-        this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null
-    }
-    var qd = /^([a-z0-9.+-]+:)/i,
-        Md = /:[0-9]*$/,
-        Ed = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
-        Dd = ["<", ">", '"', "`", " ", "\r", `
-`, "	"],
-        zd = ["{", "}", "|", "\\", "^", "`"].concat(Dd),
-        Rd = ["'"].concat(zd),
-        As = ["%", "/", "?", ";", "#"].concat(Rd),
-        qs = ["/", "?", "#"],
-        Fd = 255,
-        Ms = /^[+a-z0-9A-Z_-]{0,63}$/,
-        Bd = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
-        Es = {
-            javascript: !0,
-            "javascript:": !0
-        },
-        Ds = {
-            http: !0,
-            https: !0,
-            ftp: !0,
-            gopher: !0,
-            file: !0,
-            "http:": !0,
-            "https:": !0,
-            "ftp:": !0,
-            "gopher:": !0,
-            "file:": !0
-        };
-
-    function Nd(r, e) {
-        if (r && r instanceof E0) return r;
-        var i = new E0;
-        return i.parse(r, e), i
-    }
-    E0.prototype.parse = function(r, e) {
-        var i, a, l, c, d, f = r;
-        if (f = f.trim(), !e && r.split("#").length === 1) {
-            var g = Ed.exec(f);
-            if (g) return this.pathname = g[1], g[2] && (this.search = g[2]), this
-        }
-        var y = qd.exec(f);
-        if (y && (y = y[0], l = y.toLowerCase(), this.protocol = y, f = f.substr(y.length)), (e || y || f.match(/^\/\/[^@\/]+@[^@\/]+/)) && (d = f.substr(0, 2) === "//", d && !(y && Es[y]) && (f = f.substr(2), this.slashes = !0)), !Es[y] && (d || y && !Ds[y])) {
-            var _ = -1;
-            for (i = 0; i < qs.length; i++) c = f.indexOf(qs[i]), c !== -1 && (_ === -1 || c < _) && (_ = c);
-            var w, T;
-            for (_ === -1 ? T = f.lastIndexOf("@") : T = f.lastIndexOf("@", _), T !== -1 && (w = f.slice(0, T), f = f.slice(T + 1), this.auth = w), _ = -1, i = 0; i < As.length; i++) c = f.indexOf(As[i]), c !== -1 && (_ === -1 || c < _) && (_ = c);
-            _ === -1 && (_ = f.length), f[_ - 1] === ":" && _--;
-            var A = f.slice(0, _);
-            f = f.slice(_), this.parseHost(A), this.hostname = this.hostname || "";
-            var L = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
-            if (!L) {
-                var R = this.hostname.split(/\./);
-                for (i = 0, a = R.length; i < a; i++) {
-                    var O = R[i];
-                    if (O && !O.match(Ms)) {
-                        for (var P = "", I = 0, Y = O.length; I < Y; I++) O.charCodeAt(I) > 127 ? P += "x" : P += O[I];
-                        if (!P.match(Ms)) {
-                            var re = R.slice(0, i),
-                                te = R.slice(i + 1),
-                                j = O.match(Bd);
-                            j && (re.push(j[1]), te.unshift(j[2])), te.length && (f = te.join(".") + f), this.hostname = re.join(".");
-                            break
-                        }
-                    }
-                }
-            }
-            this.hostname.length > Fd && (this.hostname = ""), L && (this.hostname = this.hostname.substr(1, this.hostname.length - 2))
-        }
-        var ne = f.indexOf("#");
-        ne !== -1 && (this.hash = f.substr(ne), f = f.slice(0, ne));
-        var pe = f.indexOf("?");
-        return pe !== -1 && (this.search = f.substr(pe), f = f.slice(0, pe)), f && (this.pathname = f), Ds[l] && this.hostname && !this.pathname && (this.pathname = ""), this
-    };
-    E0.prototype.parseHost = function(r) {
-        var e = Md.exec(r);
-        e && (e = e[0], e !== ":" && (this.port = e.substr(1)), r = r.substr(0, r.length - e.length)), r && (this.hostname = r)
-    };
-    zs.exports = Nd
-});
-var ai = W((J4, Nr) => {
-    "use strict";
-    Nr.exports.encode = ws();
-    Nr.exports.decode = Ss();
-    Nr.exports.format = Ts();
-    Nr.exports.parse = Rs()
-});
-var si = W((K4, Fs) => {
-    Fs.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
-});
-var li = W((e2, Bs) => {
-    Bs.exports = /[\0-\x1F\x7F-\x9F]/
-});
-var Ls = W((t2, Ns) => {
-    Ns.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/
-});
-var ci = W((r2, Ps) => {
-    Ps.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
-});
-var Is = W(pr => {
-    "use strict";
-    pr.Any = si();
-    pr.Cc = li();
-    pr.Cf = Ls();
-    pr.P = A0();
-    pr.Z = ci()
-});
-var Se = W(Ke => {
-    "use strict";
-
-    function Ld(r) {
-        return Object.prototype.toString.call(r)
-    }
-
-    function Pd(r) {
-        return Ld(r) === "[object String]"
-    }
-    var Id = Object.prototype.hasOwnProperty;
-
-    function Hs(r, e) {
-        return Id.call(r, e)
-    }
-
-    function Od(r) {
-        var e = Array.prototype.slice.call(arguments, 1);
-        return e.forEach(function(i) {
-            if (i) {
-                if (typeof i != "object") throw new TypeError(i + "must be object");
-                Object.keys(i).forEach(function(a) {
-                    r[a] = i[a]
-                })
-            }
-        }), r
-    }
-
-    function Hd(r, e, i) {
-        return [].concat(r.slice(0, e), i, r.slice(e + 1))
-    }
-
-    function $s(r) {
-        return !(r >= 55296 && r <= 57343 || r >= 64976 && r <= 65007 || (r & 65535) === 65535 || (r & 65535) === 65534 || r >= 0 && r <= 8 || r === 11 || r >= 14 && r <= 31 || r >= 127 && r <= 159 || r > 1114111)
-    }
-
-    function Gs(r) {
-        if (r > 65535) {
-            r -= 65536;
-            var e = 55296 + (r >> 10),
-                i = 56320 + (r & 1023);
-            return String.fromCharCode(e, i)
-        }
-        return String.fromCharCode(r)
-    }
-    var Vs = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g,
-        $d = /&([a-z#][a-z0-9]{1,31});/gi,
-        Gd = new RegExp(Vs.source + "|" + $d.source, "gi"),
-        Vd = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i,
-        Os = oi();
-
-    function jd(r, e) {
-        var i;
-        return Hs(Os, e) ? Os[e] : e.charCodeAt(0) === 35 && Vd.test(e) && (i = e[1].toLowerCase() === "x" ? parseInt(e.slice(2), 16) : parseInt(e.slice(1), 10), $s(i)) ? Gs(i) : r
-    }
-
-    function Ud(r) {
-        return r.indexOf("\\") < 0 ? r : r.replace(Vs, "$1")
-    }
-
-    function Wd(r) {
-        return r.indexOf("\\") < 0 && r.indexOf("&") < 0 ? r : r.replace(Gd, function(e, i, a) {
-            return i || jd(e, a)
-        })
-    }
-    var Yd = /[&<>"]/,
-        Zd = /[&<>"]/g,
-        Qd = {
-            "&": "&amp;",
-            "<": "&lt;",
-            ">": "&gt;",
-            '"': "&quot;"
-        };
-
-    function Xd(r) {
-        return Qd[r]
-    }
-
-    function Jd(r) {
-        return Yd.test(r) ? r.replace(Zd, Xd) : r
-    }
-    var Kd = /[.?*+^$[\]\\(){}|-]/g;
-
-    function em(r) {
-        return r.replace(Kd, "\\$&")
-    }
-
-    function tm(r) {
-        switch (r) {
-            case 9:
-            case 32:
-                return !0
-        }
-        return !1
-    }
-
-    function rm(r) {
-        if (r >= 8192 && r <= 8202) return !0;
-        switch (r) {
-            case 9:
-            case 10:
-            case 11:
-            case 12:
-            case 13:
-            case 32:
-            case 160:
-            case 5760:
-            case 8239:
-            case 8287:
-            case 12288:
-                return !0
-        }
-        return !1
-    }
-    var nm = A0();
-
-    function im(r) {
-        return nm.test(r)
-    }
-
-    function om(r) {
-        switch (r) {
-            case 33:
-            case 34:
-            case 35:
-            case 36:
-            case 37:
-            case 38:
-            case 39:
-            case 40:
-            case 41:
-            case 42:
-            case 43:
-            case 44:
-            case 45:
-            case 46:
-            case 47:
-            case 58:
-            case 59:
-            case 60:
-            case 61:
-            case 62:
-            case 63:
-            case 64:
-            case 91:
-            case 92:
-            case 93:
-            case 94:
-            case 95:
-            case 96:
-            case 123:
-            case 124:
-            case 125:
-            case 126:
-                return !0;
-            default:
-                return !1
-        }
-    }
-
-    function am(r) {
-        return r = r.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (r = r.replace(/ẞ/g, "\xDF")), r.toLowerCase().toUpperCase()
-    }
-    Ke.lib = {};
-    Ke.lib.mdurl = ai();
-    Ke.lib.ucmicro = Is();
-    Ke.assign = Od;
-    Ke.isString = Pd;
-    Ke.has = Hs;
-    Ke.unescapeMd = Ud;
-    Ke.unescapeAll = Wd;
-    Ke.isValidEntityCode = $s;
-    Ke.fromCodePoint = Gs;
-    Ke.escapeHtml = Jd;
-    Ke.arrayReplaceAt = Hd;
-    Ke.isSpace = tm;
-    Ke.isWhiteSpace = rm;
-    Ke.isMdAsciiPunct = om;
-    Ke.isPunctChar = im;
-    Ke.escapeRE = em;
-    Ke.normalizeReference = am
-});
-var Us = W((o2, js) => {
-    "use strict";
-    js.exports = function(e, i, a) {
-        var l, c, d, f, g = -1,
-            y = e.posMax,
-            _ = e.pos;
-        for (e.pos = i + 1, l = 1; e.pos < y;) {
-            if (d = e.src.charCodeAt(e.pos), d === 93 && (l--, l === 0)) {
-                c = !0;
-                break
-            }
-            if (f = e.pos, e.md.inline.skipToken(e), d === 91) {
-                if (f === e.pos - 1) l++;
-                else if (a) return e.pos = _, -1
-            }
-        }
-        return c && (g = e.pos), e.pos = _, g
-    }
-});
-var Zs = W((a2, Ys) => {
-    "use strict";
-    var Ws = Se().unescapeAll;
-    Ys.exports = function(e, i, a) {
-        var l, c, d = i,
-            f = {
-                ok: !1,
-                pos: 0,
-                lines: 0,
-                str: ""
-            };
-        if (e.charCodeAt(d) === 60) {
-            for (d++; d < a;) {
-                if (l = e.charCodeAt(d), l === 10 || l === 60) return f;
-                if (l === 62) return f.pos = d + 1, f.str = Ws(e.slice(i + 1, d)), f.ok = !0, f;
-                if (l === 92 && d + 1 < a) {
-                    d += 2;
-                    continue
-                }
-                d++
-            }
-            return f
-        }
-        for (c = 0; d < a && (l = e.charCodeAt(d), !(l === 32 || l < 32 || l === 127));) {
-            if (l === 92 && d + 1 < a) {
-                if (e.charCodeAt(d + 1) === 32) break;
-                d += 2;
-                continue
-            }
-            if (l === 40 && (c++, c > 32)) return f;
-            if (l === 41) {
-                if (c === 0) break;
-                c--
-            }
-            d++
-        }
-        return i === d || c !== 0 || (f.str = Ws(e.slice(i, d)), f.pos = d, f.ok = !0), f
-    }
-});
-var Xs = W((s2, Qs) => {
-    "use strict";
-    var sm = Se().unescapeAll;
-    Qs.exports = function(e, i, a) {
-        var l, c, d = 0,
-            f = i,
-            g = {
-                ok: !1,
-                pos: 0,
-                lines: 0,
-                str: ""
-            };
-        if (f >= a || (c = e.charCodeAt(f), c !== 34 && c !== 39 && c !== 40)) return g;
-        for (f++, c === 40 && (c = 41); f < a;) {
-            if (l = e.charCodeAt(f), l === c) return g.pos = f + 1, g.lines = d, g.str = sm(e.slice(i + 1, f)), g.ok = !0, g;
-            if (l === 40 && c === 41) return g;
-            l === 10 ? d++ : l === 92 && f + 1 < a && (f++, e.charCodeAt(f) === 10 && d++), f++
-        }
-        return g
-    }
-});
-var Js = W(D0 => {
-    "use strict";
-    D0.parseLinkLabel = Us();
-    D0.parseLinkDestination = Zs();
-    D0.parseLinkTitle = Xs()
-});
-var el = W((c2, Ks) => {
-    "use strict";
-    var lm = Se().assign,
-        cm = Se().unescapeAll,
-        or = Se().escapeHtml,
-        Ct = {};
-    Ct.code_inline = function(r, e, i, a, l) {
-        var c = r[e];
-        return "<code" + l.renderAttrs(c) + ">" + or(c.content) + "</code>"
-    };
-    Ct.code_block = function(r, e, i, a, l) {
-        var c = r[e];
-        return "<pre" + l.renderAttrs(c) + "><code>" + or(r[e].content) + `</code></pre>
-`
-    };
-    Ct.fence = function(r, e, i, a, l) {
-        var c = r[e],
-            d = c.info ? cm(c.info).trim() : "",
-            f = "",
-            g = "",
-            y, _, w, T, A;
-        return d && (w = d.split(/(\s+)/g), f = w[0], g = w.slice(2).join("")), i.highlight ? y = i.highlight(c.content, f, g) || or(c.content) : y = or(c.content), y.indexOf("<pre") === 0 ? y + `
-` : d ? (_ = c.attrIndex("class"), T = c.attrs ? c.attrs.slice() : [], _ < 0 ? T.push(["class", i.langPrefix + f]) : (T[_] = T[_].slice(), T[_][1] += " " + i.langPrefix + f), A = {
-            attrs: T
-        }, "<pre><code" + l.renderAttrs(A) + ">" + y + `</code></pre>
-`) : "<pre><code" + l.renderAttrs(c) + ">" + y + `</code></pre>
-`
-    };
-    Ct.image = function(r, e, i, a, l) {
-        var c = r[e];
-        return c.attrs[c.attrIndex("alt")][1] = l.renderInlineAsText(c.children, i, a), l.renderToken(r, e, i)
-    };
-    Ct.hardbreak = function(r, e, i) {
-        return i.xhtmlOut ? `<br />
-` : `<br>
-`
-    };
-    Ct.softbreak = function(r, e, i) {
-        return i.breaks ? i.xhtmlOut ? `<br />
-` : `<br>
-` : `
-`
-    };
-    Ct.text = function(r, e) {
-        return or(r[e].content)
-    };
-    Ct.html_block = function(r, e) {
-        return r[e].content
-    };
-    Ct.html_inline = function(r, e) {
-        return r[e].content
-    };
-
-    function fr() {
-        this.rules = lm({}, Ct)
-    }
-    fr.prototype.renderAttrs = function(e) {
-        var i, a, l;
-        if (!e.attrs) return "";
-        for (l = "", i = 0, a = e.attrs.length; i < a; i++) l += " " + or(e.attrs[i][0]) + '="' + or(e.attrs[i][1]) + '"';
-        return l
-    };
-    fr.prototype.renderToken = function(e, i, a) {
-        var l, c = "",
-            d = !1,
-            f = e[i];
-        return f.hidden ? "" : (f.block && f.nesting !== -1 && i && e[i - 1].hidden && (c += `
-`), c += (f.nesting === -1 ? "</" : "<") + f.tag, c += this.renderAttrs(f), f.nesting === 0 && a.xhtmlOut && (c += " /"), f.block && (d = !0, f.nesting === 1 && i + 1 < e.length && (l = e[i + 1], (l.type === "inline" || l.hidden || l.nesting === -1 && l.tag === f.tag) && (d = !1))), c += d ? `>
-` : ">", c)
-    };
-    fr.prototype.renderInline = function(r, e, i) {
-        for (var a, l = "", c = this.rules, d = 0, f = r.length; d < f; d++) a = r[d].type, typeof c[a] < "u" ? l += c[a](r, d, e, i, this) : l += this.renderToken(r, d, e);
-        return l
-    };
-    fr.prototype.renderInlineAsText = function(r, e, i) {
-        for (var a = "", l = 0, c = r.length; l < c; l++) r[l].type === "text" ? a += r[l].content : r[l].type === "image" ? a += this.renderInlineAsText(r[l].children, e, i) : r[l].type === "softbreak" && (a += `
-`);
-        return a
-    };
-    fr.prototype.render = function(r, e, i) {
-        var a, l, c, d = "",
-            f = this.rules;
-        for (a = 0, l = r.length; a < l; a++) c = r[a].type, c === "inline" ? d += this.renderInline(r[a].children, e, i) : typeof f[c] < "u" ? d += f[c](r, a, e, i, this) : d += this.renderToken(r, a, e, i);
-        return d
-    };
-    Ks.exports = fr
-});
-var z0 = W((u2, tl) => {
-    "use strict";
-
-    function xt() {
-        this.__rules__ = [], this.__cache__ = null
-    }
-    xt.prototype.__find__ = function(r) {
-        for (var e = 0; e < this.__rules__.length; e++)
-            if (this.__rules__[e].name === r) return e;
-        return -1
-    };
-    xt.prototype.__compile__ = function() {
-        var r = this,
-            e = [""];
-        r.__rules__.forEach(function(i) {
-            i.enabled && i.alt.forEach(function(a) {
-                e.indexOf(a) < 0 && e.push(a)
-            })
-        }), r.__cache__ = {}, e.forEach(function(i) {
-            r.__cache__[i] = [], r.__rules__.forEach(function(a) {
-                a.enabled && (i && a.alt.indexOf(i) < 0 || r.__cache__[i].push(a.fn))
-            })
-        })
-    };
-    xt.prototype.at = function(r, e, i) {
-        var a = this.__find__(r),
-            l = i || {};
-        if (a === -1) throw new Error("Parser rule not found: " + r);
-        this.__rules__[a].fn = e, this.__rules__[a].alt = l.alt || [], this.__cache__ = null
-    };
-    xt.prototype.before = function(r, e, i, a) {
-        var l = this.__find__(r),
-            c = a || {};
-        if (l === -1) throw new Error("Parser rule not found: " + r);
-        this.__rules__.splice(l, 0, {
-            name: e,
-            enabled: !0,
-            fn: i,
-            alt: c.alt || []
-        }), this.__cache__ = null
-    };
-    xt.prototype.after = function(r, e, i, a) {
-        var l = this.__find__(r),
-            c = a || {};
-        if (l === -1) throw new Error("Parser rule not found: " + r);
-        this.__rules__.splice(l + 1, 0, {
-            name: e,
-            enabled: !0,
-            fn: i,
-            alt: c.alt || []
-        }), this.__cache__ = null
-    };
-    xt.prototype.push = function(r, e, i) {
-        var a = i || {};
-        this.__rules__.push({
-            name: r,
-            enabled: !0,
-            fn: e,
-            alt: a.alt || []
-        }), this.__cache__ = null
-    };
-    xt.prototype.enable = function(r, e) {
-        Array.isArray(r) || (r = [r]);
-        var i = [];
-        return r.forEach(function(a) {
-            var l = this.__find__(a);
-            if (l < 0) {
-                if (e) return;
-                throw new Error("Rules manager: invalid rule name " + a)
-            }
-            this.__rules__[l].enabled = !0, i.push(a)
-        }, this), this.__cache__ = null, i
-    };
-    xt.prototype.enableOnly = function(r, e) {
-        Array.isArray(r) || (r = [r]), this.__rules__.forEach(function(i) {
-            i.enabled = !1
-        }), this.enable(r, e)
-    };
-    xt.prototype.disable = function(r, e) {
-        Array.isArray(r) || (r = [r]);
-        var i = [];
-        return r.forEach(function(a) {
-            var l = this.__find__(a);
-            if (l < 0) {
-                if (e) return;
-                throw new Error("Rules manager: invalid rule name " + a)
-            }
-            this.__rules__[l].enabled = !1, i.push(a)
-        }, this), this.__cache__ = null, i
-    };
-    xt.prototype.getRules = function(r) {
-        return this.__cache__ === null && this.__compile__(), this.__cache__[r] || []
-    };
-    tl.exports = xt
-});
-var nl = W((h2, rl) => {
-    "use strict";
-    var um = /\r\n?|\n/g,
-        hm = /\0/g;
-    rl.exports = function(e) {
-        var i;
-        i = e.src.replace(um, `
-`), i = i.replace(hm, "\uFFFD"), e.src = i
-    }
-});
-var ol = W((d2, il) => {
-    "use strict";
-    il.exports = function(e) {
-        var i;
-        e.inlineMode ? (i = new e.Token("inline", "", 0), i.content = e.src, i.map = [0, 1], i.children = [], e.tokens.push(i)) : e.md.block.parse(e.src, e.md, e.env, e.tokens)
-    }
-});
-var sl = W((m2, al) => {
-    "use strict";
-    al.exports = function(e) {
-        var i = e.tokens,
-            a, l, c;
-        for (l = 0, c = i.length; l < c; l++) a = i[l], a.type === "inline" && e.md.inline.parse(a.content, e.md, e.env, a.children)
-    }
-});
-var cl = W((p2, ll) => {
-    "use strict";
-    var dm = Se().arrayReplaceAt;
-
-    function mm(r) {
-        return /^<a[>\s]/i.test(r)
-    }
-
-    function pm(r) {
-        return /^<\/a\s*>/i.test(r)
-    }
-    ll.exports = function(e) {
-        var i, a, l, c, d, f, g, y, _, w, T, A, L, R, O, P, I = e.tokens,
-            Y;
-        if (e.md.options.linkify) {
-            for (a = 0, l = I.length; a < l; a++)
-                if (!(I[a].type !== "inline" || !e.md.linkify.pretest(I[a].content)))
-                    for (c = I[a].children, L = 0, i = c.length - 1; i >= 0; i--) {
-                        if (f = c[i], f.type === "link_close") {
-                            for (i--; c[i].level !== f.level && c[i].type !== "link_open";) i--;
-                            continue
-                        }
-                        if (f.type === "html_inline" && (mm(f.content) && L > 0 && L--, pm(f.content) && L++), !(L > 0) && f.type === "text" && e.md.linkify.test(f.content)) {
-                            for (_ = f.content, Y = e.md.linkify.match(_), g = [], A = f.level, T = 0, Y.length > 0 && Y[0].index === 0 && i > 0 && c[i - 1].type === "text_special" && (Y = Y.slice(1)), y = 0; y < Y.length; y++) R = Y[y].url, O = e.md.normalizeLink(R), e.md.validateLink(O) && (P = Y[y].text, Y[y].schema ? Y[y].schema === "mailto:" && !/^mailto:/i.test(P) ? P = e.md.normalizeLinkText("mailto:" + P).replace(/^mailto:/, "") : P = e.md.normalizeLinkText(P) : P = e.md.normalizeLinkText("http://" + P).replace(/^http:\/\//, ""), w = Y[y].index, w > T && (d = new e.Token("text", "", 0), d.content = _.slice(T, w), d.level = A, g.push(d)), d = new e.Token("link_open", "a", 1), d.attrs = [
-                                ["href", O]
-                            ], d.level = A++, d.markup = "linkify", d.info = "auto", g.push(d), d = new e.Token("text", "", 0), d.content = P, d.level = A, g.push(d), d = new e.Token("link_close", "a", -1), d.level = --A, d.markup = "linkify", d.info = "auto", g.push(d), T = Y[y].lastIndex);
-                            T < _.length && (d = new e.Token("text", "", 0), d.content = _.slice(T), d.level = A, g.push(d)), I[a].children = c = dm(c, i, g)
-                        }
-                    }
-        }
-    }
-});
-var dl = W((f2, hl) => {
-    "use strict";
-    var ul = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/,
-        fm = /\((c|tm|r)\)/i,
-        gm = /\((c|tm|r)\)/ig,
-        bm = {
-            c: "\xA9",
-            r: "\xAE",
-            tm: "\u2122"
-        };
-
-    function ym(r, e) {
-        return bm[e.toLowerCase()]
-    }
-
-    function xm(r) {
-        var e, i, a = 0;
-        for (e = r.length - 1; e >= 0; e--) i = r[e], i.type === "text" && !a && (i.content = i.content.replace(gm, ym)), i.type === "link_open" && i.info === "auto" && a--, i.type === "link_close" && i.info === "auto" && a++
-    }
-
-    function vm(r) {
-        var e, i, a = 0;
-        for (e = r.length - 1; e >= 0; e--) i = r[e], i.type === "text" && !a && ul.test(i.content) && (i.content = i.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), i.type === "link_open" && i.info === "auto" && a--, i.type === "link_close" && i.info === "auto" && a++
-    }
-    hl.exports = function(e) {
-        var i;
-        if (e.md.options.typographer)
-            for (i = e.tokens.length - 1; i >= 0; i--) e.tokens[i].type === "inline" && (fm.test(e.tokens[i].content) && xm(e.tokens[i].children), ul.test(e.tokens[i].content) && vm(e.tokens[i].children))
-    }
-});
-var xl = W((g2, yl) => {
-    "use strict";
-    var ml = Se().isWhiteSpace,
-        pl = Se().isPunctChar,
-        fl = Se().isMdAsciiPunct,
-        wm = /['"]/,
-        gl = /['"]/g,
-        bl = "\u2019";
-
-    function R0(r, e, i) {
-        return r.slice(0, e) + i + r.slice(e + 1)
-    }
-
-    function km(r, e) {
-        var i, a, l, c, d, f, g, y, _, w, T, A, L, R, O, P, I, Y, re, te, j;
-        for (re = [], i = 0; i < r.length; i++) {
-            for (a = r[i], g = r[i].level, I = re.length - 1; I >= 0 && !(re[I].level <= g); I--);
-            if (re.length = I + 1, a.type === "text") {
-                l = a.content, d = 0, f = l.length;
-                e: for (; d < f && (gl.lastIndex = d, c = gl.exec(l), !!c);) {
-                    if (O = P = !0, d = c.index + 1, Y = c[0] === "'", _ = 32, c.index - 1 >= 0) _ = l.charCodeAt(c.index - 1);
-                    else
-                        for (I = i - 1; I >= 0 && !(r[I].type === "softbreak" || r[I].type === "hardbreak"); I--)
-                            if (r[I].content) {
-                                _ = r[I].content.charCodeAt(r[I].content.length - 1);
-                                break
-                            } if (w = 32, d < f) w = l.charCodeAt(d);
-                    else
-                        for (I = i + 1; I < r.length && !(r[I].type === "softbreak" || r[I].type === "hardbreak"); I++)
-                            if (r[I].content) {
-                                w = r[I].content.charCodeAt(0);
-                                break
-                            } if (T = fl(_) || pl(String.fromCharCode(_)), A = fl(w) || pl(String.fromCharCode(w)), L = ml(_), R = ml(w), R ? O = !1 : A && (L || T || (O = !1)), L ? P = !1 : T && (R || A || (P = !1)), w === 34 && c[0] === '"' && _ >= 48 && _ <= 57 && (P = O = !1), O && P && (O = T, P = A), !O && !P) {
-                        Y && (a.content = R0(a.content, c.index, bl));
-                        continue
-                    }
-                    if (P) {
-                        for (I = re.length - 1; I >= 0 && (y = re[I], !(re[I].level < g)); I--)
-                            if (y.single === Y && re[I].level === g) {
-                                y = re[I], Y ? (te = e.md.options.quotes[2], j = e.md.options.quotes[3]) : (te = e.md.options.quotes[0], j = e.md.options.quotes[1]), a.content = R0(a.content, c.index, j), r[y.token].content = R0(r[y.token].content, y.pos, te), d += j.length - 1, y.token === i && (d += te.length - 1), l = a.content, f = l.length, re.length = I;
-                                continue e
-                            }
-                    }
-                    O ? re.push({
-                        token: i,
-                        pos: c.index,
-                        single: Y,
-                        level: g
-                    }) : P && Y && (a.content = R0(a.content, c.index, bl))
-                }
-            }
-        }
-    }
-    yl.exports = function(e) {
-        var i;
-        if (e.md.options.typographer)
-            for (i = e.tokens.length - 1; i >= 0; i--) e.tokens[i].type !== "inline" || !wm.test(e.tokens[i].content) || km(e.tokens[i].children, e)
-    }
-});
-var wl = W((b2, vl) => {
-    "use strict";
-    vl.exports = function(e) {
-        var i, a, l, c, d, f, g = e.tokens;
-        for (i = 0, a = g.length; i < a; i++)
-            if (g[i].type === "inline") {
-                for (l = g[i].children, d = l.length, c = 0; c < d; c++) l[c].type === "text_special" && (l[c].type = "text");
-                for (c = f = 0; c < d; c++) l[c].type === "text" && c + 1 < d && l[c + 1].type === "text" ? l[c + 1].content = l[c].content + l[c + 1].content : (c !== f && (l[f] = l[c]), f++);
-                c !== f && (l.length = f)
-            }
-    }
-});
-var F0 = W((y2, kl) => {
-    "use strict";
-
-    function gr(r, e, i) {
-        this.type = r, this.tag = e, this.attrs = null, this.map = null, this.nesting = i, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1
-    }
-    gr.prototype.attrIndex = function(e) {
-        var i, a, l;
-        if (!this.attrs) return -1;
-        for (i = this.attrs, a = 0, l = i.length; a < l; a++)
-            if (i[a][0] === e) return a;
-        return -1
-    };
-    gr.prototype.attrPush = function(e) {
-        this.attrs ? this.attrs.push(e) : this.attrs = [e]
-    };
-    gr.prototype.attrSet = function(e, i) {
-        var a = this.attrIndex(e),
-            l = [e, i];
-        a < 0 ? this.attrPush(l) : this.attrs[a] = l
-    };
-    gr.prototype.attrGet = function(e) {
-        var i = this.attrIndex(e),
-            a = null;
-        return i >= 0 && (a = this.attrs[i][1]), a
-    };
-    gr.prototype.attrJoin = function(e, i) {
-        var a = this.attrIndex(e);
-        a < 0 ? this.attrPush([e, i]) : this.attrs[a][1] = this.attrs[a][1] + " " + i
-    };
-    kl.exports = gr
-});
-var Cl = W((x2, Sl) => {
-    "use strict";
-    var _m = F0();
-
-    function _l(r, e, i) {
-        this.src = r, this.env = i, this.tokens = [], this.inlineMode = !1, this.md = e
-    }
-    _l.prototype.Token = _m;
-    Sl.exports = _l
-});
-var Al = W((v2, Tl) => {
-    "use strict";
-    var Sm = z0(),
-        ui = [
-            ["normalize", nl()],
-            ["block", ol()],
-            ["inline", sl()],
-            ["linkify", cl()],
-            ["replacements", dl()],
-            ["smartquotes", xl()],
-            ["text_join", wl()]
-        ];
-
-    function hi() {
-        this.ruler = new Sm;
-        for (var r = 0; r < ui.length; r++) this.ruler.push(ui[r][0], ui[r][1])
-    }
-    hi.prototype.process = function(r) {
-        var e, i, a;
-        for (a = this.ruler.getRules(""), e = 0, i = a.length; e < i; e++) a[e](r)
-    };
-    hi.prototype.State = Cl();
-    Tl.exports = hi
-});
-var El = W((w2, Ml) => {
-    "use strict";
-    var di = Se().isSpace;
-
-    function mi(r, e) {
-        var i = r.bMarks[e] + r.tShift[e],
-            a = r.eMarks[e];
-        return r.src.slice(i, a)
-    }
-
-    function ql(r) {
-        var e = [],
-            i = 0,
-            a = r.length,
-            l, c = !1,
-            d = 0,
-            f = "";
-        for (l = r.charCodeAt(i); i < a;) l === 124 && (c ? (f += r.substring(d, i - 1), d = i) : (e.push(f + r.substring(d, i)), f = "", d = i + 1)), c = l === 92, i++, l = r.charCodeAt(i);
-        return e.push(f + r.substring(d)), e
-    }
-    Ml.exports = function(e, i, a, l) {
-        var c, d, f, g, y, _, w, T, A, L, R, O, P, I, Y, re, te, j;
-        if (i + 2 > a || (_ = i + 1, e.sCount[_] < e.blkIndent) || e.sCount[_] - e.blkIndent >= 4 || (f = e.bMarks[_] + e.tShift[_], f >= e.eMarks[_]) || (te = e.src.charCodeAt(f++), te !== 124 && te !== 45 && te !== 58) || f >= e.eMarks[_] || (j = e.src.charCodeAt(f++), j !== 124 && j !== 45 && j !== 58 && !di(j)) || te === 45 && di(j)) return !1;
-        for (; f < e.eMarks[_];) {
-            if (c = e.src.charCodeAt(f), c !== 124 && c !== 45 && c !== 58 && !di(c)) return !1;
-            f++
-        }
-        for (d = mi(e, i + 1), w = d.split("|"), L = [], g = 0; g < w.length; g++) {
-            if (R = w[g].trim(), !R) {
-                if (g === 0 || g === w.length - 1) continue;
-                return !1
-            }
-            if (!/^:?-+:?$/.test(R)) return !1;
-            R.charCodeAt(R.length - 1) === 58 ? L.push(R.charCodeAt(0) === 58 ? "center" : "right") : R.charCodeAt(0) === 58 ? L.push("left") : L.push("")
-        }
-        if (d = mi(e, i).trim(), d.indexOf("|") === -1 || e.sCount[i] - e.blkIndent >= 4 || (w = ql(d), w.length && w[0] === "" && w.shift(), w.length && w[w.length - 1] === "" && w.pop(), T = w.length, T === 0 || T !== L.length)) return !1;
-        if (l) return !0;
-        for (I = e.parentType, e.parentType = "table", re = e.md.block.ruler.getRules("blockquote"), A = e.push("table_open", "table", 1), A.map = O = [i, 0], A = e.push("thead_open", "thead", 1), A.map = [i, i + 1], A = e.push("tr_open", "tr", 1), A.map = [i, i + 1], g = 0; g < w.length; g++) A = e.push("th_open", "th", 1), L[g] && (A.attrs = [
-            ["style", "text-align:" + L[g]]
-        ]), A = e.push("inline", "", 0), A.content = w[g].trim(), A.children = [], A = e.push("th_close", "th", -1);
-        for (A = e.push("tr_close", "tr", -1), A = e.push("thead_close", "thead", -1), _ = i + 2; _ < a && !(e.sCount[_] < e.blkIndent); _++) {
-            for (Y = !1, g = 0, y = re.length; g < y; g++)
-                if (re[g](e, _, a, !0)) {
-                    Y = !0;
-                    break
-                } if (Y || (d = mi(e, _).trim(), !d) || e.sCount[_] - e.blkIndent >= 4) break;
-            for (w = ql(d), w.length && w[0] === "" && w.shift(), w.length && w[w.length - 1] === "" && w.pop(), _ === i + 2 && (A = e.push("tbody_open", "tbody", 1), A.map = P = [i + 2, 0]), A = e.push("tr_open", "tr", 1), A.map = [_, _ + 1], g = 0; g < T; g++) A = e.push("td_open", "td", 1), L[g] && (A.attrs = [
-                ["style", "text-align:" + L[g]]
-            ]), A = e.push("inline", "", 0), A.content = w[g] ? w[g].trim() : "", A.children = [], A = e.push("td_close", "td", -1);
-            A = e.push("tr_close", "tr", -1)
-        }
-        return P && (A = e.push("tbody_close", "tbody", -1), P[1] = _), A = e.push("table_close", "table", -1), O[1] = _, e.parentType = I, e.line = _, !0
-    }
-});
-var zl = W((k2, Dl) => {
-    "use strict";
-    Dl.exports = function(e, i, a) {
-        var l, c, d;
-        if (e.sCount[i] - e.blkIndent < 4) return !1;
-        for (c = l = i + 1; l < a;) {
-            if (e.isEmpty(l)) {
-                l++;
-                continue
-            }
-            if (e.sCount[l] - e.blkIndent >= 4) {
-                l++, c = l;
-                continue
-            }
-            break
-        }
-        return e.line = c, d = e.push("code_block", "code", 0), d.content = e.getLines(i, c, 4 + e.blkIndent, !1) + `
-`, d.map = [i, e.line], !0
-    }
-});
-var Fl = W((_2, Rl) => {
-    "use strict";
-    Rl.exports = function(e, i, a, l) {
-        var c, d, f, g, y, _, w, T = !1,
-            A = e.bMarks[i] + e.tShift[i],
-            L = e.eMarks[i];
-        if (e.sCount[i] - e.blkIndent >= 4 || A + 3 > L || (c = e.src.charCodeAt(A), c !== 126 && c !== 96) || (y = A, A = e.skipChars(A, c), d = A - y, d < 3) || (w = e.src.slice(y, A), f = e.src.slice(A, L), c === 96 && f.indexOf(String.fromCharCode(c)) >= 0)) return !1;
-        if (l) return !0;
-        for (g = i; g++, !(g >= a || (A = y = e.bMarks[g] + e.tShift[g], L = e.eMarks[g], A < L && e.sCount[g] < e.blkIndent));)
-            if (e.src.charCodeAt(A) === c && !(e.sCount[g] - e.blkIndent >= 4) && (A = e.skipChars(A, c), !(A - y < d) && (A = e.skipSpaces(A), !(A < L)))) {
-                T = !0;
-                break
-            } return d = e.sCount[i], e.line = g + (T ? 1 : 0), _ = e.push("fence", "code", 0), _.info = f, _.content = e.getLines(i + 1, g, d, !0), _.markup = w, _.map = [i, e.line], !0
-    }
-});
-var Nl = W((S2, Bl) => {
-    "use strict";
-    var Cm = Se().isSpace;
-    Bl.exports = function(e, i, a, l) {
-        var c, d, f, g, y, _, w, T, A, L, R, O, P, I, Y, re, te, j, ne, pe, ue = e.lineMax,
-            ce = e.bMarks[i] + e.tShift[i],
-            Ce = e.eMarks[i];
-        if (e.sCount[i] - e.blkIndent >= 4 || e.src.charCodeAt(ce) !== 62) return !1;
-        if (l) return !0;
-        for (L = [], R = [], I = [], Y = [], j = e.md.block.ruler.getRules("blockquote"), P = e.parentType, e.parentType = "blockquote", T = i; T < a && (pe = e.sCount[T] < e.blkIndent, ce = e.bMarks[T] + e.tShift[T], Ce = e.eMarks[T], !(ce >= Ce)); T++) {
-            if (e.src.charCodeAt(ce++) === 62 && !pe) {
-                for (g = e.sCount[T] + 1, e.src.charCodeAt(ce) === 32 ? (ce++, g++, c = !1, re = !0) : e.src.charCodeAt(ce) === 9 ? (re = !0, (e.bsCount[T] + g) % 4 === 3 ? (ce++, g++, c = !1) : c = !0) : re = !1, A = g, L.push(e.bMarks[T]), e.bMarks[T] = ce; ce < Ce && (d = e.src.charCodeAt(ce), Cm(d));) {
-                    d === 9 ? A += 4 - (A + e.bsCount[T] + (c ? 1 : 0)) % 4 : A++;
-                    ce++
-                }
-                _ = ce >= Ce, R.push(e.bsCount[T]), e.bsCount[T] = e.sCount[T] + 1 + (re ? 1 : 0), I.push(e.sCount[T]), e.sCount[T] = A - g, Y.push(e.tShift[T]), e.tShift[T] = ce - e.bMarks[T];
-                continue
-            }
-            if (_) break;
-            for (te = !1, f = 0, y = j.length; f < y; f++)
-                if (j[f](e, T, a, !0)) {
-                    te = !0;
-                    break
-                } if (te) {
-                e.lineMax = T, e.blkIndent !== 0 && (L.push(e.bMarks[T]), R.push(e.bsCount[T]), Y.push(e.tShift[T]), I.push(e.sCount[T]), e.sCount[T] -= e.blkIndent);
-                break
-            }
-            L.push(e.bMarks[T]), R.push(e.bsCount[T]), Y.push(e.tShift[T]), I.push(e.sCount[T]), e.sCount[T] = -1
-        }
-        for (O = e.blkIndent, e.blkIndent = 0, ne = e.push("blockquote_open", "blockquote", 1), ne.markup = ">", ne.map = w = [i, 0], e.md.block.tokenize(e, i, T), ne = e.push("blockquote_close", "blockquote", -1), ne.markup = ">", e.lineMax = ue, e.parentType = P, w[1] = e.line, f = 0; f < Y.length; f++) e.bMarks[f + i] = L[f], e.tShift[f + i] = Y[f], e.sCount[f + i] = I[f], e.bsCount[f + i] = R[f];
-        return e.blkIndent = O, !0
-    }
-});
-var Pl = W((C2, Ll) => {
-    "use strict";
-    var Tm = Se().isSpace;
-    Ll.exports = function(e, i, a, l) {
-        var c, d, f, g, y = e.bMarks[i] + e.tShift[i],
-            _ = e.eMarks[i];
-        if (e.sCount[i] - e.blkIndent >= 4 || (c = e.src.charCodeAt(y++), c !== 42 && c !== 45 && c !== 95)) return !1;
-        for (d = 1; y < _;) {
-            if (f = e.src.charCodeAt(y++), f !== c && !Tm(f)) return !1;
-            f === c && d++
-        }
-        return d < 3 ? !1 : (l || (e.line = i + 1, g = e.push("hr", "hr", 0), g.map = [i, e.line], g.markup = Array(d + 1).join(String.fromCharCode(c))), !0)
-    }
-});
-var Gl = W((T2, $l) => {
-    "use strict";
-    var Hl = Se().isSpace;
-
-    function Il(r, e) {
-        var i, a, l, c;
-        return a = r.bMarks[e] + r.tShift[e], l = r.eMarks[e], i = r.src.charCodeAt(a++), i !== 42 && i !== 45 && i !== 43 || a < l && (c = r.src.charCodeAt(a), !Hl(c)) ? -1 : a
-    }
-
-    function Ol(r, e) {
-        var i, a = r.bMarks[e] + r.tShift[e],
-            l = a,
-            c = r.eMarks[e];
-        if (l + 1 >= c || (i = r.src.charCodeAt(l++), i < 48 || i > 57)) return -1;
-        for (;;) {
-            if (l >= c) return -1;
-            if (i = r.src.charCodeAt(l++), i >= 48 && i <= 57) {
-                if (l - a >= 10) return -1;
-                continue
-            }
-            if (i === 41 || i === 46) break;
-            return -1
-        }
-        return l < c && (i = r.src.charCodeAt(l), !Hl(i)) ? -1 : l
-    }
-
-    function Am(r, e) {
-        var i, a, l = r.level + 2;
-        for (i = e + 2, a = r.tokens.length - 2; i < a; i++) r.tokens[i].level === l && r.tokens[i].type === "paragraph_open" && (r.tokens[i + 2].hidden = !0, r.tokens[i].hidden = !0, i += 2)
-    }
-    $l.exports = function(e, i, a, l) {
-        var c, d, f, g, y, _, w, T, A, L, R, O, P, I, Y, re, te, j, ne, pe, ue, ce, Ce, De, U, X, he, oe = i,
-            ae = !1,
-            ee = !0;
-        if (e.sCount[oe] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[oe] - e.listIndent >= 4 && e.sCount[oe] < e.blkIndent) return !1;
-        if (l && e.parentType === "paragraph" && e.sCount[oe] >= e.blkIndent && (ae = !0), (ce = Ol(e, oe)) >= 0) {
-            if (w = !0, De = e.bMarks[oe] + e.tShift[oe], P = Number(e.src.slice(De, ce - 1)), ae && P !== 1) return !1
-        } else if ((ce = Il(e, oe)) >= 0) w = !1;
-        else return !1;
-        if (ae && e.skipSpaces(ce) >= e.eMarks[oe]) return !1;
-        if (l) return !0;
-        for (O = e.src.charCodeAt(ce - 1), R = e.tokens.length, w ? (he = e.push("ordered_list_open", "ol", 1), P !== 1 && (he.attrs = [
-                ["start", P]
-            ])) : he = e.push("bullet_list_open", "ul", 1), he.map = L = [oe, 0], he.markup = String.fromCharCode(O), Ce = !1, X = e.md.block.ruler.getRules("list"), te = e.parentType, e.parentType = "list"; oe < a;) {
-            for (ue = ce, I = e.eMarks[oe], _ = Y = e.sCount[oe] + ce - (e.bMarks[oe] + e.tShift[oe]); ue < I;) {
-                if (c = e.src.charCodeAt(ue), c === 9) Y += 4 - (Y + e.bsCount[oe]) % 4;
-                else if (c === 32) Y++;
-                else break;
-                ue++
-            }
-            if (d = ue, d >= I ? y = 1 : y = Y - _, y > 4 && (y = 1), g = _ + y, he = e.push("list_item_open", "li", 1), he.markup = String.fromCharCode(O), he.map = T = [oe, 0], w && (he.info = e.src.slice(De, ce - 1)), pe = e.tight, ne = e.tShift[oe], j = e.sCount[oe], re = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = g, e.tight = !0, e.tShift[oe] = d - e.bMarks[oe], e.sCount[oe] = Y, d >= I && e.isEmpty(oe + 1) ? e.line = Math.min(e.line + 2, a) : e.md.block.tokenize(e, oe, a, !0), (!e.tight || Ce) && (ee = !1), Ce = e.line - oe > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = re, e.tShift[oe] = ne, e.sCount[oe] = j, e.tight = pe, he = e.push("list_item_close", "li", -1), he.markup = String.fromCharCode(O), oe = e.line, T[1] = oe, oe >= a || e.sCount[oe] < e.blkIndent || e.sCount[oe] - e.blkIndent >= 4) break;
-            for (U = !1, f = 0, A = X.length; f < A; f++)
-                if (X[f](e, oe, a, !0)) {
-                    U = !0;
-                    break
-                } if (U) break;
-            if (w) {
-                if (ce = Ol(e, oe), ce < 0) break;
-                De = e.bMarks[oe] + e.tShift[oe]
-            } else if (ce = Il(e, oe), ce < 0) break;
-            if (O !== e.src.charCodeAt(ce - 1)) break
-        }
-        return w ? he = e.push("ordered_list_close", "ol", -1) : he = e.push("bullet_list_close", "ul", -1), he.markup = String.fromCharCode(O), L[1] = oe, e.line = oe, e.parentType = te, ee && Am(e, R), !0
-    }
-});
-var jl = W((A2, Vl) => {
-    "use strict";
-    var qm = Se().normalizeReference,
-        B0 = Se().isSpace;
-    Vl.exports = function(e, i, a, l) {
-        var c, d, f, g, y, _, w, T, A, L, R, O, P, I, Y, re, te = 0,
-            j = e.bMarks[i] + e.tShift[i],
-            ne = e.eMarks[i],
-            pe = i + 1;
-        if (e.sCount[i] - e.blkIndent >= 4 || e.src.charCodeAt(j) !== 91) return !1;
-        for (; ++j < ne;)
-            if (e.src.charCodeAt(j) === 93 && e.src.charCodeAt(j - 1) !== 92) {
-                if (j + 1 === ne || e.src.charCodeAt(j + 1) !== 58) return !1;
-                break
-            } for (g = e.lineMax, Y = e.md.block.ruler.getRules("reference"), L = e.parentType, e.parentType = "reference"; pe < g && !e.isEmpty(pe); pe++)
-            if (!(e.sCount[pe] - e.blkIndent > 3) && !(e.sCount[pe] < 0)) {
-                for (I = !1, _ = 0, w = Y.length; _ < w; _++)
-                    if (Y[_](e, pe, g, !0)) {
-                        I = !0;
-                        break
-                    } if (I) break
-            } for (P = e.getLines(i, pe, e.blkIndent, !1).trim(), ne = P.length, j = 1; j < ne; j++) {
-            if (c = P.charCodeAt(j), c === 91) return !1;
-            if (c === 93) {
-                A = j;
-                break
-            } else c === 10 ? te++ : c === 92 && (j++, j < ne && P.charCodeAt(j) === 10 && te++)
-        }
-        if (A < 0 || P.charCodeAt(A + 1) !== 58) return !1;
-        for (j = A + 2; j < ne; j++)
-            if (c = P.charCodeAt(j), c === 10) te++;
-            else if (!B0(c)) break;
-        if (R = e.md.helpers.parseLinkDestination(P, j, ne), !R.ok || (y = e.md.normalizeLink(R.str), !e.md.validateLink(y))) return !1;
-        for (j = R.pos, te += R.lines, d = j, f = te, O = j; j < ne; j++)
-            if (c = P.charCodeAt(j), c === 10) te++;
-            else if (!B0(c)) break;
-        for (R = e.md.helpers.parseLinkTitle(P, j, ne), j < ne && O !== j && R.ok ? (re = R.str, j = R.pos, te += R.lines) : (re = "", j = d, te = f); j < ne && (c = P.charCodeAt(j), !!B0(c));) j++;
-        if (j < ne && P.charCodeAt(j) !== 10 && re)
-            for (re = "", j = d, te = f; j < ne && (c = P.charCodeAt(j), !!B0(c));) j++;
-        return j < ne && P.charCodeAt(j) !== 10 || (T = qm(P.slice(1, A)), !T) ? !1 : (l || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[T] > "u" && (e.env.references[T] = {
-            title: re,
-            href: y
-        }), e.parentType = L, e.line = i + te + 1), !0)
-    }
-});
-var Wl = W((q2, Ul) => {
-    "use strict";
-    Ul.exports = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "section", "source", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"]
-});
-var fi = W((M2, pi) => {
-    "use strict";
-    var Mm = "[a-zA-Z_:][a-zA-Z0-9:._-]*",
-        Em = "[^\"'=<>`\\x00-\\x20]+",
-        Dm = "'[^']*'",
-        zm = '"[^"]*"',
-        Rm = "(?:" + Em + "|" + Dm + "|" + zm + ")",
-        Fm = "(?:\\s+" + Mm + "(?:\\s*=\\s*" + Rm + ")?)",
-        Yl = "<[A-Za-z][A-Za-z0-9\\-]*" + Fm + "*\\s*\\/?>",
-        Zl = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>",
-        Bm = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->",
-        Nm = "<[?][\\s\\S]*?[?]>",
-        Lm = "<![A-Z]+\\s+[^>]*>",
-        Pm = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
-        Im = new RegExp("^(?:" + Yl + "|" + Zl + "|" + Bm + "|" + Nm + "|" + Lm + "|" + Pm + ")"),
-        Om = new RegExp("^(?:" + Yl + "|" + Zl + ")");
-    pi.exports.HTML_TAG_RE = Im;
-    pi.exports.HTML_OPEN_CLOSE_TAG_RE = Om
-});
-var Xl = W((E2, Ql) => {
-    "use strict";
-    var Hm = Wl(),
-        $m = fi().HTML_OPEN_CLOSE_TAG_RE,
-        br = [
-            [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
-            [/^<!--/, /-->/, !0],
-            [/^<\?/, /\?>/, !0],
-            [/^<![A-Z]/, />/, !0],
-            [/^<!\[CDATA\[/, /\]\]>/, !0],
-            [new RegExp("^</?(" + Hm.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
-            [new RegExp($m.source + "\\s*$"), /^$/, !1]
-        ];
-    Ql.exports = function(e, i, a, l) {
-        var c, d, f, g, y = e.bMarks[i] + e.tShift[i],
-            _ = e.eMarks[i];
-        if (e.sCount[i] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(y) !== 60) return !1;
-        for (g = e.src.slice(y, _), c = 0; c < br.length && !br[c][0].test(g); c++);
-        if (c === br.length) return !1;
-        if (l) return br[c][2];
-        if (d = i + 1, !br[c][1].test(g)) {
-            for (; d < a && !(e.sCount[d] < e.blkIndent); d++)
-                if (y = e.bMarks[d] + e.tShift[d], _ = e.eMarks[d], g = e.src.slice(y, _), br[c][1].test(g)) {
-                    g.length !== 0 && d++;
-                    break
-                }
-        }
-        return e.line = d, f = e.push("html_block", "", 0), f.map = [i, d], f.content = e.getLines(i, d, e.blkIndent, !0), !0
-    }
-});
-var ec = W((D2, Kl) => {
-    "use strict";
-    var Jl = Se().isSpace;
-    Kl.exports = function(e, i, a, l) {
-        var c, d, f, g, y = e.bMarks[i] + e.tShift[i],
-            _ = e.eMarks[i];
-        if (e.sCount[i] - e.blkIndent >= 4 || (c = e.src.charCodeAt(y), c !== 35 || y >= _)) return !1;
-        for (d = 1, c = e.src.charCodeAt(++y); c === 35 && y < _ && d <= 6;) d++, c = e.src.charCodeAt(++y);
-        return d > 6 || y < _ && !Jl(c) ? !1 : (l || (_ = e.skipSpacesBack(_, y), f = e.skipCharsBack(_, 35, y), f > y && Jl(e.src.charCodeAt(f - 1)) && (_ = f), e.line = i + 1, g = e.push("heading_open", "h" + String(d), 1), g.markup = "########".slice(0, d), g.map = [i, e.line], g = e.push("inline", "", 0), g.content = e.src.slice(y, _).trim(), g.map = [i, e.line], g.children = [], g = e.push("heading_close", "h" + String(d), -1), g.markup = "########".slice(0, d)), !0)
-    }
-});
-var rc = W((z2, tc) => {
-    "use strict";
-    tc.exports = function(e, i, a) {
-        var l, c, d, f, g, y, _, w, T, A = i + 1,
-            L, R = e.md.block.ruler.getRules("paragraph");
-        if (e.sCount[i] - e.blkIndent >= 4) return !1;
-        for (L = e.parentType, e.parentType = "paragraph"; A < a && !e.isEmpty(A); A++)
-            if (!(e.sCount[A] - e.blkIndent > 3)) {
-                if (e.sCount[A] >= e.blkIndent && (y = e.bMarks[A] + e.tShift[A], _ = e.eMarks[A], y < _ && (T = e.src.charCodeAt(y), (T === 45 || T === 61) && (y = e.skipChars(y, T), y = e.skipSpaces(y), y >= _)))) {
-                    w = T === 61 ? 1 : 2;
-                    break
-                }
-                if (!(e.sCount[A] < 0)) {
-                    for (c = !1, d = 0, f = R.length; d < f; d++)
-                        if (R[d](e, A, a, !0)) {
-                            c = !0;
-                            break
-                        } if (c) break
-                }
-            } return w ? (l = e.getLines(i, A, e.blkIndent, !1).trim(), e.line = A + 1, g = e.push("heading_open", "h" + String(w), 1), g.markup = String.fromCharCode(T), g.map = [i, e.line], g = e.push("inline", "", 0), g.content = l, g.map = [i, e.line - 1], g.children = [], g = e.push("heading_close", "h" + String(w), -1), g.markup = String.fromCharCode(T), e.parentType = L, !0) : !1
-    }
-});
-var ic = W((R2, nc) => {
-    "use strict";
-    nc.exports = function(e, i, a) {
-        var l, c, d, f, g, y, _ = i + 1,
-            w = e.md.block.ruler.getRules("paragraph");
-        for (y = e.parentType, e.parentType = "paragraph"; _ < a && !e.isEmpty(_); _++)
-            if (!(e.sCount[_] - e.blkIndent > 3) && !(e.sCount[_] < 0)) {
-                for (c = !1, d = 0, f = w.length; d < f; d++)
-                    if (w[d](e, _, a, !0)) {
-                        c = !0;
-                        break
-                    } if (c) break
-            } return l = e.getLines(i, _, e.blkIndent, !1).trim(), e.line = _, g = e.push("paragraph_open", "p", 1), g.map = [i, e.line], g = e.push("inline", "", 0), g.content = l, g.map = [i, e.line], g.children = [], g = e.push("paragraph_close", "p", -1), e.parentType = y, !0
-    }
-});
-var sc = W((F2, ac) => {
-    "use strict";
-    var oc = F0(),
-        N0 = Se().isSpace;
-
-    function Tt(r, e, i, a) {
-        var l, c, d, f, g, y, _, w;
-        for (this.src = r, this.md = e, this.env = i, this.tokens = a, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", c = this.src, w = !1, d = f = y = _ = 0, g = c.length; f < g; f++) {
-            if (l = c.charCodeAt(f), !w)
-                if (N0(l)) {
-                    y++, l === 9 ? _ += 4 - _ % 4 : _++;
-                    continue
-                } else w = !0;
-            (l === 10 || f === g - 1) && (l !== 10 && f++, this.bMarks.push(d), this.eMarks.push(f), this.tShift.push(y), this.sCount.push(_), this.bsCount.push(0), w = !1, y = 0, _ = 0, d = f + 1)
-        }
-        this.bMarks.push(c.length), this.eMarks.push(c.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1
-    }
-    Tt.prototype.push = function(r, e, i) {
-        var a = new oc(r, e, i);
-        return a.block = !0, i < 0 && this.level--, a.level = this.level, i > 0 && this.level++, this.tokens.push(a), a
-    };
-    Tt.prototype.isEmpty = function(e) {
-        return this.bMarks[e] + this.tShift[e] >= this.eMarks[e]
-    };
-    Tt.prototype.skipEmptyLines = function(e) {
-        for (var i = this.lineMax; e < i && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++);
-        return e
-    };
-    Tt.prototype.skipSpaces = function(e) {
-        for (var i, a = this.src.length; e < a && (i = this.src.charCodeAt(e), !!N0(i)); e++);
-        return e
-    };
-    Tt.prototype.skipSpacesBack = function(e, i) {
-        if (e <= i) return e;
-        for (; e > i;)
-            if (!N0(this.src.charCodeAt(--e))) return e + 1;
-        return e
-    };
-    Tt.prototype.skipChars = function(e, i) {
-        for (var a = this.src.length; e < a && this.src.charCodeAt(e) === i; e++);
-        return e
-    };
-    Tt.prototype.skipCharsBack = function(e, i, a) {
-        if (e <= a) return e;
-        for (; e > a;)
-            if (i !== this.src.charCodeAt(--e)) return e + 1;
-        return e
-    };
-    Tt.prototype.getLines = function(e, i, a, l) {
-        var c, d, f, g, y, _, w, T = e;
-        if (e >= i) return "";
-        for (_ = new Array(i - e), c = 0; T < i; T++, c++) {
-            for (d = 0, w = g = this.bMarks[T], T + 1 < i || l ? y = this.eMarks[T] + 1 : y = this.eMarks[T]; g < y && d < a;) {
-                if (f = this.src.charCodeAt(g), N0(f)) f === 9 ? d += 4 - (d + this.bsCount[T]) % 4 : d++;
-                else if (g - w < this.tShift[T]) d++;
-                else break;
-                g++
-            }
-            d > a ? _[c] = new Array(d - a + 1).join(" ") + this.src.slice(g, y) : _[c] = this.src.slice(g, y)
-        }
-        return _.join("")
-    };
-    Tt.prototype.Token = oc;
-    ac.exports = Tt
-});
-var cc = W((B2, lc) => {
-    "use strict";
-    var Gm = z0(),
-        L0 = [
-            ["table", El(), ["paragraph", "reference"]],
-            ["code", zl()],
-            ["fence", Fl(), ["paragraph", "reference", "blockquote", "list"]],
-            ["blockquote", Nl(), ["paragraph", "reference", "blockquote", "list"]],
-            ["hr", Pl(), ["paragraph", "reference", "blockquote", "list"]],
-            ["list", Gl(), ["paragraph", "reference", "blockquote"]],
-            ["reference", jl()],
-            ["html_block", Xl(), ["paragraph", "reference", "blockquote"]],
-            ["heading", ec(), ["paragraph", "reference", "blockquote"]],
-            ["lheading", rc()],
-            ["paragraph", ic()]
-        ];
-
-    function P0() {
-        this.ruler = new Gm;
-        for (var r = 0; r < L0.length; r++) this.ruler.push(L0[r][0], L0[r][1], {
-            alt: (L0[r][2] || []).slice()
-        })
-    }
-    P0.prototype.tokenize = function(r, e, i) {
-        for (var a, l, c, d = this.ruler.getRules(""), f = d.length, g = e, y = !1, _ = r.md.options.maxNesting; g < i && (r.line = g = r.skipEmptyLines(g), !(g >= i || r.sCount[g] < r.blkIndent));) {
-            if (r.level >= _) {
-                r.line = i;
-                break
-            }
-            for (c = r.line, l = 0; l < f; l++)
-                if (a = d[l](r, g, i, !1), a) {
-                    if (c >= r.line) throw new Error("block rule didn't increment state.line");
-                    break
-                } if (!a) throw new Error("none of the block rules matched");
-            r.tight = !y, r.isEmpty(r.line - 1) && (y = !0), g = r.line, g < i && r.isEmpty(g) && (y = !0, g++, r.line = g)
-        }
-    };
-    P0.prototype.parse = function(r, e, i, a) {
-        var l;
-        r && (l = new this.State(r, e, i, a), this.tokenize(l, l.line, l.lineMax))
-    };
-    P0.prototype.State = sc();
-    lc.exports = P0
-});
-var hc = W((N2, uc) => {
-    "use strict";
-
-    function Vm(r) {
-        switch (r) {
-            case 10:
-            case 33:
-            case 35:
-            case 36:
-            case 37:
-            case 38:
-            case 42:
-            case 43:
-            case 45:
-            case 58:
-            case 60:
-            case 61:
-            case 62:
-            case 64:
-            case 91:
-            case 92:
-            case 93:
-            case 94:
-            case 95:
-            case 96:
-            case 123:
-            case 125:
-            case 126:
-                return !0;
-            default:
-                return !1
-        }
-    }
-    uc.exports = function(e, i) {
-        for (var a = e.pos; a < e.posMax && !Vm(e.src.charCodeAt(a));) a++;
-        return a === e.pos ? !1 : (i || (e.pending += e.src.slice(e.pos, a)), e.pos = a, !0)
-    }
-});
-var mc = W((L2, dc) => {
-    "use strict";
-    var jm = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
-    dc.exports = function(e, i) {
-        var a, l, c, d, f, g, y, _;
-        return !e.md.options.linkify || e.linkLevel > 0 || (a = e.pos, l = e.posMax, a + 3 > l) || e.src.charCodeAt(a) !== 58 || e.src.charCodeAt(a + 1) !== 47 || e.src.charCodeAt(a + 2) !== 47 || (c = e.pending.match(jm), !c) || (d = c[1], f = e.md.linkify.matchAtStart(e.src.slice(a - d.length)), !f) || (g = f.url, g.length <= d.length) || (g = g.replace(/\*+$/, ""), y = e.md.normalizeLink(g), !e.md.validateLink(y)) ? !1 : (i || (e.pending = e.pending.slice(0, -d.length), _ = e.push("link_open", "a", 1), _.attrs = [
-            ["href", y]
-        ], _.markup = "linkify", _.info = "auto", _ = e.push("text", "", 0), _.content = e.md.normalizeLinkText(g), _ = e.push("link_close", "a", -1), _.markup = "linkify", _.info = "auto"), e.pos += g.length - d.length, !0)
-    }
-});
-var fc = W((P2, pc) => {
-    "use strict";
-    var Um = Se().isSpace;
-    pc.exports = function(e, i) {
-        var a, l, c, d = e.pos;
-        if (e.src.charCodeAt(d) !== 10) return !1;
-        if (a = e.pending.length - 1, l = e.posMax, !i)
-            if (a >= 0 && e.pending.charCodeAt(a) === 32)
-                if (a >= 1 && e.pending.charCodeAt(a - 1) === 32) {
-                    for (c = a - 1; c >= 1 && e.pending.charCodeAt(c - 1) === 32;) c--;
-                    e.pending = e.pending.slice(0, c), e.push("hardbreak", "br", 0)
-                } else e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
-        else e.push("softbreak", "br", 0);
-        for (d++; d < l && Um(e.src.charCodeAt(d));) d++;
-        return e.pos = d, !0
-    }
-});
-var bc = W((I2, gc) => {
-    "use strict";
-    var Wm = Se().isSpace,
-        bi = [];
-    for (gi = 0; gi < 256; gi++) bi.push(0);
-    var gi;
-    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(r) {
-        bi[r.charCodeAt(0)] = 1
-    });
-    gc.exports = function(e, i) {
-        var a, l, c, d, f, g = e.pos,
-            y = e.posMax;
-        if (e.src.charCodeAt(g) !== 92 || (g++, g >= y)) return !1;
-        if (a = e.src.charCodeAt(g), a === 10) {
-            for (i || e.push("hardbreak", "br", 0), g++; g < y && (a = e.src.charCodeAt(g), !!Wm(a));) g++;
-            return e.pos = g, !0
-        }
-        return d = e.src[g], a >= 55296 && a <= 56319 && g + 1 < y && (l = e.src.charCodeAt(g + 1), l >= 56320 && l <= 57343 && (d += e.src[g + 1], g++)), c = "\\" + d, i || (f = e.push("text_special", "", 0), a < 256 && bi[a] !== 0 ? f.content = d : f.content = c, f.markup = c, f.info = "escape"), e.pos = g + 1, !0
-    }
-});
-var xc = W((O2, yc) => {
-    "use strict";
-    yc.exports = function(e, i) {
-        var a, l, c, d, f, g, y, _, w = e.pos,
-            T = e.src.charCodeAt(w);
-        if (T !== 96) return !1;
-        for (a = w, w++, l = e.posMax; w < l && e.src.charCodeAt(w) === 96;) w++;
-        if (c = e.src.slice(a, w), y = c.length, e.backticksScanned && (e.backticks[y] || 0) <= a) return i || (e.pending += c), e.pos += y, !0;
-        for (g = w;
-            (f = e.src.indexOf("`", g)) !== -1;) {
-            for (g = f + 1; g < l && e.src.charCodeAt(g) === 96;) g++;
-            if (_ = g - f, _ === y) return i || (d = e.push("code_inline", "code", 0), d.markup = c, d.content = e.src.slice(w, f).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = g, !0;
-            e.backticks[_] = f
-        }
-        return e.backticksScanned = !0, i || (e.pending += c), e.pos += y, !0
-    }
-});
-var xi = W((H2, yi) => {
-    "use strict";
-    yi.exports.tokenize = function(e, i) {
-        var a, l, c, d, f, g = e.pos,
-            y = e.src.charCodeAt(g);
-        if (i || y !== 126 || (l = e.scanDelims(e.pos, !0), d = l.length, f = String.fromCharCode(y), d < 2)) return !1;
-        for (d % 2 && (c = e.push("text", "", 0), c.content = f, d--), a = 0; a < d; a += 2) c = e.push("text", "", 0), c.content = f + f, e.delimiters.push({
-            marker: y,
-            length: 0,
-            token: e.tokens.length - 1,
-            end: -1,
-            open: l.can_open,
-            close: l.can_close
-        });
-        return e.pos += l.length, !0
-    };
-
-    function vc(r, e) {
-        var i, a, l, c, d, f = [],
-            g = e.length;
-        for (i = 0; i < g; i++) l = e[i], l.marker === 126 && l.end !== -1 && (c = e[l.end], d = r.tokens[l.token], d.type = "s_open", d.tag = "s", d.nesting = 1, d.markup = "~~", d.content = "", d = r.tokens[c.token], d.type = "s_close", d.tag = "s", d.nesting = -1, d.markup = "~~", d.content = "", r.tokens[c.token - 1].type === "text" && r.tokens[c.token - 1].content === "~" && f.push(c.token - 1));
-        for (; f.length;) {
-            for (i = f.pop(), a = i + 1; a < r.tokens.length && r.tokens[a].type === "s_close";) a++;
-            a--, i !== a && (d = r.tokens[a], r.tokens[a] = r.tokens[i], r.tokens[i] = d)
-        }
-    }
-    yi.exports.postProcess = function(e) {
-        var i, a = e.tokens_meta,
-            l = e.tokens_meta.length;
-        for (vc(e, e.delimiters), i = 0; i < l; i++) a[i] && a[i].delimiters && vc(e, a[i].delimiters)
-    }
-});
-var wi = W(($2, vi) => {
-    "use strict";
-    vi.exports.tokenize = function(e, i) {
-        var a, l, c, d = e.pos,
-            f = e.src.charCodeAt(d);
-        if (i || f !== 95 && f !== 42) return !1;
-        for (l = e.scanDelims(e.pos, f === 42), a = 0; a < l.length; a++) c = e.push("text", "", 0), c.content = String.fromCharCode(f), e.delimiters.push({
-            marker: f,
-            length: l.length,
-            token: e.tokens.length - 1,
-            end: -1,
-            open: l.can_open,
-            close: l.can_close
-        });
-        return e.pos += l.length, !0
-    };
-
-    function wc(r, e) {
-        var i, a, l, c, d, f, g = e.length;
-        for (i = g - 1; i >= 0; i--) a = e[i], !(a.marker !== 95 && a.marker !== 42) && a.end !== -1 && (l = e[a.end], f = i > 0 && e[i - 1].end === a.end + 1 && e[i - 1].marker === a.marker && e[i - 1].token === a.token - 1 && e[a.end + 1].token === l.token + 1, d = String.fromCharCode(a.marker), c = r.tokens[a.token], c.type = f ? "strong_open" : "em_open", c.tag = f ? "strong" : "em", c.nesting = 1, c.markup = f ? d + d : d, c.content = "", c = r.tokens[l.token], c.type = f ? "strong_close" : "em_close", c.tag = f ? "strong" : "em", c.nesting = -1, c.markup = f ? d + d : d, c.content = "", f && (r.tokens[e[i - 1].token].content = "", r.tokens[e[a.end + 1].token].content = "", i--))
-    }
-    vi.exports.postProcess = function(e) {
-        var i, a = e.tokens_meta,
-            l = e.tokens_meta.length;
-        for (wc(e, e.delimiters), i = 0; i < l; i++) a[i] && a[i].delimiters && wc(e, a[i].delimiters)
-    }
-});
-var _c = W((G2, kc) => {
-    "use strict";
-    var Ym = Se().normalizeReference,
-        ki = Se().isSpace;
-    kc.exports = function(e, i) {
-        var a, l, c, d, f, g, y, _, w, T = "",
-            A = "",
-            L = e.pos,
-            R = e.posMax,
-            O = e.pos,
-            P = !0;
-        if (e.src.charCodeAt(e.pos) !== 91 || (f = e.pos + 1, d = e.md.helpers.parseLinkLabel(e, e.pos, !0), d < 0)) return !1;
-        if (g = d + 1, g < R && e.src.charCodeAt(g) === 40) {
-            for (P = !1, g++; g < R && (l = e.src.charCodeAt(g), !(!ki(l) && l !== 10)); g++);
-            if (g >= R) return !1;
-            if (O = g, y = e.md.helpers.parseLinkDestination(e.src, g, e.posMax), y.ok) {
-                for (T = e.md.normalizeLink(y.str), e.md.validateLink(T) ? g = y.pos : T = "", O = g; g < R && (l = e.src.charCodeAt(g), !(!ki(l) && l !== 10)); g++);
-                if (y = e.md.helpers.parseLinkTitle(e.src, g, e.posMax), g < R && O !== g && y.ok)
-                    for (A = y.str, g = y.pos; g < R && (l = e.src.charCodeAt(g), !(!ki(l) && l !== 10)); g++);
-            }(g >= R || e.src.charCodeAt(g) !== 41) && (P = !0), g++
-        }
-        if (P) {
-            if (typeof e.env.references > "u") return !1;
-            if (g < R && e.src.charCodeAt(g) === 91 ? (O = g + 1, g = e.md.helpers.parseLinkLabel(e, g), g >= 0 ? c = e.src.slice(O, g++) : g = d + 1) : g = d + 1, c || (c = e.src.slice(f, d)), _ = e.env.references[Ym(c)], !_) return e.pos = L, !1;
-            T = _.href, A = _.title
-        }
-        return i || (e.pos = f, e.posMax = d, w = e.push("link_open", "a", 1), w.attrs = a = [
-            ["href", T]
-        ], A && a.push(["title", A]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, w = e.push("link_close", "a", -1)), e.pos = g, e.posMax = R, !0
-    }
-});
-var Cc = W((V2, Sc) => {
-    "use strict";
-    var Zm = Se().normalizeReference,
-        _i = Se().isSpace;
-    Sc.exports = function(e, i) {
-        var a, l, c, d, f, g, y, _, w, T, A, L, R, O = "",
-            P = e.pos,
-            I = e.posMax;
-        if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (g = e.pos + 2, f = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), f < 0)) return !1;
-        if (y = f + 1, y < I && e.src.charCodeAt(y) === 40) {
-            for (y++; y < I && (l = e.src.charCodeAt(y), !(!_i(l) && l !== 10)); y++);
-            if (y >= I) return !1;
-            for (R = y, w = e.md.helpers.parseLinkDestination(e.src, y, e.posMax), w.ok && (O = e.md.normalizeLink(w.str), e.md.validateLink(O) ? y = w.pos : O = ""), R = y; y < I && (l = e.src.charCodeAt(y), !(!_i(l) && l !== 10)); y++);
-            if (w = e.md.helpers.parseLinkTitle(e.src, y, e.posMax), y < I && R !== y && w.ok)
-                for (T = w.str, y = w.pos; y < I && (l = e.src.charCodeAt(y), !(!_i(l) && l !== 10)); y++);
-            else T = "";
-            if (y >= I || e.src.charCodeAt(y) !== 41) return e.pos = P, !1;
-            y++
-        } else {
-            if (typeof e.env.references > "u") return !1;
-            if (y < I && e.src.charCodeAt(y) === 91 ? (R = y + 1, y = e.md.helpers.parseLinkLabel(e, y), y >= 0 ? d = e.src.slice(R, y++) : y = f + 1) : y = f + 1, d || (d = e.src.slice(g, f)), _ = e.env.references[Zm(d)], !_) return e.pos = P, !1;
-            O = _.href, T = _.title
-        }
-        return i || (c = e.src.slice(g, f), e.md.inline.parse(c, e.md, e.env, L = []), A = e.push("image", "img", 0), A.attrs = a = [
-            ["src", O],
-            ["alt", ""]
-        ], A.children = L, A.content = c, T && a.push(["title", T])), e.pos = y, e.posMax = I, !0
-    }
-});
-var Ac = W((j2, Tc) => {
-    "use strict";
-    var Qm = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/,
-        Xm = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
-    Tc.exports = function(e, i) {
-        var a, l, c, d, f, g, y = e.pos;
-        if (e.src.charCodeAt(y) !== 60) return !1;
-        for (f = e.pos, g = e.posMax;;) {
-            if (++y >= g || (d = e.src.charCodeAt(y), d === 60)) return !1;
-            if (d === 62) break
-        }
-        return a = e.src.slice(f + 1, y), Xm.test(a) ? (l = e.md.normalizeLink(a), e.md.validateLink(l) ? (i || (c = e.push("link_open", "a", 1), c.attrs = [
-            ["href", l]
-        ], c.markup = "autolink", c.info = "auto", c = e.push("text", "", 0), c.content = e.md.normalizeLinkText(a), c = e.push("link_close", "a", -1), c.markup = "autolink", c.info = "auto"), e.pos += a.length + 2, !0) : !1) : Qm.test(a) ? (l = e.md.normalizeLink("mailto:" + a), e.md.validateLink(l) ? (i || (c = e.push("link_open", "a", 1), c.attrs = [
-            ["href", l]
-        ], c.markup = "autolink", c.info = "auto", c = e.push("text", "", 0), c.content = e.md.normalizeLinkText(a), c = e.push("link_close", "a", -1), c.markup = "autolink", c.info = "auto"), e.pos += a.length + 2, !0) : !1) : !1
-    }
-});
-var Mc = W((U2, qc) => {
-    "use strict";
-    var Jm = fi().HTML_TAG_RE;
-
-    function Km(r) {
-        return /^<a[>\s]/i.test(r)
-    }
-
-    function ep(r) {
-        return /^<\/a\s*>/i.test(r)
-    }
-
-    function tp(r) {
-        var e = r | 32;
-        return e >= 97 && e <= 122
-    }
-    qc.exports = function(e, i) {
-        var a, l, c, d, f = e.pos;
-        return !e.md.options.html || (c = e.posMax, e.src.charCodeAt(f) !== 60 || f + 2 >= c) || (a = e.src.charCodeAt(f + 1), a !== 33 && a !== 63 && a !== 47 && !tp(a)) || (l = e.src.slice(f).match(Jm), !l) ? !1 : (i || (d = e.push("html_inline", "", 0), d.content = l[0], Km(d.content) && e.linkLevel++, ep(d.content) && e.linkLevel--), e.pos += l[0].length, !0)
-    }
-});
-var Rc = W((W2, zc) => {
-    "use strict";
-    var Ec = oi(),
-        rp = Se().has,
-        np = Se().isValidEntityCode,
-        Dc = Se().fromCodePoint,
-        ip = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i,
-        op = /^&([a-z][a-z0-9]{1,31});/i;
-    zc.exports = function(e, i) {
-        var a, l, c, d, f = e.pos,
-            g = e.posMax;
-        if (e.src.charCodeAt(f) !== 38 || f + 1 >= g) return !1;
-        if (a = e.src.charCodeAt(f + 1), a === 35) {
-            if (c = e.src.slice(f).match(ip), c) return i || (l = c[1][0].toLowerCase() === "x" ? parseInt(c[1].slice(1), 16) : parseInt(c[1], 10), d = e.push("text_special", "", 0), d.content = np(l) ? Dc(l) : Dc(65533), d.markup = c[0], d.info = "entity"), e.pos += c[0].length, !0
-        } else if (c = e.src.slice(f).match(op), c && rp(Ec, c[1])) return i || (d = e.push("text_special", "", 0), d.content = Ec[c[1]], d.markup = c[0], d.info = "entity"), e.pos += c[0].length, !0;
-        return !1
-    }
-});
-var Nc = W((Y2, Bc) => {
-    "use strict";
-
-    function Fc(r) {
-        var e, i, a, l, c, d, f, g, y = {},
-            _ = r.length;
-        if (_) {
-            var w = 0,
-                T = -2,
-                A = [];
-            for (e = 0; e < _; e++)
-                if (a = r[e], A.push(0), (r[w].marker !== a.marker || T !== a.token - 1) && (w = e), T = a.token, a.length = a.length || 0, !!a.close) {
-                    for (y.hasOwnProperty(a.marker) || (y[a.marker] = [-1, -1, -1, -1, -1, -1]), c = y[a.marker][(a.open ? 3 : 0) + a.length % 3], i = w - A[w] - 1, d = i; i > c; i -= A[i] + 1)
-                        if (l = r[i], l.marker === a.marker && l.open && l.end < 0 && (f = !1, (l.close || a.open) && (l.length + a.length) % 3 === 0 && (l.length % 3 !== 0 || a.length % 3 !== 0) && (f = !0), !f)) {
-                            g = i > 0 && !r[i - 1].open ? A[i - 1] + 1 : 0, A[e] = e - i + g, A[i] = g, a.open = !1, l.end = e, l.close = !1, d = -1, T = -2;
-                            break
-                        } d !== -1 && (y[a.marker][(a.open ? 3 : 0) + (a.length || 0) % 3] = d)
-                }
-        }
-    }
-    Bc.exports = function(e) {
-        var i, a = e.tokens_meta,
-            l = e.tokens_meta.length;
-        for (Fc(e.delimiters), i = 0; i < l; i++) a[i] && a[i].delimiters && Fc(a[i].delimiters)
-    }
-});
-var Pc = W((Z2, Lc) => {
-    "use strict";
-    Lc.exports = function(e) {
-        var i, a, l = 0,
-            c = e.tokens,
-            d = e.tokens.length;
-        for (i = a = 0; i < d; i++) c[i].nesting < 0 && l--, c[i].level = l, c[i].nesting > 0 && l++, c[i].type === "text" && i + 1 < d && c[i + 1].type === "text" ? c[i + 1].content = c[i].content + c[i + 1].content : (i !== a && (c[a] = c[i]), a++);
-        i !== a && (c.length = a)
-    }
-});
-var Gc = W((Q2, $c) => {
-    "use strict";
-    var Si = F0(),
-        Ic = Se().isWhiteSpace,
-        Oc = Se().isPunctChar,
-        Hc = Se().isMdAsciiPunct;
-
-    function Lr(r, e, i, a) {
-        this.src = r, this.env = i, this.md = e, this.tokens = a, this.tokens_meta = Array(a.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0
-    }
-    Lr.prototype.pushPending = function() {
-        var r = new Si("text", "", 0);
-        return r.content = this.pending, r.level = this.pendingLevel, this.tokens.push(r), this.pending = "", r
-    };
-    Lr.prototype.push = function(r, e, i) {
-        this.pending && this.pushPending();
-        var a = new Si(r, e, i),
-            l = null;
-        return i < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), a.level = this.level, i > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], l = {
-            delimiters: this.delimiters
-        }), this.pendingLevel = this.level, this.tokens.push(a), this.tokens_meta.push(l), a
-    };
-    Lr.prototype.scanDelims = function(r, e) {
-        var i = r,
-            a, l, c, d, f, g, y, _, w, T = !0,
-            A = !0,
-            L = this.posMax,
-            R = this.src.charCodeAt(r);
-        for (a = r > 0 ? this.src.charCodeAt(r - 1) : 32; i < L && this.src.charCodeAt(i) === R;) i++;
-        return c = i - r, l = i < L ? this.src.charCodeAt(i) : 32, y = Hc(a) || Oc(String.fromCharCode(a)), w = Hc(l) || Oc(String.fromCharCode(l)), g = Ic(a), _ = Ic(l), _ ? T = !1 : w && (g || y || (T = !1)), g ? A = !1 : y && (_ || w || (A = !1)), e ? (d = T, f = A) : (d = T && (!A || y), f = A && (!T || w)), {
-            can_open: d,
-            can_close: f,
-            length: c
-        }
-    };
-    Lr.prototype.Token = Si;
-    $c.exports = Lr
-});
-var Uc = W((X2, jc) => {
-    "use strict";
-    var Vc = z0(),
-        Ci = [
-            ["text", hc()],
-            ["linkify", mc()],
-            ["newline", fc()],
-            ["escape", bc()],
-            ["backticks", xc()],
-            ["strikethrough", xi().tokenize],
-            ["emphasis", wi().tokenize],
-            ["link", _c()],
-            ["image", Cc()],
-            ["autolink", Ac()],
-            ["html_inline", Mc()],
-            ["entity", Rc()]
-        ],
-        Ti = [
-            ["balance_pairs", Nc()],
-            ["strikethrough", xi().postProcess],
-            ["emphasis", wi().postProcess],
-            ["fragments_join", Pc()]
-        ];
-
-    function Pr() {
-        var r;
-        for (this.ruler = new Vc, r = 0; r < Ci.length; r++) this.ruler.push(Ci[r][0], Ci[r][1]);
-        for (this.ruler2 = new Vc, r = 0; r < Ti.length; r++) this.ruler2.push(Ti[r][0], Ti[r][1])
-    }
-    Pr.prototype.skipToken = function(r) {
-        var e, i, a = r.pos,
-            l = this.ruler.getRules(""),
-            c = l.length,
-            d = r.md.options.maxNesting,
-            f = r.cache;
-        if (typeof f[a] < "u") {
-            r.pos = f[a];
-            return
-        }
-        if (r.level < d) {
-            for (i = 0; i < c; i++)
-                if (r.level++, e = l[i](r, !0), r.level--, e) {
-                    if (a >= r.pos) throw new Error("inline rule didn't increment state.pos");
-                    break
-                }
-        } else r.pos = r.posMax;
-        e || r.pos++, f[a] = r.pos
-    };
-    Pr.prototype.tokenize = function(r) {
-        for (var e, i, a, l = this.ruler.getRules(""), c = l.length, d = r.posMax, f = r.md.options.maxNesting; r.pos < d;) {
-            if (a = r.pos, r.level < f) {
-                for (i = 0; i < c; i++)
-                    if (e = l[i](r, !1), e) {
-                        if (a >= r.pos) throw new Error("inline rule didn't increment state.pos");
-                        break
-                    }
-            }
-            if (e) {
-                if (r.pos >= d) break;
-                continue
-            }
-            r.pending += r.src[r.pos++]
-        }
-        r.pending && r.pushPending()
-    };
-    Pr.prototype.parse = function(r, e, i, a) {
-        var l, c, d, f = new this.State(r, e, i, a);
-        for (this.tokenize(f), c = this.ruler2.getRules(""), d = c.length, l = 0; l < d; l++) c[l](f)
-    };
-    Pr.prototype.State = Gc();
-    jc.exports = Pr
-});
-var Yc = W((J2, Wc) => {
-    "use strict";
-    Wc.exports = function(r) {
-        var e = {};
-        r = r || {}, e.src_Any = si().source, e.src_Cc = li().source, e.src_Z = ci().source, e.src_P = A0().source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
-        var i = "[><\uFF5C]";
-        return e.src_pseudo_letter = "(?:(?!" + i + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + i + "|" + e.src_ZPCc + ")(?!" + (r["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + i + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (r["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + i + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + e.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + e.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e
-    }
-});
-var Kc = W((K2, Jc) => {
-    "use strict";
-
-    function Ai(r) {
-        var e = Array.prototype.slice.call(arguments, 1);
-        return e.forEach(function(i) {
-            i && Object.keys(i).forEach(function(a) {
-                r[a] = i[a]
-            })
-        }), r
-    }
-
-    function O0(r) {
-        return Object.prototype.toString.call(r)
-    }
-
-    function ap(r) {
-        return O0(r) === "[object String]"
-    }
-
-    function sp(r) {
-        return O0(r) === "[object Object]"
-    }
-
-    function lp(r) {
-        return O0(r) === "[object RegExp]"
-    }
-
-    function Zc(r) {
-        return O0(r) === "[object Function]"
-    }
-
-    function cp(r) {
-        return r.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
-    }
-    var Xc = {
-        fuzzyLink: !0,
-        fuzzyEmail: !0,
-        fuzzyIP: !1
-    };
-
-    function up(r) {
-        return Object.keys(r || {}).reduce(function(e, i) {
-            return e || Xc.hasOwnProperty(i)
-        }, !1)
-    }
-    var hp = {
-            "http:": {
-                validate: function(r, e, i) {
-                    var a = r.slice(e);
-                    return i.re.http || (i.re.http = new RegExp("^\\/\\/" + i.re.src_auth + i.re.src_host_port_strict + i.re.src_path, "i")), i.re.http.test(a) ? a.match(i.re.http)[0].length : 0
-                }
-            },
-            "https:": "http:",
-            "ftp:": "http:",
-            "//": {
-                validate: function(r, e, i) {
-                    var a = r.slice(e);
-                    return i.re.no_http || (i.re.no_http = new RegExp("^" + i.re.src_auth + "(?:localhost|(?:(?:" + i.re.src_domain + ")\\.)+" + i.re.src_domain_root + ")" + i.re.src_port + i.re.src_host_terminator + i.re.src_path, "i")), i.re.no_http.test(a) ? e >= 3 && r[e - 3] === ":" || e >= 3 && r[e - 3] === "/" ? 0 : a.match(i.re.no_http)[0].length : 0
-                }
-            },
-            "mailto:": {
-                validate: function(r, e, i) {
-                    var a = r.slice(e);
-                    return i.re.mailto || (i.re.mailto = new RegExp("^" + i.re.src_email_name + "@" + i.re.src_host_strict, "i")), i.re.mailto.test(a) ? a.match(i.re.mailto)[0].length : 0
-                }
-            }
-        },
-        dp = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",
-        mp = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
-
-    function pp(r) {
-        r.__index__ = -1, r.__text_cache__ = ""
-    }
-
-    function fp(r) {
-        return function(e, i) {
-            var a = e.slice(i);
-            return r.test(a) ? a.match(r)[0].length : 0
-        }
-    }
-
-    function Qc() {
-        return function(r, e) {
-            e.normalize(r)
-        }
-    }
-
-    function I0(r) {
-        var e = r.re = Yc()(r.__opts__),
-            i = r.__tlds__.slice();
-        r.onCompile(), r.__tlds_replaced__ || i.push(dp), i.push(e.src_xn), e.src_tlds = i.join("|");
-
-        function a(f) {
-            return f.replace("%TLDS%", e.src_tlds)
-        }
-        e.email_fuzzy = RegExp(a(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(a(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(a(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(a(e.tpl_host_fuzzy_test), "i");
-        var l = [];
-        r.__compiled__ = {};
-
-        function c(f, g) {
-            throw new Error('(LinkifyIt) Invalid schema "' + f + '": ' + g)
-        }
-        Object.keys(r.__schemas__).forEach(function(f) {
-            var g = r.__schemas__[f];
-            if (g !== null) {
-                var y = {
-                    validate: null,
-                    link: null
-                };
-                if (r.__compiled__[f] = y, sp(g)) {
-                    lp(g.validate) ? y.validate = fp(g.validate) : Zc(g.validate) ? y.validate = g.validate : c(f, g), Zc(g.normalize) ? y.normalize = g.normalize : g.normalize ? c(f, g) : y.normalize = Qc();
-                    return
-                }
-                if (ap(g)) {
-                    l.push(f);
-                    return
-                }
-                c(f, g)
-            }
-        }), l.forEach(function(f) {
-            r.__compiled__[r.__schemas__[f]] && (r.__compiled__[f].validate = r.__compiled__[r.__schemas__[f]].validate, r.__compiled__[f].normalize = r.__compiled__[r.__schemas__[f]].normalize)
-        }), r.__compiled__[""] = {
-            validate: null,
-            normalize: Qc()
-        };
-        var d = Object.keys(r.__compiled__).filter(function(f) {
-            return f.length > 0 && r.__compiled__[f]
-        }).map(cp).join("|");
-        r.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + e.src_ZPCc + "))(" + d + ")", "i"), r.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + e.src_ZPCc + "))(" + d + ")", "ig"), r.re.schema_at_start = RegExp("^" + r.re.schema_search.source, "i"), r.re.pretest = RegExp("(" + r.re.schema_test.source + ")|(" + r.re.host_fuzzy_test.source + ")|@", "i"), pp(r)
-    }
-
-    function gp(r, e) {
-        var i = r.__index__,
-            a = r.__last_index__,
-            l = r.__text_cache__.slice(i, a);
-        this.schema = r.__schema__.toLowerCase(), this.index = i + e, this.lastIndex = a + e, this.raw = l, this.text = l, this.url = l
-    }
-
-    function qi(r, e) {
-        var i = new gp(r, e);
-        return r.__compiled__[i.schema].normalize(i, r), i
-    }
-
-    function lt(r, e) {
-        if (!(this instanceof lt)) return new lt(r, e);
-        e || up(r) && (e = r, r = {}), this.__opts__ = Ai({}, Xc, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Ai({}, hp, r), this.__compiled__ = {}, this.__tlds__ = mp, this.__tlds_replaced__ = !1, this.re = {}, I0(this)
-    }
-    lt.prototype.add = function(e, i) {
-        return this.__schemas__[e] = i, I0(this), this
-    };
-    lt.prototype.set = function(e) {
-        return this.__opts__ = Ai(this.__opts__, e), this
-    };
-    lt.prototype.test = function(e) {
-        if (this.__text_cache__ = e, this.__index__ = -1, !e.length) return !1;
-        var i, a, l, c, d, f, g, y, _;
-        if (this.re.schema_test.test(e)) {
-            for (g = this.re.schema_search, g.lastIndex = 0;
-                (i = g.exec(e)) !== null;)
-                if (c = this.testSchemaAt(e, i[2], g.lastIndex), c) {
-                    this.__schema__ = i[2], this.__index__ = i.index + i[1].length, this.__last_index__ = i.index + i[0].length + c;
-                    break
-                }
-        }
-        return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (y = e.search(this.re.host_fuzzy_test), y >= 0 && (this.__index__ < 0 || y < this.__index__) && (a = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (d = a.index + a[1].length, (this.__index__ < 0 || d < this.__index__) && (this.__schema__ = "", this.__index__ = d, this.__last_index__ = a.index + a[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (_ = e.indexOf("@"), _ >= 0 && (l = e.match(this.re.email_fuzzy)) !== null && (d = l.index + l[1].length, f = l.index + l[0].length, (this.__index__ < 0 || d < this.__index__ || d === this.__index__ && f > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = d, this.__last_index__ = f))), this.__index__ >= 0
-    };
-    lt.prototype.pretest = function(e) {
-        return this.re.pretest.test(e)
-    };
-    lt.prototype.testSchemaAt = function(e, i, a) {
-        return this.__compiled__[i.toLowerCase()] ? this.__compiled__[i.toLowerCase()].validate(e, a, this) : 0
-    };
-    lt.prototype.match = function(e) {
-        var i = 0,
-            a = [];
-        this.__index__ >= 0 && this.__text_cache__ === e && (a.push(qi(this, i)), i = this.__last_index__);
-        for (var l = i ? e.slice(i) : e; this.test(l);) a.push(qi(this, i)), l = l.slice(this.__last_index__), i += this.__last_index__;
-        return a.length ? a : null
-    };
-    lt.prototype.matchAtStart = function(e) {
-        if (this.__text_cache__ = e, this.__index__ = -1, !e.length) return null;
-        var i = this.re.schema_at_start.exec(e);
-        if (!i) return null;
-        var a = this.testSchemaAt(e, i[2], i[0].length);
-        return a ? (this.__schema__ = i[2], this.__index__ = i.index + i[1].length, this.__last_index__ = i.index + i[0].length + a, qi(this, 0)) : null
-    };
-    lt.prototype.tlds = function(e, i) {
-        return e = Array.isArray(e) ? e : [e], i ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(a, l, c) {
-            return a !== c[l - 1]
-        }).reverse(), I0(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, I0(this), this)
-    };
-    lt.prototype.normalize = function(e) {
-        e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url)
-    };
-    lt.prototype.onCompile = function() {};
-    Jc.exports = lt
-});
-var lu = W((e5, su) => {
-    "use strict";
-    var tu = "-",
-        bp = /^xn--/,
-        yp = /[^\0-\x7F]/,
-        xp = /[\x2E\u3002\uFF0E\uFF61]/g,
-        vp = {
-            overflow: "Overflow: input needs wider integers to process",
-            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
-            "invalid-input": "Invalid input"
-        },
-        Mi = 35,
-        At = Math.floor,
-        Ei = String.fromCharCode;
-
-    function Xt(r) {
-        throw new RangeError(vp[r])
-    }
-
-    function wp(r, e) {
-        let i = [],
-            a = r.length;
-        for (; a--;) i[a] = e(r[a]);
-        return i
-    }
-
-    function ru(r, e) {
-        let i = r.split("@"),
-            a = "";
-        i.length > 1 && (a = i[0] + "@", r = i[1]), r = r.replace(xp, ".");
-        let l = r.split("."),
-            c = wp(l, e).join(".");
-        return a + c
-    }
-
-    function nu(r) {
-        let e = [],
-            i = 0,
-            a = r.length;
-        for (; i < a;) {
-            let l = r.charCodeAt(i++);
-            if (l >= 55296 && l <= 56319 && i < a) {
-                let c = r.charCodeAt(i++);
-                (c & 64512) == 56320 ? e.push(((l & 1023) << 10) + (c & 1023) + 65536) : (e.push(l), i--)
-            } else e.push(l)
-        }
-        return e
-    }
-    var kp = r => String.fromCodePoint(...r),
-        _p = function(r) {
-            return r >= 48 && r < 58 ? 26 + (r - 48) : r >= 65 && r < 91 ? r - 65 : r >= 97 && r < 123 ? r - 97 : 36
-        },
-        eu = function(r, e) {
-            return r + 22 + 75 * (r < 26) - ((e != 0) << 5)
-        },
-        iu = function(r, e, i) {
-            let a = 0;
-            for (r = i ? At(r / 700) : r >> 1, r += At(r / e); r > Mi * 26 >> 1; a += 36) r = At(r / Mi);
-            return At(a + (Mi + 1) * r / (r + 38))
-        },
-        ou = function(r) {
-            let e = [],
-                i = r.length,
-                a = 0,
-                l = 128,
-                c = 72,
-                d = r.lastIndexOf(tu);
-            d < 0 && (d = 0);
-            for (let f = 0; f < d; ++f) r.charCodeAt(f) >= 128 && Xt("not-basic"), e.push(r.charCodeAt(f));
-            for (let f = d > 0 ? d + 1 : 0; f < i;) {
-                let g = a;
-                for (let _ = 1, w = 36;; w += 36) {
-                    f >= i && Xt("invalid-input");
-                    let T = _p(r.charCodeAt(f++));
-                    T >= 36 && Xt("invalid-input"), T > At((2147483647 - a) / _) && Xt("overflow"), a += T * _;
-                    let A = w <= c ? 1 : w >= c + 26 ? 26 : w - c;
-                    if (T < A) break;
-                    let L = 36 - A;
-                    _ > At(2147483647 / L) && Xt("overflow"), _ *= L
-                }
-                let y = e.length + 1;
-                c = iu(a - g, y, g == 0), At(a / y) > 2147483647 - l && Xt("overflow"), l += At(a / y), a %= y, e.splice(a++, 0, l)
-            }
-            return String.fromCodePoint(...e)
-        },
-        au = function(r) {
-            let e = [];
-            r = nu(r);
-            let i = r.length,
-                a = 128,
-                l = 0,
-                c = 72;
-            for (let g of r) g < 128 && e.push(Ei(g));
-            let d = e.length,
-                f = d;
-            for (d && e.push(tu); f < i;) {
-                let g = 2147483647;
-                for (let _ of r) _ >= a && _ < g && (g = _);
-                let y = f + 1;
-                g - a > At((2147483647 - l) / y) && Xt("overflow"), l += (g - a) * y, a = g;
-                for (let _ of r)
-                    if (_ < a && ++l > 2147483647 && Xt("overflow"), _ === a) {
-                        let w = l;
-                        for (let T = 36;; T += 36) {
-                            let A = T <= c ? 1 : T >= c + 26 ? 26 : T - c;
-                            if (w < A) break;
-                            let L = w - A,
-                                R = 36 - A;
-                            e.push(Ei(eu(A + L % R, 0))), w = At(L / R)
-                        }
-                        e.push(Ei(eu(w, 0))), c = iu(l, y, f === d), l = 0, ++f
-                    }++ l, ++a
-            }
-            return e.join("")
-        },
-        Sp = function(r) {
-            return ru(r, function(e) {
-                return bp.test(e) ? ou(e.slice(4).toLowerCase()) : e
-            })
-        },
-        Cp = function(r) {
-            return ru(r, function(e) {
-                return yp.test(e) ? "xn--" + au(e) : e
-            })
-        },
-        Tp = {
-            version: "2.3.1",
-            ucs2: {
-                decode: nu,
-                encode: kp
-            },
-            decode: ou,
-            encode: au,
-            toASCII: Cp,
-            toUnicode: Sp
-        };
-    su.exports = Tp
-});
-var uu = W((t5, cu) => {
-    "use strict";
-    cu.exports = {
-        options: {
-            html: !1,
-            xhtmlOut: !1,
-            breaks: !1,
-            langPrefix: "language-",
-            linkify: !1,
-            typographer: !1,
-            quotes: "\u201C\u201D\u2018\u2019",
-            highlight: null,
-            maxNesting: 100
-        },
-        components: {
-            core: {},
-            block: {},
-            inline: {}
-        }
-    }
-});
-var du = W((r5, hu) => {
-    "use strict";
-    hu.exports = {
-        options: {
-            html: !1,
-            xhtmlOut: !1,
-            breaks: !1,
-            langPrefix: "language-",
-            linkify: !1,
-            typographer: !1,
-            quotes: "\u201C\u201D\u2018\u2019",
-            highlight: null,
-            maxNesting: 20
-        },
-        components: {
-            core: {
-                rules: ["normalize", "block", "inline", "text_join"]
-            },
-            block: {
-                rules: ["paragraph"]
-            },
-            inline: {
-                rules: ["text"],
-                rules2: ["balance_pairs", "fragments_join"]
-            }
-        }
-    }
-});
-var pu = W((n5, mu) => {
-    "use strict";
-    mu.exports = {
-        options: {
-            html: !0,
-            xhtmlOut: !0,
-            breaks: !1,
-            langPrefix: "language-",
-            linkify: !1,
-            typographer: !1,
-            quotes: "\u201C\u201D\u2018\u2019",
-            highlight: null,
-            maxNesting: 20
-        },
-        components: {
-            core: {
-                rules: ["normalize", "block", "inline", "text_join"]
-            },
-            block: {
-                rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"]
-            },
-            inline: {
-                rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"],
-                rules2: ["balance_pairs", "emphasis", "fragments_join"]
-            }
-        }
-    }
-});
-var yu = W((i5, bu) => {
-    "use strict";
-    var Ir = Se(),
-        Ap = Js(),
-        qp = el(),
-        Mp = Al(),
-        Ep = cc(),
-        Dp = Uc(),
-        zp = Kc(),
-        ar = ai(),
-        fu = lu(),
-        Rp = {
-            default: uu(),
-            zero: du(),
-            commonmark: pu()
-        },
-        Fp = /^(vbscript|javascript|file|data):/,
-        Bp = /^data:image\/(gif|png|jpeg|webp);/;
-
-    function Np(r) {
-        var e = r.trim().toLowerCase();
-        return Fp.test(e) ? !!Bp.test(e) : !0
-    }
-    var gu = ["http:", "https:", "mailto:"];
-
-    function Lp(r) {
-        var e = ar.parse(r, !0);
-        if (e.hostname && (!e.protocol || gu.indexOf(e.protocol) >= 0)) try {
-            e.hostname = fu.toASCII(e.hostname)
-        } catch {}
-        return ar.encode(ar.format(e))
-    }
-
-    function Pp(r) {
-        var e = ar.parse(r, !0);
-        if (e.hostname && (!e.protocol || gu.indexOf(e.protocol) >= 0)) try {
-            e.hostname = fu.toUnicode(e.hostname)
-        } catch {}
-        return ar.decode(ar.format(e), ar.decode.defaultChars + "%")
-    }
-
-    function bt(r, e) {
-        if (!(this instanceof bt)) return new bt(r, e);
-        e || Ir.isString(r) || (e = r || {}, r = "default"), this.inline = new Dp, this.block = new Ep, this.core = new Mp, this.renderer = new qp, this.linkify = new zp, this.validateLink = Np, this.normalizeLink = Lp, this.normalizeLinkText = Pp, this.utils = Ir, this.helpers = Ir.assign({}, Ap), this.options = {}, this.configure(r), e && this.set(e)
-    }
-    bt.prototype.set = function(r) {
-        return Ir.assign(this.options, r), this
-    };
-    bt.prototype.configure = function(r) {
-        var e = this,
-            i;
-        if (Ir.isString(r) && (i = r, r = Rp[i], !r)) throw new Error('Wrong `markdown-it` preset "' + i + '", check name');
-        if (!r) throw new Error("Wrong `markdown-it` preset, can't be empty");
-        return r.options && e.set(r.options), r.components && Object.keys(r.components).forEach(function(a) {
-            r.components[a].rules && e[a].ruler.enableOnly(r.components[a].rules), r.components[a].rules2 && e[a].ruler2.enableOnly(r.components[a].rules2)
-        }), this
-    };
-    bt.prototype.enable = function(r, e) {
-        var i = [];
-        Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(l) {
-            i = i.concat(this[l].ruler.enable(r, !0))
-        }, this), i = i.concat(this.inline.ruler2.enable(r, !0));
-        var a = r.filter(function(l) {
-            return i.indexOf(l) < 0
-        });
-        if (a.length && !e) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + a);
-        return this
-    };
-    bt.prototype.disable = function(r, e) {
-        var i = [];
-        Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(l) {
-            i = i.concat(this[l].ruler.disable(r, !0))
-        }, this), i = i.concat(this.inline.ruler2.disable(r, !0));
-        var a = r.filter(function(l) {
-            return i.indexOf(l) < 0
-        });
-        if (a.length && !e) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + a);
-        return this
-    };
-    bt.prototype.use = function(r) {
-        var e = [this].concat(Array.prototype.slice.call(arguments, 1));
-        return r.apply(r, e), this
-    };
-    bt.prototype.parse = function(r, e) {
-        if (typeof r != "string") throw new Error("Input data should be a String");
-        var i = new this.core.State(r, this, e);
-        return this.core.process(i), i.tokens
-    };
-    bt.prototype.render = function(r, e) {
-        return e = e || {}, this.renderer.render(this.parse(r, e), this.options, e)
-    };
-    bt.prototype.parseInline = function(r, e) {
-        var i = new this.core.State(r, this, e);
-        return i.inlineMode = !0, this.core.process(i), i.tokens
-    };
-    bt.prototype.renderInline = function(r, e) {
-        return e = e || {}, this.renderer.render(this.parseInline(r, e), this.options, e)
-    };
-    bu.exports = bt
-});
-var vu = W((o5, xu) => {
-    "use strict";
-    xu.exports = yu()
-});
-var wu = W((Or, Di) => {
-    (function(e, i) {
-        typeof Or == "object" && typeof Di == "object" ? Di.exports = i() : typeof define == "function" && define.amd ? define([], i) : typeof Or == "object" ? Or.katex = i() : e.katex = i()
-    })(typeof self < "u" ? self : Or, function() {
+var ml = rt((K0, Ai) => {
+    (function(r, i) {
+        typeof K0 == "object" && typeof Ai == "object" ? Ai.exports = i() : typeof define == "function" && define.amd ? define([], i) : typeof K0 == "object" ? K0.katex = i() : r.katex = i()
+    })(typeof self < "u" ? self : K0, function() {
         return function() {
             "use strict";
-            var r = {};
+            var e = {};
             (function() {
-                r.d = function(n, t) {
-                    for (var o in t) r.o(t, o) && !r.o(n, o) && Object.defineProperty(n, o, {
+                e.d = function(n, t) {
+                    for (var u in t) e.o(t, u) && !e.o(n, u) && Object.defineProperty(n, u, {
                         enumerable: !0,
-                        get: t[o]
+                        get: t[u]
                     })
                 }
             })(),
             function() {
-                r.o = function(n, t) {
+                e.o = function(n, t) {
                     return Object.prototype.hasOwnProperty.call(n, t)
                 }
             }();
-            var e = {};
-            r.d(e, {
+            var r = {};
+            e.d(r, {
                 default: function() {
-                    return th
+                    return Wc
                 }
             });
             class i {
-                constructor(t, o) {
+                constructor(t, u) {
                     this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
-                    let s = "KaTeX parse error: " + t,
-                        u, p, b = o && o.loc;
-                    if (b && b.start <= b.end) {
-                        let S = b.lexer.input;
-                        u = b.start, p = b.end, u === S.length ? s += " at end of input: " : s += " at position " + (u + 1) + ": ";
-                        let E = S.slice(u, p).replace(/[^]/g, "$&\u0332"),
+                    let a = "KaTeX parse error: " + t,
+                        c, m, g = u && u.loc;
+                    if (g && g.start <= g.end) {
+                        let _ = g.lexer.input;
+                        c = g.start, m = g.end, c === _.length ? a += " at end of input: " : a += " at position " + (c + 1) + ": ";
+                        let D = _.slice(c, m).replace(/[^]/g, "$&\u0332"),
                             z;
-                        u > 15 ? z = "\u2026" + S.slice(u - 15, u) : z = S.slice(0, u);
-                        let F;
-                        p + 15 < S.length ? F = S.slice(p, p + 15) + "\u2026" : F = S.slice(p), s += z + E + F
+                        c > 15 ? z = "\u2026" + _.slice(c - 15, c) : z = _.slice(0, c);
+                        let R;
+                        m + 15 < _.length ? R = _.slice(m, m + 15) + "\u2026" : R = _.slice(m), a += z + D + R
                     }
-                    let v = new Error(s);
-                    return v.name = "ParseError", v.__proto__ = i.prototype, v.position = u, u != null && p != null && (v.length = p - u), v.rawMessage = t, v
+                    let v = new Error(a);
+                    return v.name = "ParseError", v.__proto__ = i.prototype, v.position = c, c != null && m != null && (v.length = m - c), v.rawMessage = t, v
                 }
             }
             i.prototype.__proto__ = Error.prototype;
-            var a = i;
-            let l = function(n, t) {
+            var o = i;
+            let s = function(n, t) {
                     return n.indexOf(t) !== -1
                 },
-                c = function(n, t) {
+                l = function(n, t) {
                     return n === void 0 ? t : n
                 },
-                d = /([A-Z])/g,
-                f = function(n) {
-                    return n.replace(d, "-$1").toLowerCase()
+                h = /([A-Z])/g,
+                p = function(n) {
+                    return n.replace(h, "-$1").toLowerCase()
                 },
-                g = {
+                b = {
                     "&": "&amp;",
                     ">": "&gt;",
                     "<": "&lt;",
                     '"': "&quot;",
                     "'": "&#x27;"
                 },
-                y = /[&><"']/g;
+                x = /[&><"']/g;
 
-            function _(n) {
-                return String(n).replace(y, t => g[t])
+            function C(n) {
+                return String(n).replace(x, t => b[t])
             }
-            let w = function(n) {
-                    return n.type === "ordgroup" || n.type === "color" ? n.body.length === 1 ? w(n.body[0]) : n : n.type === "font" ? w(n.body) : n
+            let k = function(n) {
+                    return n.type === "ordgroup" || n.type === "color" ? n.body.length === 1 ? k(n.body[0]) : n : n.type === "font" ? k(n.body) : n
                 },
-                T = function(n) {
-                    let t = w(n);
+                F = function(n) {
+                    let t = k(n);
                     return t.type === "mathord" || t.type === "textord" || t.type === "atom"
                 },
-                A = function(n) {
+                E = function(n) {
                     if (!n) throw new Error("Expected non-null, but got " + String(n));
                     return n
                 };
-            var R = {
-                contains: l,
-                deflt: c,
-                escape: _,
-                hyphenate: f,
-                getBaseElem: w,
-                isCharacterBox: T,
+            var N = {
+                contains: s,
+                deflt: l,
+                escape: C,
+                hyphenate: p,
+                getBaseElem: k,
+                isCharacterBox: F,
                 protocolFromUrl: function(n) {
                     let t = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(n);
                     return t ? t[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(t[1]) ? null : t[1].toLowerCase() : "_relative"
                 }
             };
-            let O = {
+            let G = {
                 displayMode: {
                     type: "boolean",
                     description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
                     cli: "-d, --display-mode"
                 },
                 output: {
                     type: {
@@ -5821,112 +1411,112 @@
                 },
                 globalGroup: {
                     type: "boolean",
                     cli: !1
                 }
             };
 
-            function P(n) {
+            function U(n) {
                 if (n.default) return n.default;
                 let t = n.type,
-                    o = Array.isArray(t) ? t[0] : t;
-                if (typeof o != "string") return o.enum[0];
-                switch (o) {
+                    u = Array.isArray(t) ? t[0] : t;
+                if (typeof u != "string") return u.enum[0];
+                switch (u) {
                     case "boolean":
                         return !1;
                     case "string":
                         return "";
                     case "number":
                         return 0;
                     case "object":
                         return {}
                 }
             }
-            class I {
+            class $ {
                 constructor(t) {
                     this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, t = t || {};
-                    for (let o in O)
-                        if (O.hasOwnProperty(o)) {
-                            let s = O[o];
-                            this[o] = t[o] !== void 0 ? s.processor ? s.processor(t[o]) : t[o] : P(s)
+                    for (let u in G)
+                        if (G.hasOwnProperty(u)) {
+                            let a = G[u];
+                            this[u] = t[u] !== void 0 ? a.processor ? a.processor(t[u]) : t[u] : U(a)
                         }
                 }
-                reportNonstrict(t, o, s) {
-                    let u = this.strict;
-                    if (typeof u == "function" && (u = u(t, o, s)), !(!u || u === "ignore")) {
-                        if (u === !0 || u === "error") throw new a("LaTeX-incompatible input and strict mode is set to 'error': " + (o + " [" + t + "]"), s);
-                        u === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (o + " [" + t + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + u + "': " + o + " [" + t + "]"))
+                reportNonstrict(t, u, a) {
+                    let c = this.strict;
+                    if (typeof c == "function" && (c = c(t, u, a)), !(!c || c === "ignore")) {
+                        if (c === !0 || c === "error") throw new o("LaTeX-incompatible input and strict mode is set to 'error': " + (u + " [" + t + "]"), a);
+                        c === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (u + " [" + t + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + c + "': " + u + " [" + t + "]"))
                     }
                 }
-                useStrictBehavior(t, o, s) {
-                    let u = this.strict;
-                    if (typeof u == "function") try {
-                        u = u(t, o, s)
+                useStrictBehavior(t, u, a) {
+                    let c = this.strict;
+                    if (typeof c == "function") try {
+                        c = c(t, u, a)
                     } catch {
-                        u = "error"
+                        c = "error"
                     }
-                    return !u || u === "ignore" ? !1 : u === !0 || u === "error" ? !0 : u === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (o + " [" + t + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + u + "': " + o + " [" + t + "]")), !1)
+                    return !c || c === "ignore" ? !1 : c === !0 || c === "error" ? !0 : c === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (u + " [" + t + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + c + "': " + u + " [" + t + "]")), !1)
                 }
                 isTrusted(t) {
                     if (t.url && !t.protocol) {
-                        let s = R.protocolFromUrl(t.url);
-                        if (s == null) return !1;
-                        t.protocol = s
+                        let a = N.protocolFromUrl(t.url);
+                        if (a == null) return !1;
+                        t.protocol = a
                     }
                     return !!(typeof this.trust == "function" ? this.trust(t) : this.trust)
                 }
             }
-            class Y {
-                constructor(t, o, s) {
-                    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = t, this.size = o, this.cramped = s
+            class V {
+                constructor(t, u, a) {
+                    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = t, this.size = u, this.cramped = a
                 }
                 sup() {
-                    return De[U[this.id]]
+                    return Ne[W[this.id]]
                 }
                 sub() {
-                    return De[X[this.id]]
+                    return Ne[Q[this.id]]
                 }
                 fracNum() {
-                    return De[he[this.id]]
+                    return Ne[fe[this.id]]
                 }
                 fracDen() {
-                    return De[oe[this.id]]
+                    return Ne[Qe[this.id]]
                 }
                 cramp() {
-                    return De[ae[this.id]]
+                    return Ne[ne[this.id]]
                 }
                 text() {
-                    return De[ee[this.id]]
+                    return Ne[ee[this.id]]
                 }
                 isTight() {
                     return this.size >= 2
                 }
             }
-            let re = 0,
-                te = 1,
-                j = 2,
-                ne = 3,
-                pe = 4,
-                ue = 5,
-                ce = 6,
-                Ce = 7,
-                De = [new Y(re, 0, !1), new Y(te, 0, !0), new Y(j, 1, !1), new Y(ne, 1, !0), new Y(pe, 2, !1), new Y(ue, 2, !0), new Y(ce, 3, !1), new Y(Ce, 3, !0)],
-                U = [pe, ue, pe, ue, ce, Ce, ce, Ce],
-                X = [ue, ue, ue, ue, Ce, Ce, Ce, Ce],
-                he = [j, ne, pe, ue, ce, Ce, ce, Ce],
-                oe = [ne, ne, ue, ue, Ce, Ce, Ce, Ce],
-                ae = [te, te, ne, ne, ue, ue, Ce, Ce],
-                ee = [re, te, j, ne, j, ne, j, ne];
-            var G = {
-                DISPLAY: De[re],
-                TEXT: De[j],
-                SCRIPT: De[pe],
-                SCRIPTSCRIPT: De[ce]
+            let Y = 0,
+                X = 1,
+                te = 2,
+                ie = 3,
+                ge = 4,
+                ae = 5,
+                qe = 6,
+                Ee = 7,
+                Ne = [new V(Y, 0, !1), new V(X, 0, !0), new V(te, 1, !1), new V(ie, 1, !0), new V(ge, 2, !1), new V(ae, 2, !0), new V(qe, 3, !1), new V(Ee, 3, !0)],
+                W = [ge, ae, ge, ae, qe, Ee, qe, Ee],
+                Q = [ae, ae, ae, ae, Ee, Ee, Ee, Ee],
+                fe = [te, ie, ge, ae, qe, Ee, qe, Ee],
+                Qe = [ie, ie, ae, ae, Ee, Ee, Ee, Ee],
+                ne = [X, X, ie, ie, ae, ae, Ee, Ee],
+                ee = [Y, X, te, ie, te, ie, te, ie];
+            var O = {
+                DISPLAY: Ne[Y],
+                TEXT: Ne[te],
+                SCRIPT: Ne[ge],
+                SCRIPTSCRIPT: Ne[qe]
             };
-            let fe = [{
+            let ce = [{
                 name: "latin",
                 blocks: [
                     [256, 591],
                     [768, 879]
                 ]
             }, {
                 name: "cyrillic",
@@ -5958,132 +1548,132 @@
             }, {
                 name: "hangul",
                 blocks: [
                     [44032, 55215]
                 ]
             }];
 
-            function Te(n) {
-                for (let t = 0; t < fe.length; t++) {
-                    let o = fe[t];
-                    for (let s = 0; s < o.blocks.length; s++) {
-                        let u = o.blocks[s];
-                        if (n >= u[0] && n <= u[1]) return o.name
+            function ke(n) {
+                for (let t = 0; t < ce.length; t++) {
+                    let u = ce[t];
+                    for (let a = 0; a < u.blocks.length; a++) {
+                        let c = u.blocks[a];
+                        if (n >= c[0] && n <= c[1]) return u.name
                     }
                 }
                 return null
             }
-            let Ae = [];
-            fe.forEach(n => n.blocks.forEach(t => Ae.push(...t)));
+            let _e = [];
+            ce.forEach(n => n.blocks.forEach(t => _e.push(...t)));
 
-            function qt(n) {
-                for (let t = 0; t < Ae.length; t += 2)
-                    if (n >= Ae[t] && n <= Ae[t + 1]) return !0;
+            function Mt(n) {
+                for (let t = 0; t < _e.length; t += 2)
+                    if (n >= _e[t] && n <= _e[t + 1]) return !0;
                 return !1
             }
             let ct = 80,
-                Pt = function(n, t) {
+                Gt = function(n, t) {
                     return "M95," + (622 + n + t) + `
 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
 c69,-144,104.5,-217.7,106.5,-221
 l` + n / 2.075 + " -" + n + `
 c5.3,-9.3,12,-14,20,-14
 H400000v` + (40 + n) + `H845.2724
 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
 M` + (834 + n) + " " + t + "h400000v" + (40 + n) + "h-400000z"
                 },
-                yr = function(n, t) {
+                M0 = function(n, t) {
                     return "M263," + (601 + n + t) + `c0.7,0,18,39.7,52,119
 c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
 c340,-704.7,510.7,-1060.3,512,-1067
 l` + n / 2.084 + " -" + n + `
 c4.7,-7.3,11,-11,19,-11
 H40000v` + (40 + n) + `H1012.3
 s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
 c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
 s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
 c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
 M` + (1001 + n) + " " + t + "h400000v" + (40 + n) + "h-400000z"
                 },
-                $0 = function(n, t) {
+                an = function(n, t) {
                     return "M983 " + (10 + n + t) + `
 l` + n / 3.13 + " -" + n + `
 c4,-6.7,10,-10,18,-10 H400000v` + (40 + n) + `
 H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
 s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
 c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
 c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
 c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
 c53.7,-170.3,84.5,-266.8,92.5,-289.5z
 M` + (1001 + n) + " " + t + "h400000v" + (40 + n) + "h-400000z"
                 },
-                G0 = function(n, t) {
+                sn = function(n, t) {
                     return "M424," + (2398 + n + t) + `
 c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
 c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
 s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
 s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
 l` + n / 4.223 + " -" + n + `c4,-6.7,10,-10,18,-10 H400000
 v` + (40 + n) + `H1014.6
 s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
 c-2,6,-10,9,-24,9
 c-8,0,-12,-0.7,-12,-2z M` + (1001 + n) + " " + t + `
 h400000v` + (40 + n) + "h-400000z"
                 },
-                V0 = function(n, t) {
+                ln = function(n, t) {
                     return "M473," + (2713 + n + t) + `
 c339.3,-1799.3,509.3,-2700,510,-2702 l` + n / 5.298 + " -" + n + `
 c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + n) + `H1017.7
 s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
 c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
 c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
 s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
 606zM` + (1001 + n) + " " + t + "h400000v" + (40 + n) + "H1017.7z"
                 },
-                Fu = function(n) {
+                Al = function(n) {
                     let t = n / 2;
                     return "M400000 " + n + " H0 L" + t + " 0 l65 45 L145 " + (n - 80) + " H400000z"
                 },
-                Bu = function(n, t, o) {
-                    let s = o - 54 - t - n;
+                Tl = function(n, t, u) {
+                    let a = u - 54 - t - n;
                     return "M702 " + (n + t) + "H400000" + (40 + n) + `
-H742v` + s + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
+H742v` + a + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
 h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
 c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
 219 661 l218 661zM702 ` + t + "H400000v" + (40 + n) + "H742z"
                 },
-                Nu = function(n, t, o) {
+                Dl = function(n, t, u) {
                     t = 1e3 * t;
-                    let s = "";
+                    let a = "";
                     switch (n) {
                         case "sqrtMain":
-                            s = Pt(t, ct);
+                            a = Gt(t, ct);
                             break;
                         case "sqrtSize1":
-                            s = yr(t, ct);
+                            a = M0(t, ct);
                             break;
                         case "sqrtSize2":
-                            s = $0(t, ct);
+                            a = an(t, ct);
                             break;
                         case "sqrtSize3":
-                            s = G0(t, ct);
+                            a = sn(t, ct);
                             break;
                         case "sqrtSize4":
-                            s = V0(t, ct);
+                            a = ln(t, ct);
                             break;
                         case "sqrtTall":
-                            s = Bu(t, ct, o)
+                            a = Tl(t, ct, u)
                     }
-                    return s
+                    return a
                 },
-                Lu = function(n, t) {
+                El = function(n, t) {
                     switch (n) {
                         case "\u239C":
                             return "M291 0 H417 V" + t + " H291z M291 0 H417 V" + t + " H291z";
                         case "\u2223":
                             return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z";
                         case "\u2225":
                             return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z" + ("M367 0 H410 V" + t + " H367z M367 0 H410 V" + t + " H367z");
@@ -6099,15 +1689,15 @@
                             return "M312 0 H355 V" + t + " H312z M312 0 H355 V" + t + " H312z";
                         case "\u2016":
                             return "M257 0 H300 V" + t + " H257z M257 0 H300 V" + t + " H257z" + ("M478 0 H521 V" + t + " H478z M478 0 H521 V" + t + " H478z");
                         default:
                             return ""
                     }
                 },
-                zi = {
+                Ti = {
                     doubleleftarrow: `M262 157
 l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
  0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
  14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
 c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
  157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
 -86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
@@ -6331,15 +1921,15 @@
 M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
                     shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
 c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
 -231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
 c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
 M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
                 },
-                Pu = function(n, t) {
+                Ml = function(n, t) {
                     switch (n) {
                         case "lbrack":
                             return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v1759 h347 v-84
 H403z M403 1759 V0 H319 V1759 v` + t + " v1759 h84z";
                         case "rbrack":
                             return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v1759 H0 v84 H347z
 M347 1759 V0 H263 V1759 v` + t + " v1759 h84z";
@@ -6385,37 +1975,37 @@
 c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
 l0,-` + (t + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
 -470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
                         default:
                             throw new Error("Unknown stretchy delimiter.")
                     }
                 };
-            class xr {
+            class q0 {
                 constructor(t) {
                     this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = t, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {}
                 }
                 hasClass(t) {
-                    return R.contains(this.classes, t)
+                    return N.contains(this.classes, t)
                 }
                 toNode() {
                     let t = document.createDocumentFragment();
-                    for (let o = 0; o < this.children.length; o++) t.appendChild(this.children[o].toNode());
+                    for (let u = 0; u < this.children.length; u++) t.appendChild(this.children[u].toNode());
                     return t
                 }
                 toMarkup() {
                     let t = "";
-                    for (let o = 0; o < this.children.length; o++) t += this.children[o].toMarkup();
+                    for (let u = 0; u < this.children.length; u++) t += this.children[u].toMarkup();
                     return t
                 }
                 toText() {
-                    let t = o => o.toText();
+                    let t = u => u.toText();
                     return this.children.map(t).join("")
                 }
             }
-            var vt = {
+            var wt = {
                 "AMS-Regular": {
                     32: [0, 0, 0, 0, .25],
                     65: [0, .68889, 0, 0, .72222],
                     66: [0, .68889, 0, 0, .66667],
                     67: [0, .68889, 0, 0, .72222],
                     68: [0, .68889, 0, 0, .72222],
                     69: [0, .68889, 0, 0, .66667],
@@ -8483,15 +4073,15 @@
                     937: [0, .61111, 0, 0, .525],
                     8216: [0, .61111, 0, 0, .525],
                     8217: [0, .61111, 0, 0, .525],
                     8242: [0, .61111, 0, 0, .525],
                     9251: [.11111, .21944, 0, 0, .525]
                 }
             };
-            let $r = {
+            let tr = {
                     slant: [.25, .25, .25],
                     space: [0, 0, 0],
                     stretch: [0, 0, 0],
                     shrink: [0, 0, 0],
                     xHeight: [.431, .431, .431],
                     quad: [1, 1.171, 1.472],
                     extraSpace: [0, 0, 0],
@@ -8519,15 +4109,15 @@
                     sqrtRuleThickness: [.04, .04, .04],
                     ptPerEm: [10, 10, 10],
                     doubleRuleSep: [.2, .2, .2],
                     arrayRuleWidth: [.04, .04, .04],
                     fboxsep: [.3, .3, .3],
                     fboxrule: [.04, .04, .04]
                 },
-                Ri = {
+                Di = {
                     \u00C5: "A",
                     \u00D0: "D",
                     \u00DE: "o",
                     \u00E5: "a",
                     \u00F0: "d",
                     \u00FE: "o",
                     \u0410: "A",
@@ -8592,103 +4182,103 @@
                     \u044B: "m",
                     \u044C: "a",
                     \u044D: "e",
                     \u044E: "m",
                     \u044F: "r"
                 };
 
-            function Iu(n, t) {
-                vt[n] = t
+            function ql(n, t) {
+                wt[n] = t
             }
 
-            function j0(n, t, o) {
-                if (!vt[t]) throw new Error("Font metrics not found for font: " + t + ".");
-                let s = n.charCodeAt(0),
-                    u = vt[t][s];
-                if (!u && n[0] in Ri && (s = Ri[n[0]].charCodeAt(0), u = vt[t][s]), !u && o === "text" && qt(s) && (u = vt[t][77]), u) return {
-                    depth: u[0],
-                    height: u[1],
-                    italic: u[2],
-                    skew: u[3],
-                    width: u[4]
+            function cn(n, t, u) {
+                if (!wt[t]) throw new Error("Font metrics not found for font: " + t + ".");
+                let a = n.charCodeAt(0),
+                    c = wt[t][a];
+                if (!c && n[0] in Di && (a = Di[n[0]].charCodeAt(0), c = wt[t][a]), !c && u === "text" && Mt(a) && (c = wt[t][77]), c) return {
+                    depth: c[0],
+                    height: c[1],
+                    italic: c[2],
+                    skew: c[3],
+                    width: c[4]
                 }
             }
-            let U0 = {};
+            let dn = {};
 
-            function Ou(n) {
+            function Fl(n) {
                 let t;
-                if (n >= 5 ? t = 0 : n >= 3 ? t = 1 : t = 2, !U0[t]) {
-                    let o = U0[t] = {
-                        cssEmPerMu: $r.quad[t] / 18
+                if (n >= 5 ? t = 0 : n >= 3 ? t = 1 : t = 2, !dn[t]) {
+                    let u = dn[t] = {
+                        cssEmPerMu: tr.quad[t] / 18
                     };
-                    for (let s in $r) $r.hasOwnProperty(s) && (o[s] = $r[s][t])
+                    for (let a in tr) tr.hasOwnProperty(a) && (u[a] = tr[a][t])
                 }
-                return U0[t]
+                return dn[t]
             }
-            let Hu = [
+            let zl = [
                     [1, 1, 1],
                     [2, 1, 1],
                     [3, 1, 1],
                     [4, 2, 1],
                     [5, 2, 1],
                     [6, 3, 1],
                     [7, 4, 2],
                     [8, 6, 3],
                     [9, 7, 6],
                     [10, 8, 7],
                     [11, 10, 9]
                 ],
-                Fi = [.5, .6, .7, .8, .9, 1, 1.2, 1.44, 1.728, 2.074, 2.488],
-                Bi = function(n, t) {
-                    return t.size < 2 ? n : Hu[n - 1][t.size - 1]
+                Ei = [.5, .6, .7, .8, .9, 1, 1.2, 1.44, 1.728, 2.074, 2.488],
+                Mi = function(n, t) {
+                    return t.size < 2 ? n : zl[n - 1][t.size - 1]
                 };
-            class Mt {
+            class qt {
                 constructor(t) {
-                    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = t.style, this.color = t.color, this.size = t.size || Mt.BASESIZE, this.textSize = t.textSize || this.size, this.phantom = !!t.phantom, this.font = t.font || "", this.fontFamily = t.fontFamily || "", this.fontWeight = t.fontWeight || "", this.fontShape = t.fontShape || "", this.sizeMultiplier = Fi[this.size - 1], this.maxSize = t.maxSize, this.minRuleThickness = t.minRuleThickness, this._fontMetrics = void 0
+                    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = t.style, this.color = t.color, this.size = t.size || qt.BASESIZE, this.textSize = t.textSize || this.size, this.phantom = !!t.phantom, this.font = t.font || "", this.fontFamily = t.fontFamily || "", this.fontWeight = t.fontWeight || "", this.fontShape = t.fontShape || "", this.sizeMultiplier = Ei[this.size - 1], this.maxSize = t.maxSize, this.minRuleThickness = t.minRuleThickness, this._fontMetrics = void 0
                 }
                 extend(t) {
-                    let o = {
+                    let u = {
                         style: this.style,
                         size: this.size,
                         textSize: this.textSize,
                         color: this.color,
                         phantom: this.phantom,
                         font: this.font,
                         fontFamily: this.fontFamily,
                         fontWeight: this.fontWeight,
                         fontShape: this.fontShape,
                         maxSize: this.maxSize,
                         minRuleThickness: this.minRuleThickness
                     };
-                    for (let s in t) t.hasOwnProperty(s) && (o[s] = t[s]);
-                    return new Mt(o)
+                    for (let a in t) t.hasOwnProperty(a) && (u[a] = t[a]);
+                    return new qt(u)
                 }
                 havingStyle(t) {
                     return this.style === t ? this : this.extend({
                         style: t,
-                        size: Bi(this.textSize, t)
+                        size: Mi(this.textSize, t)
                     })
                 }
                 havingCrampedStyle() {
                     return this.havingStyle(this.style.cramp())
                 }
                 havingSize(t) {
                     return this.size === t && this.textSize === t ? this : this.extend({
                         style: this.style.text(),
                         size: t,
                         textSize: t,
-                        sizeMultiplier: Fi[t - 1]
+                        sizeMultiplier: Ei[t - 1]
                     })
                 }
                 havingBaseStyle(t) {
                     t = t || this.style.text();
-                    let o = Bi(Mt.BASESIZE, t);
-                    return this.size === o && this.textSize === Mt.BASESIZE && this.style === t ? this : this.extend({
+                    let u = Mi(qt.BASESIZE, t);
+                    return this.size === u && this.textSize === qt.BASESIZE && this.style === t ? this : this.extend({
                         style: t,
-                        size: o
+                        size: u
                     })
                 }
                 havingBaseSizing() {
                     let t;
                     switch (this.style.id) {
                         case 4:
                         case 5:
@@ -8739,318 +4329,318 @@
                         font: ""
                     })
                 }
                 sizingClasses(t) {
                     return t.size !== this.size ? ["sizing", "reset-size" + t.size, "size" + this.size] : []
                 }
                 baseSizingClasses() {
-                    return this.size !== Mt.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Mt.BASESIZE] : []
+                    return this.size !== qt.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + qt.BASESIZE] : []
                 }
                 fontMetrics() {
-                    return this._fontMetrics || (this._fontMetrics = Ou(this.size)), this._fontMetrics
+                    return this._fontMetrics || (this._fontMetrics = Fl(this.size)), this._fontMetrics
                 }
                 getColor() {
                     return this.phantom ? "transparent" : this.color
                 }
             }
-            Mt.BASESIZE = 6;
-            var $u = Mt;
-            let W0 = {
+            qt.BASESIZE = 6;
+            var Rl = qt;
+            let hn = {
                     pt: 1,
                     mm: 7227 / 2540,
                     cm: 7227 / 254,
                     in: 72.27,
                     bp: 803 / 800,
                     pc: 12,
                     dd: 1238 / 1157,
                     cc: 14856 / 1157,
                     nd: 685 / 642,
                     nc: 1370 / 107,
                     sp: 1 / 65536,
                     px: 803 / 800
                 },
-                Gu = {
+                Bl = {
                     ex: !0,
                     em: !0,
                     mu: !0
                 },
-                Ni = function(n) {
-                    return typeof n != "string" && (n = n.unit), n in W0 || n in Gu || n === "ex"
+                qi = function(n) {
+                    return typeof n != "string" && (n = n.unit), n in hn || n in Bl || n === "ex"
                 },
-                Ie = function(n, t) {
-                    let o;
-                    if (n.unit in W0) o = W0[n.unit] / t.fontMetrics().ptPerEm / t.sizeMultiplier;
-                    else if (n.unit === "mu") o = t.fontMetrics().cssEmPerMu;
+                Le = function(n, t) {
+                    let u;
+                    if (n.unit in hn) u = hn[n.unit] / t.fontMetrics().ptPerEm / t.sizeMultiplier;
+                    else if (n.unit === "mu") u = t.fontMetrics().cssEmPerMu;
                     else {
-                        let s;
-                        if (t.style.isTight() ? s = t.havingStyle(t.style.text()) : s = t, n.unit === "ex") o = s.fontMetrics().xHeight;
-                        else if (n.unit === "em") o = s.fontMetrics().quad;
-                        else throw new a("Invalid unit: '" + n.unit + "'");
-                        s !== t && (o *= s.sizeMultiplier / t.sizeMultiplier)
+                        let a;
+                        if (t.style.isTight() ? a = t.havingStyle(t.style.text()) : a = t, n.unit === "ex") u = a.fontMetrics().xHeight;
+                        else if (n.unit === "em") u = a.fontMetrics().quad;
+                        else throw new o("Invalid unit: '" + n.unit + "'");
+                        a !== t && (u *= a.sizeMultiplier / t.sizeMultiplier)
                     }
-                    return Math.min(n.number * o, t.maxSize)
+                    return Math.min(n.number * u, t.maxSize)
                 },
-                Z = function(n) {
+                j = function(n) {
                     return +n.toFixed(4) + "em"
                 },
-                It = function(n) {
+                Vt = function(n) {
                     return n.filter(t => t).join(" ")
                 },
-                Li = function(n, t, o) {
-                    if (this.classes = n || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = o || {}, t) {
+                Fi = function(n, t, u) {
+                    if (this.classes = n || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = u || {}, t) {
                         t.style.isTight() && this.classes.push("mtight");
-                        let s = t.getColor();
-                        s && (this.style.color = s)
+                        let a = t.getColor();
+                        a && (this.style.color = a)
                     }
                 },
-                Pi = function(n) {
+                zi = function(n) {
                     let t = document.createElement(n);
-                    t.className = It(this.classes);
-                    for (let o in this.style) this.style.hasOwnProperty(o) && (t.style[o] = this.style[o]);
-                    for (let o in this.attributes) this.attributes.hasOwnProperty(o) && t.setAttribute(o, this.attributes[o]);
-                    for (let o = 0; o < this.children.length; o++) t.appendChild(this.children[o].toNode());
+                    t.className = Vt(this.classes);
+                    for (let u in this.style) this.style.hasOwnProperty(u) && (t.style[u] = this.style[u]);
+                    for (let u in this.attributes) this.attributes.hasOwnProperty(u) && t.setAttribute(u, this.attributes[u]);
+                    for (let u = 0; u < this.children.length; u++) t.appendChild(this.children[u].toNode());
                     return t
                 },
-                Ii = function(n) {
+                Ri = function(n) {
                     let t = "<" + n;
-                    this.classes.length && (t += ' class="' + R.escape(It(this.classes)) + '"');
-                    let o = "";
-                    for (let s in this.style) this.style.hasOwnProperty(s) && (o += R.hyphenate(s) + ":" + this.style[s] + ";");
-                    o && (t += ' style="' + R.escape(o) + '"');
-                    for (let s in this.attributes) this.attributes.hasOwnProperty(s) && (t += " " + s + '="' + R.escape(this.attributes[s]) + '"');
+                    this.classes.length && (t += ' class="' + N.escape(Vt(this.classes)) + '"');
+                    let u = "";
+                    for (let a in this.style) this.style.hasOwnProperty(a) && (u += N.hyphenate(a) + ":" + this.style[a] + ";");
+                    u && (t += ' style="' + N.escape(u) + '"');
+                    for (let a in this.attributes) this.attributes.hasOwnProperty(a) && (t += " " + a + '="' + N.escape(this.attributes[a]) + '"');
                     t += ">";
-                    for (let s = 0; s < this.children.length; s++) t += this.children[s].toMarkup();
+                    for (let a = 0; a < this.children.length; a++) t += this.children[a].toMarkup();
                     return t += "</" + n + ">", t
                 };
-            class vr {
-                constructor(t, o, s, u) {
-                    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, Li.call(this, t, s, u), this.children = o || []
+            class F0 {
+                constructor(t, u, a, c) {
+                    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, Fi.call(this, t, a, c), this.children = u || []
                 }
-                setAttribute(t, o) {
-                    this.attributes[t] = o
+                setAttribute(t, u) {
+                    this.attributes[t] = u
                 }
                 hasClass(t) {
-                    return R.contains(this.classes, t)
+                    return N.contains(this.classes, t)
                 }
                 toNode() {
-                    return Pi.call(this, "span")
+                    return zi.call(this, "span")
                 }
                 toMarkup() {
-                    return Ii.call(this, "span")
+                    return Ri.call(this, "span")
                 }
             }
-            class Y0 {
-                constructor(t, o, s, u) {
-                    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, Li.call(this, o, u), this.children = s || [], this.setAttribute("href", t)
+            class fn {
+                constructor(t, u, a, c) {
+                    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, Fi.call(this, u, c), this.children = a || [], this.setAttribute("href", t)
                 }
-                setAttribute(t, o) {
-                    this.attributes[t] = o
+                setAttribute(t, u) {
+                    this.attributes[t] = u
                 }
                 hasClass(t) {
-                    return R.contains(this.classes, t)
+                    return N.contains(this.classes, t)
                 }
                 toNode() {
-                    return Pi.call(this, "a")
+                    return zi.call(this, "a")
                 }
                 toMarkup() {
-                    return Ii.call(this, "a")
+                    return Ri.call(this, "a")
                 }
             }
-            class Vu {
-                constructor(t, o, s) {
-                    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = o, this.src = t, this.classes = ["mord"], this.style = s
+            class Nl {
+                constructor(t, u, a) {
+                    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = u, this.src = t, this.classes = ["mord"], this.style = a
                 }
                 hasClass(t) {
-                    return R.contains(this.classes, t)
+                    return N.contains(this.classes, t)
                 }
                 toNode() {
                     let t = document.createElement("img");
                     t.src = this.src, t.alt = this.alt, t.className = "mord";
-                    for (let o in this.style) this.style.hasOwnProperty(o) && (t.style[o] = this.style[o]);
+                    for (let u in this.style) this.style.hasOwnProperty(u) && (t.style[u] = this.style[u]);
                     return t
                 }
                 toMarkup() {
-                    let t = '<img src="' + R.escape(this.src) + '"' + (' alt="' + R.escape(this.alt) + '"'),
-                        o = "";
-                    for (let s in this.style) this.style.hasOwnProperty(s) && (o += R.hyphenate(s) + ":" + this.style[s] + ";");
-                    return o && (t += ' style="' + R.escape(o) + '"'), t += "'/>", t
+                    let t = '<img src="' + N.escape(this.src) + '"' + (' alt="' + N.escape(this.alt) + '"'),
+                        u = "";
+                    for (let a in this.style) this.style.hasOwnProperty(a) && (u += N.hyphenate(a) + ":" + this.style[a] + ";");
+                    return u && (t += ' style="' + N.escape(u) + '"'), t += "'/>", t
                 }
             }
-            let ju = {
+            let Ll = {
                 \u00EE: "\u0131\u0302",
                 \u00EF: "\u0131\u0308",
                 \u00ED: "\u0131\u0301",
                 \u00EC: "\u0131\u0300"
             };
-            class ut {
-                constructor(t, o, s, u, p, b, v, S) {
-                    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = t, this.height = o || 0, this.depth = s || 0, this.italic = u || 0, this.skew = p || 0, this.width = b || 0, this.classes = v || [], this.style = S || {}, this.maxFontSize = 0;
-                    let E = Te(this.text.charCodeAt(0));
-                    E && this.classes.push(E + "_fallback"), /[îïíì]/.test(this.text) && (this.text = ju[this.text])
+            class dt {
+                constructor(t, u, a, c, m, g, v, _) {
+                    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = t, this.height = u || 0, this.depth = a || 0, this.italic = c || 0, this.skew = m || 0, this.width = g || 0, this.classes = v || [], this.style = _ || {}, this.maxFontSize = 0;
+                    let D = ke(this.text.charCodeAt(0));
+                    D && this.classes.push(D + "_fallback"), /[îïíì]/.test(this.text) && (this.text = Ll[this.text])
                 }
                 hasClass(t) {
-                    return R.contains(this.classes, t)
+                    return N.contains(this.classes, t)
                 }
                 toNode() {
                     let t = document.createTextNode(this.text),
-                        o = null;
-                    this.italic > 0 && (o = document.createElement("span"), o.style.marginRight = Z(this.italic)), this.classes.length > 0 && (o = o || document.createElement("span"), o.className = It(this.classes));
-                    for (let s in this.style) this.style.hasOwnProperty(s) && (o = o || document.createElement("span"), o.style[s] = this.style[s]);
-                    return o ? (o.appendChild(t), o) : t
+                        u = null;
+                    this.italic > 0 && (u = document.createElement("span"), u.style.marginRight = j(this.italic)), this.classes.length > 0 && (u = u || document.createElement("span"), u.className = Vt(this.classes));
+                    for (let a in this.style) this.style.hasOwnProperty(a) && (u = u || document.createElement("span"), u.style[a] = this.style[a]);
+                    return u ? (u.appendChild(t), u) : t
                 }
                 toMarkup() {
                     let t = !1,
-                        o = "<span";
-                    this.classes.length && (t = !0, o += ' class="', o += R.escape(It(this.classes)), o += '"');
-                    let s = "";
-                    this.italic > 0 && (s += "margin-right:" + this.italic + "em;");
-                    for (let p in this.style) this.style.hasOwnProperty(p) && (s += R.hyphenate(p) + ":" + this.style[p] + ";");
-                    s && (t = !0, o += ' style="' + R.escape(s) + '"');
-                    let u = R.escape(this.text);
-                    return t ? (o += ">", o += u, o += "</span>", o) : u
+                        u = "<span";
+                    this.classes.length && (t = !0, u += ' class="', u += N.escape(Vt(this.classes)), u += '"');
+                    let a = "";
+                    this.italic > 0 && (a += "margin-right:" + this.italic + "em;");
+                    for (let m in this.style) this.style.hasOwnProperty(m) && (a += N.hyphenate(m) + ":" + this.style[m] + ";");
+                    a && (t = !0, u += ' style="' + N.escape(a) + '"');
+                    let c = N.escape(this.text);
+                    return t ? (u += ">", u += c, u += "</span>", u) : c
                 }
             }
-            class Et {
-                constructor(t, o) {
-                    this.children = void 0, this.attributes = void 0, this.children = t || [], this.attributes = o || {}
+            class Ft {
+                constructor(t, u) {
+                    this.children = void 0, this.attributes = void 0, this.children = t || [], this.attributes = u || {}
                 }
                 toNode() {
-                    let o = document.createElementNS("http://www.w3.org/2000/svg", "svg");
-                    for (let s in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, s) && o.setAttribute(s, this.attributes[s]);
-                    for (let s = 0; s < this.children.length; s++) o.appendChild(this.children[s].toNode());
-                    return o
+                    let u = document.createElementNS("http://www.w3.org/2000/svg", "svg");
+                    for (let a in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, a) && u.setAttribute(a, this.attributes[a]);
+                    for (let a = 0; a < this.children.length; a++) u.appendChild(this.children[a].toNode());
+                    return u
                 }
                 toMarkup() {
                     let t = '<svg xmlns="http://www.w3.org/2000/svg"';
-                    for (let o in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, o) && (t += " " + o + '="' + R.escape(this.attributes[o]) + '"');
+                    for (let u in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, u) && (t += " " + u + '="' + N.escape(this.attributes[u]) + '"');
                     t += ">";
-                    for (let o = 0; o < this.children.length; o++) t += this.children[o].toMarkup();
+                    for (let u = 0; u < this.children.length; u++) t += this.children[u].toMarkup();
                     return t += "</svg>", t
                 }
             }
-            class Ot {
-                constructor(t, o) {
-                    this.pathName = void 0, this.alternate = void 0, this.pathName = t, this.alternate = o
+            class Ut {
+                constructor(t, u) {
+                    this.pathName = void 0, this.alternate = void 0, this.pathName = t, this.alternate = u
                 }
                 toNode() {
-                    let o = document.createElementNS("http://www.w3.org/2000/svg", "path");
-                    return this.alternate ? o.setAttribute("d", this.alternate) : o.setAttribute("d", zi[this.pathName]), o
+                    let u = document.createElementNS("http://www.w3.org/2000/svg", "path");
+                    return this.alternate ? u.setAttribute("d", this.alternate) : u.setAttribute("d", Ti[this.pathName]), u
                 }
                 toMarkup() {
-                    return this.alternate ? '<path d="' + R.escape(this.alternate) + '"/>' : '<path d="' + R.escape(zi[this.pathName]) + '"/>'
+                    return this.alternate ? '<path d="' + N.escape(this.alternate) + '"/>' : '<path d="' + N.escape(Ti[this.pathName]) + '"/>'
                 }
             }
-            class Z0 {
+            class mn {
                 constructor(t) {
                     this.attributes = void 0, this.attributes = t || {}
                 }
                 toNode() {
-                    let o = document.createElementNS("http://www.w3.org/2000/svg", "line");
-                    for (let s in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, s) && o.setAttribute(s, this.attributes[s]);
-                    return o
+                    let u = document.createElementNS("http://www.w3.org/2000/svg", "line");
+                    for (let a in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, a) && u.setAttribute(a, this.attributes[a]);
+                    return u
                 }
                 toMarkup() {
                     let t = "<line";
-                    for (let o in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, o) && (t += " " + o + '="' + R.escape(this.attributes[o]) + '"');
+                    for (let u in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, u) && (t += " " + u + '="' + N.escape(this.attributes[u]) + '"');
                     return t += "/>", t
                 }
             }
 
-            function Oi(n) {
-                if (n instanceof ut) return n;
+            function Bi(n) {
+                if (n instanceof dt) return n;
                 throw new Error("Expected symbolNode but got " + String(n) + ".")
             }
 
-            function Uu(n) {
-                if (n instanceof vr) return n;
+            function Pl(n) {
+                if (n instanceof F0) return n;
                 throw new Error("Expected span<HtmlDomNode> but got " + String(n) + ".")
             }
-            let Wu = {
+            let Il = {
                     bin: 1,
                     close: 1,
                     inner: 1,
                     open: 1,
                     punct: 1,
                     rel: 1
                 },
-                Yu = {
+                Ol = {
                     "accent-token": 1,
                     mathord: 1,
                     "op-token": 1,
                     spacing: 1,
                     textord: 1
                 },
-                Gr = {
+                rr = {
                     math: {},
                     text: {}
                 };
-            var Oe = Gr;
+            var Pe = rr;
 
-            function h(n, t, o, s, u, p) {
-                Gr[n][u] = {
+            function d(n, t, u, a, c, m) {
+                rr[n][c] = {
                     font: t,
-                    group: o,
-                    replace: s
-                }, p && s && (Gr[n][s] = Gr[n][u])
-            }
-            let m = "math",
-                $ = "text",
-                x = "main",
-                C = "ams",
-                Be = "accent-token",
+                    group: u,
+                    replace: a
+                }, m && a && (rr[n][a] = rr[n][c])
+            }
+            let f = "math",
+                I = "text",
+                y = "main",
+                S = "ams",
+                Fe = "accent-token",
                 J = "bin",
                 et = "close",
-                sr = "inner",
-                se = "mathord",
-                We = "op-token",
+                g0 = "inner",
+                ue = "mathord",
+                Ue = "op-token",
                 at = "open",
-                Vr = "punct",
-                q = "rel",
-                Dt = "spacing",
-                D = "textord";
-            h(m, x, q, "\u2261", "\\equiv", !0), h(m, x, q, "\u227A", "\\prec", !0), h(m, x, q, "\u227B", "\\succ", !0), h(m, x, q, "\u223C", "\\sim", !0), h(m, x, q, "\u22A5", "\\perp"), h(m, x, q, "\u2AAF", "\\preceq", !0), h(m, x, q, "\u2AB0", "\\succeq", !0), h(m, x, q, "\u2243", "\\simeq", !0), h(m, x, q, "\u2223", "\\mid", !0), h(m, x, q, "\u226A", "\\ll", !0), h(m, x, q, "\u226B", "\\gg", !0), h(m, x, q, "\u224D", "\\asymp", !0), h(m, x, q, "\u2225", "\\parallel"), h(m, x, q, "\u22C8", "\\bowtie", !0), h(m, x, q, "\u2323", "\\smile", !0), h(m, x, q, "\u2291", "\\sqsubseteq", !0), h(m, x, q, "\u2292", "\\sqsupseteq", !0), h(m, x, q, "\u2250", "\\doteq", !0), h(m, x, q, "\u2322", "\\frown", !0), h(m, x, q, "\u220B", "\\ni", !0), h(m, x, q, "\u221D", "\\propto", !0), h(m, x, q, "\u22A2", "\\vdash", !0), h(m, x, q, "\u22A3", "\\dashv", !0), h(m, x, q, "\u220B", "\\owns"), h(m, x, Vr, ".", "\\ldotp"), h(m, x, Vr, "\u22C5", "\\cdotp"), h(m, x, D, "#", "\\#"), h($, x, D, "#", "\\#"), h(m, x, D, "&", "\\&"), h($, x, D, "&", "\\&"), h(m, x, D, "\u2135", "\\aleph", !0), h(m, x, D, "\u2200", "\\forall", !0), h(m, x, D, "\u210F", "\\hbar", !0), h(m, x, D, "\u2203", "\\exists", !0), h(m, x, D, "\u2207", "\\nabla", !0), h(m, x, D, "\u266D", "\\flat", !0), h(m, x, D, "\u2113", "\\ell", !0), h(m, x, D, "\u266E", "\\natural", !0), h(m, x, D, "\u2663", "\\clubsuit", !0), h(m, x, D, "\u2118", "\\wp", !0), h(m, x, D, "\u266F", "\\sharp", !0), h(m, x, D, "\u2662", "\\diamondsuit", !0), h(m, x, D, "\u211C", "\\Re", !0), h(m, x, D, "\u2661", "\\heartsuit", !0), h(m, x, D, "\u2111", "\\Im", !0), h(m, x, D, "\u2660", "\\spadesuit", !0), h(m, x, D, "\xA7", "\\S", !0), h($, x, D, "\xA7", "\\S"), h(m, x, D, "\xB6", "\\P", !0), h($, x, D, "\xB6", "\\P"), h(m, x, D, "\u2020", "\\dag"), h($, x, D, "\u2020", "\\dag"), h($, x, D, "\u2020", "\\textdagger"), h(m, x, D, "\u2021", "\\ddag"), h($, x, D, "\u2021", "\\ddag"), h($, x, D, "\u2021", "\\textdaggerdbl"), h(m, x, et, "\u23B1", "\\rmoustache", !0), h(m, x, at, "\u23B0", "\\lmoustache", !0), h(m, x, et, "\u27EF", "\\rgroup", !0), h(m, x, at, "\u27EE", "\\lgroup", !0), h(m, x, J, "\u2213", "\\mp", !0), h(m, x, J, "\u2296", "\\ominus", !0), h(m, x, J, "\u228E", "\\uplus", !0), h(m, x, J, "\u2293", "\\sqcap", !0), h(m, x, J, "\u2217", "\\ast"), h(m, x, J, "\u2294", "\\sqcup", !0), h(m, x, J, "\u25EF", "\\bigcirc", !0), h(m, x, J, "\u2219", "\\bullet", !0), h(m, x, J, "\u2021", "\\ddagger"), h(m, x, J, "\u2240", "\\wr", !0), h(m, x, J, "\u2A3F", "\\amalg"), h(m, x, J, "&", "\\And"), h(m, x, q, "\u27F5", "\\longleftarrow", !0), h(m, x, q, "\u21D0", "\\Leftarrow", !0), h(m, x, q, "\u27F8", "\\Longleftarrow", !0), h(m, x, q, "\u27F6", "\\longrightarrow", !0), h(m, x, q, "\u21D2", "\\Rightarrow", !0), h(m, x, q, "\u27F9", "\\Longrightarrow", !0), h(m, x, q, "\u2194", "\\leftrightarrow", !0), h(m, x, q, "\u27F7", "\\longleftrightarrow", !0), h(m, x, q, "\u21D4", "\\Leftrightarrow", !0), h(m, x, q, "\u27FA", "\\Longleftrightarrow", !0), h(m, x, q, "\u21A6", "\\mapsto", !0), h(m, x, q, "\u27FC", "\\longmapsto", !0), h(m, x, q, "\u2197", "\\nearrow", !0), h(m, x, q, "\u21A9", "\\hookleftarrow", !0), h(m, x, q, "\u21AA", "\\hookrightarrow", !0), h(m, x, q, "\u2198", "\\searrow", !0), h(m, x, q, "\u21BC", "\\leftharpoonup", !0), h(m, x, q, "\u21C0", "\\rightharpoonup", !0), h(m, x, q, "\u2199", "\\swarrow", !0), h(m, x, q, "\u21BD", "\\leftharpoondown", !0), h(m, x, q, "\u21C1", "\\rightharpoondown", !0), h(m, x, q, "\u2196", "\\nwarrow", !0), h(m, x, q, "\u21CC", "\\rightleftharpoons", !0), h(m, C, q, "\u226E", "\\nless", !0), h(m, C, q, "\uE010", "\\@nleqslant"), h(m, C, q, "\uE011", "\\@nleqq"), h(m, C, q, "\u2A87", "\\lneq", !0), h(m, C, q, "\u2268", "\\lneqq", !0), h(m, C, q, "\uE00C", "\\@lvertneqq"), h(m, C, q, "\u22E6", "\\lnsim", !0), h(m, C, q, "\u2A89", "\\lnapprox", !0), h(m, C, q, "\u2280", "\\nprec", !0), h(m, C, q, "\u22E0", "\\npreceq", !0), h(m, C, q, "\u22E8", "\\precnsim", !0), h(m, C, q, "\u2AB9", "\\precnapprox", !0), h(m, C, q, "\u2241", "\\nsim", !0), h(m, C, q, "\uE006", "\\@nshortmid"), h(m, C, q, "\u2224", "\\nmid", !0), h(m, C, q, "\u22AC", "\\nvdash", !0), h(m, C, q, "\u22AD", "\\nvDash", !0), h(m, C, q, "\u22EA", "\\ntriangleleft"), h(m, C, q, "\u22EC", "\\ntrianglelefteq", !0), h(m, C, q, "\u228A", "\\subsetneq", !0), h(m, C, q, "\uE01A", "\\@varsubsetneq"), h(m, C, q, "\u2ACB", "\\subsetneqq", !0), h(m, C, q, "\uE017", "\\@varsubsetneqq"), h(m, C, q, "\u226F", "\\ngtr", !0), h(m, C, q, "\uE00F", "\\@ngeqslant"), h(m, C, q, "\uE00E", "\\@ngeqq"), h(m, C, q, "\u2A88", "\\gneq", !0), h(m, C, q, "\u2269", "\\gneqq", !0), h(m, C, q, "\uE00D", "\\@gvertneqq"), h(m, C, q, "\u22E7", "\\gnsim", !0), h(m, C, q, "\u2A8A", "\\gnapprox", !0), h(m, C, q, "\u2281", "\\nsucc", !0), h(m, C, q, "\u22E1", "\\nsucceq", !0), h(m, C, q, "\u22E9", "\\succnsim", !0), h(m, C, q, "\u2ABA", "\\succnapprox", !0), h(m, C, q, "\u2246", "\\ncong", !0), h(m, C, q, "\uE007", "\\@nshortparallel"), h(m, C, q, "\u2226", "\\nparallel", !0), h(m, C, q, "\u22AF", "\\nVDash", !0), h(m, C, q, "\u22EB", "\\ntriangleright"), h(m, C, q, "\u22ED", "\\ntrianglerighteq", !0), h(m, C, q, "\uE018", "\\@nsupseteqq"), h(m, C, q, "\u228B", "\\supsetneq", !0), h(m, C, q, "\uE01B", "\\@varsupsetneq"), h(m, C, q, "\u2ACC", "\\supsetneqq", !0), h(m, C, q, "\uE019", "\\@varsupsetneqq"), h(m, C, q, "\u22AE", "\\nVdash", !0), h(m, C, q, "\u2AB5", "\\precneqq", !0), h(m, C, q, "\u2AB6", "\\succneqq", !0), h(m, C, q, "\uE016", "\\@nsubseteqq"), h(m, C, J, "\u22B4", "\\unlhd"), h(m, C, J, "\u22B5", "\\unrhd"), h(m, C, q, "\u219A", "\\nleftarrow", !0), h(m, C, q, "\u219B", "\\nrightarrow", !0), h(m, C, q, "\u21CD", "\\nLeftarrow", !0), h(m, C, q, "\u21CF", "\\nRightarrow", !0), h(m, C, q, "\u21AE", "\\nleftrightarrow", !0), h(m, C, q, "\u21CE", "\\nLeftrightarrow", !0), h(m, C, q, "\u25B3", "\\vartriangle"), h(m, C, D, "\u210F", "\\hslash"), h(m, C, D, "\u25BD", "\\triangledown"), h(m, C, D, "\u25CA", "\\lozenge"), h(m, C, D, "\u24C8", "\\circledS"), h(m, C, D, "\xAE", "\\circledR"), h($, C, D, "\xAE", "\\circledR"), h(m, C, D, "\u2221", "\\measuredangle", !0), h(m, C, D, "\u2204", "\\nexists"), h(m, C, D, "\u2127", "\\mho"), h(m, C, D, "\u2132", "\\Finv", !0), h(m, C, D, "\u2141", "\\Game", !0), h(m, C, D, "\u2035", "\\backprime"), h(m, C, D, "\u25B2", "\\blacktriangle"), h(m, C, D, "\u25BC", "\\blacktriangledown"), h(m, C, D, "\u25A0", "\\blacksquare"), h(m, C, D, "\u29EB", "\\blacklozenge"), h(m, C, D, "\u2605", "\\bigstar"), h(m, C, D, "\u2222", "\\sphericalangle", !0), h(m, C, D, "\u2201", "\\complement", !0), h(m, C, D, "\xF0", "\\eth", !0), h($, x, D, "\xF0", "\xF0"), h(m, C, D, "\u2571", "\\diagup"), h(m, C, D, "\u2572", "\\diagdown"), h(m, C, D, "\u25A1", "\\square"), h(m, C, D, "\u25A1", "\\Box"), h(m, C, D, "\u25CA", "\\Diamond"), h(m, C, D, "\xA5", "\\yen", !0), h($, C, D, "\xA5", "\\yen", !0), h(m, C, D, "\u2713", "\\checkmark", !0), h($, C, D, "\u2713", "\\checkmark"), h(m, C, D, "\u2136", "\\beth", !0), h(m, C, D, "\u2138", "\\daleth", !0), h(m, C, D, "\u2137", "\\gimel", !0), h(m, C, D, "\u03DD", "\\digamma", !0), h(m, C, D, "\u03F0", "\\varkappa"), h(m, C, at, "\u250C", "\\@ulcorner", !0), h(m, C, et, "\u2510", "\\@urcorner", !0), h(m, C, at, "\u2514", "\\@llcorner", !0), h(m, C, et, "\u2518", "\\@lrcorner", !0), h(m, C, q, "\u2266", "\\leqq", !0), h(m, C, q, "\u2A7D", "\\leqslant", !0), h(m, C, q, "\u2A95", "\\eqslantless", !0), h(m, C, q, "\u2272", "\\lesssim", !0), h(m, C, q, "\u2A85", "\\lessapprox", !0), h(m, C, q, "\u224A", "\\approxeq", !0), h(m, C, J, "\u22D6", "\\lessdot"), h(m, C, q, "\u22D8", "\\lll", !0), h(m, C, q, "\u2276", "\\lessgtr", !0), h(m, C, q, "\u22DA", "\\lesseqgtr", !0), h(m, C, q, "\u2A8B", "\\lesseqqgtr", !0), h(m, C, q, "\u2251", "\\doteqdot"), h(m, C, q, "\u2253", "\\risingdotseq", !0), h(m, C, q, "\u2252", "\\fallingdotseq", !0), h(m, C, q, "\u223D", "\\backsim", !0), h(m, C, q, "\u22CD", "\\backsimeq", !0), h(m, C, q, "\u2AC5", "\\subseteqq", !0), h(m, C, q, "\u22D0", "\\Subset", !0), h(m, C, q, "\u228F", "\\sqsubset", !0), h(m, C, q, "\u227C", "\\preccurlyeq", !0), h(m, C, q, "\u22DE", "\\curlyeqprec", !0), h(m, C, q, "\u227E", "\\precsim", !0), h(m, C, q, "\u2AB7", "\\precapprox", !0), h(m, C, q, "\u22B2", "\\vartriangleleft"), h(m, C, q, "\u22B4", "\\trianglelefteq"), h(m, C, q, "\u22A8", "\\vDash", !0), h(m, C, q, "\u22AA", "\\Vvdash", !0), h(m, C, q, "\u2323", "\\smallsmile"), h(m, C, q, "\u2322", "\\smallfrown"), h(m, C, q, "\u224F", "\\bumpeq", !0), h(m, C, q, "\u224E", "\\Bumpeq", !0), h(m, C, q, "\u2267", "\\geqq", !0), h(m, C, q, "\u2A7E", "\\geqslant", !0), h(m, C, q, "\u2A96", "\\eqslantgtr", !0), h(m, C, q, "\u2273", "\\gtrsim", !0), h(m, C, q, "\u2A86", "\\gtrapprox", !0), h(m, C, J, "\u22D7", "\\gtrdot"), h(m, C, q, "\u22D9", "\\ggg", !0), h(m, C, q, "\u2277", "\\gtrless", !0), h(m, C, q, "\u22DB", "\\gtreqless", !0), h(m, C, q, "\u2A8C", "\\gtreqqless", !0), h(m, C, q, "\u2256", "\\eqcirc", !0), h(m, C, q, "\u2257", "\\circeq", !0), h(m, C, q, "\u225C", "\\triangleq", !0), h(m, C, q, "\u223C", "\\thicksim"), h(m, C, q, "\u2248", "\\thickapprox"), h(m, C, q, "\u2AC6", "\\supseteqq", !0), h(m, C, q, "\u22D1", "\\Supset", !0), h(m, C, q, "\u2290", "\\sqsupset", !0), h(m, C, q, "\u227D", "\\succcurlyeq", !0), h(m, C, q, "\u22DF", "\\curlyeqsucc", !0), h(m, C, q, "\u227F", "\\succsim", !0), h(m, C, q, "\u2AB8", "\\succapprox", !0), h(m, C, q, "\u22B3", "\\vartriangleright"), h(m, C, q, "\u22B5", "\\trianglerighteq"), h(m, C, q, "\u22A9", "\\Vdash", !0), h(m, C, q, "\u2223", "\\shortmid"), h(m, C, q, "\u2225", "\\shortparallel"), h(m, C, q, "\u226C", "\\between", !0), h(m, C, q, "\u22D4", "\\pitchfork", !0), h(m, C, q, "\u221D", "\\varpropto"), h(m, C, q, "\u25C0", "\\blacktriangleleft"), h(m, C, q, "\u2234", "\\therefore", !0), h(m, C, q, "\u220D", "\\backepsilon"), h(m, C, q, "\u25B6", "\\blacktriangleright"), h(m, C, q, "\u2235", "\\because", !0), h(m, C, q, "\u22D8", "\\llless"), h(m, C, q, "\u22D9", "\\gggtr"), h(m, C, J, "\u22B2", "\\lhd"), h(m, C, J, "\u22B3", "\\rhd"), h(m, C, q, "\u2242", "\\eqsim", !0), h(m, x, q, "\u22C8", "\\Join"), h(m, C, q, "\u2251", "\\Doteq", !0), h(m, C, J, "\u2214", "\\dotplus", !0), h(m, C, J, "\u2216", "\\smallsetminus"), h(m, C, J, "\u22D2", "\\Cap", !0), h(m, C, J, "\u22D3", "\\Cup", !0), h(m, C, J, "\u2A5E", "\\doublebarwedge", !0), h(m, C, J, "\u229F", "\\boxminus", !0), h(m, C, J, "\u229E", "\\boxplus", !0), h(m, C, J, "\u22C7", "\\divideontimes", !0), h(m, C, J, "\u22C9", "\\ltimes", !0), h(m, C, J, "\u22CA", "\\rtimes", !0), h(m, C, J, "\u22CB", "\\leftthreetimes", !0), h(m, C, J, "\u22CC", "\\rightthreetimes", !0), h(m, C, J, "\u22CF", "\\curlywedge", !0), h(m, C, J, "\u22CE", "\\curlyvee", !0), h(m, C, J, "\u229D", "\\circleddash", !0), h(m, C, J, "\u229B", "\\circledast", !0), h(m, C, J, "\u22C5", "\\centerdot"), h(m, C, J, "\u22BA", "\\intercal", !0), h(m, C, J, "\u22D2", "\\doublecap"), h(m, C, J, "\u22D3", "\\doublecup"), h(m, C, J, "\u22A0", "\\boxtimes", !0), h(m, C, q, "\u21E2", "\\dashrightarrow", !0), h(m, C, q, "\u21E0", "\\dashleftarrow", !0), h(m, C, q, "\u21C7", "\\leftleftarrows", !0), h(m, C, q, "\u21C6", "\\leftrightarrows", !0), h(m, C, q, "\u21DA", "\\Lleftarrow", !0), h(m, C, q, "\u219E", "\\twoheadleftarrow", !0), h(m, C, q, "\u21A2", "\\leftarrowtail", !0), h(m, C, q, "\u21AB", "\\looparrowleft", !0), h(m, C, q, "\u21CB", "\\leftrightharpoons", !0), h(m, C, q, "\u21B6", "\\curvearrowleft", !0), h(m, C, q, "\u21BA", "\\circlearrowleft", !0), h(m, C, q, "\u21B0", "\\Lsh", !0), h(m, C, q, "\u21C8", "\\upuparrows", !0), h(m, C, q, "\u21BF", "\\upharpoonleft", !0), h(m, C, q, "\u21C3", "\\downharpoonleft", !0), h(m, x, q, "\u22B6", "\\origof", !0), h(m, x, q, "\u22B7", "\\imageof", !0), h(m, C, q, "\u22B8", "\\multimap", !0), h(m, C, q, "\u21AD", "\\leftrightsquigarrow", !0), h(m, C, q, "\u21C9", "\\rightrightarrows", !0), h(m, C, q, "\u21C4", "\\rightleftarrows", !0), h(m, C, q, "\u21A0", "\\twoheadrightarrow", !0), h(m, C, q, "\u21A3", "\\rightarrowtail", !0), h(m, C, q, "\u21AC", "\\looparrowright", !0), h(m, C, q, "\u21B7", "\\curvearrowright", !0), h(m, C, q, "\u21BB", "\\circlearrowright", !0), h(m, C, q, "\u21B1", "\\Rsh", !0), h(m, C, q, "\u21CA", "\\downdownarrows", !0), h(m, C, q, "\u21BE", "\\upharpoonright", !0), h(m, C, q, "\u21C2", "\\downharpoonright", !0), h(m, C, q, "\u21DD", "\\rightsquigarrow", !0), h(m, C, q, "\u21DD", "\\leadsto"), h(m, C, q, "\u21DB", "\\Rrightarrow", !0), h(m, C, q, "\u21BE", "\\restriction"), h(m, x, D, "\u2018", "`"), h(m, x, D, "$", "\\$"), h($, x, D, "$", "\\$"), h($, x, D, "$", "\\textdollar"), h(m, x, D, "%", "\\%"), h($, x, D, "%", "\\%"), h(m, x, D, "_", "\\_"), h($, x, D, "_", "\\_"), h($, x, D, "_", "\\textunderscore"), h(m, x, D, "\u2220", "\\angle", !0), h(m, x, D, "\u221E", "\\infty", !0), h(m, x, D, "\u2032", "\\prime"), h(m, x, D, "\u25B3", "\\triangle"), h(m, x, D, "\u0393", "\\Gamma", !0), h(m, x, D, "\u0394", "\\Delta", !0), h(m, x, D, "\u0398", "\\Theta", !0), h(m, x, D, "\u039B", "\\Lambda", !0), h(m, x, D, "\u039E", "\\Xi", !0), h(m, x, D, "\u03A0", "\\Pi", !0), h(m, x, D, "\u03A3", "\\Sigma", !0), h(m, x, D, "\u03A5", "\\Upsilon", !0), h(m, x, D, "\u03A6", "\\Phi", !0), h(m, x, D, "\u03A8", "\\Psi", !0), h(m, x, D, "\u03A9", "\\Omega", !0), h(m, x, D, "A", "\u0391"), h(m, x, D, "B", "\u0392"), h(m, x, D, "E", "\u0395"), h(m, x, D, "Z", "\u0396"), h(m, x, D, "H", "\u0397"), h(m, x, D, "I", "\u0399"), h(m, x, D, "K", "\u039A"), h(m, x, D, "M", "\u039C"), h(m, x, D, "N", "\u039D"), h(m, x, D, "O", "\u039F"), h(m, x, D, "P", "\u03A1"), h(m, x, D, "T", "\u03A4"), h(m, x, D, "X", "\u03A7"), h(m, x, D, "\xAC", "\\neg", !0), h(m, x, D, "\xAC", "\\lnot"), h(m, x, D, "\u22A4", "\\top"), h(m, x, D, "\u22A5", "\\bot"), h(m, x, D, "\u2205", "\\emptyset"), h(m, C, D, "\u2205", "\\varnothing"), h(m, x, se, "\u03B1", "\\alpha", !0), h(m, x, se, "\u03B2", "\\beta", !0), h(m, x, se, "\u03B3", "\\gamma", !0), h(m, x, se, "\u03B4", "\\delta", !0), h(m, x, se, "\u03F5", "\\epsilon", !0), h(m, x, se, "\u03B6", "\\zeta", !0), h(m, x, se, "\u03B7", "\\eta", !0), h(m, x, se, "\u03B8", "\\theta", !0), h(m, x, se, "\u03B9", "\\iota", !0), h(m, x, se, "\u03BA", "\\kappa", !0), h(m, x, se, "\u03BB", "\\lambda", !0), h(m, x, se, "\u03BC", "\\mu", !0), h(m, x, se, "\u03BD", "\\nu", !0), h(m, x, se, "\u03BE", "\\xi", !0), h(m, x, se, "\u03BF", "\\omicron", !0), h(m, x, se, "\u03C0", "\\pi", !0), h(m, x, se, "\u03C1", "\\rho", !0), h(m, x, se, "\u03C3", "\\sigma", !0), h(m, x, se, "\u03C4", "\\tau", !0), h(m, x, se, "\u03C5", "\\upsilon", !0), h(m, x, se, "\u03D5", "\\phi", !0), h(m, x, se, "\u03C7", "\\chi", !0), h(m, x, se, "\u03C8", "\\psi", !0), h(m, x, se, "\u03C9", "\\omega", !0), h(m, x, se, "\u03B5", "\\varepsilon", !0), h(m, x, se, "\u03D1", "\\vartheta", !0), h(m, x, se, "\u03D6", "\\varpi", !0), h(m, x, se, "\u03F1", "\\varrho", !0), h(m, x, se, "\u03C2", "\\varsigma", !0), h(m, x, se, "\u03C6", "\\varphi", !0), h(m, x, J, "\u2217", "*", !0), h(m, x, J, "+", "+"), h(m, x, J, "\u2212", "-", !0), h(m, x, J, "\u22C5", "\\cdot", !0), h(m, x, J, "\u2218", "\\circ", !0), h(m, x, J, "\xF7", "\\div", !0), h(m, x, J, "\xB1", "\\pm", !0), h(m, x, J, "\xD7", "\\times", !0), h(m, x, J, "\u2229", "\\cap", !0), h(m, x, J, "\u222A", "\\cup", !0), h(m, x, J, "\u2216", "\\setminus", !0), h(m, x, J, "\u2227", "\\land"), h(m, x, J, "\u2228", "\\lor"), h(m, x, J, "\u2227", "\\wedge", !0), h(m, x, J, "\u2228", "\\vee", !0), h(m, x, D, "\u221A", "\\surd"), h(m, x, at, "\u27E8", "\\langle", !0), h(m, x, at, "\u2223", "\\lvert"), h(m, x, at, "\u2225", "\\lVert"), h(m, x, et, "?", "?"), h(m, x, et, "!", "!"), h(m, x, et, "\u27E9", "\\rangle", !0), h(m, x, et, "\u2223", "\\rvert"), h(m, x, et, "\u2225", "\\rVert"), h(m, x, q, "=", "="), h(m, x, q, ":", ":"), h(m, x, q, "\u2248", "\\approx", !0), h(m, x, q, "\u2245", "\\cong", !0), h(m, x, q, "\u2265", "\\ge"), h(m, x, q, "\u2265", "\\geq", !0), h(m, x, q, "\u2190", "\\gets"), h(m, x, q, ">", "\\gt", !0), h(m, x, q, "\u2208", "\\in", !0), h(m, x, q, "\uE020", "\\@not"), h(m, x, q, "\u2282", "\\subset", !0), h(m, x, q, "\u2283", "\\supset", !0), h(m, x, q, "\u2286", "\\subseteq", !0), h(m, x, q, "\u2287", "\\supseteq", !0), h(m, C, q, "\u2288", "\\nsubseteq", !0), h(m, C, q, "\u2289", "\\nsupseteq", !0), h(m, x, q, "\u22A8", "\\models"), h(m, x, q, "\u2190", "\\leftarrow", !0), h(m, x, q, "\u2264", "\\le"), h(m, x, q, "\u2264", "\\leq", !0), h(m, x, q, "<", "\\lt", !0), h(m, x, q, "\u2192", "\\rightarrow", !0), h(m, x, q, "\u2192", "\\to"), h(m, C, q, "\u2271", "\\ngeq", !0), h(m, C, q, "\u2270", "\\nleq", !0), h(m, x, Dt, "\xA0", "\\ "), h(m, x, Dt, "\xA0", "\\space"), h(m, x, Dt, "\xA0", "\\nobreakspace"), h($, x, Dt, "\xA0", "\\ "), h($, x, Dt, "\xA0", " "), h($, x, Dt, "\xA0", "\\space"), h($, x, Dt, "\xA0", "\\nobreakspace"), h(m, x, Dt, null, "\\nobreak"), h(m, x, Dt, null, "\\allowbreak"), h(m, x, Vr, ",", ","), h(m, x, Vr, ";", ";"), h(m, C, J, "\u22BC", "\\barwedge", !0), h(m, C, J, "\u22BB", "\\veebar", !0), h(m, x, J, "\u2299", "\\odot", !0), h(m, x, J, "\u2295", "\\oplus", !0), h(m, x, J, "\u2297", "\\otimes", !0), h(m, x, D, "\u2202", "\\partial", !0), h(m, x, J, "\u2298", "\\oslash", !0), h(m, C, J, "\u229A", "\\circledcirc", !0), h(m, C, J, "\u22A1", "\\boxdot", !0), h(m, x, J, "\u25B3", "\\bigtriangleup"), h(m, x, J, "\u25BD", "\\bigtriangledown"), h(m, x, J, "\u2020", "\\dagger"), h(m, x, J, "\u22C4", "\\diamond"), h(m, x, J, "\u22C6", "\\star"), h(m, x, J, "\u25C3", "\\triangleleft"), h(m, x, J, "\u25B9", "\\triangleright"), h(m, x, at, "{", "\\{"), h($, x, D, "{", "\\{"), h($, x, D, "{", "\\textbraceleft"), h(m, x, et, "}", "\\}"), h($, x, D, "}", "\\}"), h($, x, D, "}", "\\textbraceright"), h(m, x, at, "{", "\\lbrace"), h(m, x, et, "}", "\\rbrace"), h(m, x, at, "[", "\\lbrack", !0), h($, x, D, "[", "\\lbrack", !0), h(m, x, et, "]", "\\rbrack", !0), h($, x, D, "]", "\\rbrack", !0), h(m, x, at, "(", "\\lparen", !0), h(m, x, et, ")", "\\rparen", !0), h($, x, D, "<", "\\textless", !0), h($, x, D, ">", "\\textgreater", !0), h(m, x, at, "\u230A", "\\lfloor", !0), h(m, x, et, "\u230B", "\\rfloor", !0), h(m, x, at, "\u2308", "\\lceil", !0), h(m, x, et, "\u2309", "\\rceil", !0), h(m, x, D, "\\", "\\backslash"), h(m, x, D, "\u2223", "|"), h(m, x, D, "\u2223", "\\vert"), h($, x, D, "|", "\\textbar", !0), h(m, x, D, "\u2225", "\\|"), h(m, x, D, "\u2225", "\\Vert"), h($, x, D, "\u2225", "\\textbardbl"), h($, x, D, "~", "\\textasciitilde"), h($, x, D, "\\", "\\textbackslash"), h($, x, D, "^", "\\textasciicircum"), h(m, x, q, "\u2191", "\\uparrow", !0), h(m, x, q, "\u21D1", "\\Uparrow", !0), h(m, x, q, "\u2193", "\\downarrow", !0), h(m, x, q, "\u21D3", "\\Downarrow", !0), h(m, x, q, "\u2195", "\\updownarrow", !0), h(m, x, q, "\u21D5", "\\Updownarrow", !0), h(m, x, We, "\u2210", "\\coprod"), h(m, x, We, "\u22C1", "\\bigvee"), h(m, x, We, "\u22C0", "\\bigwedge"), h(m, x, We, "\u2A04", "\\biguplus"), h(m, x, We, "\u22C2", "\\bigcap"), h(m, x, We, "\u22C3", "\\bigcup"), h(m, x, We, "\u222B", "\\int"), h(m, x, We, "\u222B", "\\intop"), h(m, x, We, "\u222C", "\\iint"), h(m, x, We, "\u222D", "\\iiint"), h(m, x, We, "\u220F", "\\prod"), h(m, x, We, "\u2211", "\\sum"), h(m, x, We, "\u2A02", "\\bigotimes"), h(m, x, We, "\u2A01", "\\bigoplus"), h(m, x, We, "\u2A00", "\\bigodot"), h(m, x, We, "\u222E", "\\oint"), h(m, x, We, "\u222F", "\\oiint"), h(m, x, We, "\u2230", "\\oiiint"), h(m, x, We, "\u2A06", "\\bigsqcup"), h(m, x, We, "\u222B", "\\smallint"), h($, x, sr, "\u2026", "\\textellipsis"), h(m, x, sr, "\u2026", "\\mathellipsis"), h($, x, sr, "\u2026", "\\ldots", !0), h(m, x, sr, "\u2026", "\\ldots", !0), h(m, x, sr, "\u22EF", "\\@cdots", !0), h(m, x, sr, "\u22F1", "\\ddots", !0), h(m, x, D, "\u22EE", "\\varvdots"), h(m, x, Be, "\u02CA", "\\acute"), h(m, x, Be, "\u02CB", "\\grave"), h(m, x, Be, "\xA8", "\\ddot"), h(m, x, Be, "~", "\\tilde"), h(m, x, Be, "\u02C9", "\\bar"), h(m, x, Be, "\u02D8", "\\breve"), h(m, x, Be, "\u02C7", "\\check"), h(m, x, Be, "^", "\\hat"), h(m, x, Be, "\u20D7", "\\vec"), h(m, x, Be, "\u02D9", "\\dot"), h(m, x, Be, "\u02DA", "\\mathring"), h(m, x, se, "\uE131", "\\@imath"), h(m, x, se, "\uE237", "\\@jmath"), h(m, x, D, "\u0131", "\u0131"), h(m, x, D, "\u0237", "\u0237"), h($, x, D, "\u0131", "\\i", !0), h($, x, D, "\u0237", "\\j", !0), h($, x, D, "\xDF", "\\ss", !0), h($, x, D, "\xE6", "\\ae", !0), h($, x, D, "\u0153", "\\oe", !0), h($, x, D, "\xF8", "\\o", !0), h($, x, D, "\xC6", "\\AE", !0), h($, x, D, "\u0152", "\\OE", !0), h($, x, D, "\xD8", "\\O", !0), h($, x, Be, "\u02CA", "\\'"), h($, x, Be, "\u02CB", "\\`"), h($, x, Be, "\u02C6", "\\^"), h($, x, Be, "\u02DC", "\\~"), h($, x, Be, "\u02C9", "\\="), h($, x, Be, "\u02D8", "\\u"), h($, x, Be, "\u02D9", "\\."), h($, x, Be, "\xB8", "\\c"), h($, x, Be, "\u02DA", "\\r"), h($, x, Be, "\u02C7", "\\v"), h($, x, Be, "\xA8", '\\"'), h($, x, Be, "\u02DD", "\\H"), h($, x, Be, "\u25EF", "\\textcircled");
-            let Hi = {
+                nr = "punct",
+                A = "rel",
+                zt = "spacing",
+                q = "textord";
+            d(f, y, A, "\u2261", "\\equiv", !0), d(f, y, A, "\u227A", "\\prec", !0), d(f, y, A, "\u227B", "\\succ", !0), d(f, y, A, "\u223C", "\\sim", !0), d(f, y, A, "\u22A5", "\\perp"), d(f, y, A, "\u2AAF", "\\preceq", !0), d(f, y, A, "\u2AB0", "\\succeq", !0), d(f, y, A, "\u2243", "\\simeq", !0), d(f, y, A, "\u2223", "\\mid", !0), d(f, y, A, "\u226A", "\\ll", !0), d(f, y, A, "\u226B", "\\gg", !0), d(f, y, A, "\u224D", "\\asymp", !0), d(f, y, A, "\u2225", "\\parallel"), d(f, y, A, "\u22C8", "\\bowtie", !0), d(f, y, A, "\u2323", "\\smile", !0), d(f, y, A, "\u2291", "\\sqsubseteq", !0), d(f, y, A, "\u2292", "\\sqsupseteq", !0), d(f, y, A, "\u2250", "\\doteq", !0), d(f, y, A, "\u2322", "\\frown", !0), d(f, y, A, "\u220B", "\\ni", !0), d(f, y, A, "\u221D", "\\propto", !0), d(f, y, A, "\u22A2", "\\vdash", !0), d(f, y, A, "\u22A3", "\\dashv", !0), d(f, y, A, "\u220B", "\\owns"), d(f, y, nr, ".", "\\ldotp"), d(f, y, nr, "\u22C5", "\\cdotp"), d(f, y, q, "#", "\\#"), d(I, y, q, "#", "\\#"), d(f, y, q, "&", "\\&"), d(I, y, q, "&", "\\&"), d(f, y, q, "\u2135", "\\aleph", !0), d(f, y, q, "\u2200", "\\forall", !0), d(f, y, q, "\u210F", "\\hbar", !0), d(f, y, q, "\u2203", "\\exists", !0), d(f, y, q, "\u2207", "\\nabla", !0), d(f, y, q, "\u266D", "\\flat", !0), d(f, y, q, "\u2113", "\\ell", !0), d(f, y, q, "\u266E", "\\natural", !0), d(f, y, q, "\u2663", "\\clubsuit", !0), d(f, y, q, "\u2118", "\\wp", !0), d(f, y, q, "\u266F", "\\sharp", !0), d(f, y, q, "\u2662", "\\diamondsuit", !0), d(f, y, q, "\u211C", "\\Re", !0), d(f, y, q, "\u2661", "\\heartsuit", !0), d(f, y, q, "\u2111", "\\Im", !0), d(f, y, q, "\u2660", "\\spadesuit", !0), d(f, y, q, "\xA7", "\\S", !0), d(I, y, q, "\xA7", "\\S"), d(f, y, q, "\xB6", "\\P", !0), d(I, y, q, "\xB6", "\\P"), d(f, y, q, "\u2020", "\\dag"), d(I, y, q, "\u2020", "\\dag"), d(I, y, q, "\u2020", "\\textdagger"), d(f, y, q, "\u2021", "\\ddag"), d(I, y, q, "\u2021", "\\ddag"), d(I, y, q, "\u2021", "\\textdaggerdbl"), d(f, y, et, "\u23B1", "\\rmoustache", !0), d(f, y, at, "\u23B0", "\\lmoustache", !0), d(f, y, et, "\u27EF", "\\rgroup", !0), d(f, y, at, "\u27EE", "\\lgroup", !0), d(f, y, J, "\u2213", "\\mp", !0), d(f, y, J, "\u2296", "\\ominus", !0), d(f, y, J, "\u228E", "\\uplus", !0), d(f, y, J, "\u2293", "\\sqcap", !0), d(f, y, J, "\u2217", "\\ast"), d(f, y, J, "\u2294", "\\sqcup", !0), d(f, y, J, "\u25EF", "\\bigcirc", !0), d(f, y, J, "\u2219", "\\bullet", !0), d(f, y, J, "\u2021", "\\ddagger"), d(f, y, J, "\u2240", "\\wr", !0), d(f, y, J, "\u2A3F", "\\amalg"), d(f, y, J, "&", "\\And"), d(f, y, A, "\u27F5", "\\longleftarrow", !0), d(f, y, A, "\u21D0", "\\Leftarrow", !0), d(f, y, A, "\u27F8", "\\Longleftarrow", !0), d(f, y, A, "\u27F6", "\\longrightarrow", !0), d(f, y, A, "\u21D2", "\\Rightarrow", !0), d(f, y, A, "\u27F9", "\\Longrightarrow", !0), d(f, y, A, "\u2194", "\\leftrightarrow", !0), d(f, y, A, "\u27F7", "\\longleftrightarrow", !0), d(f, y, A, "\u21D4", "\\Leftrightarrow", !0), d(f, y, A, "\u27FA", "\\Longleftrightarrow", !0), d(f, y, A, "\u21A6", "\\mapsto", !0), d(f, y, A, "\u27FC", "\\longmapsto", !0), d(f, y, A, "\u2197", "\\nearrow", !0), d(f, y, A, "\u21A9", "\\hookleftarrow", !0), d(f, y, A, "\u21AA", "\\hookrightarrow", !0), d(f, y, A, "\u2198", "\\searrow", !0), d(f, y, A, "\u21BC", "\\leftharpoonup", !0), d(f, y, A, "\u21C0", "\\rightharpoonup", !0), d(f, y, A, "\u2199", "\\swarrow", !0), d(f, y, A, "\u21BD", "\\leftharpoondown", !0), d(f, y, A, "\u21C1", "\\rightharpoondown", !0), d(f, y, A, "\u2196", "\\nwarrow", !0), d(f, y, A, "\u21CC", "\\rightleftharpoons", !0), d(f, S, A, "\u226E", "\\nless", !0), d(f, S, A, "\uE010", "\\@nleqslant"), d(f, S, A, "\uE011", "\\@nleqq"), d(f, S, A, "\u2A87", "\\lneq", !0), d(f, S, A, "\u2268", "\\lneqq", !0), d(f, S, A, "\uE00C", "\\@lvertneqq"), d(f, S, A, "\u22E6", "\\lnsim", !0), d(f, S, A, "\u2A89", "\\lnapprox", !0), d(f, S, A, "\u2280", "\\nprec", !0), d(f, S, A, "\u22E0", "\\npreceq", !0), d(f, S, A, "\u22E8", "\\precnsim", !0), d(f, S, A, "\u2AB9", "\\precnapprox", !0), d(f, S, A, "\u2241", "\\nsim", !0), d(f, S, A, "\uE006", "\\@nshortmid"), d(f, S, A, "\u2224", "\\nmid", !0), d(f, S, A, "\u22AC", "\\nvdash", !0), d(f, S, A, "\u22AD", "\\nvDash", !0), d(f, S, A, "\u22EA", "\\ntriangleleft"), d(f, S, A, "\u22EC", "\\ntrianglelefteq", !0), d(f, S, A, "\u228A", "\\subsetneq", !0), d(f, S, A, "\uE01A", "\\@varsubsetneq"), d(f, S, A, "\u2ACB", "\\subsetneqq", !0), d(f, S, A, "\uE017", "\\@varsubsetneqq"), d(f, S, A, "\u226F", "\\ngtr", !0), d(f, S, A, "\uE00F", "\\@ngeqslant"), d(f, S, A, "\uE00E", "\\@ngeqq"), d(f, S, A, "\u2A88", "\\gneq", !0), d(f, S, A, "\u2269", "\\gneqq", !0), d(f, S, A, "\uE00D", "\\@gvertneqq"), d(f, S, A, "\u22E7", "\\gnsim", !0), d(f, S, A, "\u2A8A", "\\gnapprox", !0), d(f, S, A, "\u2281", "\\nsucc", !0), d(f, S, A, "\u22E1", "\\nsucceq", !0), d(f, S, A, "\u22E9", "\\succnsim", !0), d(f, S, A, "\u2ABA", "\\succnapprox", !0), d(f, S, A, "\u2246", "\\ncong", !0), d(f, S, A, "\uE007", "\\@nshortparallel"), d(f, S, A, "\u2226", "\\nparallel", !0), d(f, S, A, "\u22AF", "\\nVDash", !0), d(f, S, A, "\u22EB", "\\ntriangleright"), d(f, S, A, "\u22ED", "\\ntrianglerighteq", !0), d(f, S, A, "\uE018", "\\@nsupseteqq"), d(f, S, A, "\u228B", "\\supsetneq", !0), d(f, S, A, "\uE01B", "\\@varsupsetneq"), d(f, S, A, "\u2ACC", "\\supsetneqq", !0), d(f, S, A, "\uE019", "\\@varsupsetneqq"), d(f, S, A, "\u22AE", "\\nVdash", !0), d(f, S, A, "\u2AB5", "\\precneqq", !0), d(f, S, A, "\u2AB6", "\\succneqq", !0), d(f, S, A, "\uE016", "\\@nsubseteqq"), d(f, S, J, "\u22B4", "\\unlhd"), d(f, S, J, "\u22B5", "\\unrhd"), d(f, S, A, "\u219A", "\\nleftarrow", !0), d(f, S, A, "\u219B", "\\nrightarrow", !0), d(f, S, A, "\u21CD", "\\nLeftarrow", !0), d(f, S, A, "\u21CF", "\\nRightarrow", !0), d(f, S, A, "\u21AE", "\\nleftrightarrow", !0), d(f, S, A, "\u21CE", "\\nLeftrightarrow", !0), d(f, S, A, "\u25B3", "\\vartriangle"), d(f, S, q, "\u210F", "\\hslash"), d(f, S, q, "\u25BD", "\\triangledown"), d(f, S, q, "\u25CA", "\\lozenge"), d(f, S, q, "\u24C8", "\\circledS"), d(f, S, q, "\xAE", "\\circledR"), d(I, S, q, "\xAE", "\\circledR"), d(f, S, q, "\u2221", "\\measuredangle", !0), d(f, S, q, "\u2204", "\\nexists"), d(f, S, q, "\u2127", "\\mho"), d(f, S, q, "\u2132", "\\Finv", !0), d(f, S, q, "\u2141", "\\Game", !0), d(f, S, q, "\u2035", "\\backprime"), d(f, S, q, "\u25B2", "\\blacktriangle"), d(f, S, q, "\u25BC", "\\blacktriangledown"), d(f, S, q, "\u25A0", "\\blacksquare"), d(f, S, q, "\u29EB", "\\blacklozenge"), d(f, S, q, "\u2605", "\\bigstar"), d(f, S, q, "\u2222", "\\sphericalangle", !0), d(f, S, q, "\u2201", "\\complement", !0), d(f, S, q, "\xF0", "\\eth", !0), d(I, y, q, "\xF0", "\xF0"), d(f, S, q, "\u2571", "\\diagup"), d(f, S, q, "\u2572", "\\diagdown"), d(f, S, q, "\u25A1", "\\square"), d(f, S, q, "\u25A1", "\\Box"), d(f, S, q, "\u25CA", "\\Diamond"), d(f, S, q, "\xA5", "\\yen", !0), d(I, S, q, "\xA5", "\\yen", !0), d(f, S, q, "\u2713", "\\checkmark", !0), d(I, S, q, "\u2713", "\\checkmark"), d(f, S, q, "\u2136", "\\beth", !0), d(f, S, q, "\u2138", "\\daleth", !0), d(f, S, q, "\u2137", "\\gimel", !0), d(f, S, q, "\u03DD", "\\digamma", !0), d(f, S, q, "\u03F0", "\\varkappa"), d(f, S, at, "\u250C", "\\@ulcorner", !0), d(f, S, et, "\u2510", "\\@urcorner", !0), d(f, S, at, "\u2514", "\\@llcorner", !0), d(f, S, et, "\u2518", "\\@lrcorner", !0), d(f, S, A, "\u2266", "\\leqq", !0), d(f, S, A, "\u2A7D", "\\leqslant", !0), d(f, S, A, "\u2A95", "\\eqslantless", !0), d(f, S, A, "\u2272", "\\lesssim", !0), d(f, S, A, "\u2A85", "\\lessapprox", !0), d(f, S, A, "\u224A", "\\approxeq", !0), d(f, S, J, "\u22D6", "\\lessdot"), d(f, S, A, "\u22D8", "\\lll", !0), d(f, S, A, "\u2276", "\\lessgtr", !0), d(f, S, A, "\u22DA", "\\lesseqgtr", !0), d(f, S, A, "\u2A8B", "\\lesseqqgtr", !0), d(f, S, A, "\u2251", "\\doteqdot"), d(f, S, A, "\u2253", "\\risingdotseq", !0), d(f, S, A, "\u2252", "\\fallingdotseq", !0), d(f, S, A, "\u223D", "\\backsim", !0), d(f, S, A, "\u22CD", "\\backsimeq", !0), d(f, S, A, "\u2AC5", "\\subseteqq", !0), d(f, S, A, "\u22D0", "\\Subset", !0), d(f, S, A, "\u228F", "\\sqsubset", !0), d(f, S, A, "\u227C", "\\preccurlyeq", !0), d(f, S, A, "\u22DE", "\\curlyeqprec", !0), d(f, S, A, "\u227E", "\\precsim", !0), d(f, S, A, "\u2AB7", "\\precapprox", !0), d(f, S, A, "\u22B2", "\\vartriangleleft"), d(f, S, A, "\u22B4", "\\trianglelefteq"), d(f, S, A, "\u22A8", "\\vDash", !0), d(f, S, A, "\u22AA", "\\Vvdash", !0), d(f, S, A, "\u2323", "\\smallsmile"), d(f, S, A, "\u2322", "\\smallfrown"), d(f, S, A, "\u224F", "\\bumpeq", !0), d(f, S, A, "\u224E", "\\Bumpeq", !0), d(f, S, A, "\u2267", "\\geqq", !0), d(f, S, A, "\u2A7E", "\\geqslant", !0), d(f, S, A, "\u2A96", "\\eqslantgtr", !0), d(f, S, A, "\u2273", "\\gtrsim", !0), d(f, S, A, "\u2A86", "\\gtrapprox", !0), d(f, S, J, "\u22D7", "\\gtrdot"), d(f, S, A, "\u22D9", "\\ggg", !0), d(f, S, A, "\u2277", "\\gtrless", !0), d(f, S, A, "\u22DB", "\\gtreqless", !0), d(f, S, A, "\u2A8C", "\\gtreqqless", !0), d(f, S, A, "\u2256", "\\eqcirc", !0), d(f, S, A, "\u2257", "\\circeq", !0), d(f, S, A, "\u225C", "\\triangleq", !0), d(f, S, A, "\u223C", "\\thicksim"), d(f, S, A, "\u2248", "\\thickapprox"), d(f, S, A, "\u2AC6", "\\supseteqq", !0), d(f, S, A, "\u22D1", "\\Supset", !0), d(f, S, A, "\u2290", "\\sqsupset", !0), d(f, S, A, "\u227D", "\\succcurlyeq", !0), d(f, S, A, "\u22DF", "\\curlyeqsucc", !0), d(f, S, A, "\u227F", "\\succsim", !0), d(f, S, A, "\u2AB8", "\\succapprox", !0), d(f, S, A, "\u22B3", "\\vartriangleright"), d(f, S, A, "\u22B5", "\\trianglerighteq"), d(f, S, A, "\u22A9", "\\Vdash", !0), d(f, S, A, "\u2223", "\\shortmid"), d(f, S, A, "\u2225", "\\shortparallel"), d(f, S, A, "\u226C", "\\between", !0), d(f, S, A, "\u22D4", "\\pitchfork", !0), d(f, S, A, "\u221D", "\\varpropto"), d(f, S, A, "\u25C0", "\\blacktriangleleft"), d(f, S, A, "\u2234", "\\therefore", !0), d(f, S, A, "\u220D", "\\backepsilon"), d(f, S, A, "\u25B6", "\\blacktriangleright"), d(f, S, A, "\u2235", "\\because", !0), d(f, S, A, "\u22D8", "\\llless"), d(f, S, A, "\u22D9", "\\gggtr"), d(f, S, J, "\u22B2", "\\lhd"), d(f, S, J, "\u22B3", "\\rhd"), d(f, S, A, "\u2242", "\\eqsim", !0), d(f, y, A, "\u22C8", "\\Join"), d(f, S, A, "\u2251", "\\Doteq", !0), d(f, S, J, "\u2214", "\\dotplus", !0), d(f, S, J, "\u2216", "\\smallsetminus"), d(f, S, J, "\u22D2", "\\Cap", !0), d(f, S, J, "\u22D3", "\\Cup", !0), d(f, S, J, "\u2A5E", "\\doublebarwedge", !0), d(f, S, J, "\u229F", "\\boxminus", !0), d(f, S, J, "\u229E", "\\boxplus", !0), d(f, S, J, "\u22C7", "\\divideontimes", !0), d(f, S, J, "\u22C9", "\\ltimes", !0), d(f, S, J, "\u22CA", "\\rtimes", !0), d(f, S, J, "\u22CB", "\\leftthreetimes", !0), d(f, S, J, "\u22CC", "\\rightthreetimes", !0), d(f, S, J, "\u22CF", "\\curlywedge", !0), d(f, S, J, "\u22CE", "\\curlyvee", !0), d(f, S, J, "\u229D", "\\circleddash", !0), d(f, S, J, "\u229B", "\\circledast", !0), d(f, S, J, "\u22C5", "\\centerdot"), d(f, S, J, "\u22BA", "\\intercal", !0), d(f, S, J, "\u22D2", "\\doublecap"), d(f, S, J, "\u22D3", "\\doublecup"), d(f, S, J, "\u22A0", "\\boxtimes", !0), d(f, S, A, "\u21E2", "\\dashrightarrow", !0), d(f, S, A, "\u21E0", "\\dashleftarrow", !0), d(f, S, A, "\u21C7", "\\leftleftarrows", !0), d(f, S, A, "\u21C6", "\\leftrightarrows", !0), d(f, S, A, "\u21DA", "\\Lleftarrow", !0), d(f, S, A, "\u219E", "\\twoheadleftarrow", !0), d(f, S, A, "\u21A2", "\\leftarrowtail", !0), d(f, S, A, "\u21AB", "\\looparrowleft", !0), d(f, S, A, "\u21CB", "\\leftrightharpoons", !0), d(f, S, A, "\u21B6", "\\curvearrowleft", !0), d(f, S, A, "\u21BA", "\\circlearrowleft", !0), d(f, S, A, "\u21B0", "\\Lsh", !0), d(f, S, A, "\u21C8", "\\upuparrows", !0), d(f, S, A, "\u21BF", "\\upharpoonleft", !0), d(f, S, A, "\u21C3", "\\downharpoonleft", !0), d(f, y, A, "\u22B6", "\\origof", !0), d(f, y, A, "\u22B7", "\\imageof", !0), d(f, S, A, "\u22B8", "\\multimap", !0), d(f, S, A, "\u21AD", "\\leftrightsquigarrow", !0), d(f, S, A, "\u21C9", "\\rightrightarrows", !0), d(f, S, A, "\u21C4", "\\rightleftarrows", !0), d(f, S, A, "\u21A0", "\\twoheadrightarrow", !0), d(f, S, A, "\u21A3", "\\rightarrowtail", !0), d(f, S, A, "\u21AC", "\\looparrowright", !0), d(f, S, A, "\u21B7", "\\curvearrowright", !0), d(f, S, A, "\u21BB", "\\circlearrowright", !0), d(f, S, A, "\u21B1", "\\Rsh", !0), d(f, S, A, "\u21CA", "\\downdownarrows", !0), d(f, S, A, "\u21BE", "\\upharpoonright", !0), d(f, S, A, "\u21C2", "\\downharpoonright", !0), d(f, S, A, "\u21DD", "\\rightsquigarrow", !0), d(f, S, A, "\u21DD", "\\leadsto"), d(f, S, A, "\u21DB", "\\Rrightarrow", !0), d(f, S, A, "\u21BE", "\\restriction"), d(f, y, q, "\u2018", "`"), d(f, y, q, "$", "\\$"), d(I, y, q, "$", "\\$"), d(I, y, q, "$", "\\textdollar"), d(f, y, q, "%", "\\%"), d(I, y, q, "%", "\\%"), d(f, y, q, "_", "\\_"), d(I, y, q, "_", "\\_"), d(I, y, q, "_", "\\textunderscore"), d(f, y, q, "\u2220", "\\angle", !0), d(f, y, q, "\u221E", "\\infty", !0), d(f, y, q, "\u2032", "\\prime"), d(f, y, q, "\u25B3", "\\triangle"), d(f, y, q, "\u0393", "\\Gamma", !0), d(f, y, q, "\u0394", "\\Delta", !0), d(f, y, q, "\u0398", "\\Theta", !0), d(f, y, q, "\u039B", "\\Lambda", !0), d(f, y, q, "\u039E", "\\Xi", !0), d(f, y, q, "\u03A0", "\\Pi", !0), d(f, y, q, "\u03A3", "\\Sigma", !0), d(f, y, q, "\u03A5", "\\Upsilon", !0), d(f, y, q, "\u03A6", "\\Phi", !0), d(f, y, q, "\u03A8", "\\Psi", !0), d(f, y, q, "\u03A9", "\\Omega", !0), d(f, y, q, "A", "\u0391"), d(f, y, q, "B", "\u0392"), d(f, y, q, "E", "\u0395"), d(f, y, q, "Z", "\u0396"), d(f, y, q, "H", "\u0397"), d(f, y, q, "I", "\u0399"), d(f, y, q, "K", "\u039A"), d(f, y, q, "M", "\u039C"), d(f, y, q, "N", "\u039D"), d(f, y, q, "O", "\u039F"), d(f, y, q, "P", "\u03A1"), d(f, y, q, "T", "\u03A4"), d(f, y, q, "X", "\u03A7"), d(f, y, q, "\xAC", "\\neg", !0), d(f, y, q, "\xAC", "\\lnot"), d(f, y, q, "\u22A4", "\\top"), d(f, y, q, "\u22A5", "\\bot"), d(f, y, q, "\u2205", "\\emptyset"), d(f, S, q, "\u2205", "\\varnothing"), d(f, y, ue, "\u03B1", "\\alpha", !0), d(f, y, ue, "\u03B2", "\\beta", !0), d(f, y, ue, "\u03B3", "\\gamma", !0), d(f, y, ue, "\u03B4", "\\delta", !0), d(f, y, ue, "\u03F5", "\\epsilon", !0), d(f, y, ue, "\u03B6", "\\zeta", !0), d(f, y, ue, "\u03B7", "\\eta", !0), d(f, y, ue, "\u03B8", "\\theta", !0), d(f, y, ue, "\u03B9", "\\iota", !0), d(f, y, ue, "\u03BA", "\\kappa", !0), d(f, y, ue, "\u03BB", "\\lambda", !0), d(f, y, ue, "\u03BC", "\\mu", !0), d(f, y, ue, "\u03BD", "\\nu", !0), d(f, y, ue, "\u03BE", "\\xi", !0), d(f, y, ue, "\u03BF", "\\omicron", !0), d(f, y, ue, "\u03C0", "\\pi", !0), d(f, y, ue, "\u03C1", "\\rho", !0), d(f, y, ue, "\u03C3", "\\sigma", !0), d(f, y, ue, "\u03C4", "\\tau", !0), d(f, y, ue, "\u03C5", "\\upsilon", !0), d(f, y, ue, "\u03D5", "\\phi", !0), d(f, y, ue, "\u03C7", "\\chi", !0), d(f, y, ue, "\u03C8", "\\psi", !0), d(f, y, ue, "\u03C9", "\\omega", !0), d(f, y, ue, "\u03B5", "\\varepsilon", !0), d(f, y, ue, "\u03D1", "\\vartheta", !0), d(f, y, ue, "\u03D6", "\\varpi", !0), d(f, y, ue, "\u03F1", "\\varrho", !0), d(f, y, ue, "\u03C2", "\\varsigma", !0), d(f, y, ue, "\u03C6", "\\varphi", !0), d(f, y, J, "\u2217", "*", !0), d(f, y, J, "+", "+"), d(f, y, J, "\u2212", "-", !0), d(f, y, J, "\u22C5", "\\cdot", !0), d(f, y, J, "\u2218", "\\circ", !0), d(f, y, J, "\xF7", "\\div", !0), d(f, y, J, "\xB1", "\\pm", !0), d(f, y, J, "\xD7", "\\times", !0), d(f, y, J, "\u2229", "\\cap", !0), d(f, y, J, "\u222A", "\\cup", !0), d(f, y, J, "\u2216", "\\setminus", !0), d(f, y, J, "\u2227", "\\land"), d(f, y, J, "\u2228", "\\lor"), d(f, y, J, "\u2227", "\\wedge", !0), d(f, y, J, "\u2228", "\\vee", !0), d(f, y, q, "\u221A", "\\surd"), d(f, y, at, "\u27E8", "\\langle", !0), d(f, y, at, "\u2223", "\\lvert"), d(f, y, at, "\u2225", "\\lVert"), d(f, y, et, "?", "?"), d(f, y, et, "!", "!"), d(f, y, et, "\u27E9", "\\rangle", !0), d(f, y, et, "\u2223", "\\rvert"), d(f, y, et, "\u2225", "\\rVert"), d(f, y, A, "=", "="), d(f, y, A, ":", ":"), d(f, y, A, "\u2248", "\\approx", !0), d(f, y, A, "\u2245", "\\cong", !0), d(f, y, A, "\u2265", "\\ge"), d(f, y, A, "\u2265", "\\geq", !0), d(f, y, A, "\u2190", "\\gets"), d(f, y, A, ">", "\\gt", !0), d(f, y, A, "\u2208", "\\in", !0), d(f, y, A, "\uE020", "\\@not"), d(f, y, A, "\u2282", "\\subset", !0), d(f, y, A, "\u2283", "\\supset", !0), d(f, y, A, "\u2286", "\\subseteq", !0), d(f, y, A, "\u2287", "\\supseteq", !0), d(f, S, A, "\u2288", "\\nsubseteq", !0), d(f, S, A, "\u2289", "\\nsupseteq", !0), d(f, y, A, "\u22A8", "\\models"), d(f, y, A, "\u2190", "\\leftarrow", !0), d(f, y, A, "\u2264", "\\le"), d(f, y, A, "\u2264", "\\leq", !0), d(f, y, A, "<", "\\lt", !0), d(f, y, A, "\u2192", "\\rightarrow", !0), d(f, y, A, "\u2192", "\\to"), d(f, S, A, "\u2271", "\\ngeq", !0), d(f, S, A, "\u2270", "\\nleq", !0), d(f, y, zt, "\xA0", "\\ "), d(f, y, zt, "\xA0", "\\space"), d(f, y, zt, "\xA0", "\\nobreakspace"), d(I, y, zt, "\xA0", "\\ "), d(I, y, zt, "\xA0", " "), d(I, y, zt, "\xA0", "\\space"), d(I, y, zt, "\xA0", "\\nobreakspace"), d(f, y, zt, null, "\\nobreak"), d(f, y, zt, null, "\\allowbreak"), d(f, y, nr, ",", ","), d(f, y, nr, ";", ";"), d(f, S, J, "\u22BC", "\\barwedge", !0), d(f, S, J, "\u22BB", "\\veebar", !0), d(f, y, J, "\u2299", "\\odot", !0), d(f, y, J, "\u2295", "\\oplus", !0), d(f, y, J, "\u2297", "\\otimes", !0), d(f, y, q, "\u2202", "\\partial", !0), d(f, y, J, "\u2298", "\\oslash", !0), d(f, S, J, "\u229A", "\\circledcirc", !0), d(f, S, J, "\u22A1", "\\boxdot", !0), d(f, y, J, "\u25B3", "\\bigtriangleup"), d(f, y, J, "\u25BD", "\\bigtriangledown"), d(f, y, J, "\u2020", "\\dagger"), d(f, y, J, "\u22C4", "\\diamond"), d(f, y, J, "\u22C6", "\\star"), d(f, y, J, "\u25C3", "\\triangleleft"), d(f, y, J, "\u25B9", "\\triangleright"), d(f, y, at, "{", "\\{"), d(I, y, q, "{", "\\{"), d(I, y, q, "{", "\\textbraceleft"), d(f, y, et, "}", "\\}"), d(I, y, q, "}", "\\}"), d(I, y, q, "}", "\\textbraceright"), d(f, y, at, "{", "\\lbrace"), d(f, y, et, "}", "\\rbrace"), d(f, y, at, "[", "\\lbrack", !0), d(I, y, q, "[", "\\lbrack", !0), d(f, y, et, "]", "\\rbrack", !0), d(I, y, q, "]", "\\rbrack", !0), d(f, y, at, "(", "\\lparen", !0), d(f, y, et, ")", "\\rparen", !0), d(I, y, q, "<", "\\textless", !0), d(I, y, q, ">", "\\textgreater", !0), d(f, y, at, "\u230A", "\\lfloor", !0), d(f, y, et, "\u230B", "\\rfloor", !0), d(f, y, at, "\u2308", "\\lceil", !0), d(f, y, et, "\u2309", "\\rceil", !0), d(f, y, q, "\\", "\\backslash"), d(f, y, q, "\u2223", "|"), d(f, y, q, "\u2223", "\\vert"), d(I, y, q, "|", "\\textbar", !0), d(f, y, q, "\u2225", "\\|"), d(f, y, q, "\u2225", "\\Vert"), d(I, y, q, "\u2225", "\\textbardbl"), d(I, y, q, "~", "\\textasciitilde"), d(I, y, q, "\\", "\\textbackslash"), d(I, y, q, "^", "\\textasciicircum"), d(f, y, A, "\u2191", "\\uparrow", !0), d(f, y, A, "\u21D1", "\\Uparrow", !0), d(f, y, A, "\u2193", "\\downarrow", !0), d(f, y, A, "\u21D3", "\\Downarrow", !0), d(f, y, A, "\u2195", "\\updownarrow", !0), d(f, y, A, "\u21D5", "\\Updownarrow", !0), d(f, y, Ue, "\u2210", "\\coprod"), d(f, y, Ue, "\u22C1", "\\bigvee"), d(f, y, Ue, "\u22C0", "\\bigwedge"), d(f, y, Ue, "\u2A04", "\\biguplus"), d(f, y, Ue, "\u22C2", "\\bigcap"), d(f, y, Ue, "\u22C3", "\\bigcup"), d(f, y, Ue, "\u222B", "\\int"), d(f, y, Ue, "\u222B", "\\intop"), d(f, y, Ue, "\u222C", "\\iint"), d(f, y, Ue, "\u222D", "\\iiint"), d(f, y, Ue, "\u220F", "\\prod"), d(f, y, Ue, "\u2211", "\\sum"), d(f, y, Ue, "\u2A02", "\\bigotimes"), d(f, y, Ue, "\u2A01", "\\bigoplus"), d(f, y, Ue, "\u2A00", "\\bigodot"), d(f, y, Ue, "\u222E", "\\oint"), d(f, y, Ue, "\u222F", "\\oiint"), d(f, y, Ue, "\u2230", "\\oiiint"), d(f, y, Ue, "\u2A06", "\\bigsqcup"), d(f, y, Ue, "\u222B", "\\smallint"), d(I, y, g0, "\u2026", "\\textellipsis"), d(f, y, g0, "\u2026", "\\mathellipsis"), d(I, y, g0, "\u2026", "\\ldots", !0), d(f, y, g0, "\u2026", "\\ldots", !0), d(f, y, g0, "\u22EF", "\\@cdots", !0), d(f, y, g0, "\u22F1", "\\ddots", !0), d(f, y, q, "\u22EE", "\\varvdots"), d(f, y, Fe, "\u02CA", "\\acute"), d(f, y, Fe, "\u02CB", "\\grave"), d(f, y, Fe, "\xA8", "\\ddot"), d(f, y, Fe, "~", "\\tilde"), d(f, y, Fe, "\u02C9", "\\bar"), d(f, y, Fe, "\u02D8", "\\breve"), d(f, y, Fe, "\u02C7", "\\check"), d(f, y, Fe, "^", "\\hat"), d(f, y, Fe, "\u20D7", "\\vec"), d(f, y, Fe, "\u02D9", "\\dot"), d(f, y, Fe, "\u02DA", "\\mathring"), d(f, y, ue, "\uE131", "\\@imath"), d(f, y, ue, "\uE237", "\\@jmath"), d(f, y, q, "\u0131", "\u0131"), d(f, y, q, "\u0237", "\u0237"), d(I, y, q, "\u0131", "\\i", !0), d(I, y, q, "\u0237", "\\j", !0), d(I, y, q, "\xDF", "\\ss", !0), d(I, y, q, "\xE6", "\\ae", !0), d(I, y, q, "\u0153", "\\oe", !0), d(I, y, q, "\xF8", "\\o", !0), d(I, y, q, "\xC6", "\\AE", !0), d(I, y, q, "\u0152", "\\OE", !0), d(I, y, q, "\xD8", "\\O", !0), d(I, y, Fe, "\u02CA", "\\'"), d(I, y, Fe, "\u02CB", "\\`"), d(I, y, Fe, "\u02C6", "\\^"), d(I, y, Fe, "\u02DC", "\\~"), d(I, y, Fe, "\u02C9", "\\="), d(I, y, Fe, "\u02D8", "\\u"), d(I, y, Fe, "\u02D9", "\\."), d(I, y, Fe, "\xB8", "\\c"), d(I, y, Fe, "\u02DA", "\\r"), d(I, y, Fe, "\u02C7", "\\v"), d(I, y, Fe, "\xA8", '\\"'), d(I, y, Fe, "\u02DD", "\\H"), d(I, y, Fe, "\u25EF", "\\textcircled");
+            let Ni = {
                 "--": !0,
                 "---": !0,
                 "``": !0,
                 "''": !0
             };
-            h($, x, D, "\u2013", "--", !0), h($, x, D, "\u2013", "\\textendash"), h($, x, D, "\u2014", "---", !0), h($, x, D, "\u2014", "\\textemdash"), h($, x, D, "\u2018", "`", !0), h($, x, D, "\u2018", "\\textquoteleft"), h($, x, D, "\u2019", "'", !0), h($, x, D, "\u2019", "\\textquoteright"), h($, x, D, "\u201C", "``", !0), h($, x, D, "\u201C", "\\textquotedblleft"), h($, x, D, "\u201D", "''", !0), h($, x, D, "\u201D", "\\textquotedblright"), h(m, x, D, "\xB0", "\\degree", !0), h($, x, D, "\xB0", "\\degree"), h($, x, D, "\xB0", "\\textdegree", !0), h(m, x, D, "\xA3", "\\pounds"), h(m, x, D, "\xA3", "\\mathsterling", !0), h($, x, D, "\xA3", "\\pounds"), h($, x, D, "\xA3", "\\textsterling", !0), h(m, C, D, "\u2720", "\\maltese"), h($, C, D, "\u2720", "\\maltese");
-            let $i = '0123456789/@."';
-            for (let n = 0; n < $i.length; n++) {
-                let t = $i.charAt(n);
-                h(m, x, D, t, t)
-            }
-            let Gi = '0123456789!@*()-=+";:?/.,';
-            for (let n = 0; n < Gi.length; n++) {
-                let t = Gi.charAt(n);
-                h($, x, D, t, t)
-            }
-            let jr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
-            for (let n = 0; n < jr.length; n++) {
-                let t = jr.charAt(n);
-                h(m, x, se, t, t), h($, x, D, t, t)
-            }
-            h(m, C, D, "C", "\u2102"), h($, C, D, "C", "\u2102"), h(m, C, D, "H", "\u210D"), h($, C, D, "H", "\u210D"), h(m, C, D, "N", "\u2115"), h($, C, D, "N", "\u2115"), h(m, C, D, "P", "\u2119"), h($, C, D, "P", "\u2119"), h(m, C, D, "Q", "\u211A"), h($, C, D, "Q", "\u211A"), h(m, C, D, "R", "\u211D"), h($, C, D, "R", "\u211D"), h(m, C, D, "Z", "\u2124"), h($, C, D, "Z", "\u2124"), h(m, x, se, "h", "\u210E"), h($, x, se, "h", "\u210E");
-            let le = "";
-            for (let n = 0; n < jr.length; n++) {
-                let t = jr.charAt(n);
-                le = String.fromCharCode(55349, 56320 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 56372 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 56424 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 56580 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 56684 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 56736 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 56788 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 56840 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 56944 + n), h(m, x, se, t, le), h($, x, D, t, le), n < 26 && (le = String.fromCharCode(55349, 56632 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 56476 + n), h(m, x, se, t, le), h($, x, D, t, le))
+            d(I, y, q, "\u2013", "--", !0), d(I, y, q, "\u2013", "\\textendash"), d(I, y, q, "\u2014", "---", !0), d(I, y, q, "\u2014", "\\textemdash"), d(I, y, q, "\u2018", "`", !0), d(I, y, q, "\u2018", "\\textquoteleft"), d(I, y, q, "\u2019", "'", !0), d(I, y, q, "\u2019", "\\textquoteright"), d(I, y, q, "\u201C", "``", !0), d(I, y, q, "\u201C", "\\textquotedblleft"), d(I, y, q, "\u201D", "''", !0), d(I, y, q, "\u201D", "\\textquotedblright"), d(f, y, q, "\xB0", "\\degree", !0), d(I, y, q, "\xB0", "\\degree"), d(I, y, q, "\xB0", "\\textdegree", !0), d(f, y, q, "\xA3", "\\pounds"), d(f, y, q, "\xA3", "\\mathsterling", !0), d(I, y, q, "\xA3", "\\pounds"), d(I, y, q, "\xA3", "\\textsterling", !0), d(f, S, q, "\u2720", "\\maltese"), d(I, S, q, "\u2720", "\\maltese");
+            let Li = '0123456789/@."';
+            for (let n = 0; n < Li.length; n++) {
+                let t = Li.charAt(n);
+                d(f, y, q, t, t)
+            }
+            let Pi = '0123456789!@*()-=+";:?/.,';
+            for (let n = 0; n < Pi.length; n++) {
+                let t = Pi.charAt(n);
+                d(I, y, q, t, t)
+            }
+            let ur = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
+            for (let n = 0; n < ur.length; n++) {
+                let t = ur.charAt(n);
+                d(f, y, ue, t, t), d(I, y, q, t, t)
+            }
+            d(f, S, q, "C", "\u2102"), d(I, S, q, "C", "\u2102"), d(f, S, q, "H", "\u210D"), d(I, S, q, "H", "\u210D"), d(f, S, q, "N", "\u2115"), d(I, S, q, "N", "\u2115"), d(f, S, q, "P", "\u2119"), d(I, S, q, "P", "\u2119"), d(f, S, q, "Q", "\u211A"), d(I, S, q, "Q", "\u211A"), d(f, S, q, "R", "\u211D"), d(I, S, q, "R", "\u211D"), d(f, S, q, "Z", "\u2124"), d(I, S, q, "Z", "\u2124"), d(f, y, ue, "h", "\u210E"), d(I, y, ue, "h", "\u210E");
+            let oe = "";
+            for (let n = 0; n < ur.length; n++) {
+                let t = ur.charAt(n);
+                oe = String.fromCharCode(55349, 56320 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 56372 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 56424 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 56580 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 56684 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 56736 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 56788 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 56840 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 56944 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), n < 26 && (oe = String.fromCharCode(55349, 56632 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 56476 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe))
             }
-            le = "\u{1D55C}", h(m, x, se, "k", le), h($, x, D, "k", le);
+            oe = "\u{1D55C}", d(f, y, ue, "k", oe), d(I, y, q, "k", oe);
             for (let n = 0; n < 10; n++) {
                 let t = n.toString();
-                le = String.fromCharCode(55349, 57294 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 57314 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 57324 + n), h(m, x, se, t, le), h($, x, D, t, le), le = String.fromCharCode(55349, 57334 + n), h(m, x, se, t, le), h($, x, D, t, le)
+                oe = String.fromCharCode(55349, 57294 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 57314 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 57324 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe), oe = String.fromCharCode(55349, 57334 + n), d(f, y, ue, t, oe), d(I, y, q, t, oe)
             }
-            let Q0 = "\xD0\xDE\xFE";
-            for (let n = 0; n < Q0.length; n++) {
-                let t = Q0.charAt(n);
-                h(m, x, se, t, t), h($, x, D, t, t)
+            let pn = "\xD0\xDE\xFE";
+            for (let n = 0; n < pn.length; n++) {
+                let t = pn.charAt(n);
+                d(f, y, ue, t, t), d(I, y, q, t, t)
             }
-            let Ur = [
+            let ir = [
                     ["mathbf", "textbf", "Main-Bold"],
                     ["mathbf", "textbf", "Main-Bold"],
                     ["mathnormal", "textit", "Math-Italic"],
                     ["mathnormal", "textit", "Math-Italic"],
                     ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
                     ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
                     ["mathscr", "textscr", "Script-Regular"],
@@ -9070,270 +4660,270 @@
                     ["mathitsf", "textitsf", "SansSerif-Italic"],
                     ["mathitsf", "textitsf", "SansSerif-Italic"],
                     ["", "", ""],
                     ["", "", ""],
                     ["mathtt", "texttt", "Typewriter-Regular"],
                     ["mathtt", "texttt", "Typewriter-Regular"]
                 ],
-                Vi = [
+                Ii = [
                     ["mathbf", "textbf", "Main-Bold"],
                     ["", "", ""],
                     ["mathsf", "textsf", "SansSerif-Regular"],
                     ["mathboldsf", "textboldsf", "SansSerif-Bold"],
                     ["mathtt", "texttt", "Typewriter-Regular"]
                 ],
-                Zu = function(n, t) {
-                    let o = n.charCodeAt(0),
-                        s = n.charCodeAt(1),
-                        u = (o - 55296) * 1024 + (s - 56320) + 65536,
-                        p = t === "math" ? 0 : 1;
-                    if (119808 <= u && u < 120484) {
-                        let b = Math.floor((u - 119808) / 26);
-                        return [Ur[b][2], Ur[b][p]]
-                    } else if (120782 <= u && u <= 120831) {
-                        let b = Math.floor((u - 120782) / 10);
-                        return [Vi[b][2], Vi[b][p]]
+                Hl = function(n, t) {
+                    let u = n.charCodeAt(0),
+                        a = n.charCodeAt(1),
+                        c = (u - 55296) * 1024 + (a - 56320) + 65536,
+                        m = t === "math" ? 0 : 1;
+                    if (119808 <= c && c < 120484) {
+                        let g = Math.floor((c - 119808) / 26);
+                        return [ir[g][2], ir[g][m]]
+                    } else if (120782 <= c && c <= 120831) {
+                        let g = Math.floor((c - 120782) / 10);
+                        return [Ii[g][2], Ii[g][m]]
                     } else {
-                        if (u === 120485 || u === 120486) return [Ur[0][2], Ur[0][p]];
-                        if (120486 < u && u < 120782) return ["", ""];
-                        throw new a("Unsupported character: " + n)
+                        if (c === 120485 || c === 120486) return [ir[0][2], ir[0][m]];
+                        if (120486 < c && c < 120782) return ["", ""];
+                        throw new o("Unsupported character: " + n)
                     }
                 },
-                Wr = function(n, t, o) {
-                    return Oe[o][n] && Oe[o][n].replace && (n = Oe[o][n].replace), {
+                or = function(n, t, u) {
+                    return Pe[u][n] && Pe[u][n].replace && (n = Pe[u][n].replace), {
                         value: n,
-                        metrics: j0(n, t, o)
+                        metrics: cn(n, t, u)
                     }
                 },
-                yt = function(n, t, o, s, u) {
-                    let p = Wr(n, t, o),
-                        b = p.metrics;
-                    n = p.value;
+                yt = function(n, t, u, a, c) {
+                    let m = or(n, t, u),
+                        g = m.metrics;
+                    n = m.value;
                     let v;
-                    if (b) {
-                        let S = b.italic;
-                        (o === "text" || s && s.font === "mathit") && (S = 0), v = new ut(n, b.height, b.depth, S, b.skew, b.width, u)
-                    } else typeof console < "u" && console.warn("No character metrics " + ("for '" + n + "' in style '" + t + "' and mode '" + o + "'")), v = new ut(n, 0, 0, 0, 0, 0, u);
-                    if (s) {
-                        v.maxFontSize = s.sizeMultiplier, s.style.isTight() && v.classes.push("mtight");
-                        let S = s.getColor();
-                        S && (v.style.color = S)
+                    if (g) {
+                        let _ = g.italic;
+                        (u === "text" || a && a.font === "mathit") && (_ = 0), v = new dt(n, g.height, g.depth, _, g.skew, g.width, c)
+                    } else typeof console < "u" && console.warn("No character metrics " + ("for '" + n + "' in style '" + t + "' and mode '" + u + "'")), v = new dt(n, 0, 0, 0, 0, 0, c);
+                    if (a) {
+                        v.maxFontSize = a.sizeMultiplier, a.style.isTight() && v.classes.push("mtight");
+                        let _ = a.getColor();
+                        _ && (v.style.color = _)
                     }
                     return v
                 },
-                Qu = function(n, t, o, s) {
-                    return s === void 0 && (s = []), o.font === "boldsymbol" && Wr(n, "Main-Bold", t).metrics ? yt(n, "Main-Bold", t, o, s.concat(["mathbf"])) : n === "\\" || Oe[t][n].font === "main" ? yt(n, "Main-Regular", t, o, s) : yt(n, "AMS-Regular", t, o, s.concat(["amsrm"]))
+                $l = function(n, t, u, a) {
+                    return a === void 0 && (a = []), u.font === "boldsymbol" && or(n, "Main-Bold", t).metrics ? yt(n, "Main-Bold", t, u, a.concat(["mathbf"])) : n === "\\" || Pe[t][n].font === "main" ? yt(n, "Main-Regular", t, u, a) : yt(n, "AMS-Regular", t, u, a.concat(["amsrm"]))
                 },
-                Xu = function(n, t, o, s, u) {
-                    return u !== "textord" && Wr(n, "Math-BoldItalic", t).metrics ? {
+                Gl = function(n, t, u, a, c) {
+                    return c !== "textord" && or(n, "Math-BoldItalic", t).metrics ? {
                         fontName: "Math-BoldItalic",
                         fontClass: "boldsymbol"
                     } : {
                         fontName: "Main-Bold",
                         fontClass: "mathbf"
                     }
                 },
-                Ju = function(n, t, o) {
-                    let s = n.mode,
-                        u = n.text,
-                        p = ["mord"],
-                        b = s === "math" || s === "text" && t.font,
-                        v = b ? t.font : t.fontFamily,
-                        S = "",
-                        E = "";
-                    if (u.charCodeAt(0) === 55349 && ([S, E] = Zu(u, s)), S.length > 0) return yt(u, S, s, t, p.concat(E));
+                Vl = function(n, t, u) {
+                    let a = n.mode,
+                        c = n.text,
+                        m = ["mord"],
+                        g = a === "math" || a === "text" && t.font,
+                        v = g ? t.font : t.fontFamily,
+                        _ = "",
+                        D = "";
+                    if (c.charCodeAt(0) === 55349 && ([_, D] = Hl(c, a)), _.length > 0) return yt(c, _, a, t, m.concat(D));
                     if (v) {
-                        let z, F;
+                        let z, R;
                         if (v === "boldsymbol") {
-                            let N = Xu(u, s, t, p, o);
-                            z = N.fontName, F = [N.fontClass]
-                        } else b ? (z = Wi[v].fontName, F = [v]) : (z = Yr(v, t.fontWeight, t.fontShape), F = [v, t.fontWeight, t.fontShape]);
-                        if (Wr(u, z, s).metrics) return yt(u, z, s, t, p.concat(F));
-                        if (Hi.hasOwnProperty(u) && z.slice(0, 10) === "Typewriter") {
-                            let N = [];
-                            for (let H = 0; H < u.length; H++) N.push(yt(u[H], z, s, t, p.concat(F)));
-                            return Ui(N)
+                            let L = Gl(c, a, t, m, u);
+                            z = L.fontName, R = [L.fontClass]
+                        } else g ? (z = $i[v].fontName, R = [v]) : (z = ar(v, t.fontWeight, t.fontShape), R = [v, t.fontWeight, t.fontShape]);
+                        if (or(c, z, a).metrics) return yt(c, z, a, t, m.concat(R));
+                        if (Ni.hasOwnProperty(c) && z.slice(0, 10) === "Typewriter") {
+                            let L = [];
+                            for (let P = 0; P < c.length; P++) L.push(yt(c[P], z, a, t, m.concat(R)));
+                            return Hi(L)
                         }
                     }
-                    if (o === "mathord") return yt(u, "Math-Italic", s, t, p.concat(["mathnormal"]));
-                    if (o === "textord") {
-                        let z = Oe[s][u] && Oe[s][u].font;
+                    if (u === "mathord") return yt(c, "Math-Italic", a, t, m.concat(["mathnormal"]));
+                    if (u === "textord") {
+                        let z = Pe[a][c] && Pe[a][c].font;
                         if (z === "ams") {
-                            let F = Yr("amsrm", t.fontWeight, t.fontShape);
-                            return yt(u, F, s, t, p.concat("amsrm", t.fontWeight, t.fontShape))
+                            let R = ar("amsrm", t.fontWeight, t.fontShape);
+                            return yt(c, R, a, t, m.concat("amsrm", t.fontWeight, t.fontShape))
                         } else if (z === "main" || !z) {
-                            let F = Yr("textrm", t.fontWeight, t.fontShape);
-                            return yt(u, F, s, t, p.concat(t.fontWeight, t.fontShape))
+                            let R = ar("textrm", t.fontWeight, t.fontShape);
+                            return yt(c, R, a, t, m.concat(t.fontWeight, t.fontShape))
                         } else {
-                            let F = Yr(z, t.fontWeight, t.fontShape);
-                            return yt(u, F, s, t, p.concat(F, t.fontWeight, t.fontShape))
+                            let R = ar(z, t.fontWeight, t.fontShape);
+                            return yt(c, R, a, t, m.concat(R, t.fontWeight, t.fontShape))
                         }
-                    } else throw new Error("unexpected type: " + o + " in makeOrd")
+                    } else throw new Error("unexpected type: " + u + " in makeOrd")
                 },
-                Ku = (n, t) => {
-                    if (It(n.classes) !== It(t.classes) || n.skew !== t.skew || n.maxFontSize !== t.maxFontSize) return !1;
+                Ul = (n, t) => {
+                    if (Vt(n.classes) !== Vt(t.classes) || n.skew !== t.skew || n.maxFontSize !== t.maxFontSize) return !1;
                     if (n.classes.length === 1) {
-                        let o = n.classes[0];
-                        if (o === "mbin" || o === "mord") return !1
+                        let u = n.classes[0];
+                        if (u === "mbin" || u === "mord") return !1
                     }
-                    for (let o in n.style)
-                        if (n.style.hasOwnProperty(o) && n.style[o] !== t.style[o]) return !1;
-                    for (let o in t.style)
-                        if (t.style.hasOwnProperty(o) && n.style[o] !== t.style[o]) return !1;
+                    for (let u in n.style)
+                        if (n.style.hasOwnProperty(u) && n.style[u] !== t.style[u]) return !1;
+                    for (let u in t.style)
+                        if (t.style.hasOwnProperty(u) && n.style[u] !== t.style[u]) return !1;
                     return !0
                 },
-                e1 = n => {
+                jl = n => {
                     for (let t = 0; t < n.length - 1; t++) {
-                        let o = n[t],
-                            s = n[t + 1];
-                        o instanceof ut && s instanceof ut && Ku(o, s) && (o.text += s.text, o.height = Math.max(o.height, s.height), o.depth = Math.max(o.depth, s.depth), o.italic = s.italic, n.splice(t + 1, 1), t--)
+                        let u = n[t],
+                            a = n[t + 1];
+                        u instanceof dt && a instanceof dt && Ul(u, a) && (u.text += a.text, u.height = Math.max(u.height, a.height), u.depth = Math.max(u.depth, a.depth), u.italic = a.italic, n.splice(t + 1, 1), t--)
                     }
                     return n
                 },
-                X0 = function(n) {
+                bn = function(n) {
                     let t = 0,
-                        o = 0,
-                        s = 0;
-                    for (let u = 0; u < n.children.length; u++) {
-                        let p = n.children[u];
-                        p.height > t && (t = p.height), p.depth > o && (o = p.depth), p.maxFontSize > s && (s = p.maxFontSize)
-                    }
-                    n.height = t, n.depth = o, n.maxFontSize = s
-                },
-                nt = function(n, t, o, s) {
-                    let u = new vr(n, t, o, s);
-                    return X0(u), u
-                },
-                ji = (n, t, o, s) => new vr(n, t, o, s),
-                t1 = function(n, t, o) {
-                    let s = nt([n], [], t);
-                    return s.height = Math.max(o || t.fontMetrics().defaultRuleThickness, t.minRuleThickness), s.style.borderBottomWidth = Z(s.height), s.maxFontSize = 1, s
-                },
-                r1 = function(n, t, o, s) {
-                    let u = new Y0(n, t, o, s);
-                    return X0(u), u
-                },
-                Ui = function(n) {
-                    let t = new xr(n);
-                    return X0(t), t
+                        u = 0,
+                        a = 0;
+                    for (let c = 0; c < n.children.length; c++) {
+                        let m = n.children[c];
+                        m.height > t && (t = m.height), m.depth > u && (u = m.depth), m.maxFontSize > a && (a = m.maxFontSize)
+                    }
+                    n.height = t, n.depth = u, n.maxFontSize = a
+                },
+                ut = function(n, t, u, a) {
+                    let c = new F0(n, t, u, a);
+                    return bn(c), c
+                },
+                Oi = (n, t, u, a) => new F0(n, t, u, a),
+                Wl = function(n, t, u) {
+                    let a = ut([n], [], t);
+                    return a.height = Math.max(u || t.fontMetrics().defaultRuleThickness, t.minRuleThickness), a.style.borderBottomWidth = j(a.height), a.maxFontSize = 1, a
+                },
+                Yl = function(n, t, u, a) {
+                    let c = new fn(n, t, u, a);
+                    return bn(c), c
+                },
+                Hi = function(n) {
+                    let t = new q0(n);
+                    return bn(t), t
                 },
-                n1 = function(n, t) {
-                    return n instanceof xr ? nt([], [n], t) : n
+                Zl = function(n, t) {
+                    return n instanceof q0 ? ut([], [n], t) : n
                 },
-                i1 = function(n) {
+                Xl = function(n) {
                     if (n.positionType === "individualShift") {
-                        let o = n.children,
-                            s = [o[0]],
-                            u = -o[0].shift - o[0].elem.depth,
-                            p = u;
-                        for (let b = 1; b < o.length; b++) {
-                            let v = -o[b].shift - p - o[b].elem.depth,
-                                S = v - (o[b - 1].elem.height + o[b - 1].elem.depth);
-                            p = p + v, s.push({
+                        let u = n.children,
+                            a = [u[0]],
+                            c = -u[0].shift - u[0].elem.depth,
+                            m = c;
+                        for (let g = 1; g < u.length; g++) {
+                            let v = -u[g].shift - m - u[g].elem.depth,
+                                _ = v - (u[g - 1].elem.height + u[g - 1].elem.depth);
+                            m = m + v, a.push({
                                 type: "kern",
-                                size: S
-                            }), s.push(o[b])
+                                size: _
+                            }), a.push(u[g])
                         }
                         return {
-                            children: s,
-                            depth: u
+                            children: a,
+                            depth: c
                         }
                     }
                     let t;
                     if (n.positionType === "top") {
-                        let o = n.positionData;
-                        for (let s = 0; s < n.children.length; s++) {
-                            let u = n.children[s];
-                            o -= u.type === "kern" ? u.size : u.elem.height + u.elem.depth
+                        let u = n.positionData;
+                        for (let a = 0; a < n.children.length; a++) {
+                            let c = n.children[a];
+                            u -= c.type === "kern" ? c.size : c.elem.height + c.elem.depth
                         }
-                        t = o
+                        t = u
                     } else if (n.positionType === "bottom") t = -n.positionData;
                     else {
-                        let o = n.children[0];
-                        if (o.type !== "elem") throw new Error('First child must have type "elem".');
-                        if (n.positionType === "shift") t = -o.elem.depth - n.positionData;
-                        else if (n.positionType === "firstBaseline") t = -o.elem.depth;
+                        let u = n.children[0];
+                        if (u.type !== "elem") throw new Error('First child must have type "elem".');
+                        if (n.positionType === "shift") t = -u.elem.depth - n.positionData;
+                        else if (n.positionType === "firstBaseline") t = -u.elem.depth;
                         else throw new Error("Invalid positionType " + n.positionType + ".")
                     }
                     return {
                         children: n.children,
                         depth: t
                     }
                 },
-                o1 = function(n, t) {
+                Ql = function(n, t) {
                     let {
-                        children: o,
-                        depth: s
-                    } = i1(n), u = 0;
-                    for (let H = 0; H < o.length; H++) {
-                        let K = o[H];
+                        children: u,
+                        depth: a
+                    } = Xl(n), c = 0;
+                    for (let P = 0; P < u.length; P++) {
+                        let K = u[P];
                         if (K.type === "elem") {
-                            let ie = K.elem;
-                            u = Math.max(u, ie.maxFontSize, ie.height)
+                            let re = K.elem;
+                            c = Math.max(c, re.maxFontSize, re.height)
                         }
                     }
-                    u += 2;
-                    let p = nt(["pstrut"], []);
-                    p.style.height = Z(u);
-                    let b = [],
-                        v = s,
-                        S = s,
-                        E = s;
-                    for (let H = 0; H < o.length; H++) {
-                        let K = o[H];
-                        if (K.type === "kern") E += K.size;
+                    c += 2;
+                    let m = ut(["pstrut"], []);
+                    m.style.height = j(c);
+                    let g = [],
+                        v = a,
+                        _ = a,
+                        D = a;
+                    for (let P = 0; P < u.length; P++) {
+                        let K = u[P];
+                        if (K.type === "kern") D += K.size;
                         else {
-                            let ie = K.elem,
-                                ye = K.wrapperClasses || [],
-                                ge = K.wrapperStyle || {},
-                                xe = nt(ye, [p, ie], void 0, ge);
-                            xe.style.top = Z(-u - E - ie.depth), K.marginLeft && (xe.style.marginLeft = K.marginLeft), K.marginRight && (xe.style.marginRight = K.marginRight), b.push(xe), E += ie.height + ie.depth
+                            let re = K.elem,
+                                pe = K.wrapperClasses || [],
+                                de = K.wrapperStyle || {},
+                                be = ut(pe, [m, re], void 0, de);
+                            be.style.top = j(-c - D - re.depth), K.marginLeft && (be.style.marginLeft = K.marginLeft), K.marginRight && (be.style.marginRight = K.marginRight), g.push(be), D += re.height + re.depth
                         }
-                        v = Math.min(v, E), S = Math.max(S, E)
+                        v = Math.min(v, D), _ = Math.max(_, D)
                     }
-                    let z = nt(["vlist"], b);
-                    z.style.height = Z(S);
-                    let F;
+                    let z = ut(["vlist"], g);
+                    z.style.height = j(_);
+                    let R;
                     if (v < 0) {
-                        let H = nt([], []),
-                            K = nt(["vlist"], [H]);
-                        K.style.height = Z(-v);
-                        let ie = nt(["vlist-s"], [new ut("\u200B")]);
-                        F = [nt(["vlist-r"], [z, ie]), nt(["vlist-r"], [K])]
-                    } else F = [nt(["vlist-r"], [z])];
-                    let N = nt(["vlist-t"], F);
-                    return F.length === 2 && N.classes.push("vlist-t2"), N.height = S, N.depth = -v, N
-                },
-                a1 = (n, t) => {
-                    let o = nt(["mspace"], [], t),
-                        s = Ie(n, t);
-                    return o.style.marginRight = Z(s), o
+                        let P = ut([], []),
+                            K = ut(["vlist"], [P]);
+                        K.style.height = j(-v);
+                        let re = ut(["vlist-s"], [new dt("\u200B")]);
+                        R = [ut(["vlist-r"], [z, re]), ut(["vlist-r"], [K])]
+                    } else R = [ut(["vlist-r"], [z])];
+                    let L = ut(["vlist-t"], R);
+                    return R.length === 2 && L.classes.push("vlist-t2"), L.height = _, L.depth = -v, L
+                },
+                Jl = (n, t) => {
+                    let u = ut(["mspace"], [], t),
+                        a = Le(n, t);
+                    return u.style.marginRight = j(a), u
                 },
-                Yr = function(n, t, o) {
-                    let s = "";
+                ar = function(n, t, u) {
+                    let a = "";
                     switch (n) {
                         case "amsrm":
-                            s = "AMS";
+                            a = "AMS";
                             break;
                         case "textrm":
-                            s = "Main";
+                            a = "Main";
                             break;
                         case "textsf":
-                            s = "SansSerif";
+                            a = "SansSerif";
                             break;
                         case "texttt":
-                            s = "Typewriter";
+                            a = "Typewriter";
                             break;
                         default:
-                            s = n
+                            a = n
                     }
-                    let u;
-                    return t === "textbf" && o === "textit" ? u = "BoldItalic" : t === "textbf" ? u = "Bold" : t === "textit" ? u = "Italic" : u = "Regular", s + "-" + u
+                    let c;
+                    return t === "textbf" && u === "textit" ? c = "BoldItalic" : t === "textbf" ? c = "Bold" : t === "textit" ? c = "Italic" : c = "Regular", a + "-" + c
                 },
-                Wi = {
+                $i = {
                     mathbf: {
                         variant: "bold",
                         fontName: "Main-Bold"
                     },
                     mathrm: {
                         variant: "normal",
                         fontName: "Main-Regular"
@@ -9371,510 +4961,510 @@
                         fontName: "SansSerif-Regular"
                     },
                     mathtt: {
                         variant: "monospace",
                         fontName: "Typewriter-Regular"
                     }
                 },
-                Yi = {
+                Gi = {
                     vec: ["vec", .471, .714],
                     oiintSize1: ["oiintSize1", .957, .499],
                     oiintSize2: ["oiintSize2", 1.472, .659],
                     oiiintSize1: ["oiiintSize1", 1.304, .499],
                     oiiintSize2: ["oiiintSize2", 1.98, .659]
                 };
             var B = {
-                fontMap: Wi,
+                fontMap: $i,
                 makeSymbol: yt,
-                mathsym: Qu,
-                makeSpan: nt,
-                makeSvgSpan: ji,
-                makeLineSpan: t1,
-                makeAnchor: r1,
-                makeFragment: Ui,
-                wrapFragment: n1,
-                makeVList: o1,
-                makeOrd: Ju,
-                makeGlue: a1,
+                mathsym: $l,
+                makeSpan: ut,
+                makeSvgSpan: Oi,
+                makeLineSpan: Wl,
+                makeAnchor: Yl,
+                makeFragment: Hi,
+                wrapFragment: Zl,
+                makeVList: Ql,
+                makeOrd: Vl,
+                makeGlue: Jl,
                 staticSvg: function(n, t) {
-                    let [o, s, u] = Yi[n], p = new Ot(o), b = new Et([p], {
-                        width: Z(s),
-                        height: Z(u),
-                        style: "width:" + Z(s),
-                        viewBox: "0 0 " + 1e3 * s + " " + 1e3 * u,
+                    let [u, a, c] = Gi[n], m = new Ut(u), g = new Ft([m], {
+                        width: j(a),
+                        height: j(c),
+                        style: "width:" + j(a),
+                        viewBox: "0 0 " + 1e3 * a + " " + 1e3 * c,
                         preserveAspectRatio: "xMinYMin"
-                    }), v = ji(["overlay"], [b], t);
-                    return v.height = u, v.style.height = Z(u), v.style.width = Z(s), v
+                    }), v = Oi(["overlay"], [g], t);
+                    return v.height = c, v.style.height = j(c), v.style.width = j(a), v
                 },
-                svgData: Yi,
-                tryCombineChars: e1
+                svgData: Gi,
+                tryCombineChars: jl
             };
-            let He = {
+            let Ie = {
                     number: 3,
                     unit: "mu"
                 },
-                Jt = {
+                i0 = {
                     number: 4,
                     unit: "mu"
                 },
-                zt = {
+                Rt = {
                     number: 5,
                     unit: "mu"
                 },
-                s1 = {
+                Kl = {
                     mord: {
-                        mop: He,
-                        mbin: Jt,
-                        mrel: zt,
-                        minner: He
+                        mop: Ie,
+                        mbin: i0,
+                        mrel: Rt,
+                        minner: Ie
                     },
                     mop: {
-                        mord: He,
-                        mop: He,
-                        mrel: zt,
-                        minner: He
+                        mord: Ie,
+                        mop: Ie,
+                        mrel: Rt,
+                        minner: Ie
                     },
                     mbin: {
-                        mord: Jt,
-                        mop: Jt,
-                        mopen: Jt,
-                        minner: Jt
+                        mord: i0,
+                        mop: i0,
+                        mopen: i0,
+                        minner: i0
                     },
                     mrel: {
-                        mord: zt,
-                        mop: zt,
-                        mopen: zt,
-                        minner: zt
+                        mord: Rt,
+                        mop: Rt,
+                        mopen: Rt,
+                        minner: Rt
                     },
                     mopen: {},
                     mclose: {
-                        mop: He,
-                        mbin: Jt,
-                        mrel: zt,
-                        minner: He
+                        mop: Ie,
+                        mbin: i0,
+                        mrel: Rt,
+                        minner: Ie
                     },
                     mpunct: {
-                        mord: He,
-                        mop: He,
-                        mrel: zt,
-                        mopen: He,
-                        mclose: He,
-                        mpunct: He,
-                        minner: He
+                        mord: Ie,
+                        mop: Ie,
+                        mrel: Rt,
+                        mopen: Ie,
+                        mclose: Ie,
+                        mpunct: Ie,
+                        minner: Ie
                     },
                     minner: {
-                        mord: He,
-                        mop: He,
-                        mbin: Jt,
-                        mrel: zt,
-                        mopen: He,
-                        mpunct: He,
-                        minner: He
+                        mord: Ie,
+                        mop: Ie,
+                        mbin: i0,
+                        mrel: Rt,
+                        mopen: Ie,
+                        mpunct: Ie,
+                        minner: Ie
                     }
                 },
-                l1 = {
+                ec = {
                     mord: {
-                        mop: He
+                        mop: Ie
                     },
                     mop: {
-                        mord: He,
-                        mop: He
+                        mord: Ie,
+                        mop: Ie
                     },
                     mbin: {},
                     mrel: {},
                     mopen: {},
                     mclose: {
-                        mop: He
+                        mop: Ie
                     },
                     mpunct: {},
                     minner: {
-                        mop: He
+                        mop: Ie
                     }
                 },
-                Zi = {},
-                Zr = {},
-                Qr = {};
+                Vi = {},
+                sr = {},
+                lr = {};
 
-            function Q(n) {
+            function Z(n) {
                 let {
                     type: t,
-                    names: o,
-                    props: s,
-                    handler: u,
-                    htmlBuilder: p,
-                    mathmlBuilder: b
+                    names: u,
+                    props: a,
+                    handler: c,
+                    htmlBuilder: m,
+                    mathmlBuilder: g
                 } = n, v = {
                     type: t,
-                    numArgs: s.numArgs,
-                    argTypes: s.argTypes,
-                    allowedInArgument: !!s.allowedInArgument,
-                    allowedInText: !!s.allowedInText,
-                    allowedInMath: s.allowedInMath === void 0 ? !0 : s.allowedInMath,
-                    numOptionalArgs: s.numOptionalArgs || 0,
-                    infix: !!s.infix,
-                    primitive: !!s.primitive,
-                    handler: u
+                    numArgs: a.numArgs,
+                    argTypes: a.argTypes,
+                    allowedInArgument: !!a.allowedInArgument,
+                    allowedInText: !!a.allowedInText,
+                    allowedInMath: a.allowedInMath === void 0 ? !0 : a.allowedInMath,
+                    numOptionalArgs: a.numOptionalArgs || 0,
+                    infix: !!a.infix,
+                    primitive: !!a.primitive,
+                    handler: c
                 };
-                for (let S = 0; S < o.length; ++S) Zi[o[S]] = v;
-                t && (p && (Zr[t] = p), b && (Qr[t] = b))
+                for (let _ = 0; _ < u.length; ++_) Vi[u[_]] = v;
+                t && (m && (sr[t] = m), g && (lr[t] = g))
             }
 
-            function Kt(n) {
+            function o0(n) {
                 let {
                     type: t,
-                    htmlBuilder: o,
-                    mathmlBuilder: s
+                    htmlBuilder: u,
+                    mathmlBuilder: a
                 } = n;
-                Q({
+                Z({
                     type: t,
                     names: [],
                     props: {
                         numArgs: 0
                     },
                     handler() {
                         throw new Error("Should never be called.")
                     },
-                    htmlBuilder: o,
-                    mathmlBuilder: s
+                    htmlBuilder: u,
+                    mathmlBuilder: a
                 })
             }
-            let Xr = function(n) {
+            let cr = function(n) {
                     return n.type === "ordgroup" && n.body.length === 1 ? n.body[0] : n
                 },
-                je = function(n) {
+                Ge = function(n) {
                     return n.type === "ordgroup" ? n.body : [n]
                 },
-                Rt = B.makeSpan,
-                c1 = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"],
-                u1 = ["rightmost", "mrel", "mclose", "mpunct"],
-                h1 = {
-                    display: G.DISPLAY,
-                    text: G.TEXT,
-                    script: G.SCRIPT,
-                    scriptscript: G.SCRIPTSCRIPT
+                Bt = B.makeSpan,
+                tc = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"],
+                rc = ["rightmost", "mrel", "mclose", "mpunct"],
+                nc = {
+                    display: O.DISPLAY,
+                    text: O.TEXT,
+                    script: O.SCRIPT,
+                    scriptscript: O.SCRIPTSCRIPT
                 },
-                d1 = {
+                uc = {
                     mord: "mord",
                     mop: "mop",
                     mbin: "mbin",
                     mrel: "mrel",
                     mopen: "mopen",
                     mclose: "mclose",
                     mpunct: "mpunct",
                     minner: "minner"
                 },
-                Ze = function(n, t, o, s) {
-                    s === void 0 && (s = [null, null]);
-                    let u = [];
-                    for (let E = 0; E < n.length; E++) {
-                        let z = ve(n[E], t);
-                        if (z instanceof xr) {
-                            let F = z.children;
-                            u.push(...F)
-                        } else u.push(z)
+                We = function(n, t, u, a) {
+                    a === void 0 && (a = [null, null]);
+                    let c = [];
+                    for (let D = 0; D < n.length; D++) {
+                        let z = xe(n[D], t);
+                        if (z instanceof q0) {
+                            let R = z.children;
+                            c.push(...R)
+                        } else c.push(z)
                     }
-                    if (B.tryCombineChars(u), !o) return u;
-                    let p = t;
+                    if (B.tryCombineChars(c), !u) return c;
+                    let m = t;
                     if (n.length === 1) {
-                        let E = n[0];
-                        E.type === "sizing" ? p = t.havingSize(E.size) : E.type === "styling" && (p = t.havingStyle(h1[E.style]))
+                        let D = n[0];
+                        D.type === "sizing" ? m = t.havingSize(D.size) : D.type === "styling" && (m = t.havingStyle(nc[D.style]))
                     }
-                    let b = Rt([s[0] || "leftmost"], [], t),
-                        v = Rt([s[1] || "rightmost"], [], t),
-                        S = o === "root";
-                    return J0(u, (E, z) => {
-                        let F = z.classes[0],
-                            N = E.classes[0];
-                        F === "mbin" && R.contains(u1, N) ? z.classes[0] = "mord" : N === "mbin" && R.contains(c1, F) && (E.classes[0] = "mord")
+                    let g = Bt([a[0] || "leftmost"], [], t),
+                        v = Bt([a[1] || "rightmost"], [], t),
+                        _ = u === "root";
+                    return gn(c, (D, z) => {
+                        let R = z.classes[0],
+                            L = D.classes[0];
+                        R === "mbin" && N.contains(rc, L) ? z.classes[0] = "mord" : L === "mbin" && N.contains(tc, R) && (D.classes[0] = "mord")
                     }, {
-                        node: b
-                    }, v, S), J0(u, (E, z) => {
-                        let F = en(z),
-                            N = en(E),
-                            H = F && N ? E.hasClass("mtight") ? l1[F][N] : s1[F][N] : null;
-                        if (H) return B.makeGlue(H, p)
+                        node: g
+                    }, v, _), gn(c, (D, z) => {
+                        let R = yn(z),
+                            L = yn(D),
+                            P = R && L ? D.hasClass("mtight") ? ec[R][L] : Kl[R][L] : null;
+                        if (P) return B.makeGlue(P, m)
                     }, {
-                        node: b
-                    }, v, S), u
+                        node: g
+                    }, v, _), c
                 },
-                J0 = function(n, t, o, s, u) {
-                    s && n.push(s);
-                    let p = 0;
-                    for (; p < n.length; p++) {
-                        let b = n[p],
-                            v = Qi(b);
+                gn = function(n, t, u, a, c) {
+                    a && n.push(a);
+                    let m = 0;
+                    for (; m < n.length; m++) {
+                        let g = n[m],
+                            v = Ui(g);
                         if (v) {
-                            J0(v.children, t, o, null, u);
+                            gn(v.children, t, u, null, c);
                             continue
                         }
-                        let S = !b.hasClass("mspace");
-                        if (S) {
-                            let E = t(b, o.node);
-                            E && (o.insertAfter ? o.insertAfter(E) : (n.unshift(E), p++))
+                        let _ = !g.hasClass("mspace");
+                        if (_) {
+                            let D = t(g, u.node);
+                            D && (u.insertAfter ? u.insertAfter(D) : (n.unshift(D), m++))
                         }
-                        S ? o.node = b : u && b.hasClass("newline") && (o.node = Rt(["leftmost"])), o.insertAfter = (E => z => {
-                            n.splice(E + 1, 0, z), p++
-                        })(p)
-                    }
-                    s && n.pop()
-                },
-                Qi = function(n) {
-                    return n instanceof xr || n instanceof Y0 || n instanceof vr && n.hasClass("enclosing") ? n : null
-                },
-                K0 = function(n, t) {
-                    let o = Qi(n);
-                    if (o) {
-                        let s = o.children;
-                        if (s.length) {
-                            if (t === "right") return K0(s[s.length - 1], "right");
-                            if (t === "left") return K0(s[0], "left")
+                        _ ? u.node = g : c && g.hasClass("newline") && (u.node = Bt(["leftmost"])), u.insertAfter = (D => z => {
+                            n.splice(D + 1, 0, z), m++
+                        })(m)
+                    }
+                    a && n.pop()
+                },
+                Ui = function(n) {
+                    return n instanceof q0 || n instanceof fn || n instanceof F0 && n.hasClass("enclosing") ? n : null
+                },
+                xn = function(n, t) {
+                    let u = Ui(n);
+                    if (u) {
+                        let a = u.children;
+                        if (a.length) {
+                            if (t === "right") return xn(a[a.length - 1], "right");
+                            if (t === "left") return xn(a[0], "left")
                         }
                     }
                     return n
                 },
-                en = function(n, t) {
-                    return n ? (t && (n = K0(n, t)), d1[n.classes[0]] || null) : null
+                yn = function(n, t) {
+                    return n ? (t && (n = xn(n, t)), uc[n.classes[0]] || null) : null
                 },
-                wr = function(n, t) {
-                    let o = ["nulldelimiter"].concat(n.baseSizingClasses());
-                    return Rt(t.concat(o))
-                },
-                ve = function(n, t, o) {
-                    if (!n) return Rt();
-                    if (Zr[n.type]) {
-                        let s = Zr[n.type](n, t);
-                        if (o && t.size !== o.size) {
-                            s = Rt(t.sizingClasses(o), [s], t);
-                            let u = t.sizeMultiplier / o.sizeMultiplier;
-                            s.height *= u, s.depth *= u
+                z0 = function(n, t) {
+                    let u = ["nulldelimiter"].concat(n.baseSizingClasses());
+                    return Bt(t.concat(u))
+                },
+                xe = function(n, t, u) {
+                    if (!n) return Bt();
+                    if (sr[n.type]) {
+                        let a = sr[n.type](n, t);
+                        if (u && t.size !== u.size) {
+                            a = Bt(t.sizingClasses(u), [a], t);
+                            let c = t.sizeMultiplier / u.sizeMultiplier;
+                            a.height *= c, a.depth *= c
                         }
-                        return s
-                    } else throw new a("Got group of unknown type: '" + n.type + "'")
+                        return a
+                    } else throw new o("Got group of unknown type: '" + n.type + "'")
                 };
 
-            function Jr(n, t) {
-                let o = Rt(["base"], n, t),
-                    s = Rt(["strut"]);
-                return s.style.height = Z(o.height + o.depth), o.depth && (s.style.verticalAlign = Z(-o.depth)), o.children.unshift(s), o
-            }
-
-            function tn(n, t) {
-                let o = null;
-                n.length === 1 && n[0].type === "tag" && (o = n[0].tag, n = n[0].body);
-                let s = Ze(n, t, "root"),
-                    u;
-                s.length === 2 && s[1].hasClass("tag") && (u = s.pop());
-                let p = [],
-                    b = [];
-                for (let E = 0; E < s.length; E++)
-                    if (b.push(s[E]), s[E].hasClass("mbin") || s[E].hasClass("mrel") || s[E].hasClass("allowbreak")) {
+            function dr(n, t) {
+                let u = Bt(["base"], n, t),
+                    a = Bt(["strut"]);
+                return a.style.height = j(u.height + u.depth), u.depth && (a.style.verticalAlign = j(-u.depth)), u.children.unshift(a), u
+            }
+
+            function vn(n, t) {
+                let u = null;
+                n.length === 1 && n[0].type === "tag" && (u = n[0].tag, n = n[0].body);
+                let a = We(n, t, "root"),
+                    c;
+                a.length === 2 && a[1].hasClass("tag") && (c = a.pop());
+                let m = [],
+                    g = [];
+                for (let D = 0; D < a.length; D++)
+                    if (g.push(a[D]), a[D].hasClass("mbin") || a[D].hasClass("mrel") || a[D].hasClass("allowbreak")) {
                         let z = !1;
-                        for (; E < s.length - 1 && s[E + 1].hasClass("mspace") && !s[E + 1].hasClass("newline");) E++, b.push(s[E]), s[E].hasClass("nobreak") && (z = !0);
-                        z || (p.push(Jr(b, t)), b = [])
-                    } else s[E].hasClass("newline") && (b.pop(), b.length > 0 && (p.push(Jr(b, t)), b = []), p.push(s[E]));
-                b.length > 0 && p.push(Jr(b, t));
+                        for (; D < a.length - 1 && a[D + 1].hasClass("mspace") && !a[D + 1].hasClass("newline");) D++, g.push(a[D]), a[D].hasClass("nobreak") && (z = !0);
+                        z || (m.push(dr(g, t)), g = [])
+                    } else a[D].hasClass("newline") && (g.pop(), g.length > 0 && (m.push(dr(g, t)), g = []), m.push(a[D]));
+                g.length > 0 && m.push(dr(g, t));
                 let v;
-                o ? (v = Jr(Ze(o, t, !0)), v.classes = ["tag"], p.push(v)) : u && p.push(u);
-                let S = Rt(["katex-html"], p);
-                if (S.setAttribute("aria-hidden", "true"), v) {
-                    let E = v.children[0];
-                    E.style.height = Z(S.height + S.depth), S.depth && (E.style.verticalAlign = Z(-S.depth))
+                u ? (v = dr(We(u, t, !0)), v.classes = ["tag"], m.push(v)) : c && m.push(c);
+                let _ = Bt(["katex-html"], m);
+                if (_.setAttribute("aria-hidden", "true"), v) {
+                    let D = v.children[0];
+                    D.style.height = j(_.height + _.depth), _.depth && (D.style.verticalAlign = j(-_.depth))
                 }
-                return S
+                return _
             }
 
-            function Xi(n) {
-                return new xr(n)
+            function ji(n) {
+                return new q0(n)
             }
             class ht {
-                constructor(t, o, s) {
-                    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = t, this.attributes = {}, this.children = o || [], this.classes = s || []
+                constructor(t, u, a) {
+                    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = t, this.attributes = {}, this.children = u || [], this.classes = a || []
                 }
-                setAttribute(t, o) {
-                    this.attributes[t] = o
+                setAttribute(t, u) {
+                    this.attributes[t] = u
                 }
                 getAttribute(t) {
                     return this.attributes[t]
                 }
                 toNode() {
                     let t = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
-                    for (let o in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, o) && t.setAttribute(o, this.attributes[o]);
-                    this.classes.length > 0 && (t.className = It(this.classes));
-                    for (let o = 0; o < this.children.length; o++) t.appendChild(this.children[o].toNode());
+                    for (let u in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, u) && t.setAttribute(u, this.attributes[u]);
+                    this.classes.length > 0 && (t.className = Vt(this.classes));
+                    for (let u = 0; u < this.children.length; u++) t.appendChild(this.children[u].toNode());
                     return t
                 }
                 toMarkup() {
                     let t = "<" + this.type;
-                    for (let o in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, o) && (t += " " + o + '="', t += R.escape(this.attributes[o]), t += '"');
-                    this.classes.length > 0 && (t += ' class ="' + R.escape(It(this.classes)) + '"'), t += ">";
-                    for (let o = 0; o < this.children.length; o++) t += this.children[o].toMarkup();
+                    for (let u in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, u) && (t += " " + u + '="', t += N.escape(this.attributes[u]), t += '"');
+                    this.classes.length > 0 && (t += ' class ="' + N.escape(Vt(this.classes)) + '"'), t += ">";
+                    for (let u = 0; u < this.children.length; u++) t += this.children[u].toMarkup();
                     return t += "</" + this.type + ">", t
                 }
                 toText() {
                     return this.children.map(t => t.toText()).join("")
                 }
             }
-            class kr {
+            class R0 {
                 constructor(t) {
                     this.text = void 0, this.text = t
                 }
                 toNode() {
                     return document.createTextNode(this.text)
                 }
                 toMarkup() {
-                    return R.escape(this.toText())
+                    return N.escape(this.toText())
                 }
                 toText() {
                     return this.text
                 }
             }
-            class m1 {
+            class ic {
                 constructor(t) {
                     this.width = void 0, this.character = void 0, this.width = t, t >= .05555 && t <= .05556 ? this.character = "\u200A" : t >= .1666 && t <= .1667 ? this.character = "\u2009" : t >= .2222 && t <= .2223 ? this.character = "\u2005" : t >= .2777 && t <= .2778 ? this.character = "\u2005\u200A" : t >= -.05556 && t <= -.05555 ? this.character = "\u200A\u2063" : t >= -.1667 && t <= -.1666 ? this.character = "\u2009\u2063" : t >= -.2223 && t <= -.2222 ? this.character = "\u205F\u2063" : t >= -.2778 && t <= -.2777 ? this.character = "\u2005\u2063" : this.character = null
                 }
                 toNode() {
                     if (this.character) return document.createTextNode(this.character);
                     {
                         let t = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
-                        return t.setAttribute("width", Z(this.width)), t
+                        return t.setAttribute("width", j(this.width)), t
                     }
                 }
                 toMarkup() {
-                    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + Z(this.width) + '"/>'
+                    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + j(this.width) + '"/>'
                 }
                 toText() {
                     return this.character ? this.character : " "
                 }
             }
-            var V = {
+            var H = {
                 MathNode: ht,
-                TextNode: kr,
-                SpaceNode: m1,
-                newDocumentFragment: Xi
+                TextNode: R0,
+                SpaceNode: ic,
+                newDocumentFragment: ji
             };
-            let dt = function(n, t, o) {
-                    return Oe[t][n] && Oe[t][n].replace && n.charCodeAt(0) !== 55349 && !(Hi.hasOwnProperty(n) && o && (o.fontFamily && o.fontFamily.slice(4, 6) === "tt" || o.font && o.font.slice(4, 6) === "tt")) && (n = Oe[t][n].replace), new V.TextNode(n)
+            let ft = function(n, t, u) {
+                    return Pe[t][n] && Pe[t][n].replace && n.charCodeAt(0) !== 55349 && !(Ni.hasOwnProperty(n) && u && (u.fontFamily && u.fontFamily.slice(4, 6) === "tt" || u.font && u.font.slice(4, 6) === "tt")) && (n = Pe[t][n].replace), new H.TextNode(n)
                 },
-                rn = function(n) {
-                    return n.length === 1 ? n[0] : new V.MathNode("mrow", n)
+                wn = function(n) {
+                    return n.length === 1 ? n[0] : new H.MathNode("mrow", n)
                 },
-                nn = function(n, t) {
+                kn = function(n, t) {
                     if (t.fontFamily === "texttt") return "monospace";
                     if (t.fontFamily === "textsf") return t.fontShape === "textit" && t.fontWeight === "textbf" ? "sans-serif-bold-italic" : t.fontShape === "textit" ? "sans-serif-italic" : t.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
                     if (t.fontShape === "textit" && t.fontWeight === "textbf") return "bold-italic";
                     if (t.fontShape === "textit") return "italic";
                     if (t.fontWeight === "textbf") return "bold";
-                    let o = t.font;
-                    if (!o || o === "mathnormal") return null;
-                    let s = n.mode;
-                    if (o === "mathit") return "italic";
-                    if (o === "boldsymbol") return n.type === "textord" ? "bold" : "bold-italic";
-                    if (o === "mathbf") return "bold";
-                    if (o === "mathbb") return "double-struck";
-                    if (o === "mathfrak") return "fraktur";
-                    if (o === "mathscr" || o === "mathcal") return "script";
-                    if (o === "mathsf") return "sans-serif";
-                    if (o === "mathtt") return "monospace";
-                    let u = n.text;
-                    if (R.contains(["\\imath", "\\jmath"], u)) return null;
-                    Oe[s][u] && Oe[s][u].replace && (u = Oe[s][u].replace);
-                    let p = B.fontMap[o].fontName;
-                    return j0(u, p, s) ? B.fontMap[o].variant : null
+                    let u = t.font;
+                    if (!u || u === "mathnormal") return null;
+                    let a = n.mode;
+                    if (u === "mathit") return "italic";
+                    if (u === "boldsymbol") return n.type === "textord" ? "bold" : "bold-italic";
+                    if (u === "mathbf") return "bold";
+                    if (u === "mathbb") return "double-struck";
+                    if (u === "mathfrak") return "fraktur";
+                    if (u === "mathscr" || u === "mathcal") return "script";
+                    if (u === "mathsf") return "sans-serif";
+                    if (u === "mathtt") return "monospace";
+                    let c = n.text;
+                    if (N.contains(["\\imath", "\\jmath"], c)) return null;
+                    Pe[a][c] && Pe[a][c].replace && (c = Pe[a][c].replace);
+                    let m = B.fontMap[u].fontName;
+                    return cn(c, m, a) ? B.fontMap[u].variant : null
                 },
-                it = function(n, t, o) {
+                it = function(n, t, u) {
                     if (n.length === 1) {
-                        let p = Ee(n[0], t);
-                        return o && p instanceof ht && p.type === "mo" && (p.setAttribute("lspace", "0em"), p.setAttribute("rspace", "0em")), [p]
+                        let m = Ae(n[0], t);
+                        return u && m instanceof ht && m.type === "mo" && (m.setAttribute("lspace", "0em"), m.setAttribute("rspace", "0em")), [m]
                     }
-                    let s = [],
-                        u;
-                    for (let p = 0; p < n.length; p++) {
-                        let b = Ee(n[p], t);
-                        if (b instanceof ht && u instanceof ht) {
-                            if (b.type === "mtext" && u.type === "mtext" && b.getAttribute("mathvariant") === u.getAttribute("mathvariant")) {
-                                u.children.push(...b.children);
+                    let a = [],
+                        c;
+                    for (let m = 0; m < n.length; m++) {
+                        let g = Ae(n[m], t);
+                        if (g instanceof ht && c instanceof ht) {
+                            if (g.type === "mtext" && c.type === "mtext" && g.getAttribute("mathvariant") === c.getAttribute("mathvariant")) {
+                                c.children.push(...g.children);
                                 continue
-                            } else if (b.type === "mn" && u.type === "mn") {
-                                u.children.push(...b.children);
+                            } else if (g.type === "mn" && c.type === "mn") {
+                                c.children.push(...g.children);
                                 continue
-                            } else if (b.type === "mi" && b.children.length === 1 && u.type === "mn") {
-                                let v = b.children[0];
-                                if (v instanceof kr && v.text === ".") {
-                                    u.children.push(...b.children);
+                            } else if (g.type === "mi" && g.children.length === 1 && c.type === "mn") {
+                                let v = g.children[0];
+                                if (v instanceof R0 && v.text === ".") {
+                                    c.children.push(...g.children);
                                     continue
                                 }
-                            } else if (u.type === "mi" && u.children.length === 1) {
-                                let v = u.children[0];
-                                if (v instanceof kr && v.text === "\u0338" && (b.type === "mo" || b.type === "mi" || b.type === "mn")) {
-                                    let S = b.children[0];
-                                    S instanceof kr && S.text.length > 0 && (S.text = S.text.slice(0, 1) + "\u0338" + S.text.slice(1), s.pop())
+                            } else if (c.type === "mi" && c.children.length === 1) {
+                                let v = c.children[0];
+                                if (v instanceof R0 && v.text === "\u0338" && (g.type === "mo" || g.type === "mi" || g.type === "mn")) {
+                                    let _ = g.children[0];
+                                    _ instanceof R0 && _.text.length > 0 && (_.text = _.text.slice(0, 1) + "\u0338" + _.text.slice(1), a.pop())
                                 }
                             }
                         }
-                        s.push(b), u = b
+                        a.push(g), c = g
                     }
-                    return s
+                    return a
                 },
-                Ht = function(n, t, o) {
-                    return rn(it(n, t, o))
+                jt = function(n, t, u) {
+                    return wn(it(n, t, u))
                 },
-                Ee = function(n, t) {
-                    if (!n) return new V.MathNode("mrow");
-                    if (Qr[n.type]) return Qr[n.type](n, t);
-                    throw new a("Got group of unknown type: '" + n.type + "'")
+                Ae = function(n, t) {
+                    if (!n) return new H.MathNode("mrow");
+                    if (lr[n.type]) return lr[n.type](n, t);
+                    throw new o("Got group of unknown type: '" + n.type + "'")
                 };
 
-            function Ji(n, t, o, s, u) {
-                let p = it(n, o),
-                    b;
-                p.length === 1 && p[0] instanceof ht && R.contains(["mrow", "mtable"], p[0].type) ? b = p[0] : b = new V.MathNode("mrow", p);
-                let v = new V.MathNode("annotation", [new V.TextNode(t)]);
+            function Wi(n, t, u, a, c) {
+                let m = it(n, u),
+                    g;
+                m.length === 1 && m[0] instanceof ht && N.contains(["mrow", "mtable"], m[0].type) ? g = m[0] : g = new H.MathNode("mrow", m);
+                let v = new H.MathNode("annotation", [new H.TextNode(t)]);
                 v.setAttribute("encoding", "application/x-tex");
-                let S = new V.MathNode("semantics", [b, v]),
-                    E = new V.MathNode("math", [S]);
-                E.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), s && E.setAttribute("display", "block");
-                let z = u ? "katex" : "katex-mathml";
-                return B.makeSpan([z], [E])
-            }
-            let Ki = function(n) {
-                    return new $u({
-                        style: n.displayMode ? G.DISPLAY : G.TEXT,
+                let _ = new H.MathNode("semantics", [g, v]),
+                    D = new H.MathNode("math", [_]);
+                D.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), a && D.setAttribute("display", "block");
+                let z = c ? "katex" : "katex-mathml";
+                return B.makeSpan([z], [D])
+            }
+            let Yi = function(n) {
+                    return new Rl({
+                        style: n.displayMode ? O.DISPLAY : O.TEXT,
                         maxSize: n.maxSize,
                         minRuleThickness: n.minRuleThickness
                     })
                 },
-                eo = function(n, t) {
+                Zi = function(n, t) {
                     if (t.displayMode) {
-                        let o = ["katex-display"];
-                        t.leqno && o.push("leqno"), t.fleqn && o.push("fleqn"), n = B.makeSpan(o, [n])
+                        let u = ["katex-display"];
+                        t.leqno && u.push("leqno"), t.fleqn && u.push("fleqn"), n = B.makeSpan(u, [n])
                     }
                     return n
                 },
-                p1 = function(n, t, o) {
-                    let s = Ki(o),
-                        u;
-                    if (o.output === "mathml") return Ji(n, t, s, o.displayMode, !0);
-                    if (o.output === "html") {
-                        let p = tn(n, s);
-                        u = B.makeSpan(["katex"], [p])
+                oc = function(n, t, u) {
+                    let a = Yi(u),
+                        c;
+                    if (u.output === "mathml") return Wi(n, t, a, u.displayMode, !0);
+                    if (u.output === "html") {
+                        let m = vn(n, a);
+                        c = B.makeSpan(["katex"], [m])
                     } else {
-                        let p = Ji(n, t, s, o.displayMode, !1),
-                            b = tn(n, s);
-                        u = B.makeSpan(["katex"], [p, b])
-                    }
-                    return eo(u, o)
-                },
-                f1 = function(n, t, o) {
-                    let s = Ki(o),
-                        u = tn(n, s),
-                        p = B.makeSpan(["katex"], [u]);
-                    return eo(p, o)
+                        let m = Wi(n, t, a, u.displayMode, !1),
+                            g = vn(n, a);
+                        c = B.makeSpan(["katex"], [m, g])
+                    }
+                    return Zi(c, u)
+                },
+                ac = function(n, t, u) {
+                    let a = Yi(u),
+                        c = vn(n, a),
+                        m = B.makeSpan(["katex"], [c]);
+                    return Zi(m, u)
                 };
-            var Kp = null;
-            let g1 = {
+            var S2 = null;
+            let sc = {
                     widehat: "^",
                     widecheck: "\u02C7",
                     widetilde: "~",
                     utilde: "~",
                     overleftarrow: "\u2190",
                     underleftarrow: "\u2190",
                     xleftarrow: "\u2190",
@@ -9910,19 +5500,19 @@
                     xrightleftarrows: "\u21C4",
                     xrightequilibrium: "\u21CC",
                     xleftequilibrium: "\u21CB",
                     "\\cdrightarrow": "\u2192",
                     "\\cdleftarrow": "\u2190",
                     "\\cdlongequal": "="
                 },
-                b1 = function(n) {
-                    let t = new V.MathNode("mo", [new V.TextNode(g1[n.replace(/^\\/, "")])]);
+                lc = function(n) {
+                    let t = new H.MathNode("mo", [new H.TextNode(sc[n.replace(/^\\/, "")])]);
                     return t.setAttribute("stretchy", "true"), t
                 },
-                y1 = {
+                cc = {
                     overrightarrow: [
                         ["rightarrow"], .888, 522, "xMaxYMin"
                     ],
                     overleftarrow: [
                         ["leftarrow"], .888, 522, "xMinYMin"
                     ],
                     underrightarrow: [
@@ -10036,1108 +5626,1108 @@
                     xrightequilibrium: [
                         ["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716
                     ],
                     xleftequilibrium: [
                         ["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716
                     ]
                 },
-                x1 = function(n) {
+                dc = function(n) {
                     return n.type === "ordgroup" ? n.body.length : 1
                 };
-            var Ft = {
-                encloseSpan: function(n, t, o, s, u) {
-                    let p, b = n.height + n.depth + o + s;
+            var Nt = {
+                encloseSpan: function(n, t, u, a, c) {
+                    let m, g = n.height + n.depth + u + a;
                     if (/fbox|color|angl/.test(t)) {
-                        if (p = B.makeSpan(["stretchy", t], [], u), t === "fbox") {
-                            let v = u.color && u.getColor();
-                            v && (p.style.borderColor = v)
+                        if (m = B.makeSpan(["stretchy", t], [], c), t === "fbox") {
+                            let v = c.color && c.getColor();
+                            v && (m.style.borderColor = v)
                         }
                     } else {
                         let v = [];
-                        /^[bx]cancel$/.test(t) && v.push(new Z0({
+                        /^[bx]cancel$/.test(t) && v.push(new mn({
                             x1: "0",
                             y1: "0",
                             x2: "100%",
                             y2: "100%",
                             "stroke-width": "0.046em"
-                        })), /^x?cancel$/.test(t) && v.push(new Z0({
+                        })), /^x?cancel$/.test(t) && v.push(new mn({
                             x1: "0",
                             y1: "100%",
                             x2: "100%",
                             y2: "0",
                             "stroke-width": "0.046em"
                         }));
-                        let S = new Et(v, {
+                        let _ = new Ft(v, {
                             width: "100%",
-                            height: Z(b)
+                            height: j(g)
                         });
-                        p = B.makeSvgSpan([], [S], u)
+                        m = B.makeSvgSpan([], [_], c)
                     }
-                    return p.height = b, p.style.height = Z(b), p
+                    return m.height = g, m.style.height = j(g), m
                 },
-                mathMLnode: b1,
+                mathMLnode: lc,
                 svgSpan: function(n, t) {
-                    function o() {
-                        let b = 4e5,
+                    function u() {
+                        let g = 4e5,
                             v = n.label.slice(1);
-                        if (R.contains(["widehat", "widecheck", "widetilde", "utilde"], v)) {
-                            let E = x1(n.base),
-                                z, F, N;
-                            if (E > 5) v === "widehat" || v === "widecheck" ? (z = 420, b = 2364, N = .42, F = v + "4") : (z = 312, b = 2340, N = .34, F = "tilde4");
+                        if (N.contains(["widehat", "widecheck", "widetilde", "utilde"], v)) {
+                            let D = dc(n.base),
+                                z, R, L;
+                            if (D > 5) v === "widehat" || v === "widecheck" ? (z = 420, g = 2364, L = .42, R = v + "4") : (z = 312, g = 2340, L = .34, R = "tilde4");
                             else {
-                                let ie = [1, 1, 2, 2, 3, 3][E];
-                                v === "widehat" || v === "widecheck" ? (b = [0, 1062, 2364, 2364, 2364][ie], z = [0, 239, 300, 360, 420][ie], N = [0, .24, .3, .3, .36, .42][ie], F = v + ie) : (b = [0, 600, 1033, 2339, 2340][ie], z = [0, 260, 286, 306, 312][ie], N = [0, .26, .286, .3, .306, .34][ie], F = "tilde" + ie)
+                                let re = [1, 1, 2, 2, 3, 3][D];
+                                v === "widehat" || v === "widecheck" ? (g = [0, 1062, 2364, 2364, 2364][re], z = [0, 239, 300, 360, 420][re], L = [0, .24, .3, .3, .36, .42][re], R = v + re) : (g = [0, 600, 1033, 2339, 2340][re], z = [0, 260, 286, 306, 312][re], L = [0, .26, .286, .3, .306, .34][re], R = "tilde" + re)
                             }
-                            let H = new Ot(F),
-                                K = new Et([H], {
+                            let P = new Ut(R),
+                                K = new Ft([P], {
                                     width: "100%",
-                                    height: Z(N),
-                                    viewBox: "0 0 " + b + " " + z,
+                                    height: j(L),
+                                    viewBox: "0 0 " + g + " " + z,
                                     preserveAspectRatio: "none"
                                 });
                             return {
                                 span: B.makeSvgSpan([], [K], t),
                                 minWidth: 0,
-                                height: N
+                                height: L
                             }
                         } else {
-                            let S = [],
-                                E = y1[v],
-                                [z, F, N] = E,
-                                H = N / 1e3,
+                            let _ = [],
+                                D = cc[v],
+                                [z, R, L] = D,
+                                P = L / 1e3,
                                 K = z.length,
-                                ie, ye;
+                                re, pe;
                             if (K === 1) {
-                                let ge = E[3];
-                                ie = ["hide-tail"], ye = [ge]
-                            } else if (K === 2) ie = ["halfarrow-left", "halfarrow-right"], ye = ["xMinYMin", "xMaxYMin"];
-                            else if (K === 3) ie = ["brace-left", "brace-center", "brace-right"], ye = ["xMinYMin", "xMidYMin", "xMaxYMin"];
+                                let de = D[3];
+                                re = ["hide-tail"], pe = [de]
+                            } else if (K === 2) re = ["halfarrow-left", "halfarrow-right"], pe = ["xMinYMin", "xMaxYMin"];
+                            else if (K === 3) re = ["brace-left", "brace-center", "brace-right"], pe = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                             else throw new Error(`Correct katexImagesData or update code here to support
                     ` + K + " children.");
-                            for (let ge = 0; ge < K; ge++) {
-                                let xe = new Ot(z[ge]),
-                                    ke = new Et([xe], {
+                            for (let de = 0; de < K; de++) {
+                                let be = new Ut(z[de]),
+                                    ve = new Ft([be], {
                                         width: "400em",
-                                        height: Z(H),
-                                        viewBox: "0 0 " + b + " " + N,
-                                        preserveAspectRatio: ye[ge] + " slice"
+                                        height: j(P),
+                                        viewBox: "0 0 " + g + " " + L,
+                                        preserveAspectRatio: pe[de] + " slice"
                                     }),
-                                    ze = B.makeSvgSpan([ie[ge]], [ke], t);
+                                    Te = B.makeSvgSpan([re[de]], [ve], t);
                                 if (K === 1) return {
-                                    span: ze,
-                                    minWidth: F,
-                                    height: H
+                                    span: Te,
+                                    minWidth: R,
+                                    height: P
                                 };
-                                ze.style.height = Z(H), S.push(ze)
+                                Te.style.height = j(P), _.push(Te)
                             }
                             return {
-                                span: B.makeSpan(["stretchy"], S, t),
-                                minWidth: F,
-                                height: H
+                                span: B.makeSpan(["stretchy"], _, t),
+                                minWidth: R,
+                                height: P
                             }
                         }
                     }
                     let {
-                        span: s,
-                        minWidth: u,
-                        height: p
-                    } = o();
-                    return s.height = p, s.style.height = Z(p), u > 0 && (s.style.minWidth = Z(u)), s
+                        span: a,
+                        minWidth: c,
+                        height: m
+                    } = u();
+                    return a.height = m, a.style.height = j(m), c > 0 && (a.style.minWidth = j(c)), a
                 }
             };
 
-            function de(n, t) {
+            function se(n, t) {
                 if (!n || n.type !== t) throw new Error("Expected node of type " + t + ", but got " + (n ? "node of type " + n.type : String(n)));
                 return n
             }
 
-            function on(n) {
-                let t = Kr(n);
+            function _n(n) {
+                let t = hr(n);
                 if (!t) throw new Error("Expected node of symbol group type, but got " + (n ? "node of type " + n.type : String(n)));
                 return t
             }
 
-            function Kr(n) {
-                return n && (n.type === "atom" || Yu.hasOwnProperty(n.type)) ? n : null
+            function hr(n) {
+                return n && (n.type === "atom" || Ol.hasOwnProperty(n.type)) ? n : null
             }
-            let an = (n, t) => {
-                    let o, s, u;
-                    n && n.type === "supsub" ? (s = de(n.base, "accent"), o = s.base, n.base = o, u = Uu(ve(n, t)), n.base = s) : (s = de(n, "accent"), o = s.base);
-                    let p = ve(o, t.havingCrampedStyle()),
-                        b = s.isShifty && R.isCharacterBox(o),
+            let Cn = (n, t) => {
+                    let u, a, c;
+                    n && n.type === "supsub" ? (a = se(n.base, "accent"), u = a.base, n.base = u, c = Pl(xe(n, t)), n.base = a) : (a = se(n, "accent"), u = a.base);
+                    let m = xe(u, t.havingCrampedStyle()),
+                        g = a.isShifty && N.isCharacterBox(u),
                         v = 0;
-                    if (b) {
-                        let N = R.getBaseElem(o),
-                            H = ve(N, t.havingCrampedStyle());
-                        v = Oi(H).skew
+                    if (g) {
+                        let L = N.getBaseElem(u),
+                            P = xe(L, t.havingCrampedStyle());
+                        v = Bi(P).skew
                     }
-                    let S = s.label === "\\c",
-                        E = S ? p.height + p.depth : Math.min(p.height, t.fontMetrics().xHeight),
+                    let _ = a.label === "\\c",
+                        D = _ ? m.height + m.depth : Math.min(m.height, t.fontMetrics().xHeight),
                         z;
-                    if (s.isStretchy) z = Ft.svgSpan(s, t), z = B.makeVList({
+                    if (a.isStretchy) z = Nt.svgSpan(a, t), z = B.makeVList({
                         positionType: "firstBaseline",
                         children: [{
                             type: "elem",
-                            elem: p
+                            elem: m
                         }, {
                             type: "elem",
                             elem: z,
                             wrapperClasses: ["svg-align"],
                             wrapperStyle: v > 0 ? {
-                                width: "calc(100% - " + Z(2 * v) + ")",
-                                marginLeft: Z(2 * v)
+                                width: "calc(100% - " + j(2 * v) + ")",
+                                marginLeft: j(2 * v)
                             } : void 0
                         }]
                     }, t);
                     else {
-                        let N, H;
-                        s.label === "\\vec" ? (N = B.staticSvg("vec", t), H = B.svgData.vec[1]) : (N = B.makeOrd({
-                            mode: s.mode,
-                            text: s.label
-                        }, t, "textord"), N = Oi(N), N.italic = 0, H = N.width, S && (E += N.depth)), z = B.makeSpan(["accent-body"], [N]);
-                        let K = s.label === "\\textcircled";
-                        K && (z.classes.push("accent-full"), E = p.height);
-                        let ie = v;
-                        K || (ie -= H / 2), z.style.left = Z(ie), s.label === "\\textcircled" && (z.style.top = ".2em"), z = B.makeVList({
+                        let L, P;
+                        a.label === "\\vec" ? (L = B.staticSvg("vec", t), P = B.svgData.vec[1]) : (L = B.makeOrd({
+                            mode: a.mode,
+                            text: a.label
+                        }, t, "textord"), L = Bi(L), L.italic = 0, P = L.width, _ && (D += L.depth)), z = B.makeSpan(["accent-body"], [L]);
+                        let K = a.label === "\\textcircled";
+                        K && (z.classes.push("accent-full"), D = m.height);
+                        let re = v;
+                        K || (re -= P / 2), z.style.left = j(re), a.label === "\\textcircled" && (z.style.top = ".2em"), z = B.makeVList({
                             positionType: "firstBaseline",
                             children: [{
                                 type: "elem",
-                                elem: p
+                                elem: m
                             }, {
                                 type: "kern",
-                                size: -E
+                                size: -D
                             }, {
                                 type: "elem",
                                 elem: z
                             }]
                         }, t)
                     }
-                    let F = B.makeSpan(["mord", "accent"], [z], t);
-                    return u ? (u.children[0] = F, u.height = Math.max(F.height, u.height), u.classes[0] = "mord", u) : F
+                    let R = B.makeSpan(["mord", "accent"], [z], t);
+                    return c ? (c.children[0] = R, c.height = Math.max(R.height, c.height), c.classes[0] = "mord", c) : R
                 },
-                to = (n, t) => {
-                    let o = n.isStretchy ? Ft.mathMLnode(n.label) : new V.MathNode("mo", [dt(n.label, n.mode)]),
-                        s = new V.MathNode("mover", [Ee(n.base, t), o]);
-                    return s.setAttribute("accent", "true"), s
+                Xi = (n, t) => {
+                    let u = n.isStretchy ? Nt.mathMLnode(n.label) : new H.MathNode("mo", [ft(n.label, n.mode)]),
+                        a = new H.MathNode("mover", [Ae(n.base, t), u]);
+                    return a.setAttribute("accent", "true"), a
                 },
-                v1 = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(n => "\\" + n).join("|"));
-            Q({
+                hc = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(n => "\\" + n).join("|"));
+            Z({
                 type: "accent",
                 names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
                 props: {
                     numArgs: 1
                 },
                 handler: (n, t) => {
-                    let o = Xr(t[0]),
-                        s = !v1.test(n.funcName),
-                        u = !s || n.funcName === "\\widehat" || n.funcName === "\\widetilde" || n.funcName === "\\widecheck";
+                    let u = cr(t[0]),
+                        a = !hc.test(n.funcName),
+                        c = !a || n.funcName === "\\widehat" || n.funcName === "\\widetilde" || n.funcName === "\\widecheck";
                     return {
                         type: "accent",
                         mode: n.parser.mode,
                         label: n.funcName,
-                        isStretchy: s,
-                        isShifty: u,
-                        base: o
+                        isStretchy: a,
+                        isShifty: c,
+                        base: u
                     }
                 },
-                htmlBuilder: an,
-                mathmlBuilder: to
-            }), Q({
+                htmlBuilder: Cn,
+                mathmlBuilder: Xi
+            }), Z({
                 type: "accent",
                 names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
                 props: {
                     numArgs: 1,
                     allowedInText: !0,
                     allowedInMath: !0,
                     argTypes: ["primitive"]
                 },
                 handler: (n, t) => {
-                    let o = t[0],
-                        s = n.parser.mode;
-                    return s === "math" && (n.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + n.funcName + " works only in text mode"), s = "text"), {
+                    let u = t[0],
+                        a = n.parser.mode;
+                    return a === "math" && (n.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + n.funcName + " works only in text mode"), a = "text"), {
                         type: "accent",
-                        mode: s,
+                        mode: a,
                         label: n.funcName,
                         isStretchy: !1,
                         isShifty: !0,
-                        base: o
+                        base: u
                     }
                 },
-                htmlBuilder: an,
-                mathmlBuilder: to
-            }), Q({
+                htmlBuilder: Cn,
+                mathmlBuilder: Xi
+            }), Z({
                 type: "accentUnder",
                 names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
                 props: {
                     numArgs: 1
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[0];
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[0];
                     return {
                         type: "accentUnder",
-                        mode: o.mode,
-                        label: s,
-                        base: u
+                        mode: u.mode,
+                        label: a,
+                        base: c
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    let o = ve(n.base, t),
-                        s = Ft.svgSpan(n, t),
-                        u = n.label === "\\utilde" ? .12 : 0,
-                        p = B.makeVList({
+                    let u = xe(n.base, t),
+                        a = Nt.svgSpan(n, t),
+                        c = n.label === "\\utilde" ? .12 : 0,
+                        m = B.makeVList({
                             positionType: "top",
-                            positionData: o.height,
+                            positionData: u.height,
                             children: [{
                                 type: "elem",
-                                elem: s,
+                                elem: a,
                                 wrapperClasses: ["svg-align"]
                             }, {
                                 type: "kern",
-                                size: u
+                                size: c
                             }, {
                                 type: "elem",
-                                elem: o
+                                elem: u
                             }]
                         }, t);
-                    return B.makeSpan(["mord", "accentunder"], [p], t)
+                    return B.makeSpan(["mord", "accentunder"], [m], t)
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = Ft.mathMLnode(n.label),
-                        s = new V.MathNode("munder", [Ee(n.base, t), o]);
-                    return s.setAttribute("accentunder", "true"), s
+                    let u = Nt.mathMLnode(n.label),
+                        a = new H.MathNode("munder", [Ae(n.base, t), u]);
+                    return a.setAttribute("accentunder", "true"), a
                 }
             });
-            let e0 = n => {
-                let t = new V.MathNode("mpadded", n ? [n] : []);
+            let fr = n => {
+                let t = new H.MathNode("mpadded", n ? [n] : []);
                 return t.setAttribute("width", "+0.6em"), t.setAttribute("lspace", "0.3em"), t
             };
-            Q({
+            Z({
                 type: "xArrow",
                 names: ["\\xleftarrow", "\\xrightarrow", "\\xLeftarrow", "\\xRightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xrightharpoondown", "\\xrightharpoonup", "\\xleftharpoondown", "\\xleftharpoonup", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xlongequal", "\\xtwoheadrightarrow", "\\xtwoheadleftarrow", "\\xtofrom", "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium", "\\\\cdrightarrow", "\\\\cdleftarrow", "\\\\cdlongequal"],
                 props: {
                     numArgs: 1,
                     numOptionalArgs: 1
                 },
-                handler(n, t, o) {
+                handler(n, t, u) {
                     let {
-                        parser: s,
-                        funcName: u
+                        parser: a,
+                        funcName: c
                     } = n;
                     return {
                         type: "xArrow",
-                        mode: s.mode,
-                        label: u,
+                        mode: a.mode,
+                        label: c,
                         body: t[0],
-                        below: o[0]
+                        below: u[0]
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = t.style,
-                        s = t.havingStyle(o.sup()),
-                        u = B.wrapFragment(ve(n.body, s, t), t),
-                        p = n.label.slice(0, 2) === "\\x" ? "x" : "cd";
-                    u.classes.push(p + "-arrow-pad");
-                    let b;
-                    n.below && (s = t.havingStyle(o.sub()), b = B.wrapFragment(ve(n.below, s, t), t), b.classes.push(p + "-arrow-pad"));
-                    let v = Ft.svgSpan(n, t),
-                        S = -t.fontMetrics().axisHeight + .5 * v.height,
-                        E = -t.fontMetrics().axisHeight - .5 * v.height - .111;
-                    (u.depth > .25 || n.label === "\\xleftequilibrium") && (E -= u.depth);
+                    let u = t.style,
+                        a = t.havingStyle(u.sup()),
+                        c = B.wrapFragment(xe(n.body, a, t), t),
+                        m = n.label.slice(0, 2) === "\\x" ? "x" : "cd";
+                    c.classes.push(m + "-arrow-pad");
+                    let g;
+                    n.below && (a = t.havingStyle(u.sub()), g = B.wrapFragment(xe(n.below, a, t), t), g.classes.push(m + "-arrow-pad"));
+                    let v = Nt.svgSpan(n, t),
+                        _ = -t.fontMetrics().axisHeight + .5 * v.height,
+                        D = -t.fontMetrics().axisHeight - .5 * v.height - .111;
+                    (c.depth > .25 || n.label === "\\xleftequilibrium") && (D -= c.depth);
                     let z;
-                    if (b) {
-                        let F = -t.fontMetrics().axisHeight + b.height + .5 * v.height + .111;
+                    if (g) {
+                        let R = -t.fontMetrics().axisHeight + g.height + .5 * v.height + .111;
                         z = B.makeVList({
                             positionType: "individualShift",
                             children: [{
                                 type: "elem",
-                                elem: u,
-                                shift: E
+                                elem: c,
+                                shift: D
                             }, {
                                 type: "elem",
                                 elem: v,
-                                shift: S
+                                shift: _
                             }, {
                                 type: "elem",
-                                elem: b,
-                                shift: F
+                                elem: g,
+                                shift: R
                             }]
                         }, t)
                     } else z = B.makeVList({
                         positionType: "individualShift",
                         children: [{
                             type: "elem",
-                            elem: u,
-                            shift: E
+                            elem: c,
+                            shift: D
                         }, {
                             type: "elem",
                             elem: v,
-                            shift: S
+                            shift: _
                         }]
                     }, t);
                     return z.children[0].children[0].children[1].classes.push("svg-align"), B.makeSpan(["mrel", "x-arrow"], [z], t)
                 },
                 mathmlBuilder(n, t) {
-                    let o = Ft.mathMLnode(n.label);
-                    o.setAttribute("minsize", n.label.charAt(0) === "x" ? "1.75em" : "3.0em");
-                    let s;
+                    let u = Nt.mathMLnode(n.label);
+                    u.setAttribute("minsize", n.label.charAt(0) === "x" ? "1.75em" : "3.0em");
+                    let a;
                     if (n.body) {
-                        let u = e0(Ee(n.body, t));
+                        let c = fr(Ae(n.body, t));
                         if (n.below) {
-                            let p = e0(Ee(n.below, t));
-                            s = new V.MathNode("munderover", [o, p, u])
-                        } else s = new V.MathNode("mover", [o, u])
+                            let m = fr(Ae(n.below, t));
+                            a = new H.MathNode("munderover", [u, m, c])
+                        } else a = new H.MathNode("mover", [u, c])
                     } else if (n.below) {
-                        let u = e0(Ee(n.below, t));
-                        s = new V.MathNode("munder", [o, u])
-                    } else s = e0(), s = new V.MathNode("mover", [o, s]);
-                    return s
+                        let c = fr(Ae(n.below, t));
+                        a = new H.MathNode("munder", [u, c])
+                    } else a = fr(), a = new H.MathNode("mover", [u, a]);
+                    return a
                 }
             });
-            let w1 = B.makeSpan;
+            let fc = B.makeSpan;
 
-            function ro(n, t) {
-                let o = Ze(n.body, t, !0);
-                return w1([n.mclass], o, t)
+            function Qi(n, t) {
+                let u = We(n.body, t, !0);
+                return fc([n.mclass], u, t)
             }
 
-            function no(n, t) {
-                let o, s = it(n.body, t);
-                return n.mclass === "minner" ? o = new V.MathNode("mpadded", s) : n.mclass === "mord" ? n.isCharacterBox ? (o = s[0], o.type = "mi") : o = new V.MathNode("mi", s) : (n.isCharacterBox ? (o = s[0], o.type = "mo") : o = new V.MathNode("mo", s), n.mclass === "mbin" ? (o.attributes.lspace = "0.22em", o.attributes.rspace = "0.22em") : n.mclass === "mpunct" ? (o.attributes.lspace = "0em", o.attributes.rspace = "0.17em") : n.mclass === "mopen" || n.mclass === "mclose" ? (o.attributes.lspace = "0em", o.attributes.rspace = "0em") : n.mclass === "minner" && (o.attributes.lspace = "0.0556em", o.attributes.width = "+0.1111em")), o
+            function Ji(n, t) {
+                let u, a = it(n.body, t);
+                return n.mclass === "minner" ? u = new H.MathNode("mpadded", a) : n.mclass === "mord" ? n.isCharacterBox ? (u = a[0], u.type = "mi") : u = new H.MathNode("mi", a) : (n.isCharacterBox ? (u = a[0], u.type = "mo") : u = new H.MathNode("mo", a), n.mclass === "mbin" ? (u.attributes.lspace = "0.22em", u.attributes.rspace = "0.22em") : n.mclass === "mpunct" ? (u.attributes.lspace = "0em", u.attributes.rspace = "0.17em") : n.mclass === "mopen" || n.mclass === "mclose" ? (u.attributes.lspace = "0em", u.attributes.rspace = "0em") : n.mclass === "minner" && (u.attributes.lspace = "0.0556em", u.attributes.width = "+0.1111em")), u
             }
-            Q({
+            Z({
                 type: "mclass",
                 names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
                 props: {
                     numArgs: 1,
                     primitive: !0
                 },
                 handler(n, t) {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[0];
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[0];
                     return {
                         type: "mclass",
-                        mode: o.mode,
-                        mclass: "m" + s.slice(5),
-                        body: je(u),
-                        isCharacterBox: R.isCharacterBox(u)
+                        mode: u.mode,
+                        mclass: "m" + a.slice(5),
+                        body: Ge(c),
+                        isCharacterBox: N.isCharacterBox(c)
                     }
                 },
-                htmlBuilder: ro,
-                mathmlBuilder: no
+                htmlBuilder: Qi,
+                mathmlBuilder: Ji
             });
-            let t0 = n => {
+            let mr = n => {
                 let t = n.type === "ordgroup" && n.body.length ? n.body[0] : n;
                 return t.type === "atom" && (t.family === "bin" || t.family === "rel") ? "m" + t.family : "mord"
             };
-            Q({
+            Z({
                 type: "mclass",
                 names: ["\\@binrel"],
                 props: {
                     numArgs: 2
                 },
                 handler(n, t) {
                     let {
-                        parser: o
+                        parser: u
                     } = n;
                     return {
                         type: "mclass",
-                        mode: o.mode,
-                        mclass: t0(t[0]),
-                        body: je(t[1]),
-                        isCharacterBox: R.isCharacterBox(t[1])
+                        mode: u.mode,
+                        mclass: mr(t[0]),
+                        body: Ge(t[1]),
+                        isCharacterBox: N.isCharacterBox(t[1])
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "mclass",
                 names: ["\\stackrel", "\\overset", "\\underset"],
                 props: {
                     numArgs: 2
                 },
                 handler(n, t) {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[1], p = t[0], b;
-                    s !== "\\stackrel" ? b = t0(u) : b = "mrel";
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[1], m = t[0], g;
+                    a !== "\\stackrel" ? g = mr(c) : g = "mrel";
                     let v = {
                             type: "op",
-                            mode: u.mode,
+                            mode: c.mode,
                             limits: !0,
                             alwaysHandleSupSub: !0,
                             parentIsSupSub: !1,
                             symbol: !1,
-                            suppressBaseShift: s !== "\\stackrel",
-                            body: je(u)
+                            suppressBaseShift: a !== "\\stackrel",
+                            body: Ge(c)
                         },
-                        S = {
+                        _ = {
                             type: "supsub",
-                            mode: p.mode,
+                            mode: m.mode,
                             base: v,
-                            sup: s === "\\underset" ? null : p,
-                            sub: s === "\\underset" ? p : null
+                            sup: a === "\\underset" ? null : m,
+                            sub: a === "\\underset" ? m : null
                         };
                     return {
                         type: "mclass",
-                        mode: o.mode,
-                        mclass: b,
-                        body: [S],
-                        isCharacterBox: R.isCharacterBox(S)
+                        mode: u.mode,
+                        mclass: g,
+                        body: [_],
+                        isCharacterBox: N.isCharacterBox(_)
                     }
                 },
-                htmlBuilder: ro,
-                mathmlBuilder: no
-            }), Q({
+                htmlBuilder: Qi,
+                mathmlBuilder: Ji
+            }), Z({
                 type: "pmb",
                 names: ["\\pmb"],
                 props: {
                     numArgs: 1,
                     allowedInText: !0
                 },
                 handler(n, t) {
                     let {
-                        parser: o
+                        parser: u
                     } = n;
                     return {
                         type: "pmb",
-                        mode: o.mode,
-                        mclass: t0(t[0]),
-                        body: je(t[0])
+                        mode: u.mode,
+                        mclass: mr(t[0]),
+                        body: Ge(t[0])
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = Ze(n.body, t, !0),
-                        s = B.makeSpan([n.mclass], o, t);
-                    return s.style.textShadow = "0.02em 0.01em 0.04px", s
+                    let u = We(n.body, t, !0),
+                        a = B.makeSpan([n.mclass], u, t);
+                    return a.style.textShadow = "0.02em 0.01em 0.04px", a
                 },
                 mathmlBuilder(n, t) {
-                    let o = it(n.body, t),
-                        s = new V.MathNode("mstyle", o);
-                    return s.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), s
+                    let u = it(n.body, t),
+                        a = new H.MathNode("mstyle", u);
+                    return a.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), a
                 }
             });
-            let k1 = {
+            let mc = {
                     ">": "\\\\cdrightarrow",
                     "<": "\\\\cdleftarrow",
                     "=": "\\\\cdlongequal",
                     A: "\\uparrow",
                     V: "\\downarrow",
                     "|": "\\Vert",
                     ".": "no arrow"
                 },
-                io = () => ({
+                Ki = () => ({
                     type: "styling",
                     body: [],
                     mode: "math",
                     style: "display"
                 }),
-                oo = n => n.type === "textord" && n.text === "@",
-                _1 = (n, t) => (n.type === "mathord" || n.type === "atom") && n.text === t;
+                eo = n => n.type === "textord" && n.text === "@",
+                pc = (n, t) => (n.type === "mathord" || n.type === "atom") && n.text === t;
 
-            function S1(n, t, o) {
-                let s = k1[n];
-                switch (s) {
+            function bc(n, t, u) {
+                let a = mc[n];
+                switch (a) {
                     case "\\\\cdrightarrow":
                     case "\\\\cdleftarrow":
-                        return o.callFunction(s, [t[0]], [t[1]]);
+                        return u.callFunction(a, [t[0]], [t[1]]);
                     case "\\uparrow":
                     case "\\downarrow": {
-                        let u = o.callFunction("\\\\cdleft", [t[0]], []),
-                            p = {
+                        let c = u.callFunction("\\\\cdleft", [t[0]], []),
+                            m = {
                                 type: "atom",
-                                text: s,
+                                text: a,
                                 mode: "math",
                                 family: "rel"
                             },
-                            b = o.callFunction("\\Big", [p], []),
-                            v = o.callFunction("\\\\cdright", [t[1]], []),
-                            S = {
+                            g = u.callFunction("\\Big", [m], []),
+                            v = u.callFunction("\\\\cdright", [t[1]], []),
+                            _ = {
                                 type: "ordgroup",
                                 mode: "math",
-                                body: [u, b, v]
+                                body: [c, g, v]
                             };
-                        return o.callFunction("\\\\cdparent", [S], [])
+                        return u.callFunction("\\\\cdparent", [_], [])
                     }
                     case "\\\\cdlongequal":
-                        return o.callFunction("\\\\cdlongequal", [], []);
+                        return u.callFunction("\\\\cdlongequal", [], []);
                     case "\\Vert": {
-                        let u = {
+                        let c = {
                             type: "textord",
                             text: "\\Vert",
                             mode: "math"
                         };
-                        return o.callFunction("\\Big", [u], [])
+                        return u.callFunction("\\Big", [c], [])
                     }
                     default:
                         return {
                             type: "textord", text: " ", mode: "math"
                         }
                 }
             }
 
-            function C1(n) {
+            function gc(n) {
                 let t = [];
                 for (n.gullet.beginGroup(), n.gullet.macros.set("\\cr", "\\\\\\relax"), n.gullet.beginGroup();;) {
                     t.push(n.parseExpression(!1, "\\\\")), n.gullet.endGroup(), n.gullet.beginGroup();
-                    let p = n.fetch().text;
-                    if (p === "&" || p === "\\\\") n.consume();
-                    else if (p === "\\end") {
+                    let m = n.fetch().text;
+                    if (m === "&" || m === "\\\\") n.consume();
+                    else if (m === "\\end") {
                         t[t.length - 1].length === 0 && t.pop();
                         break
-                    } else throw new a("Expected \\\\ or \\cr or \\end", n.nextToken)
+                    } else throw new o("Expected \\\\ or \\cr or \\end", n.nextToken)
                 }
-                let o = [],
-                    s = [o];
-                for (let p = 0; p < t.length; p++) {
-                    let b = t[p],
-                        v = io();
-                    for (let S = 0; S < b.length; S++)
-                        if (!oo(b[S])) v.body.push(b[S]);
+                let u = [],
+                    a = [u];
+                for (let m = 0; m < t.length; m++) {
+                    let g = t[m],
+                        v = Ki();
+                    for (let _ = 0; _ < g.length; _++)
+                        if (!eo(g[_])) v.body.push(g[_]);
                         else {
-                            o.push(v), S += 1;
-                            let E = on(b[S]).text,
+                            u.push(v), _ += 1;
+                            let D = _n(g[_]).text,
                                 z = new Array(2);
                             if (z[0] = {
                                     type: "ordgroup",
                                     mode: "math",
                                     body: []
                                 }, z[1] = {
                                     type: "ordgroup",
                                     mode: "math",
                                     body: []
-                                }, !("=|.".indexOf(E) > -1))
-                                if ("<>AV".indexOf(E) > -1)
-                                    for (let H = 0; H < 2; H++) {
+                                }, !("=|.".indexOf(D) > -1))
+                                if ("<>AV".indexOf(D) > -1)
+                                    for (let P = 0; P < 2; P++) {
                                         let K = !0;
-                                        for (let ie = S + 1; ie < b.length; ie++) {
-                                            if (_1(b[ie], E)) {
-                                                K = !1, S = ie;
+                                        for (let re = _ + 1; re < g.length; re++) {
+                                            if (pc(g[re], D)) {
+                                                K = !1, _ = re;
                                                 break
                                             }
-                                            if (oo(b[ie])) throw new a("Missing a " + E + " character to complete a CD arrow.", b[ie]);
-                                            z[H].body.push(b[ie])
+                                            if (eo(g[re])) throw new o("Missing a " + D + " character to complete a CD arrow.", g[re]);
+                                            z[P].body.push(g[re])
                                         }
-                                        if (K) throw new a("Missing a " + E + " character to complete a CD arrow.", b[S])
-                                    } else throw new a('Expected one of "<>AV=|." after @', b[S]);
-                            let N = {
+                                        if (K) throw new o("Missing a " + D + " character to complete a CD arrow.", g[_])
+                                    } else throw new o('Expected one of "<>AV=|." after @', g[_]);
+                            let L = {
                                 type: "styling",
-                                body: [S1(E, z, n)],
+                                body: [bc(D, z, n)],
                                 mode: "math",
                                 style: "display"
                             };
-                            o.push(N), v = io()
-                        } p % 2 === 0 ? o.push(v) : o.shift(), o = [], s.push(o)
+                            u.push(L), v = Ki()
+                        } m % 2 === 0 ? u.push(v) : u.shift(), u = [], a.push(u)
                 }
                 n.gullet.endGroup(), n.gullet.endGroup();
-                let u = new Array(s[0].length).fill({
+                let c = new Array(a[0].length).fill({
                     type: "align",
                     align: "c",
                     pregap: .25,
                     postgap: .25
                 });
                 return {
                     type: "array",
                     mode: "math",
-                    body: s,
+                    body: a,
                     arraystretch: 1,
                     addJot: !0,
                     rowGaps: [null],
-                    cols: u,
+                    cols: c,
                     colSeparationType: "CD",
-                    hLinesBeforeRow: new Array(s.length + 1).fill([])
+                    hLinesBeforeRow: new Array(a.length + 1).fill([])
                 }
             }
-            Q({
+            Z({
                 type: "cdlabel",
                 names: ["\\\\cdleft", "\\\\cdright"],
                 props: {
                     numArgs: 1
                 },
                 handler(n, t) {
                     let {
-                        parser: o,
-                        funcName: s
+                        parser: u,
+                        funcName: a
                     } = n;
                     return {
                         type: "cdlabel",
-                        mode: o.mode,
-                        side: s.slice(4),
+                        mode: u.mode,
+                        side: a.slice(4),
                         label: t[0]
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = t.havingStyle(t.style.sup()),
-                        s = B.wrapFragment(ve(n.label, o, t), t);
-                    return s.classes.push("cd-label-" + n.side), s.style.bottom = Z(.8 - s.depth), s.height = 0, s.depth = 0, s
+                    let u = t.havingStyle(t.style.sup()),
+                        a = B.wrapFragment(xe(n.label, u, t), t);
+                    return a.classes.push("cd-label-" + n.side), a.style.bottom = j(.8 - a.depth), a.height = 0, a.depth = 0, a
                 },
                 mathmlBuilder(n, t) {
-                    let o = new V.MathNode("mrow", [Ee(n.label, t)]);
-                    return o = new V.MathNode("mpadded", [o]), o.setAttribute("width", "0"), n.side === "left" && o.setAttribute("lspace", "-1width"), o.setAttribute("voffset", "0.7em"), o = new V.MathNode("mstyle", [o]), o.setAttribute("displaystyle", "false"), o.setAttribute("scriptlevel", "1"), o
+                    let u = new H.MathNode("mrow", [Ae(n.label, t)]);
+                    return u = new H.MathNode("mpadded", [u]), u.setAttribute("width", "0"), n.side === "left" && u.setAttribute("lspace", "-1width"), u.setAttribute("voffset", "0.7em"), u = new H.MathNode("mstyle", [u]), u.setAttribute("displaystyle", "false"), u.setAttribute("scriptlevel", "1"), u
                 }
-            }), Q({
+            }), Z({
                 type: "cdlabelparent",
                 names: ["\\\\cdparent"],
                 props: {
                     numArgs: 1
                 },
                 handler(n, t) {
                     let {
-                        parser: o
+                        parser: u
                     } = n;
                     return {
                         type: "cdlabelparent",
-                        mode: o.mode,
+                        mode: u.mode,
                         fragment: t[0]
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = B.wrapFragment(ve(n.fragment, t), t);
-                    return o.classes.push("cd-vert-arrow"), o
+                    let u = B.wrapFragment(xe(n.fragment, t), t);
+                    return u.classes.push("cd-vert-arrow"), u
                 },
                 mathmlBuilder(n, t) {
-                    return new V.MathNode("mrow", [Ee(n.fragment, t)])
+                    return new H.MathNode("mrow", [Ae(n.fragment, t)])
                 }
-            }), Q({
+            }), Z({
                 type: "textord",
                 names: ["\\@char"],
                 props: {
                     numArgs: 1,
                     allowedInText: !0
                 },
                 handler(n, t) {
                     let {
-                        parser: o
-                    } = n, u = de(t[0], "ordgroup").body, p = "";
-                    for (let S = 0; S < u.length; S++) {
-                        let E = de(u[S], "textord");
-                        p += E.text
+                        parser: u
+                    } = n, c = se(t[0], "ordgroup").body, m = "";
+                    for (let _ = 0; _ < c.length; _++) {
+                        let D = se(c[_], "textord");
+                        m += D.text
                     }
-                    let b = parseInt(p),
+                    let g = parseInt(m),
                         v;
-                    if (isNaN(b)) throw new a("\\@char has non-numeric argument " + p);
-                    if (b < 0 || b >= 1114111) throw new a("\\@char with invalid code point " + p);
-                    return b <= 65535 ? v = String.fromCharCode(b) : (b -= 65536, v = String.fromCharCode((b >> 10) + 55296, (b & 1023) + 56320)), {
+                    if (isNaN(g)) throw new o("\\@char has non-numeric argument " + m);
+                    if (g < 0 || g >= 1114111) throw new o("\\@char with invalid code point " + m);
+                    return g <= 65535 ? v = String.fromCharCode(g) : (g -= 65536, v = String.fromCharCode((g >> 10) + 55296, (g & 1023) + 56320)), {
                         type: "textord",
-                        mode: o.mode,
+                        mode: u.mode,
                         text: v
                     }
                 }
             });
-            let ao = (n, t) => {
-                    let o = Ze(n.body, t.withColor(n.color), !1);
-                    return B.makeFragment(o)
-                },
-                so = (n, t) => {
-                    let o = it(n.body, t.withColor(n.color)),
-                        s = new V.MathNode("mstyle", o);
-                    return s.setAttribute("mathcolor", n.color), s
+            let to = (n, t) => {
+                    let u = We(n.body, t.withColor(n.color), !1);
+                    return B.makeFragment(u)
+                },
+                ro = (n, t) => {
+                    let u = it(n.body, t.withColor(n.color)),
+                        a = new H.MathNode("mstyle", u);
+                    return a.setAttribute("mathcolor", n.color), a
                 };
-            Q({
+            Z({
                 type: "color",
                 names: ["\\textcolor"],
                 props: {
                     numArgs: 2,
                     allowedInText: !0,
                     argTypes: ["color", "original"]
                 },
                 handler(n, t) {
                     let {
-                        parser: o
-                    } = n, s = de(t[0], "color-token").color, u = t[1];
+                        parser: u
+                    } = n, a = se(t[0], "color-token").color, c = t[1];
                     return {
                         type: "color",
-                        mode: o.mode,
-                        color: s,
-                        body: je(u)
+                        mode: u.mode,
+                        color: a,
+                        body: Ge(c)
                     }
                 },
-                htmlBuilder: ao,
-                mathmlBuilder: so
-            }), Q({
+                htmlBuilder: to,
+                mathmlBuilder: ro
+            }), Z({
                 type: "color",
                 names: ["\\color"],
                 props: {
                     numArgs: 1,
                     allowedInText: !0,
                     argTypes: ["color"]
                 },
                 handler(n, t) {
                     let {
-                        parser: o,
-                        breakOnTokenText: s
-                    } = n, u = de(t[0], "color-token").color;
-                    o.gullet.macros.set("\\current@color", u);
-                    let p = o.parseExpression(!0, s);
+                        parser: u,
+                        breakOnTokenText: a
+                    } = n, c = se(t[0], "color-token").color;
+                    u.gullet.macros.set("\\current@color", c);
+                    let m = u.parseExpression(!0, a);
                     return {
                         type: "color",
-                        mode: o.mode,
-                        color: u,
-                        body: p
+                        mode: u.mode,
+                        color: c,
+                        body: m
                     }
                 },
-                htmlBuilder: ao,
-                mathmlBuilder: so
-            }), Q({
+                htmlBuilder: to,
+                mathmlBuilder: ro
+            }), Z({
                 type: "cr",
                 names: ["\\\\"],
                 props: {
                     numArgs: 0,
                     numOptionalArgs: 0,
                     allowedInText: !0
                 },
-                handler(n, t, o) {
+                handler(n, t, u) {
                     let {
-                        parser: s
-                    } = n, u = s.gullet.future().text === "[" ? s.parseSizeGroup(!0) : null, p = !s.settings.displayMode || !s.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
+                        parser: a
+                    } = n, c = a.gullet.future().text === "[" ? a.parseSizeGroup(!0) : null, m = !a.settings.displayMode || !a.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
                     return {
                         type: "cr",
-                        mode: s.mode,
-                        newLine: p,
-                        size: u && de(u, "size").value
+                        mode: a.mode,
+                        newLine: m,
+                        size: c && se(c, "size").value
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = B.makeSpan(["mspace"], [], t);
-                    return n.newLine && (o.classes.push("newline"), n.size && (o.style.marginTop = Z(Ie(n.size, t)))), o
+                    let u = B.makeSpan(["mspace"], [], t);
+                    return n.newLine && (u.classes.push("newline"), n.size && (u.style.marginTop = j(Le(n.size, t)))), u
                 },
                 mathmlBuilder(n, t) {
-                    let o = new V.MathNode("mspace");
-                    return n.newLine && (o.setAttribute("linebreak", "newline"), n.size && o.setAttribute("height", Z(Ie(n.size, t)))), o
+                    let u = new H.MathNode("mspace");
+                    return n.newLine && (u.setAttribute("linebreak", "newline"), n.size && u.setAttribute("height", j(Le(n.size, t)))), u
                 }
             });
-            let sn = {
+            let Sn = {
                     "\\global": "\\global",
                     "\\long": "\\\\globallong",
                     "\\\\globallong": "\\\\globallong",
                     "\\def": "\\gdef",
                     "\\gdef": "\\gdef",
                     "\\edef": "\\xdef",
                     "\\xdef": "\\xdef",
                     "\\let": "\\\\globallet",
                     "\\futurelet": "\\\\globalfuture"
                 },
-                lo = n => {
+                no = n => {
                     let t = n.text;
-                    if (/^(?:[\\{}$&#^_]|EOF)$/.test(t)) throw new a("Expected a control sequence", n);
+                    if (/^(?:[\\{}$&#^_]|EOF)$/.test(t)) throw new o("Expected a control sequence", n);
                     return t
                 },
-                T1 = n => {
+                xc = n => {
                     let t = n.gullet.popToken();
                     return t.text === "=" && (t = n.gullet.popToken(), t.text === " " && (t = n.gullet.popToken())), t
                 },
-                co = (n, t, o, s) => {
-                    let u = n.gullet.macros.get(o.text);
-                    u == null && (o.noexpand = !0, u = {
-                        tokens: [o],
+                uo = (n, t, u, a) => {
+                    let c = n.gullet.macros.get(u.text);
+                    c == null && (u.noexpand = !0, c = {
+                        tokens: [u],
                         numArgs: 0,
-                        unexpandable: !n.gullet.isExpandable(o.text)
-                    }), n.gullet.macros.set(t, u, s)
+                        unexpandable: !n.gullet.isExpandable(u.text)
+                    }), n.gullet.macros.set(t, c, a)
                 };
-            Q({
+            Z({
                 type: "internal",
                 names: ["\\global", "\\long", "\\\\globallong"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0
                 },
                 handler(n) {
                     let {
                         parser: t,
-                        funcName: o
+                        funcName: u
                     } = n;
                     t.consumeSpaces();
-                    let s = t.fetch();
-                    if (sn[s.text]) return (o === "\\global" || o === "\\\\globallong") && (s.text = sn[s.text]), de(t.parseFunction(), "internal");
-                    throw new a("Invalid token after macro prefix", s)
+                    let a = t.fetch();
+                    if (Sn[a.text]) return (u === "\\global" || u === "\\\\globallong") && (a.text = Sn[a.text]), se(t.parseFunction(), "internal");
+                    throw new o("Invalid token after macro prefix", a)
                 }
-            }), Q({
+            }), Z({
                 type: "internal",
                 names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0,
                     primitive: !0
                 },
                 handler(n) {
                     let {
                         parser: t,
-                        funcName: o
-                    } = n, s = t.gullet.popToken(), u = s.text;
-                    if (/^(?:[\\{}$&#^_]|EOF)$/.test(u)) throw new a("Expected a control sequence", s);
-                    let p = 0,
-                        b, v = [
+                        funcName: u
+                    } = n, a = t.gullet.popToken(), c = a.text;
+                    if (/^(?:[\\{}$&#^_]|EOF)$/.test(c)) throw new o("Expected a control sequence", a);
+                    let m = 0,
+                        g, v = [
                             []
                         ];
                     for (; t.gullet.future().text !== "{";)
-                        if (s = t.gullet.popToken(), s.text === "#") {
+                        if (a = t.gullet.popToken(), a.text === "#") {
                             if (t.gullet.future().text === "{") {
-                                b = t.gullet.future(), v[p].push("{");
+                                g = t.gullet.future(), v[m].push("{");
                                 break
                             }
-                            if (s = t.gullet.popToken(), !/^[1-9]$/.test(s.text)) throw new a('Invalid argument number "' + s.text + '"');
-                            if (parseInt(s.text) !== p + 1) throw new a('Argument number "' + s.text + '" out of order');
-                            p++, v.push([])
+                            if (a = t.gullet.popToken(), !/^[1-9]$/.test(a.text)) throw new o('Invalid argument number "' + a.text + '"');
+                            if (parseInt(a.text) !== m + 1) throw new o('Argument number "' + a.text + '" out of order');
+                            m++, v.push([])
                         } else {
-                            if (s.text === "EOF") throw new a("Expected a macro definition");
-                            v[p].push(s.text)
+                            if (a.text === "EOF") throw new o("Expected a macro definition");
+                            v[m].push(a.text)
                         } let {
-                        tokens: S
+                        tokens: _
                     } = t.gullet.consumeArg();
-                    return b && S.unshift(b), (o === "\\edef" || o === "\\xdef") && (S = t.gullet.expandTokens(S), S.reverse()), t.gullet.macros.set(u, {
-                        tokens: S,
-                        numArgs: p,
+                    return g && _.unshift(g), (u === "\\edef" || u === "\\xdef") && (_ = t.gullet.expandTokens(_), _.reverse()), t.gullet.macros.set(c, {
+                        tokens: _,
+                        numArgs: m,
                         delimiters: v
-                    }, o === sn[o]), {
+                    }, u === Sn[u]), {
                         type: "internal",
                         mode: t.mode
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "internal",
                 names: ["\\let", "\\\\globallet"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0,
                     primitive: !0
                 },
                 handler(n) {
                     let {
                         parser: t,
-                        funcName: o
-                    } = n, s = lo(t.gullet.popToken());
+                        funcName: u
+                    } = n, a = no(t.gullet.popToken());
                     t.gullet.consumeSpaces();
-                    let u = T1(t);
-                    return co(t, s, u, o === "\\\\globallet"), {
+                    let c = xc(t);
+                    return uo(t, a, c, u === "\\\\globallet"), {
                         type: "internal",
                         mode: t.mode
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "internal",
                 names: ["\\futurelet", "\\\\globalfuture"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0,
                     primitive: !0
                 },
                 handler(n) {
                     let {
                         parser: t,
-                        funcName: o
-                    } = n, s = lo(t.gullet.popToken()), u = t.gullet.popToken(), p = t.gullet.popToken();
-                    return co(t, s, p, o === "\\\\globalfuture"), t.gullet.pushToken(p), t.gullet.pushToken(u), {
+                        funcName: u
+                    } = n, a = no(t.gullet.popToken()), c = t.gullet.popToken(), m = t.gullet.popToken();
+                    return uo(t, a, m, u === "\\\\globalfuture"), t.gullet.pushToken(m), t.gullet.pushToken(c), {
                         type: "internal",
                         mode: t.mode
                     }
                 }
             });
-            let _r = function(n, t, o) {
-                    let s = Oe.math[n] && Oe.math[n].replace,
-                        u = j0(s || n, t, o);
-                    if (!u) throw new Error("Unsupported symbol " + n + " and font size " + t + ".");
-                    return u
+            let B0 = function(n, t, u) {
+                    let a = Pe.math[n] && Pe.math[n].replace,
+                        c = cn(a || n, t, u);
+                    if (!c) throw new Error("Unsupported symbol " + n + " and font size " + t + ".");
+                    return c
                 },
-                ln = function(n, t, o, s) {
-                    let u = o.havingBaseStyle(t),
-                        p = B.makeSpan(s.concat(u.sizingClasses(o)), [n], o),
-                        b = u.sizeMultiplier / o.sizeMultiplier;
-                    return p.height *= b, p.depth *= b, p.maxFontSize = u.sizeMultiplier, p
-                },
-                uo = function(n, t, o) {
-                    let s = t.havingBaseStyle(o),
-                        u = (1 - t.sizeMultiplier / s.sizeMultiplier) * t.fontMetrics().axisHeight;
-                    n.classes.push("delimcenter"), n.style.top = Z(u), n.height -= u, n.depth += u
-                },
-                A1 = function(n, t, o, s, u, p) {
-                    let b = B.makeSymbol(n, "Main-Regular", u, s),
-                        v = ln(b, t, s, p);
-                    return o && uo(v, s, t), v
-                },
-                q1 = function(n, t, o, s) {
-                    return B.makeSymbol(n, "Size" + t + "-Regular", o, s)
-                },
-                ho = function(n, t, o, s, u, p) {
-                    let b = q1(n, t, u, s),
-                        v = ln(B.makeSpan(["delimsizing", "size" + t], [b], s), G.TEXT, s, p);
-                    return o && uo(v, s, G.TEXT), v
-                },
-                cn = function(n, t, o) {
-                    let s;
-                    return t === "Size1-Regular" ? s = "delim-size1" : s = "delim-size4", {
+                An = function(n, t, u, a) {
+                    let c = u.havingBaseStyle(t),
+                        m = B.makeSpan(a.concat(c.sizingClasses(u)), [n], u),
+                        g = c.sizeMultiplier / u.sizeMultiplier;
+                    return m.height *= g, m.depth *= g, m.maxFontSize = c.sizeMultiplier, m
+                },
+                io = function(n, t, u) {
+                    let a = t.havingBaseStyle(u),
+                        c = (1 - t.sizeMultiplier / a.sizeMultiplier) * t.fontMetrics().axisHeight;
+                    n.classes.push("delimcenter"), n.style.top = j(c), n.height -= c, n.depth += c
+                },
+                yc = function(n, t, u, a, c, m) {
+                    let g = B.makeSymbol(n, "Main-Regular", c, a),
+                        v = An(g, t, a, m);
+                    return u && io(v, a, t), v
+                },
+                vc = function(n, t, u, a) {
+                    return B.makeSymbol(n, "Size" + t + "-Regular", u, a)
+                },
+                oo = function(n, t, u, a, c, m) {
+                    let g = vc(n, t, c, a),
+                        v = An(B.makeSpan(["delimsizing", "size" + t], [g], a), O.TEXT, a, m);
+                    return u && io(v, a, O.TEXT), v
+                },
+                Tn = function(n, t, u) {
+                    let a;
+                    return t === "Size1-Regular" ? a = "delim-size1" : a = "delim-size4", {
                         type: "elem",
-                        elem: B.makeSpan(["delimsizinginner", s], [B.makeSpan([], [B.makeSymbol(n, t, o)])])
+                        elem: B.makeSpan(["delimsizinginner", a], [B.makeSpan([], [B.makeSymbol(n, t, u)])])
                     }
                 },
-                un = function(n, t, o) {
-                    let s = vt["Size4-Regular"][n.charCodeAt(0)] ? vt["Size4-Regular"][n.charCodeAt(0)][4] : vt["Size1-Regular"][n.charCodeAt(0)][4],
-                        u = new Ot("inner", Lu(n, Math.round(1e3 * t))),
-                        p = new Et([u], {
-                            width: Z(s),
-                            height: Z(t),
-                            style: "width:" + Z(s),
-                            viewBox: "0 0 " + 1e3 * s + " " + Math.round(1e3 * t),
+                Dn = function(n, t, u) {
+                    let a = wt["Size4-Regular"][n.charCodeAt(0)] ? wt["Size4-Regular"][n.charCodeAt(0)][4] : wt["Size1-Regular"][n.charCodeAt(0)][4],
+                        c = new Ut("inner", El(n, Math.round(1e3 * t))),
+                        m = new Ft([c], {
+                            width: j(a),
+                            height: j(t),
+                            style: "width:" + j(a),
+                            viewBox: "0 0 " + 1e3 * a + " " + Math.round(1e3 * t),
                             preserveAspectRatio: "xMinYMin"
                         }),
-                        b = B.makeSvgSpan([], [p], o);
-                    return b.height = t, b.style.height = Z(t), b.style.width = Z(s), {
+                        g = B.makeSvgSpan([], [m], u);
+                    return g.height = t, g.style.height = j(t), g.style.width = j(a), {
                         type: "elem",
-                        elem: b
+                        elem: g
                     }
                 },
-                hn = .008,
-                r0 = {
+                En = .008,
+                pr = {
                     type: "kern",
-                    size: -1 * hn
+                    size: -1 * En
                 },
-                M1 = ["|", "\\lvert", "\\rvert", "\\vert"],
-                E1 = ["\\|", "\\lVert", "\\rVert", "\\Vert"],
-                mo = function(n, t, o, s, u, p) {
-                    let b, v, S, E, z = "",
-                        F = 0;
-                    b = S = E = n, v = null;
-                    let N = "Size1-Regular";
-                    n === "\\uparrow" ? S = E = "\u23D0" : n === "\\Uparrow" ? S = E = "\u2016" : n === "\\downarrow" ? b = S = "\u23D0" : n === "\\Downarrow" ? b = S = "\u2016" : n === "\\updownarrow" ? (b = "\\uparrow", S = "\u23D0", E = "\\downarrow") : n === "\\Updownarrow" ? (b = "\\Uparrow", S = "\u2016", E = "\\Downarrow") : R.contains(M1, n) ? (S = "\u2223", z = "vert", F = 333) : R.contains(E1, n) ? (S = "\u2225", z = "doublevert", F = 556) : n === "[" || n === "\\lbrack" ? (b = "\u23A1", S = "\u23A2", E = "\u23A3", N = "Size4-Regular", z = "lbrack", F = 667) : n === "]" || n === "\\rbrack" ? (b = "\u23A4", S = "\u23A5", E = "\u23A6", N = "Size4-Regular", z = "rbrack", F = 667) : n === "\\lfloor" || n === "\u230A" ? (S = b = "\u23A2", E = "\u23A3", N = "Size4-Regular", z = "lfloor", F = 667) : n === "\\lceil" || n === "\u2308" ? (b = "\u23A1", S = E = "\u23A2", N = "Size4-Regular", z = "lceil", F = 667) : n === "\\rfloor" || n === "\u230B" ? (S = b = "\u23A5", E = "\u23A6", N = "Size4-Regular", z = "rfloor", F = 667) : n === "\\rceil" || n === "\u2309" ? (b = "\u23A4", S = E = "\u23A5", N = "Size4-Regular", z = "rceil", F = 667) : n === "(" || n === "\\lparen" ? (b = "\u239B", S = "\u239C", E = "\u239D", N = "Size4-Regular", z = "lparen", F = 875) : n === ")" || n === "\\rparen" ? (b = "\u239E", S = "\u239F", E = "\u23A0", N = "Size4-Regular", z = "rparen", F = 875) : n === "\\{" || n === "\\lbrace" ? (b = "\u23A7", v = "\u23A8", E = "\u23A9", S = "\u23AA", N = "Size4-Regular") : n === "\\}" || n === "\\rbrace" ? (b = "\u23AB", v = "\u23AC", E = "\u23AD", S = "\u23AA", N = "Size4-Regular") : n === "\\lgroup" || n === "\u27EE" ? (b = "\u23A7", E = "\u23A9", S = "\u23AA", N = "Size4-Regular") : n === "\\rgroup" || n === "\u27EF" ? (b = "\u23AB", E = "\u23AD", S = "\u23AA", N = "Size4-Regular") : n === "\\lmoustache" || n === "\u23B0" ? (b = "\u23A7", E = "\u23AD", S = "\u23AA", N = "Size4-Regular") : (n === "\\rmoustache" || n === "\u23B1") && (b = "\u23AB", E = "\u23A9", S = "\u23AA", N = "Size4-Regular");
-                    let H = _r(b, N, u),
-                        K = H.height + H.depth,
-                        ie = _r(S, N, u),
-                        ye = ie.height + ie.depth,
-                        ge = _r(E, N, u),
-                        xe = ge.height + ge.depth,
-                        ke = 0,
-                        ze = 1;
+                wc = ["|", "\\lvert", "\\rvert", "\\vert"],
+                kc = ["\\|", "\\lVert", "\\rVert", "\\Vert"],
+                ao = function(n, t, u, a, c, m) {
+                    let g, v, _, D, z = "",
+                        R = 0;
+                    g = _ = D = n, v = null;
+                    let L = "Size1-Regular";
+                    n === "\\uparrow" ? _ = D = "\u23D0" : n === "\\Uparrow" ? _ = D = "\u2016" : n === "\\downarrow" ? g = _ = "\u23D0" : n === "\\Downarrow" ? g = _ = "\u2016" : n === "\\updownarrow" ? (g = "\\uparrow", _ = "\u23D0", D = "\\downarrow") : n === "\\Updownarrow" ? (g = "\\Uparrow", _ = "\u2016", D = "\\Downarrow") : N.contains(wc, n) ? (_ = "\u2223", z = "vert", R = 333) : N.contains(kc, n) ? (_ = "\u2225", z = "doublevert", R = 556) : n === "[" || n === "\\lbrack" ? (g = "\u23A1", _ = "\u23A2", D = "\u23A3", L = "Size4-Regular", z = "lbrack", R = 667) : n === "]" || n === "\\rbrack" ? (g = "\u23A4", _ = "\u23A5", D = "\u23A6", L = "Size4-Regular", z = "rbrack", R = 667) : n === "\\lfloor" || n === "\u230A" ? (_ = g = "\u23A2", D = "\u23A3", L = "Size4-Regular", z = "lfloor", R = 667) : n === "\\lceil" || n === "\u2308" ? (g = "\u23A1", _ = D = "\u23A2", L = "Size4-Regular", z = "lceil", R = 667) : n === "\\rfloor" || n === "\u230B" ? (_ = g = "\u23A5", D = "\u23A6", L = "Size4-Regular", z = "rfloor", R = 667) : n === "\\rceil" || n === "\u2309" ? (g = "\u23A4", _ = D = "\u23A5", L = "Size4-Regular", z = "rceil", R = 667) : n === "(" || n === "\\lparen" ? (g = "\u239B", _ = "\u239C", D = "\u239D", L = "Size4-Regular", z = "lparen", R = 875) : n === ")" || n === "\\rparen" ? (g = "\u239E", _ = "\u239F", D = "\u23A0", L = "Size4-Regular", z = "rparen", R = 875) : n === "\\{" || n === "\\lbrace" ? (g = "\u23A7", v = "\u23A8", D = "\u23A9", _ = "\u23AA", L = "Size4-Regular") : n === "\\}" || n === "\\rbrace" ? (g = "\u23AB", v = "\u23AC", D = "\u23AD", _ = "\u23AA", L = "Size4-Regular") : n === "\\lgroup" || n === "\u27EE" ? (g = "\u23A7", D = "\u23A9", _ = "\u23AA", L = "Size4-Regular") : n === "\\rgroup" || n === "\u27EF" ? (g = "\u23AB", D = "\u23AD", _ = "\u23AA", L = "Size4-Regular") : n === "\\lmoustache" || n === "\u23B0" ? (g = "\u23A7", D = "\u23AD", _ = "\u23AA", L = "Size4-Regular") : (n === "\\rmoustache" || n === "\u23B1") && (g = "\u23AB", D = "\u23A9", _ = "\u23AA", L = "Size4-Regular");
+                    let P = B0(g, L, c),
+                        K = P.height + P.depth,
+                        re = B0(_, L, c),
+                        pe = re.height + re.depth,
+                        de = B0(D, L, c),
+                        be = de.height + de.depth,
+                        ve = 0,
+                        Te = 1;
                     if (v !== null) {
-                        let Ve = _r(v, N, u);
-                        ke = Ve.height + Ve.depth, ze = 2
+                        let $e = B0(v, L, c);
+                        ve = $e.height + $e.depth, Te = 2
                     }
-                    let tt = K + xe + ke,
-                        Qe = Math.max(0, Math.ceil((t - tt) / (ze * ye))),
-                        pt = tt + Qe * ze * ye,
-                        cr = s.fontMetrics().axisHeight;
-                    o && (cr *= s.sizeMultiplier);
-                    let we = pt / 2 - cr,
-                        qe = [];
+                    let tt = K + be + ve,
+                        Ye = Math.max(0, Math.ceil((t - tt) / (Te * pe))),
+                        pt = tt + Ye * Te * pe,
+                        y0 = a.fontMetrics().axisHeight;
+                    u && (y0 *= a.sizeMultiplier);
+                    let ye = pt / 2 - y0,
+                        Ce = [];
                     if (z.length > 0) {
-                        let Ve = pt - K - xe,
-                            $e = Math.round(pt * 1e3),
-                            ft = Pu(z, Math.round(Ve * 1e3)),
-                            rh = new Ot(z, ft),
-                            na = (F / 1e3).toFixed(3) + "em",
-                            ia = ($e / 1e3).toFixed(3) + "em",
-                            nh = new Et([rh], {
-                                width: na,
-                                height: ia,
-                                viewBox: "0 0 " + F + " " + $e
+                        let $e = pt - K - be,
+                            Oe = Math.round(pt * 1e3),
+                            bt = Ml(z, Math.round($e * 1e3)),
+                            Yc = new Ut(z, bt),
+                            Jo = (R / 1e3).toFixed(3) + "em",
+                            Ko = (Oe / 1e3).toFixed(3) + "em",
+                            Zc = new Ft([Yc], {
+                                width: Jo,
+                                height: Ko,
+                                viewBox: "0 0 " + R + " " + Oe
                             }),
-                            s0 = B.makeSvgSpan([], [nh], s);
-                        s0.height = $e / 1e3, s0.style.width = na, s0.style.height = ia, qe.push({
+                            vr = B.makeSvgSpan([], [Zc], a);
+                        vr.height = Oe / 1e3, vr.style.width = Jo, vr.style.height = Ko, Ce.push({
                             type: "elem",
-                            elem: s0
+                            elem: vr
                         })
                     } else {
-                        if (qe.push(cn(E, N, u)), qe.push(r0), v === null) {
-                            let Ve = pt - K - xe + 2 * hn;
-                            qe.push(un(S, Ve, s))
+                        if (Ce.push(Tn(D, L, c)), Ce.push(pr), v === null) {
+                            let $e = pt - K - be + 2 * En;
+                            Ce.push(Dn(_, $e, a))
                         } else {
-                            let Ve = (pt - K - xe - ke) / 2 + 2 * hn;
-                            qe.push(un(S, Ve, s)), qe.push(r0), qe.push(cn(v, N, u)), qe.push(r0), qe.push(un(S, Ve, s))
+                            let $e = (pt - K - be - ve) / 2 + 2 * En;
+                            Ce.push(Dn(_, $e, a)), Ce.push(pr), Ce.push(Tn(v, L, c)), Ce.push(pr), Ce.push(Dn(_, $e, a))
                         }
-                        qe.push(r0), qe.push(cn(b, N, u))
+                        Ce.push(pr), Ce.push(Tn(g, L, c))
                     }
-                    let Fe = s.havingBaseStyle(G.TEXT),
-                        Ne = B.makeVList({
+                    let Me = a.havingBaseStyle(O.TEXT),
+                        ze = B.makeVList({
                             positionType: "bottom",
-                            positionData: we,
-                            children: qe
-                        }, Fe);
-                    return ln(B.makeSpan(["delimsizing", "mult"], [Ne], Fe), G.TEXT, s, p)
-                },
-                dn = 80,
-                mn = .08,
-                pn = function(n, t, o, s, u) {
-                    let p = Nu(n, s, o),
-                        b = new Ot(n, p),
-                        v = new Et([b], {
+                            positionData: ye,
+                            children: Ce
+                        }, Me);
+                    return An(B.makeSpan(["delimsizing", "mult"], [ze], Me), O.TEXT, a, m)
+                },
+                Mn = 80,
+                qn = .08,
+                Fn = function(n, t, u, a, c) {
+                    let m = Dl(n, a, u),
+                        g = new Ut(n, m),
+                        v = new Ft([g], {
                             width: "400em",
-                            height: Z(t),
-                            viewBox: "0 0 400000 " + o,
+                            height: j(t),
+                            viewBox: "0 0 400000 " + u,
                             preserveAspectRatio: "xMinYMin slice"
                         });
-                    return B.makeSvgSpan(["hide-tail"], [v], u)
+                    return B.makeSvgSpan(["hide-tail"], [v], c)
                 },
-                D1 = function(n, t) {
-                    let o = t.havingBaseSizing(),
-                        s = bo("\\surd", n * o.sizeMultiplier, go, o),
-                        u = o.sizeMultiplier,
-                        p = Math.max(0, t.minRuleThickness - t.fontMetrics().sqrtRuleThickness),
-                        b, v = 0,
-                        S = 0,
-                        E = 0,
+                _c = function(n, t) {
+                    let u = t.havingBaseSizing(),
+                        a = ho("\\surd", n * u.sizeMultiplier, co, u),
+                        c = u.sizeMultiplier,
+                        m = Math.max(0, t.minRuleThickness - t.fontMetrics().sqrtRuleThickness),
+                        g, v = 0,
+                        _ = 0,
+                        D = 0,
                         z;
-                    return s.type === "small" ? (E = 1e3 + 1e3 * p + dn, n < 1 ? u = 1 : n < 1.4 && (u = .7), v = (1 + p + mn) / u, S = (1 + p) / u, b = pn("sqrtMain", v, E, p, t), b.style.minWidth = "0.853em", z = .833 / u) : s.type === "large" ? (E = (1e3 + dn) * Sr[s.size], S = (Sr[s.size] + p) / u, v = (Sr[s.size] + p + mn) / u, b = pn("sqrtSize" + s.size, v, E, p, t), b.style.minWidth = "1.02em", z = 1 / u) : (v = n + p + mn, S = n + p, E = Math.floor(1e3 * n + p) + dn, b = pn("sqrtTall", v, E, p, t), b.style.minWidth = "0.742em", z = 1.056), b.height = S, b.style.height = Z(v), {
-                        span: b,
+                    return a.type === "small" ? (D = 1e3 + 1e3 * m + Mn, n < 1 ? c = 1 : n < 1.4 && (c = .7), v = (1 + m + qn) / c, _ = (1 + m) / c, g = Fn("sqrtMain", v, D, m, t), g.style.minWidth = "0.853em", z = .833 / c) : a.type === "large" ? (D = (1e3 + Mn) * N0[a.size], _ = (N0[a.size] + m) / c, v = (N0[a.size] + m + qn) / c, g = Fn("sqrtSize" + a.size, v, D, m, t), g.style.minWidth = "1.02em", z = 1 / c) : (v = n + m + qn, _ = n + m, D = Math.floor(1e3 * n + m) + Mn, g = Fn("sqrtTall", v, D, m, t), g.style.minWidth = "0.742em", z = 1.056), g.height = _, g.style.height = j(v), {
+                        span: g,
                         advanceWidth: z,
-                        ruleWidth: (t.fontMetrics().sqrtRuleThickness + p) * u
+                        ruleWidth: (t.fontMetrics().sqrtRuleThickness + m) * c
                     }
                 },
-                po = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"],
-                z1 = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"],
-                fo = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"],
-                Sr = [0, 1.2, 1.8, 2.4, 3],
-                R1 = function(n, t, o, s, u) {
-                    if (n === "<" || n === "\\lt" || n === "\u27E8" ? n = "\\langle" : (n === ">" || n === "\\gt" || n === "\u27E9") && (n = "\\rangle"), R.contains(po, n) || R.contains(fo, n)) return ho(n, t, !1, o, s, u);
-                    if (R.contains(z1, n)) return mo(n, Sr[t], !1, o, s, u);
-                    throw new a("Illegal delimiter: '" + n + "'")
+                so = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"],
+                Cc = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"],
+                lo = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"],
+                N0 = [0, 1.2, 1.8, 2.4, 3],
+                Sc = function(n, t, u, a, c) {
+                    if (n === "<" || n === "\\lt" || n === "\u27E8" ? n = "\\langle" : (n === ">" || n === "\\gt" || n === "\u27E9") && (n = "\\rangle"), N.contains(so, n) || N.contains(lo, n)) return oo(n, t, !1, u, a, c);
+                    if (N.contains(Cc, n)) return ao(n, N0[t], !1, u, a, c);
+                    throw new o("Illegal delimiter: '" + n + "'")
                 },
-                F1 = [{
+                Ac = [{
                     type: "small",
-                    style: G.SCRIPTSCRIPT
+                    style: O.SCRIPTSCRIPT
                 }, {
                     type: "small",
-                    style: G.SCRIPT
+                    style: O.SCRIPT
                 }, {
                     type: "small",
-                    style: G.TEXT
+                    style: O.TEXT
                 }, {
                     type: "large",
                     size: 1
                 }, {
                     type: "large",
                     size: 2
                 }, {
                     type: "large",
                     size: 3
                 }, {
                     type: "large",
                     size: 4
                 }],
-                B1 = [{
+                Tc = [{
                     type: "small",
-                    style: G.SCRIPTSCRIPT
+                    style: O.SCRIPTSCRIPT
                 }, {
                     type: "small",
-                    style: G.SCRIPT
+                    style: O.SCRIPT
                 }, {
                     type: "small",
-                    style: G.TEXT
+                    style: O.TEXT
                 }, {
                     type: "stack"
                 }],
-                go = [{
+                co = [{
                     type: "small",
-                    style: G.SCRIPTSCRIPT
+                    style: O.SCRIPTSCRIPT
                 }, {
                     type: "small",
-                    style: G.SCRIPT
+                    style: O.SCRIPT
                 }, {
                     type: "small",
-                    style: G.TEXT
+                    style: O.TEXT
                 }, {
                     type: "large",
                     size: 1
                 }, {
                     type: "large",
                     size: 2
                 }, {
@@ -11145,55 +6735,55 @@
                     size: 3
                 }, {
                     type: "large",
                     size: 4
                 }, {
                     type: "stack"
                 }],
-                N1 = function(n) {
+                Dc = function(n) {
                     if (n.type === "small") return "Main-Regular";
                     if (n.type === "large") return "Size" + n.size + "-Regular";
                     if (n.type === "stack") return "Size4-Regular";
                     throw new Error("Add support for delim type '" + n.type + "' here.")
                 },
-                bo = function(n, t, o, s) {
-                    let u = Math.min(2, 3 - s.style.size);
-                    for (let p = u; p < o.length && o[p].type !== "stack"; p++) {
-                        let b = _r(n, N1(o[p]), "math"),
-                            v = b.height + b.depth;
-                        if (o[p].type === "small") {
-                            let S = s.havingBaseStyle(o[p].style);
-                            v *= S.sizeMultiplier
+                ho = function(n, t, u, a) {
+                    let c = Math.min(2, 3 - a.style.size);
+                    for (let m = c; m < u.length && u[m].type !== "stack"; m++) {
+                        let g = B0(n, Dc(u[m]), "math"),
+                            v = g.height + g.depth;
+                        if (u[m].type === "small") {
+                            let _ = a.havingBaseStyle(u[m].style);
+                            v *= _.sizeMultiplier
                         }
-                        if (v > t) return o[p]
+                        if (v > t) return u[m]
                     }
-                    return o[o.length - 1]
+                    return u[u.length - 1]
                 },
-                yo = function(n, t, o, s, u, p) {
+                fo = function(n, t, u, a, c, m) {
                     n === "<" || n === "\\lt" || n === "\u27E8" ? n = "\\langle" : (n === ">" || n === "\\gt" || n === "\u27E9") && (n = "\\rangle");
-                    let b;
-                    R.contains(fo, n) ? b = F1 : R.contains(po, n) ? b = go : b = B1;
-                    let v = bo(n, t, b, s);
-                    return v.type === "small" ? A1(n, v.style, o, s, u, p) : v.type === "large" ? ho(n, v.size, o, s, u, p) : mo(n, t, o, s, u, p)
+                    let g;
+                    N.contains(lo, n) ? g = Ac : N.contains(so, n) ? g = co : g = Tc;
+                    let v = ho(n, t, g, a);
+                    return v.type === "small" ? yc(n, v.style, u, a, c, m) : v.type === "large" ? oo(n, v.size, u, a, c, m) : ao(n, t, u, a, c, m)
                 };
-            var Bt = {
-                sqrtImage: D1,
-                sizedDelim: R1,
-                sizeToMaxHeight: Sr,
-                customSizedDelim: yo,
-                leftRightDelim: function(n, t, o, s, u, p) {
-                    let b = s.fontMetrics().axisHeight * s.sizeMultiplier,
+            var Lt = {
+                sqrtImage: _c,
+                sizedDelim: Sc,
+                sizeToMaxHeight: N0,
+                customSizedDelim: fo,
+                leftRightDelim: function(n, t, u, a, c, m) {
+                    let g = a.fontMetrics().axisHeight * a.sizeMultiplier,
                         v = 901,
-                        S = 5 / s.fontMetrics().ptPerEm,
-                        E = Math.max(t - b, o + b),
-                        z = Math.max(E / 500 * v, 2 * E - S);
-                    return yo(n, z, !0, s, u, p)
+                        _ = 5 / a.fontMetrics().ptPerEm,
+                        D = Math.max(t - g, u + g),
+                        z = Math.max(D / 500 * v, 2 * D - _);
+                    return fo(n, z, !0, a, c, m)
                 }
             };
-            let xo = {
+            let mo = {
                     "\\bigl": {
                         mclass: "mopen",
                         size: 1
                     },
                     "\\Bigl": {
                         mclass: "mopen",
                         size: 2
@@ -11251,847 +6841,847 @@
                         size: 3
                     },
                     "\\Bigg": {
                         mclass: "mord",
                         size: 4
                     }
                 },
-                L1 = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
+                Ec = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
 
-            function n0(n, t) {
-                let o = Kr(n);
-                if (o && R.contains(L1, o.text)) return o;
-                throw o ? new a("Invalid delimiter '" + o.text + "' after '" + t.funcName + "'", n) : new a("Invalid delimiter type '" + n.type + "'", n)
+            function br(n, t) {
+                let u = hr(n);
+                if (u && N.contains(Ec, u.text)) return u;
+                throw u ? new o("Invalid delimiter '" + u.text + "' after '" + t.funcName + "'", n) : new o("Invalid delimiter type '" + n.type + "'", n)
             }
-            Q({
+            Z({
                 type: "delimsizing",
                 names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
                 props: {
                     numArgs: 1,
                     argTypes: ["primitive"]
                 },
                 handler: (n, t) => {
-                    let o = n0(t[0], n);
+                    let u = br(t[0], n);
                     return {
                         type: "delimsizing",
                         mode: n.parser.mode,
-                        size: xo[n.funcName].size,
-                        mclass: xo[n.funcName].mclass,
-                        delim: o.text
+                        size: mo[n.funcName].size,
+                        mclass: mo[n.funcName].mclass,
+                        delim: u.text
                     }
                 },
-                htmlBuilder: (n, t) => n.delim === "." ? B.makeSpan([n.mclass]) : Bt.sizedDelim(n.delim, n.size, t, n.mode, [n.mclass]),
+                htmlBuilder: (n, t) => n.delim === "." ? B.makeSpan([n.mclass]) : Lt.sizedDelim(n.delim, n.size, t, n.mode, [n.mclass]),
                 mathmlBuilder: n => {
                     let t = [];
-                    n.delim !== "." && t.push(dt(n.delim, n.mode));
-                    let o = new V.MathNode("mo", t);
-                    n.mclass === "mopen" || n.mclass === "mclose" ? o.setAttribute("fence", "true") : o.setAttribute("fence", "false"), o.setAttribute("stretchy", "true");
-                    let s = Z(Bt.sizeToMaxHeight[n.size]);
-                    return o.setAttribute("minsize", s), o.setAttribute("maxsize", s), o
+                    n.delim !== "." && t.push(ft(n.delim, n.mode));
+                    let u = new H.MathNode("mo", t);
+                    n.mclass === "mopen" || n.mclass === "mclose" ? u.setAttribute("fence", "true") : u.setAttribute("fence", "false"), u.setAttribute("stretchy", "true");
+                    let a = j(Lt.sizeToMaxHeight[n.size]);
+                    return u.setAttribute("minsize", a), u.setAttribute("maxsize", a), u
                 }
             });
 
-            function vo(n) {
+            function po(n) {
                 if (!n.body) throw new Error("Bug: The leftright ParseNode wasn't fully parsed.")
             }
-            Q({
+            Z({
                 type: "leftright-right",
                 names: ["\\right"],
                 props: {
                     numArgs: 1,
                     primitive: !0
                 },
                 handler: (n, t) => {
-                    let o = n.parser.gullet.macros.get("\\current@color");
-                    if (o && typeof o != "string") throw new a("\\current@color set to non-string in \\right");
+                    let u = n.parser.gullet.macros.get("\\current@color");
+                    if (u && typeof u != "string") throw new o("\\current@color set to non-string in \\right");
                     return {
                         type: "leftright-right",
                         mode: n.parser.mode,
-                        delim: n0(t[0], n).text,
-                        color: o
+                        delim: br(t[0], n).text,
+                        color: u
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "leftright",
                 names: ["\\left"],
                 props: {
                     numArgs: 1,
                     primitive: !0
                 },
                 handler: (n, t) => {
-                    let o = n0(t[0], n),
-                        s = n.parser;
-                    ++s.leftrightDepth;
-                    let u = s.parseExpression(!1);
-                    --s.leftrightDepth, s.expect("\\right", !1);
-                    let p = de(s.parseFunction(), "leftright-right");
+                    let u = br(t[0], n),
+                        a = n.parser;
+                    ++a.leftrightDepth;
+                    let c = a.parseExpression(!1);
+                    --a.leftrightDepth, a.expect("\\right", !1);
+                    let m = se(a.parseFunction(), "leftright-right");
                     return {
                         type: "leftright",
-                        mode: s.mode,
-                        body: u,
-                        left: o.text,
-                        right: p.delim,
-                        rightColor: p.color
+                        mode: a.mode,
+                        body: c,
+                        left: u.text,
+                        right: m.delim,
+                        rightColor: m.color
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    vo(n);
-                    let o = Ze(n.body, t, !0, ["mopen", "mclose"]),
-                        s = 0,
-                        u = 0,
-                        p = !1;
-                    for (let S = 0; S < o.length; S++) o[S].isMiddle ? p = !0 : (s = Math.max(o[S].height, s), u = Math.max(o[S].depth, u));
-                    s *= t.sizeMultiplier, u *= t.sizeMultiplier;
-                    let b;
-                    if (n.left === "." ? b = wr(t, ["mopen"]) : b = Bt.leftRightDelim(n.left, s, u, t, n.mode, ["mopen"]), o.unshift(b), p)
-                        for (let S = 1; S < o.length; S++) {
-                            let z = o[S].isMiddle;
-                            z && (o[S] = Bt.leftRightDelim(z.delim, s, u, z.options, n.mode, []))
+                    po(n);
+                    let u = We(n.body, t, !0, ["mopen", "mclose"]),
+                        a = 0,
+                        c = 0,
+                        m = !1;
+                    for (let _ = 0; _ < u.length; _++) u[_].isMiddle ? m = !0 : (a = Math.max(u[_].height, a), c = Math.max(u[_].depth, c));
+                    a *= t.sizeMultiplier, c *= t.sizeMultiplier;
+                    let g;
+                    if (n.left === "." ? g = z0(t, ["mopen"]) : g = Lt.leftRightDelim(n.left, a, c, t, n.mode, ["mopen"]), u.unshift(g), m)
+                        for (let _ = 1; _ < u.length; _++) {
+                            let z = u[_].isMiddle;
+                            z && (u[_] = Lt.leftRightDelim(z.delim, a, c, z.options, n.mode, []))
                         }
                     let v;
-                    if (n.right === ".") v = wr(t, ["mclose"]);
+                    if (n.right === ".") v = z0(t, ["mclose"]);
                     else {
-                        let S = n.rightColor ? t.withColor(n.rightColor) : t;
-                        v = Bt.leftRightDelim(n.right, s, u, S, n.mode, ["mclose"])
+                        let _ = n.rightColor ? t.withColor(n.rightColor) : t;
+                        v = Lt.leftRightDelim(n.right, a, c, _, n.mode, ["mclose"])
                     }
-                    return o.push(v), B.makeSpan(["minner"], o, t)
+                    return u.push(v), B.makeSpan(["minner"], u, t)
                 },
                 mathmlBuilder: (n, t) => {
-                    vo(n);
-                    let o = it(n.body, t);
+                    po(n);
+                    let u = it(n.body, t);
                     if (n.left !== ".") {
-                        let s = new V.MathNode("mo", [dt(n.left, n.mode)]);
-                        s.setAttribute("fence", "true"), o.unshift(s)
+                        let a = new H.MathNode("mo", [ft(n.left, n.mode)]);
+                        a.setAttribute("fence", "true"), u.unshift(a)
                     }
                     if (n.right !== ".") {
-                        let s = new V.MathNode("mo", [dt(n.right, n.mode)]);
-                        s.setAttribute("fence", "true"), n.rightColor && s.setAttribute("mathcolor", n.rightColor), o.push(s)
+                        let a = new H.MathNode("mo", [ft(n.right, n.mode)]);
+                        a.setAttribute("fence", "true"), n.rightColor && a.setAttribute("mathcolor", n.rightColor), u.push(a)
                     }
-                    return rn(o)
+                    return wn(u)
                 }
-            }), Q({
+            }), Z({
                 type: "middle",
                 names: ["\\middle"],
                 props: {
                     numArgs: 1,
                     primitive: !0
                 },
                 handler: (n, t) => {
-                    let o = n0(t[0], n);
-                    if (!n.parser.leftrightDepth) throw new a("\\middle without preceding \\left", o);
+                    let u = br(t[0], n);
+                    if (!n.parser.leftrightDepth) throw new o("\\middle without preceding \\left", u);
                     return {
                         type: "middle",
                         mode: n.parser.mode,
-                        delim: o.text
+                        delim: u.text
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    let o;
-                    if (n.delim === ".") o = wr(t, []);
+                    let u;
+                    if (n.delim === ".") u = z0(t, []);
                     else {
-                        o = Bt.sizedDelim(n.delim, 1, t, n.mode, []);
-                        let s = {
+                        u = Lt.sizedDelim(n.delim, 1, t, n.mode, []);
+                        let a = {
                             delim: n.delim,
                             options: t
                         };
-                        o.isMiddle = s
+                        u.isMiddle = a
                     }
-                    return o
+                    return u
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = n.delim === "\\vert" || n.delim === "|" ? dt("|", "text") : dt(n.delim, n.mode),
-                        s = new V.MathNode("mo", [o]);
-                    return s.setAttribute("fence", "true"), s.setAttribute("lspace", "0.05em"), s.setAttribute("rspace", "0.05em"), s
+                    let u = n.delim === "\\vert" || n.delim === "|" ? ft("|", "text") : ft(n.delim, n.mode),
+                        a = new H.MathNode("mo", [u]);
+                    return a.setAttribute("fence", "true"), a.setAttribute("lspace", "0.05em"), a.setAttribute("rspace", "0.05em"), a
                 }
             });
-            let fn = (n, t) => {
-                    let o = B.wrapFragment(ve(n.body, t), t),
-                        s = n.label.slice(1),
-                        u = t.sizeMultiplier,
-                        p, b = 0,
-                        v = R.isCharacterBox(n.body);
-                    if (s === "sout") p = B.makeSpan(["stretchy", "sout"]), p.height = t.fontMetrics().defaultRuleThickness / u, b = -.5 * t.fontMetrics().xHeight;
-                    else if (s === "phase") {
-                        let E = Ie({
+            let zn = (n, t) => {
+                    let u = B.wrapFragment(xe(n.body, t), t),
+                        a = n.label.slice(1),
+                        c = t.sizeMultiplier,
+                        m, g = 0,
+                        v = N.isCharacterBox(n.body);
+                    if (a === "sout") m = B.makeSpan(["stretchy", "sout"]), m.height = t.fontMetrics().defaultRuleThickness / c, g = -.5 * t.fontMetrics().xHeight;
+                    else if (a === "phase") {
+                        let D = Le({
                                 number: .6,
                                 unit: "pt"
                             }, t),
-                            z = Ie({
+                            z = Le({
                                 number: .35,
                                 unit: "ex"
                             }, t),
-                            F = t.havingBaseSizing();
-                        u = u / F.sizeMultiplier;
-                        let N = o.height + o.depth + E + z;
-                        o.style.paddingLeft = Z(N / 2 + E);
-                        let H = Math.floor(1e3 * N * u),
-                            K = Fu(H),
-                            ie = new Et([new Ot("phase", K)], {
+                            R = t.havingBaseSizing();
+                        c = c / R.sizeMultiplier;
+                        let L = u.height + u.depth + D + z;
+                        u.style.paddingLeft = j(L / 2 + D);
+                        let P = Math.floor(1e3 * L * c),
+                            K = Al(P),
+                            re = new Ft([new Ut("phase", K)], {
                                 width: "400em",
-                                height: Z(H / 1e3),
-                                viewBox: "0 0 400000 " + H,
+                                height: j(P / 1e3),
+                                viewBox: "0 0 400000 " + P,
                                 preserveAspectRatio: "xMinYMin slice"
                             });
-                        p = B.makeSvgSpan(["hide-tail"], [ie], t), p.style.height = Z(N), b = o.depth + E + z
+                        m = B.makeSvgSpan(["hide-tail"], [re], t), m.style.height = j(L), g = u.depth + D + z
                     } else {
-                        /cancel/.test(s) ? v || o.classes.push("cancel-pad") : s === "angl" ? o.classes.push("anglpad") : o.classes.push("boxpad");
-                        let E = 0,
+                        /cancel/.test(a) ? v || u.classes.push("cancel-pad") : a === "angl" ? u.classes.push("anglpad") : u.classes.push("boxpad");
+                        let D = 0,
                             z = 0,
-                            F = 0;
-                        /box/.test(s) ? (F = Math.max(t.fontMetrics().fboxrule, t.minRuleThickness), E = t.fontMetrics().fboxsep + (s === "colorbox" ? 0 : F), z = E) : s === "angl" ? (F = Math.max(t.fontMetrics().defaultRuleThickness, t.minRuleThickness), E = 4 * F, z = Math.max(0, .25 - o.depth)) : (E = v ? .2 : 0, z = E), p = Ft.encloseSpan(o, s, E, z, t), /fbox|boxed|fcolorbox/.test(s) ? (p.style.borderStyle = "solid", p.style.borderWidth = Z(F)) : s === "angl" && F !== .049 && (p.style.borderTopWidth = Z(F), p.style.borderRightWidth = Z(F)), b = o.depth + z, n.backgroundColor && (p.style.backgroundColor = n.backgroundColor, n.borderColor && (p.style.borderColor = n.borderColor))
+                            R = 0;
+                        /box/.test(a) ? (R = Math.max(t.fontMetrics().fboxrule, t.minRuleThickness), D = t.fontMetrics().fboxsep + (a === "colorbox" ? 0 : R), z = D) : a === "angl" ? (R = Math.max(t.fontMetrics().defaultRuleThickness, t.minRuleThickness), D = 4 * R, z = Math.max(0, .25 - u.depth)) : (D = v ? .2 : 0, z = D), m = Nt.encloseSpan(u, a, D, z, t), /fbox|boxed|fcolorbox/.test(a) ? (m.style.borderStyle = "solid", m.style.borderWidth = j(R)) : a === "angl" && R !== .049 && (m.style.borderTopWidth = j(R), m.style.borderRightWidth = j(R)), g = u.depth + z, n.backgroundColor && (m.style.backgroundColor = n.backgroundColor, n.borderColor && (m.style.borderColor = n.borderColor))
                     }
-                    let S;
-                    if (n.backgroundColor) S = B.makeVList({
+                    let _;
+                    if (n.backgroundColor) _ = B.makeVList({
                         positionType: "individualShift",
                         children: [{
                             type: "elem",
-                            elem: p,
-                            shift: b
+                            elem: m,
+                            shift: g
                         }, {
                             type: "elem",
-                            elem: o,
+                            elem: u,
                             shift: 0
                         }]
                     }, t);
                     else {
-                        let E = /cancel|phase/.test(s) ? ["svg-align"] : [];
-                        S = B.makeVList({
+                        let D = /cancel|phase/.test(a) ? ["svg-align"] : [];
+                        _ = B.makeVList({
                             positionType: "individualShift",
                             children: [{
                                 type: "elem",
-                                elem: o,
+                                elem: u,
                                 shift: 0
                             }, {
                                 type: "elem",
-                                elem: p,
-                                shift: b,
-                                wrapperClasses: E
+                                elem: m,
+                                shift: g,
+                                wrapperClasses: D
                             }]
                         }, t)
                     }
-                    return /cancel/.test(s) && (S.height = o.height, S.depth = o.depth), /cancel/.test(s) && !v ? B.makeSpan(["mord", "cancel-lap"], [S], t) : B.makeSpan(["mord"], [S], t)
+                    return /cancel/.test(a) && (_.height = u.height, _.depth = u.depth), /cancel/.test(a) && !v ? B.makeSpan(["mord", "cancel-lap"], [_], t) : B.makeSpan(["mord"], [_], t)
                 },
-                gn = (n, t) => {
-                    let o = 0,
-                        s = new V.MathNode(n.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [Ee(n.body, t)]);
+                Rn = (n, t) => {
+                    let u = 0,
+                        a = new H.MathNode(n.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [Ae(n.body, t)]);
                     switch (n.label) {
                         case "\\cancel":
-                            s.setAttribute("notation", "updiagonalstrike");
+                            a.setAttribute("notation", "updiagonalstrike");
                             break;
                         case "\\bcancel":
-                            s.setAttribute("notation", "downdiagonalstrike");
+                            a.setAttribute("notation", "downdiagonalstrike");
                             break;
                         case "\\phase":
-                            s.setAttribute("notation", "phasorangle");
+                            a.setAttribute("notation", "phasorangle");
                             break;
                         case "\\sout":
-                            s.setAttribute("notation", "horizontalstrike");
+                            a.setAttribute("notation", "horizontalstrike");
                             break;
                         case "\\fbox":
-                            s.setAttribute("notation", "box");
+                            a.setAttribute("notation", "box");
                             break;
                         case "\\angl":
-                            s.setAttribute("notation", "actuarial");
+                            a.setAttribute("notation", "actuarial");
                             break;
                         case "\\fcolorbox":
                         case "\\colorbox":
-                            if (o = t.fontMetrics().fboxsep * t.fontMetrics().ptPerEm, s.setAttribute("width", "+" + 2 * o + "pt"), s.setAttribute("height", "+" + 2 * o + "pt"), s.setAttribute("lspace", o + "pt"), s.setAttribute("voffset", o + "pt"), n.label === "\\fcolorbox") {
-                                let u = Math.max(t.fontMetrics().fboxrule, t.minRuleThickness);
-                                s.setAttribute("style", "border: " + u + "em solid " + String(n.borderColor))
+                            if (u = t.fontMetrics().fboxsep * t.fontMetrics().ptPerEm, a.setAttribute("width", "+" + 2 * u + "pt"), a.setAttribute("height", "+" + 2 * u + "pt"), a.setAttribute("lspace", u + "pt"), a.setAttribute("voffset", u + "pt"), n.label === "\\fcolorbox") {
+                                let c = Math.max(t.fontMetrics().fboxrule, t.minRuleThickness);
+                                a.setAttribute("style", "border: " + c + "em solid " + String(n.borderColor))
                             }
                             break;
                         case "\\xcancel":
-                            s.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
+                            a.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                             break
                     }
-                    return n.backgroundColor && s.setAttribute("mathbackground", n.backgroundColor), s
+                    return n.backgroundColor && a.setAttribute("mathbackground", n.backgroundColor), a
                 };
-            Q({
+            Z({
                 type: "enclose",
                 names: ["\\colorbox"],
                 props: {
                     numArgs: 2,
                     allowedInText: !0,
                     argTypes: ["color", "text"]
                 },
-                handler(n, t, o) {
+                handler(n, t, u) {
                     let {
-                        parser: s,
-                        funcName: u
-                    } = n, p = de(t[0], "color-token").color, b = t[1];
+                        parser: a,
+                        funcName: c
+                    } = n, m = se(t[0], "color-token").color, g = t[1];
                     return {
                         type: "enclose",
-                        mode: s.mode,
-                        label: u,
-                        backgroundColor: p,
-                        body: b
+                        mode: a.mode,
+                        label: c,
+                        backgroundColor: m,
+                        body: g
                     }
                 },
-                htmlBuilder: fn,
-                mathmlBuilder: gn
-            }), Q({
+                htmlBuilder: zn,
+                mathmlBuilder: Rn
+            }), Z({
                 type: "enclose",
                 names: ["\\fcolorbox"],
                 props: {
                     numArgs: 3,
                     allowedInText: !0,
                     argTypes: ["color", "color", "text"]
                 },
-                handler(n, t, o) {
+                handler(n, t, u) {
                     let {
-                        parser: s,
-                        funcName: u
-                    } = n, p = de(t[0], "color-token").color, b = de(t[1], "color-token").color, v = t[2];
+                        parser: a,
+                        funcName: c
+                    } = n, m = se(t[0], "color-token").color, g = se(t[1], "color-token").color, v = t[2];
                     return {
                         type: "enclose",
-                        mode: s.mode,
-                        label: u,
-                        backgroundColor: b,
-                        borderColor: p,
+                        mode: a.mode,
+                        label: c,
+                        backgroundColor: g,
+                        borderColor: m,
                         body: v
                     }
                 },
-                htmlBuilder: fn,
-                mathmlBuilder: gn
-            }), Q({
+                htmlBuilder: zn,
+                mathmlBuilder: Rn
+            }), Z({
                 type: "enclose",
                 names: ["\\fbox"],
                 props: {
                     numArgs: 1,
                     argTypes: ["hbox"],
                     allowedInText: !0
                 },
                 handler(n, t) {
                     let {
-                        parser: o
+                        parser: u
                     } = n;
                     return {
                         type: "enclose",
-                        mode: o.mode,
+                        mode: u.mode,
                         label: "\\fbox",
                         body: t[0]
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "enclose",
                 names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
                 props: {
                     numArgs: 1
                 },
                 handler(n, t) {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[0];
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[0];
                     return {
                         type: "enclose",
-                        mode: o.mode,
-                        label: s,
-                        body: u
+                        mode: u.mode,
+                        label: a,
+                        body: c
                     }
                 },
-                htmlBuilder: fn,
-                mathmlBuilder: gn
-            }), Q({
+                htmlBuilder: zn,
+                mathmlBuilder: Rn
+            }), Z({
                 type: "enclose",
                 names: ["\\angl"],
                 props: {
                     numArgs: 1,
                     argTypes: ["hbox"],
                     allowedInText: !1
                 },
                 handler(n, t) {
                     let {
-                        parser: o
+                        parser: u
                     } = n;
                     return {
                         type: "enclose",
-                        mode: o.mode,
+                        mode: u.mode,
                         label: "\\angl",
                         body: t[0]
                     }
                 }
             });
-            let wo = {};
+            let bo = {};
 
-            function wt(n) {
+            function kt(n) {
                 let {
                     type: t,
-                    names: o,
-                    props: s,
-                    handler: u,
-                    htmlBuilder: p,
-                    mathmlBuilder: b
+                    names: u,
+                    props: a,
+                    handler: c,
+                    htmlBuilder: m,
+                    mathmlBuilder: g
                 } = n, v = {
                     type: t,
-                    numArgs: s.numArgs || 0,
+                    numArgs: a.numArgs || 0,
                     allowedInText: !1,
                     numOptionalArgs: 0,
-                    handler: u
+                    handler: c
                 };
-                for (let S = 0; S < o.length; ++S) wo[o[S]] = v;
-                p && (Zr[t] = p), b && (Qr[t] = b)
+                for (let _ = 0; _ < u.length; ++_) bo[u[_]] = v;
+                m && (sr[t] = m), g && (lr[t] = g)
             }
-            let ko = {};
+            let go = {};
 
-            function k(n, t) {
-                ko[n] = t
+            function w(n, t) {
+                go[n] = t
             }
             class st {
-                constructor(t, o, s) {
-                    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = t, this.start = o, this.end = s
+                constructor(t, u, a) {
+                    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = t, this.start = u, this.end = a
                 }
-                static range(t, o) {
-                    return o ? !t || !t.loc || !o.loc || t.loc.lexer !== o.loc.lexer ? null : new st(t.loc.lexer, t.loc.start, o.loc.end) : t && t.loc
+                static range(t, u) {
+                    return u ? !t || !t.loc || !u.loc || t.loc.lexer !== u.loc.lexer ? null : new st(t.loc.lexer, t.loc.start, u.loc.end) : t && t.loc
                 }
             }
             class mt {
-                constructor(t, o) {
-                    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = t, this.loc = o
+                constructor(t, u) {
+                    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = t, this.loc = u
                 }
-                range(t, o) {
-                    return new mt(o, st.range(this, t))
+                range(t, u) {
+                    return new mt(u, st.range(this, t))
                 }
             }
 
-            function _o(n) {
+            function xo(n) {
                 let t = [];
                 n.consumeSpaces();
-                let o = n.fetch().text;
-                for (o === "\\relax" && (n.consume(), n.consumeSpaces(), o = n.fetch().text); o === "\\hline" || o === "\\hdashline";) n.consume(), t.push(o === "\\hdashline"), n.consumeSpaces(), o = n.fetch().text;
+                let u = n.fetch().text;
+                for (u === "\\relax" && (n.consume(), n.consumeSpaces(), u = n.fetch().text); u === "\\hline" || u === "\\hdashline";) n.consume(), t.push(u === "\\hdashline"), n.consumeSpaces(), u = n.fetch().text;
                 return t
             }
-            let i0 = n => {
-                if (!n.parser.settings.displayMode) throw new a("{" + n.envName + "} can be used only in display mode.")
+            let gr = n => {
+                if (!n.parser.settings.displayMode) throw new o("{" + n.envName + "} can be used only in display mode.")
             };
 
-            function bn(n) {
+            function Bn(n) {
                 if (n.indexOf("ed") === -1) return n.indexOf("*") === -1
             }
 
-            function $t(n, t, o) {
+            function Wt(n, t, u) {
                 let {
-                    hskipBeforeAndAfter: s,
-                    addJot: u,
-                    cols: p,
-                    arraystretch: b,
+                    hskipBeforeAndAfter: a,
+                    addJot: c,
+                    cols: m,
+                    arraystretch: g,
                     colSeparationType: v,
-                    autoTag: S,
-                    singleRow: E,
+                    autoTag: _,
+                    singleRow: D,
                     emptySingleRow: z,
-                    maxNumCols: F,
-                    leqno: N
+                    maxNumCols: R,
+                    leqno: L
                 } = t;
-                if (n.gullet.beginGroup(), E || n.gullet.macros.set("\\cr", "\\\\\\relax"), !b) {
-                    let ze = n.gullet.expandMacroAsText("\\arraystretch");
-                    if (ze == null) b = 1;
-                    else if (b = parseFloat(ze), !b || b < 0) throw new a("Invalid \\arraystretch: " + ze)
+                if (n.gullet.beginGroup(), D || n.gullet.macros.set("\\cr", "\\\\\\relax"), !g) {
+                    let Te = n.gullet.expandMacroAsText("\\arraystretch");
+                    if (Te == null) g = 1;
+                    else if (g = parseFloat(Te), !g || g < 0) throw new o("Invalid \\arraystretch: " + Te)
                 }
                 n.gullet.beginGroup();
-                let H = [],
-                    K = [H],
-                    ie = [],
-                    ye = [],
-                    ge = S != null ? [] : void 0;
-
-                function xe() {
-                    S && n.gullet.macros.set("\\@eqnsw", "1", !0)
-                }
-
-                function ke() {
-                    ge && (n.gullet.macros.get("\\df@tag") ? (ge.push(n.subparse([new mt("\\df@tag")])), n.gullet.macros.set("\\df@tag", void 0, !0)) : ge.push(!!S && n.gullet.macros.get("\\@eqnsw") === "1"))
-                }
-                for (xe(), ye.push(_o(n));;) {
-                    let ze = n.parseExpression(!1, E ? "\\end" : "\\\\");
-                    n.gullet.endGroup(), n.gullet.beginGroup(), ze = {
+                let P = [],
+                    K = [P],
+                    re = [],
+                    pe = [],
+                    de = _ != null ? [] : void 0;
+
+                function be() {
+                    _ && n.gullet.macros.set("\\@eqnsw", "1", !0)
+                }
+
+                function ve() {
+                    de && (n.gullet.macros.get("\\df@tag") ? (de.push(n.subparse([new mt("\\df@tag")])), n.gullet.macros.set("\\df@tag", void 0, !0)) : de.push(!!_ && n.gullet.macros.get("\\@eqnsw") === "1"))
+                }
+                for (be(), pe.push(xo(n));;) {
+                    let Te = n.parseExpression(!1, D ? "\\end" : "\\\\");
+                    n.gullet.endGroup(), n.gullet.beginGroup(), Te = {
                         type: "ordgroup",
                         mode: n.mode,
-                        body: ze
-                    }, o && (ze = {
+                        body: Te
+                    }, u && (Te = {
                         type: "styling",
                         mode: n.mode,
-                        style: o,
-                        body: [ze]
-                    }), H.push(ze);
+                        style: u,
+                        body: [Te]
+                    }), P.push(Te);
                     let tt = n.fetch().text;
                     if (tt === "&") {
-                        if (F && H.length === F) {
-                            if (E || v) throw new a("Too many tab characters: &", n.nextToken);
+                        if (R && P.length === R) {
+                            if (D || v) throw new o("Too many tab characters: &", n.nextToken);
                             n.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.")
                         }
                         n.consume()
                     } else if (tt === "\\end") {
-                        ke(), H.length === 1 && ze.type === "styling" && ze.body[0].body.length === 0 && (K.length > 1 || !z) && K.pop(), ye.length < K.length + 1 && ye.push([]);
+                        ve(), P.length === 1 && Te.type === "styling" && Te.body[0].body.length === 0 && (K.length > 1 || !z) && K.pop(), pe.length < K.length + 1 && pe.push([]);
                         break
                     } else if (tt === "\\\\") {
                         n.consume();
-                        let Qe;
-                        n.gullet.future().text !== " " && (Qe = n.parseSizeGroup(!0)), ie.push(Qe ? Qe.value : null), ke(), ye.push(_o(n)), H = [], K.push(H), xe()
-                    } else throw new a("Expected & or \\\\ or \\cr or \\end", n.nextToken)
+                        let Ye;
+                        n.gullet.future().text !== " " && (Ye = n.parseSizeGroup(!0)), re.push(Ye ? Ye.value : null), ve(), pe.push(xo(n)), P = [], K.push(P), be()
+                    } else throw new o("Expected & or \\\\ or \\cr or \\end", n.nextToken)
                 }
                 return n.gullet.endGroup(), n.gullet.endGroup(), {
                     type: "array",
                     mode: n.mode,
-                    addJot: u,
-                    arraystretch: b,
+                    addJot: c,
+                    arraystretch: g,
                     body: K,
-                    cols: p,
-                    rowGaps: ie,
-                    hskipBeforeAndAfter: s,
-                    hLinesBeforeRow: ye,
+                    cols: m,
+                    rowGaps: re,
+                    hskipBeforeAndAfter: a,
+                    hLinesBeforeRow: pe,
                     colSeparationType: v,
-                    tags: ge,
-                    leqno: N
+                    tags: de,
+                    leqno: L
                 }
             }
 
-            function yn(n) {
+            function Nn(n) {
                 return n.slice(0, 1) === "d" ? "display" : "text"
             }
-            let kt = function(n, t) {
-                    let o, s, u = n.body.length,
-                        p = n.hLinesBeforeRow,
-                        b = 0,
-                        v = new Array(u),
-                        S = [],
-                        E = Math.max(t.fontMetrics().arrayRuleWidth, t.minRuleThickness),
+            let _t = function(n, t) {
+                    let u, a, c = n.body.length,
+                        m = n.hLinesBeforeRow,
+                        g = 0,
+                        v = new Array(c),
+                        _ = [],
+                        D = Math.max(t.fontMetrics().arrayRuleWidth, t.minRuleThickness),
                         z = 1 / t.fontMetrics().ptPerEm,
-                        F = 5 * z;
-                    n.colSeparationType && n.colSeparationType === "small" && (F = .2778 * (t.havingStyle(G.SCRIPT).sizeMultiplier / t.sizeMultiplier));
-                    let N = n.colSeparationType === "CD" ? Ie({
+                        R = 5 * z;
+                    n.colSeparationType && n.colSeparationType === "small" && (R = .2778 * (t.havingStyle(O.SCRIPT).sizeMultiplier / t.sizeMultiplier));
+                    let L = n.colSeparationType === "CD" ? Le({
                             number: 3,
                             unit: "ex"
                         }, t) : 12 * z,
-                        H = 3 * z,
-                        K = n.arraystretch * N,
-                        ie = .7 * K,
-                        ye = .3 * K,
-                        ge = 0;
-
-                    function xe(we) {
-                        for (let qe = 0; qe < we.length; ++qe) qe > 0 && (ge += .25), S.push({
-                            pos: ge,
-                            isDashed: we[qe]
+                        P = 3 * z,
+                        K = n.arraystretch * L,
+                        re = .7 * K,
+                        pe = .3 * K,
+                        de = 0;
+
+                    function be(ye) {
+                        for (let Ce = 0; Ce < ye.length; ++Ce) Ce > 0 && (de += .25), _.push({
+                            pos: de,
+                            isDashed: ye[Ce]
                         })
                     }
-                    for (xe(p[0]), o = 0; o < n.body.length; ++o) {
-                        let we = n.body[o],
-                            qe = ie,
-                            Fe = ye;
-                        b < we.length && (b = we.length);
-                        let Ne = new Array(we.length);
-                        for (s = 0; s < we.length; ++s) {
-                            let ft = ve(we[s], t);
-                            Fe < ft.depth && (Fe = ft.depth), qe < ft.height && (qe = ft.height), Ne[s] = ft
+                    for (be(m[0]), u = 0; u < n.body.length; ++u) {
+                        let ye = n.body[u],
+                            Ce = re,
+                            Me = pe;
+                        g < ye.length && (g = ye.length);
+                        let ze = new Array(ye.length);
+                        for (a = 0; a < ye.length; ++a) {
+                            let bt = xe(ye[a], t);
+                            Me < bt.depth && (Me = bt.depth), Ce < bt.height && (Ce = bt.height), ze[a] = bt
                         }
-                        let Ve = n.rowGaps[o],
-                            $e = 0;
-                        Ve && ($e = Ie(Ve, t), $e > 0 && ($e += ye, Fe < $e && (Fe = $e), $e = 0)), n.addJot && (Fe += H), Ne.height = qe, Ne.depth = Fe, ge += qe, Ne.pos = ge, ge += Fe + $e, v[o] = Ne, xe(p[o + 1])
+                        let $e = n.rowGaps[u],
+                            Oe = 0;
+                        $e && (Oe = Le($e, t), Oe > 0 && (Oe += pe, Me < Oe && (Me = Oe), Oe = 0)), n.addJot && (Me += P), ze.height = Ce, ze.depth = Me, de += Ce, ze.pos = de, de += Me + Oe, v[u] = ze, be(m[u + 1])
                     }
-                    let ke = ge / 2 + t.fontMetrics().axisHeight,
-                        ze = n.cols || [],
+                    let ve = de / 2 + t.fontMetrics().axisHeight,
+                        Te = n.cols || [],
                         tt = [],
-                        Qe, pt, cr = [];
-                    if (n.tags && n.tags.some(we => we))
-                        for (o = 0; o < u; ++o) {
-                            let we = v[o],
-                                qe = we.pos - ke,
-                                Fe = n.tags[o],
-                                Ne;
-                            Fe === !0 ? Ne = B.makeSpan(["eqn-num"], [], t) : Fe === !1 ? Ne = B.makeSpan([], [], t) : Ne = B.makeSpan([], Ze(Fe, t, !0), t), Ne.depth = we.depth, Ne.height = we.height, cr.push({
+                        Ye, pt, y0 = [];
+                    if (n.tags && n.tags.some(ye => ye))
+                        for (u = 0; u < c; ++u) {
+                            let ye = v[u],
+                                Ce = ye.pos - ve,
+                                Me = n.tags[u],
+                                ze;
+                            Me === !0 ? ze = B.makeSpan(["eqn-num"], [], t) : Me === !1 ? ze = B.makeSpan([], [], t) : ze = B.makeSpan([], We(Me, t, !0), t), ze.depth = ye.depth, ze.height = ye.height, y0.push({
                                 type: "elem",
-                                elem: Ne,
-                                shift: qe
+                                elem: ze,
+                                shift: Ce
                             })
                         }
-                    for (s = 0, pt = 0; s < b || pt < ze.length; ++s, ++pt) {
-                        let we = ze[pt] || {},
-                            qe = !0;
-                        for (; we.type === "separator";) {
-                            if (qe || (Qe = B.makeSpan(["arraycolsep"], []), Qe.style.width = Z(t.fontMetrics().doubleRuleSep), tt.push(Qe)), we.separator === "|" || we.separator === ":") {
-                                let Ve = we.separator === "|" ? "solid" : "dashed",
-                                    $e = B.makeSpan(["vertical-separator"], [], t);
-                                $e.style.height = Z(ge), $e.style.borderRightWidth = Z(E), $e.style.borderRightStyle = Ve, $e.style.margin = "0 " + Z(-E / 2);
-                                let ft = ge - ke;
-                                ft && ($e.style.verticalAlign = Z(-ft)), tt.push($e)
-                            } else throw new a("Invalid separator type: " + we.separator);
-                            pt++, we = ze[pt] || {}, qe = !1
+                    for (a = 0, pt = 0; a < g || pt < Te.length; ++a, ++pt) {
+                        let ye = Te[pt] || {},
+                            Ce = !0;
+                        for (; ye.type === "separator";) {
+                            if (Ce || (Ye = B.makeSpan(["arraycolsep"], []), Ye.style.width = j(t.fontMetrics().doubleRuleSep), tt.push(Ye)), ye.separator === "|" || ye.separator === ":") {
+                                let $e = ye.separator === "|" ? "solid" : "dashed",
+                                    Oe = B.makeSpan(["vertical-separator"], [], t);
+                                Oe.style.height = j(de), Oe.style.borderRightWidth = j(D), Oe.style.borderRightStyle = $e, Oe.style.margin = "0 " + j(-D / 2);
+                                let bt = de - ve;
+                                bt && (Oe.style.verticalAlign = j(-bt)), tt.push(Oe)
+                            } else throw new o("Invalid separator type: " + ye.separator);
+                            pt++, ye = Te[pt] || {}, Ce = !1
                         }
-                        if (s >= b) continue;
-                        let Fe;
-                        (s > 0 || n.hskipBeforeAndAfter) && (Fe = R.deflt(we.pregap, F), Fe !== 0 && (Qe = B.makeSpan(["arraycolsep"], []), Qe.style.width = Z(Fe), tt.push(Qe)));
-                        let Ne = [];
-                        for (o = 0; o < u; ++o) {
-                            let Ve = v[o],
-                                $e = Ve[s];
-                            if (!$e) continue;
-                            let ft = Ve.pos - ke;
-                            $e.depth = Ve.depth, $e.height = Ve.height, Ne.push({
+                        if (a >= g) continue;
+                        let Me;
+                        (a > 0 || n.hskipBeforeAndAfter) && (Me = N.deflt(ye.pregap, R), Me !== 0 && (Ye = B.makeSpan(["arraycolsep"], []), Ye.style.width = j(Me), tt.push(Ye)));
+                        let ze = [];
+                        for (u = 0; u < c; ++u) {
+                            let $e = v[u],
+                                Oe = $e[a];
+                            if (!Oe) continue;
+                            let bt = $e.pos - ve;
+                            Oe.depth = $e.depth, Oe.height = $e.height, ze.push({
                                 type: "elem",
-                                elem: $e,
-                                shift: ft
+                                elem: Oe,
+                                shift: bt
                             })
                         }
-                        Ne = B.makeVList({
+                        ze = B.makeVList({
                             positionType: "individualShift",
-                            children: Ne
-                        }, t), Ne = B.makeSpan(["col-align-" + (we.align || "c")], [Ne]), tt.push(Ne), (s < b - 1 || n.hskipBeforeAndAfter) && (Fe = R.deflt(we.postgap, F), Fe !== 0 && (Qe = B.makeSpan(["arraycolsep"], []), Qe.style.width = Z(Fe), tt.push(Qe)))
+                            children: ze
+                        }, t), ze = B.makeSpan(["col-align-" + (ye.align || "c")], [ze]), tt.push(ze), (a < g - 1 || n.hskipBeforeAndAfter) && (Me = N.deflt(ye.postgap, R), Me !== 0 && (Ye = B.makeSpan(["arraycolsep"], []), Ye.style.width = j(Me), tt.push(Ye)))
                     }
-                    if (v = B.makeSpan(["mtable"], tt), S.length > 0) {
-                        let we = B.makeLineSpan("hline", t, E),
-                            qe = B.makeLineSpan("hdashline", t, E),
-                            Fe = [{
+                    if (v = B.makeSpan(["mtable"], tt), _.length > 0) {
+                        let ye = B.makeLineSpan("hline", t, D),
+                            Ce = B.makeLineSpan("hdashline", t, D),
+                            Me = [{
                                 type: "elem",
                                 elem: v,
                                 shift: 0
                             }];
-                        for (; S.length > 0;) {
-                            let Ne = S.pop(),
-                                Ve = Ne.pos - ke;
-                            Ne.isDashed ? Fe.push({
+                        for (; _.length > 0;) {
+                            let ze = _.pop(),
+                                $e = ze.pos - ve;
+                            ze.isDashed ? Me.push({
                                 type: "elem",
-                                elem: qe,
-                                shift: Ve
-                            }) : Fe.push({
+                                elem: Ce,
+                                shift: $e
+                            }) : Me.push({
                                 type: "elem",
-                                elem: we,
-                                shift: Ve
+                                elem: ye,
+                                shift: $e
                             })
                         }
                         v = B.makeVList({
                             positionType: "individualShift",
-                            children: Fe
+                            children: Me
                         }, t)
                     }
-                    if (cr.length === 0) return B.makeSpan(["mord"], [v], t);
+                    if (y0.length === 0) return B.makeSpan(["mord"], [v], t);
                     {
-                        let we = B.makeVList({
+                        let ye = B.makeVList({
                             positionType: "individualShift",
-                            children: cr
+                            children: y0
                         }, t);
-                        return we = B.makeSpan(["tag"], [we], t), B.makeFragment([v, we])
+                        return ye = B.makeSpan(["tag"], [ye], t), B.makeFragment([v, ye])
                     }
                 },
-                P1 = {
+                Mc = {
                     c: "center ",
                     l: "left ",
                     r: "right "
                 },
-                _t = function(n, t) {
-                    let o = [],
-                        s = new V.MathNode("mtd", [], ["mtr-glue"]),
-                        u = new V.MathNode("mtd", [], ["mml-eqn-num"]);
-                    for (let F = 0; F < n.body.length; F++) {
-                        let N = n.body[F],
-                            H = [];
-                        for (let K = 0; K < N.length; K++) H.push(new V.MathNode("mtd", [Ee(N[K], t)]));
-                        n.tags && n.tags[F] && (H.unshift(s), H.push(s), n.leqno ? H.unshift(u) : H.push(u)), o.push(new V.MathNode("mtr", H))
-                    }
-                    let p = new V.MathNode("mtable", o),
-                        b = n.arraystretch === .5 ? .1 : .16 + n.arraystretch - 1 + (n.addJot ? .09 : 0);
-                    p.setAttribute("rowspacing", Z(b));
+                Ct = function(n, t) {
+                    let u = [],
+                        a = new H.MathNode("mtd", [], ["mtr-glue"]),
+                        c = new H.MathNode("mtd", [], ["mml-eqn-num"]);
+                    for (let R = 0; R < n.body.length; R++) {
+                        let L = n.body[R],
+                            P = [];
+                        for (let K = 0; K < L.length; K++) P.push(new H.MathNode("mtd", [Ae(L[K], t)]));
+                        n.tags && n.tags[R] && (P.unshift(a), P.push(a), n.leqno ? P.unshift(c) : P.push(c)), u.push(new H.MathNode("mtr", P))
+                    }
+                    let m = new H.MathNode("mtable", u),
+                        g = n.arraystretch === .5 ? .1 : .16 + n.arraystretch - 1 + (n.addJot ? .09 : 0);
+                    m.setAttribute("rowspacing", j(g));
                     let v = "",
-                        S = "";
+                        _ = "";
                     if (n.cols && n.cols.length > 0) {
-                        let F = n.cols,
-                            N = "",
-                            H = !1,
+                        let R = n.cols,
+                            L = "",
+                            P = !1,
                             K = 0,
-                            ie = F.length;
-                        F[0].type === "separator" && (v += "top ", K = 1), F[F.length - 1].type === "separator" && (v += "bottom ", ie -= 1);
-                        for (let ye = K; ye < ie; ye++) F[ye].type === "align" ? (S += P1[F[ye].align], H && (N += "none "), H = !0) : F[ye].type === "separator" && H && (N += F[ye].separator === "|" ? "solid " : "dashed ", H = !1);
-                        p.setAttribute("columnalign", S.trim()), /[sd]/.test(N) && p.setAttribute("columnlines", N.trim())
+                            re = R.length;
+                        R[0].type === "separator" && (v += "top ", K = 1), R[R.length - 1].type === "separator" && (v += "bottom ", re -= 1);
+                        for (let pe = K; pe < re; pe++) R[pe].type === "align" ? (_ += Mc[R[pe].align], P && (L += "none "), P = !0) : R[pe].type === "separator" && P && (L += R[pe].separator === "|" ? "solid " : "dashed ", P = !1);
+                        m.setAttribute("columnalign", _.trim()), /[sd]/.test(L) && m.setAttribute("columnlines", L.trim())
                     }
                     if (n.colSeparationType === "align") {
-                        let F = n.cols || [],
-                            N = "";
-                        for (let H = 1; H < F.length; H++) N += H % 2 ? "0em " : "1em ";
-                        p.setAttribute("columnspacing", N.trim())
-                    } else n.colSeparationType === "alignat" || n.colSeparationType === "gather" ? p.setAttribute("columnspacing", "0em") : n.colSeparationType === "small" ? p.setAttribute("columnspacing", "0.2778em") : n.colSeparationType === "CD" ? p.setAttribute("columnspacing", "0.5em") : p.setAttribute("columnspacing", "1em");
-                    let E = "",
+                        let R = n.cols || [],
+                            L = "";
+                        for (let P = 1; P < R.length; P++) L += P % 2 ? "0em " : "1em ";
+                        m.setAttribute("columnspacing", L.trim())
+                    } else n.colSeparationType === "alignat" || n.colSeparationType === "gather" ? m.setAttribute("columnspacing", "0em") : n.colSeparationType === "small" ? m.setAttribute("columnspacing", "0.2778em") : n.colSeparationType === "CD" ? m.setAttribute("columnspacing", "0.5em") : m.setAttribute("columnspacing", "1em");
+                    let D = "",
                         z = n.hLinesBeforeRow;
                     v += z[0].length > 0 ? "left " : "", v += z[z.length - 1].length > 0 ? "right " : "";
-                    for (let F = 1; F < z.length - 1; F++) E += z[F].length === 0 ? "none " : z[F][0] ? "dashed " : "solid ";
-                    return /[sd]/.test(E) && p.setAttribute("rowlines", E.trim()), v !== "" && (p = new V.MathNode("menclose", [p]), p.setAttribute("notation", v.trim())), n.arraystretch && n.arraystretch < 1 && (p = new V.MathNode("mstyle", [p]), p.setAttribute("scriptlevel", "1")), p
+                    for (let R = 1; R < z.length - 1; R++) D += z[R].length === 0 ? "none " : z[R][0] ? "dashed " : "solid ";
+                    return /[sd]/.test(D) && m.setAttribute("rowlines", D.trim()), v !== "" && (m = new H.MathNode("menclose", [m]), m.setAttribute("notation", v.trim())), n.arraystretch && n.arraystretch < 1 && (m = new H.MathNode("mstyle", [m]), m.setAttribute("scriptlevel", "1")), m
                 },
-                So = function(n, t) {
-                    n.envName.indexOf("ed") === -1 && i0(n);
-                    let o = [],
-                        s = n.envName.indexOf("at") > -1 ? "alignat" : "align",
-                        u = n.envName === "split",
-                        p = $t(n.parser, {
-                            cols: o,
+                yo = function(n, t) {
+                    n.envName.indexOf("ed") === -1 && gr(n);
+                    let u = [],
+                        a = n.envName.indexOf("at") > -1 ? "alignat" : "align",
+                        c = n.envName === "split",
+                        m = Wt(n.parser, {
+                            cols: u,
                             addJot: !0,
-                            autoTag: u ? void 0 : bn(n.envName),
+                            autoTag: c ? void 0 : Bn(n.envName),
                             emptySingleRow: !0,
-                            colSeparationType: s,
-                            maxNumCols: u ? 2 : void 0,
+                            colSeparationType: a,
+                            maxNumCols: c ? 2 : void 0,
                             leqno: n.parser.settings.leqno
                         }, "display"),
-                        b, v = 0,
-                        S = {
+                        g, v = 0,
+                        _ = {
                             type: "ordgroup",
                             mode: n.mode,
                             body: []
                         };
                     if (t[0] && t[0].type === "ordgroup") {
                         let z = "";
-                        for (let F = 0; F < t[0].body.length; F++) {
-                            let N = de(t[0].body[F], "textord");
-                            z += N.text
+                        for (let R = 0; R < t[0].body.length; R++) {
+                            let L = se(t[0].body[R], "textord");
+                            z += L.text
                         }
-                        b = Number(z), v = b * 2
+                        g = Number(z), v = g * 2
                     }
-                    let E = !v;
-                    p.body.forEach(function(z) {
-                        for (let F = 1; F < z.length; F += 2) {
-                            let N = de(z[F], "styling");
-                            de(N.body[0], "ordgroup").body.unshift(S)
+                    let D = !v;
+                    m.body.forEach(function(z) {
+                        for (let R = 1; R < z.length; R += 2) {
+                            let L = se(z[R], "styling");
+                            se(L.body[0], "ordgroup").body.unshift(_)
                         }
-                        if (E) v < z.length && (v = z.length);
+                        if (D) v < z.length && (v = z.length);
                         else {
-                            let F = z.length / 2;
-                            if (b < F) throw new a("Too many math in a row: " + ("expected " + b + ", but got " + F), z[0])
+                            let R = z.length / 2;
+                            if (g < R) throw new o("Too many math in a row: " + ("expected " + g + ", but got " + R), z[0])
                         }
                     });
                     for (let z = 0; z < v; ++z) {
-                        let F = "r",
-                            N = 0;
-                        z % 2 === 1 ? F = "l" : z > 0 && E && (N = 1), o[z] = {
+                        let R = "r",
+                            L = 0;
+                        z % 2 === 1 ? R = "l" : z > 0 && D && (L = 1), u[z] = {
                             type: "align",
-                            align: F,
-                            pregap: N,
+                            align: R,
+                            pregap: L,
                             postgap: 0
                         }
                     }
-                    return p.colSeparationType = E ? "align" : "alignat", p
+                    return m.colSeparationType = D ? "align" : "alignat", m
                 };
-            wt({
+            kt({
                 type: "array",
                 names: ["array", "darray"],
                 props: {
                     numArgs: 1
                 },
                 handler(n, t) {
-                    let u = (Kr(t[0]) ? [t[0]] : de(t[0], "ordgroup").body).map(function(b) {
-                            let S = on(b).text;
-                            if ("lcr".indexOf(S) !== -1) return {
+                    let c = (hr(t[0]) ? [t[0]] : se(t[0], "ordgroup").body).map(function(g) {
+                            let _ = _n(g).text;
+                            if ("lcr".indexOf(_) !== -1) return {
                                 type: "align",
-                                align: S
+                                align: _
                             };
-                            if (S === "|") return {
+                            if (_ === "|") return {
                                 type: "separator",
                                 separator: "|"
                             };
-                            if (S === ":") return {
+                            if (_ === ":") return {
                                 type: "separator",
                                 separator: ":"
                             };
-                            throw new a("Unknown column alignment: " + S, b)
+                            throw new o("Unknown column alignment: " + _, g)
                         }),
-                        p = {
-                            cols: u,
+                        m = {
+                            cols: c,
                             hskipBeforeAndAfter: !0,
-                            maxNumCols: u.length
+                            maxNumCols: c.length
                         };
-                    return $t(n.parser, p, yn(n.envName))
+                    return Wt(n.parser, m, Nn(n.envName))
                 },
-                htmlBuilder: kt,
-                mathmlBuilder: _t
-            }), wt({
+                htmlBuilder: _t,
+                mathmlBuilder: Ct
+            }), kt({
                 type: "array",
                 names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
                 props: {
                     numArgs: 0
                 },
                 handler(n) {
                     let t = {
                             matrix: null,
                             pmatrix: ["(", ")"],
                             bmatrix: ["[", "]"],
                             Bmatrix: ["\\{", "\\}"],
                             vmatrix: ["|", "|"],
                             Vmatrix: ["\\Vert", "\\Vert"]
                         } [n.envName.replace("*", "")],
-                        o = "c",
-                        s = {
+                        u = "c",
+                        a = {
                             hskipBeforeAndAfter: !1,
                             cols: [{
                                 type: "align",
-                                align: o
+                                align: u
                             }]
                         };
                     if (n.envName.charAt(n.envName.length - 1) === "*") {
-                        let b = n.parser;
-                        if (b.consumeSpaces(), b.fetch().text === "[") {
-                            if (b.consume(), b.consumeSpaces(), o = b.fetch().text, "lcr".indexOf(o) === -1) throw new a("Expected l or c or r", b.nextToken);
-                            b.consume(), b.consumeSpaces(), b.expect("]"), b.consume(), s.cols = [{
+                        let g = n.parser;
+                        if (g.consumeSpaces(), g.fetch().text === "[") {
+                            if (g.consume(), g.consumeSpaces(), u = g.fetch().text, "lcr".indexOf(u) === -1) throw new o("Expected l or c or r", g.nextToken);
+                            g.consume(), g.consumeSpaces(), g.expect("]"), g.consume(), a.cols = [{
                                 type: "align",
-                                align: o
+                                align: u
                             }]
                         }
                     }
-                    let u = $t(n.parser, s, yn(n.envName)),
-                        p = Math.max(0, ...u.body.map(b => b.length));
-                    return u.cols = new Array(p).fill({
+                    let c = Wt(n.parser, a, Nn(n.envName)),
+                        m = Math.max(0, ...c.body.map(g => g.length));
+                    return c.cols = new Array(m).fill({
                         type: "align",
-                        align: o
+                        align: u
                     }), t ? {
                         type: "leftright",
                         mode: n.mode,
-                        body: [u],
+                        body: [c],
                         left: t[0],
                         right: t[1],
                         rightColor: void 0
-                    } : u
+                    } : c
                 },
-                htmlBuilder: kt,
-                mathmlBuilder: _t
-            }), wt({
+                htmlBuilder: _t,
+                mathmlBuilder: Ct
+            }), kt({
                 type: "array",
                 names: ["smallmatrix"],
                 props: {
                     numArgs: 0
                 },
                 handler(n) {
                     let t = {
                             arraystretch: .5
                         },
-                        o = $t(n.parser, t, "script");
-                    return o.colSeparationType = "small", o
+                        u = Wt(n.parser, t, "script");
+                    return u.colSeparationType = "small", u
                 },
-                htmlBuilder: kt,
-                mathmlBuilder: _t
-            }), wt({
+                htmlBuilder: _t,
+                mathmlBuilder: Ct
+            }), kt({
                 type: "array",
                 names: ["subarray"],
                 props: {
                     numArgs: 1
                 },
                 handler(n, t) {
-                    let u = (Kr(t[0]) ? [t[0]] : de(t[0], "ordgroup").body).map(function(b) {
-                        let S = on(b).text;
-                        if ("lc".indexOf(S) !== -1) return {
+                    let c = (hr(t[0]) ? [t[0]] : se(t[0], "ordgroup").body).map(function(g) {
+                        let _ = _n(g).text;
+                        if ("lc".indexOf(_) !== -1) return {
                             type: "align",
-                            align: S
+                            align: _
                         };
-                        throw new a("Unknown column alignment: " + S, b)
+                        throw new o("Unknown column alignment: " + _, g)
                     });
-                    if (u.length > 1) throw new a("{subarray} can contain only one column");
-                    let p = {
-                        cols: u,
+                    if (c.length > 1) throw new o("{subarray} can contain only one column");
+                    let m = {
+                        cols: c,
                         hskipBeforeAndAfter: !1,
                         arraystretch: .5
                     };
-                    if (p = $t(n.parser, p, "script"), p.body.length > 0 && p.body[0].length > 1) throw new a("{subarray} can contain only one column");
-                    return p
+                    if (m = Wt(n.parser, m, "script"), m.body.length > 0 && m.body[0].length > 1) throw new o("{subarray} can contain only one column");
+                    return m
                 },
-                htmlBuilder: kt,
-                mathmlBuilder: _t
-            }), wt({
+                htmlBuilder: _t,
+                mathmlBuilder: Ct
+            }), kt({
                 type: "array",
                 names: ["cases", "dcases", "rcases", "drcases"],
                 props: {
                     numArgs: 0
                 },
                 handler(n) {
                     let t = {
@@ -12104,1600 +7694,1600 @@
                             }, {
                                 type: "align",
                                 align: "l",
                                 pregap: 0,
                                 postgap: 0
                             }]
                         },
-                        o = $t(n.parser, t, yn(n.envName));
+                        u = Wt(n.parser, t, Nn(n.envName));
                     return {
                         type: "leftright",
                         mode: n.mode,
-                        body: [o],
+                        body: [u],
                         left: n.envName.indexOf("r") > -1 ? "." : "\\{",
                         right: n.envName.indexOf("r") > -1 ? "\\}" : ".",
                         rightColor: void 0
                     }
                 },
-                htmlBuilder: kt,
-                mathmlBuilder: _t
-            }), wt({
+                htmlBuilder: _t,
+                mathmlBuilder: Ct
+            }), kt({
                 type: "array",
                 names: ["align", "align*", "aligned", "split"],
                 props: {
                     numArgs: 0
                 },
-                handler: So,
-                htmlBuilder: kt,
-                mathmlBuilder: _t
-            }), wt({
+                handler: yo,
+                htmlBuilder: _t,
+                mathmlBuilder: Ct
+            }), kt({
                 type: "array",
                 names: ["gathered", "gather", "gather*"],
                 props: {
                     numArgs: 0
                 },
                 handler(n) {
-                    R.contains(["gather", "gather*"], n.envName) && i0(n);
+                    N.contains(["gather", "gather*"], n.envName) && gr(n);
                     let t = {
                         cols: [{
                             type: "align",
                             align: "c"
                         }],
                         addJot: !0,
                         colSeparationType: "gather",
-                        autoTag: bn(n.envName),
+                        autoTag: Bn(n.envName),
                         emptySingleRow: !0,
                         leqno: n.parser.settings.leqno
                     };
-                    return $t(n.parser, t, "display")
+                    return Wt(n.parser, t, "display")
                 },
-                htmlBuilder: kt,
-                mathmlBuilder: _t
-            }), wt({
+                htmlBuilder: _t,
+                mathmlBuilder: Ct
+            }), kt({
                 type: "array",
                 names: ["alignat", "alignat*", "alignedat"],
                 props: {
                     numArgs: 1
                 },
-                handler: So,
-                htmlBuilder: kt,
-                mathmlBuilder: _t
-            }), wt({
+                handler: yo,
+                htmlBuilder: _t,
+                mathmlBuilder: Ct
+            }), kt({
                 type: "array",
                 names: ["equation", "equation*"],
                 props: {
                     numArgs: 0
                 },
                 handler(n) {
-                    i0(n);
+                    gr(n);
                     let t = {
-                        autoTag: bn(n.envName),
+                        autoTag: Bn(n.envName),
                         emptySingleRow: !0,
                         singleRow: !0,
                         maxNumCols: 1,
                         leqno: n.parser.settings.leqno
                     };
-                    return $t(n.parser, t, "display")
+                    return Wt(n.parser, t, "display")
                 },
-                htmlBuilder: kt,
-                mathmlBuilder: _t
-            }), wt({
+                htmlBuilder: _t,
+                mathmlBuilder: Ct
+            }), kt({
                 type: "array",
                 names: ["CD"],
                 props: {
                     numArgs: 0
                 },
                 handler(n) {
-                    return i0(n), C1(n.parser)
+                    return gr(n), gc(n.parser)
                 },
-                htmlBuilder: kt,
-                mathmlBuilder: _t
-            }), k("\\nonumber", "\\gdef\\@eqnsw{0}"), k("\\notag", "\\nonumber"), Q({
+                htmlBuilder: _t,
+                mathmlBuilder: Ct
+            }), w("\\nonumber", "\\gdef\\@eqnsw{0}"), w("\\notag", "\\nonumber"), Z({
                 type: "text",
                 names: ["\\hline", "\\hdashline"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0,
                     allowedInMath: !0
                 },
                 handler(n, t) {
-                    throw new a(n.funcName + " valid only within array environment")
+                    throw new o(n.funcName + " valid only within array environment")
                 }
             });
-            var Co = wo;
-            Q({
+            var vo = bo;
+            Z({
                 type: "environment",
                 names: ["\\begin", "\\end"],
                 props: {
                     numArgs: 1,
                     argTypes: ["text"]
                 },
                 handler(n, t) {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[0];
-                    if (u.type !== "ordgroup") throw new a("Invalid environment name", u);
-                    let p = "";
-                    for (let b = 0; b < u.body.length; ++b) p += de(u.body[b], "textord").text;
-                    if (s === "\\begin") {
-                        if (!Co.hasOwnProperty(p)) throw new a("No such environment: " + p, u);
-                        let b = Co[p],
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[0];
+                    if (c.type !== "ordgroup") throw new o("Invalid environment name", c);
+                    let m = "";
+                    for (let g = 0; g < c.body.length; ++g) m += se(c.body[g], "textord").text;
+                    if (a === "\\begin") {
+                        if (!vo.hasOwnProperty(m)) throw new o("No such environment: " + m, c);
+                        let g = vo[m],
                             {
                                 args: v,
-                                optArgs: S
-                            } = o.parseArguments("\\begin{" + p + "}", b),
-                            E = {
-                                mode: o.mode,
-                                envName: p,
-                                parser: o
+                                optArgs: _
+                            } = u.parseArguments("\\begin{" + m + "}", g),
+                            D = {
+                                mode: u.mode,
+                                envName: m,
+                                parser: u
                             },
-                            z = b.handler(E, v, S);
-                        o.expect("\\end", !1);
-                        let F = o.nextToken,
-                            N = de(o.parseFunction(), "environment");
-                        if (N.name !== p) throw new a("Mismatch: \\begin{" + p + "} matched by \\end{" + N.name + "}", F);
+                            z = g.handler(D, v, _);
+                        u.expect("\\end", !1);
+                        let R = u.nextToken,
+                            L = se(u.parseFunction(), "environment");
+                        if (L.name !== m) throw new o("Mismatch: \\begin{" + m + "} matched by \\end{" + L.name + "}", R);
                         return z
                     }
                     return {
                         type: "environment",
-                        mode: o.mode,
-                        name: p,
-                        nameGroup: u
+                        mode: u.mode,
+                        name: m,
+                        nameGroup: c
                     }
                 }
             });
-            let To = (n, t) => {
-                    let o = n.font,
-                        s = t.withFont(o);
-                    return ve(n.body, s)
-                },
-                Ao = (n, t) => {
-                    let o = n.font,
-                        s = t.withFont(o);
-                    return Ee(n.body, s)
+            let wo = (n, t) => {
+                    let u = n.font,
+                        a = t.withFont(u);
+                    return xe(n.body, a)
+                },
+                ko = (n, t) => {
+                    let u = n.font,
+                        a = t.withFont(u);
+                    return Ae(n.body, a)
                 },
-                qo = {
+                _o = {
                     "\\Bbb": "\\mathbb",
                     "\\bold": "\\mathbf",
                     "\\frak": "\\mathfrak",
                     "\\bm": "\\boldsymbol"
                 };
-            Q({
+            Z({
                 type: "font",
                 names: ["\\mathrm", "\\mathit", "\\mathbf", "\\mathnormal", "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf", "\\mathtt", "\\Bbb", "\\bold", "\\frak"],
                 props: {
                     numArgs: 1,
                     allowedInArgument: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = Xr(t[0]), p = s;
-                    return p in qo && (p = qo[p]), {
+                        parser: u,
+                        funcName: a
+                    } = n, c = cr(t[0]), m = a;
+                    return m in _o && (m = _o[m]), {
                         type: "font",
-                        mode: o.mode,
-                        font: p.slice(1),
-                        body: u
+                        mode: u.mode,
+                        font: m.slice(1),
+                        body: c
                     }
                 },
-                htmlBuilder: To,
-                mathmlBuilder: Ao
-            }), Q({
+                htmlBuilder: wo,
+                mathmlBuilder: ko
+            }), Z({
                 type: "mclass",
                 names: ["\\boldsymbol", "\\bm"],
                 props: {
                     numArgs: 1
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o
-                    } = n, s = t[0], u = R.isCharacterBox(s);
+                        parser: u
+                    } = n, a = t[0], c = N.isCharacterBox(a);
                     return {
                         type: "mclass",
-                        mode: o.mode,
-                        mclass: t0(s),
+                        mode: u.mode,
+                        mclass: mr(a),
                         body: [{
                             type: "font",
-                            mode: o.mode,
+                            mode: u.mode,
                             font: "boldsymbol",
-                            body: s
+                            body: a
                         }],
-                        isCharacterBox: u
+                        isCharacterBox: c
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "font",
                 names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o,
-                        funcName: s,
-                        breakOnTokenText: u
+                        parser: u,
+                        funcName: a,
+                        breakOnTokenText: c
                     } = n, {
-                        mode: p
-                    } = o, b = o.parseExpression(!0, u), v = "math" + s.slice(1);
+                        mode: m
+                    } = u, g = u.parseExpression(!0, c), v = "math" + a.slice(1);
                     return {
                         type: "font",
-                        mode: p,
+                        mode: m,
                         font: v,
                         body: {
                             type: "ordgroup",
-                            mode: o.mode,
-                            body: b
+                            mode: u.mode,
+                            body: g
                         }
                     }
                 },
-                htmlBuilder: To,
-                mathmlBuilder: Ao
+                htmlBuilder: wo,
+                mathmlBuilder: ko
             });
-            let Mo = (n, t) => {
-                    let o = t;
-                    return n === "display" ? o = o.id >= G.SCRIPT.id ? o.text() : G.DISPLAY : n === "text" && o.size === G.DISPLAY.size ? o = G.TEXT : n === "script" ? o = G.SCRIPT : n === "scriptscript" && (o = G.SCRIPTSCRIPT), o
-                },
-                xn = (n, t) => {
-                    let o = Mo(n.size, t.style),
-                        s = o.fracNum(),
-                        u = o.fracDen(),
-                        p;
-                    p = t.havingStyle(s);
-                    let b = ve(n.numer, p, t);
+            let Co = (n, t) => {
+                    let u = t;
+                    return n === "display" ? u = u.id >= O.SCRIPT.id ? u.text() : O.DISPLAY : n === "text" && u.size === O.DISPLAY.size ? u = O.TEXT : n === "script" ? u = O.SCRIPT : n === "scriptscript" && (u = O.SCRIPTSCRIPT), u
+                },
+                Ln = (n, t) => {
+                    let u = Co(n.size, t.style),
+                        a = u.fracNum(),
+                        c = u.fracDen(),
+                        m;
+                    m = t.havingStyle(a);
+                    let g = xe(n.numer, m, t);
                     if (n.continued) {
-                        let xe = 8.5 / t.fontMetrics().ptPerEm,
-                            ke = 3.5 / t.fontMetrics().ptPerEm;
-                        b.height = b.height < xe ? xe : b.height, b.depth = b.depth < ke ? ke : b.depth
-                    }
-                    p = t.havingStyle(u);
-                    let v = ve(n.denom, p, t),
-                        S, E, z;
-                    n.hasBarLine ? (n.barSize ? (E = Ie(n.barSize, t), S = B.makeLineSpan("frac-line", t, E)) : S = B.makeLineSpan("frac-line", t), E = S.height, z = S.height) : (S = null, E = 0, z = t.fontMetrics().defaultRuleThickness);
-                    let F, N, H;
-                    o.size === G.DISPLAY.size || n.size === "display" ? (F = t.fontMetrics().num1, E > 0 ? N = 3 * z : N = 7 * z, H = t.fontMetrics().denom1) : (E > 0 ? (F = t.fontMetrics().num2, N = z) : (F = t.fontMetrics().num3, N = 3 * z), H = t.fontMetrics().denom2);
+                        let be = 8.5 / t.fontMetrics().ptPerEm,
+                            ve = 3.5 / t.fontMetrics().ptPerEm;
+                        g.height = g.height < be ? be : g.height, g.depth = g.depth < ve ? ve : g.depth
+                    }
+                    m = t.havingStyle(c);
+                    let v = xe(n.denom, m, t),
+                        _, D, z;
+                    n.hasBarLine ? (n.barSize ? (D = Le(n.barSize, t), _ = B.makeLineSpan("frac-line", t, D)) : _ = B.makeLineSpan("frac-line", t), D = _.height, z = _.height) : (_ = null, D = 0, z = t.fontMetrics().defaultRuleThickness);
+                    let R, L, P;
+                    u.size === O.DISPLAY.size || n.size === "display" ? (R = t.fontMetrics().num1, D > 0 ? L = 3 * z : L = 7 * z, P = t.fontMetrics().denom1) : (D > 0 ? (R = t.fontMetrics().num2, L = z) : (R = t.fontMetrics().num3, L = 3 * z), P = t.fontMetrics().denom2);
                     let K;
-                    if (S) {
-                        let xe = t.fontMetrics().axisHeight;
-                        F - b.depth - (xe + .5 * E) < N && (F += N - (F - b.depth - (xe + .5 * E))), xe - .5 * E - (v.height - H) < N && (H += N - (xe - .5 * E - (v.height - H)));
-                        let ke = -(xe - .5 * E);
+                    if (_) {
+                        let be = t.fontMetrics().axisHeight;
+                        R - g.depth - (be + .5 * D) < L && (R += L - (R - g.depth - (be + .5 * D))), be - .5 * D - (v.height - P) < L && (P += L - (be - .5 * D - (v.height - P)));
+                        let ve = -(be - .5 * D);
                         K = B.makeVList({
                             positionType: "individualShift",
                             children: [{
                                 type: "elem",
                                 elem: v,
-                                shift: H
+                                shift: P
                             }, {
                                 type: "elem",
-                                elem: S,
-                                shift: ke
+                                elem: _,
+                                shift: ve
                             }, {
                                 type: "elem",
-                                elem: b,
-                                shift: -F
+                                elem: g,
+                                shift: -R
                             }]
                         }, t)
                     } else {
-                        let xe = F - b.depth - (v.height - H);
-                        xe < N && (F += .5 * (N - xe), H += .5 * (N - xe)), K = B.makeVList({
+                        let be = R - g.depth - (v.height - P);
+                        be < L && (R += .5 * (L - be), P += .5 * (L - be)), K = B.makeVList({
                             positionType: "individualShift",
                             children: [{
                                 type: "elem",
                                 elem: v,
-                                shift: H
+                                shift: P
                             }, {
                                 type: "elem",
-                                elem: b,
-                                shift: -F
+                                elem: g,
+                                shift: -R
                             }]
                         }, t)
                     }
-                    p = t.havingStyle(o), K.height *= p.sizeMultiplier / t.sizeMultiplier, K.depth *= p.sizeMultiplier / t.sizeMultiplier;
-                    let ie;
-                    o.size === G.DISPLAY.size ? ie = t.fontMetrics().delim1 : o.size === G.SCRIPTSCRIPT.size ? ie = t.havingStyle(G.SCRIPT).fontMetrics().delim2 : ie = t.fontMetrics().delim2;
-                    let ye, ge;
-                    return n.leftDelim == null ? ye = wr(t, ["mopen"]) : ye = Bt.customSizedDelim(n.leftDelim, ie, !0, t.havingStyle(o), n.mode, ["mopen"]), n.continued ? ge = B.makeSpan([]) : n.rightDelim == null ? ge = wr(t, ["mclose"]) : ge = Bt.customSizedDelim(n.rightDelim, ie, !0, t.havingStyle(o), n.mode, ["mclose"]), B.makeSpan(["mord"].concat(p.sizingClasses(t)), [ye, B.makeSpan(["mfrac"], [K]), ge], t)
-                },
-                vn = (n, t) => {
-                    let o = new V.MathNode("mfrac", [Ee(n.numer, t), Ee(n.denom, t)]);
-                    if (!n.hasBarLine) o.setAttribute("linethickness", "0px");
+                    m = t.havingStyle(u), K.height *= m.sizeMultiplier / t.sizeMultiplier, K.depth *= m.sizeMultiplier / t.sizeMultiplier;
+                    let re;
+                    u.size === O.DISPLAY.size ? re = t.fontMetrics().delim1 : u.size === O.SCRIPTSCRIPT.size ? re = t.havingStyle(O.SCRIPT).fontMetrics().delim2 : re = t.fontMetrics().delim2;
+                    let pe, de;
+                    return n.leftDelim == null ? pe = z0(t, ["mopen"]) : pe = Lt.customSizedDelim(n.leftDelim, re, !0, t.havingStyle(u), n.mode, ["mopen"]), n.continued ? de = B.makeSpan([]) : n.rightDelim == null ? de = z0(t, ["mclose"]) : de = Lt.customSizedDelim(n.rightDelim, re, !0, t.havingStyle(u), n.mode, ["mclose"]), B.makeSpan(["mord"].concat(m.sizingClasses(t)), [pe, B.makeSpan(["mfrac"], [K]), de], t)
+                },
+                Pn = (n, t) => {
+                    let u = new H.MathNode("mfrac", [Ae(n.numer, t), Ae(n.denom, t)]);
+                    if (!n.hasBarLine) u.setAttribute("linethickness", "0px");
                     else if (n.barSize) {
-                        let u = Ie(n.barSize, t);
-                        o.setAttribute("linethickness", Z(u))
+                        let c = Le(n.barSize, t);
+                        u.setAttribute("linethickness", j(c))
                     }
-                    let s = Mo(n.size, t.style);
-                    if (s.size !== t.style.size) {
-                        o = new V.MathNode("mstyle", [o]);
-                        let u = s.size === G.DISPLAY.size ? "true" : "false";
-                        o.setAttribute("displaystyle", u), o.setAttribute("scriptlevel", "0")
+                    let a = Co(n.size, t.style);
+                    if (a.size !== t.style.size) {
+                        u = new H.MathNode("mstyle", [u]);
+                        let c = a.size === O.DISPLAY.size ? "true" : "false";
+                        u.setAttribute("displaystyle", c), u.setAttribute("scriptlevel", "0")
                     }
                     if (n.leftDelim != null || n.rightDelim != null) {
-                        let u = [];
+                        let c = [];
                         if (n.leftDelim != null) {
-                            let p = new V.MathNode("mo", [new V.TextNode(n.leftDelim.replace("\\", ""))]);
-                            p.setAttribute("fence", "true"), u.push(p)
+                            let m = new H.MathNode("mo", [new H.TextNode(n.leftDelim.replace("\\", ""))]);
+                            m.setAttribute("fence", "true"), c.push(m)
                         }
-                        if (u.push(o), n.rightDelim != null) {
-                            let p = new V.MathNode("mo", [new V.TextNode(n.rightDelim.replace("\\", ""))]);
-                            p.setAttribute("fence", "true"), u.push(p)
+                        if (c.push(u), n.rightDelim != null) {
+                            let m = new H.MathNode("mo", [new H.TextNode(n.rightDelim.replace("\\", ""))]);
+                            m.setAttribute("fence", "true"), c.push(m)
                         }
-                        return rn(u)
+                        return wn(c)
                     }
-                    return o
+                    return u
                 };
-            Q({
+            Z({
                 type: "genfrac",
                 names: ["\\dfrac", "\\frac", "\\tfrac", "\\dbinom", "\\binom", "\\tbinom", "\\\\atopfrac", "\\\\bracefrac", "\\\\brackfrac"],
                 props: {
                     numArgs: 2,
                     allowedInArgument: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[0], p = t[1], b, v = null, S = null, E = "auto";
-                    switch (s) {
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[0], m = t[1], g, v = null, _ = null, D = "auto";
+                    switch (a) {
                         case "\\dfrac":
                         case "\\frac":
                         case "\\tfrac":
-                            b = !0;
+                            g = !0;
                             break;
                         case "\\\\atopfrac":
-                            b = !1;
+                            g = !1;
                             break;
                         case "\\dbinom":
                         case "\\binom":
                         case "\\tbinom":
-                            b = !1, v = "(", S = ")";
+                            g = !1, v = "(", _ = ")";
                             break;
                         case "\\\\bracefrac":
-                            b = !1, v = "\\{", S = "\\}";
+                            g = !1, v = "\\{", _ = "\\}";
                             break;
                         case "\\\\brackfrac":
-                            b = !1, v = "[", S = "]";
+                            g = !1, v = "[", _ = "]";
                             break;
                         default:
                             throw new Error("Unrecognized genfrac command")
                     }
-                    switch (s) {
+                    switch (a) {
                         case "\\dfrac":
                         case "\\dbinom":
-                            E = "display";
+                            D = "display";
                             break;
                         case "\\tfrac":
                         case "\\tbinom":
-                            E = "text";
+                            D = "text";
                             break
                     }
                     return {
                         type: "genfrac",
-                        mode: o.mode,
+                        mode: u.mode,
                         continued: !1,
-                        numer: u,
-                        denom: p,
-                        hasBarLine: b,
+                        numer: c,
+                        denom: m,
+                        hasBarLine: g,
                         leftDelim: v,
-                        rightDelim: S,
-                        size: E,
+                        rightDelim: _,
+                        size: D,
                         barSize: null
                     }
                 },
-                htmlBuilder: xn,
-                mathmlBuilder: vn
-            }), Q({
+                htmlBuilder: Ln,
+                mathmlBuilder: Pn
+            }), Z({
                 type: "genfrac",
                 names: ["\\cfrac"],
                 props: {
                     numArgs: 2
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[0], p = t[1];
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[0], m = t[1];
                     return {
                         type: "genfrac",
-                        mode: o.mode,
+                        mode: u.mode,
                         continued: !0,
-                        numer: u,
-                        denom: p,
+                        numer: c,
+                        denom: m,
                         hasBarLine: !0,
                         leftDelim: null,
                         rightDelim: null,
                         size: "display",
                         barSize: null
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "infix",
                 names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
                 props: {
                     numArgs: 0,
                     infix: !0
                 },
                 handler(n) {
                     let {
                         parser: t,
-                        funcName: o,
-                        token: s
-                    } = n, u;
-                    switch (o) {
+                        funcName: u,
+                        token: a
+                    } = n, c;
+                    switch (u) {
                         case "\\over":
-                            u = "\\frac";
+                            c = "\\frac";
                             break;
                         case "\\choose":
-                            u = "\\binom";
+                            c = "\\binom";
                             break;
                         case "\\atop":
-                            u = "\\\\atopfrac";
+                            c = "\\\\atopfrac";
                             break;
                         case "\\brace":
-                            u = "\\\\bracefrac";
+                            c = "\\\\bracefrac";
                             break;
                         case "\\brack":
-                            u = "\\\\brackfrac";
+                            c = "\\\\brackfrac";
                             break;
                         default:
                             throw new Error("Unrecognized infix genfrac command")
                     }
                     return {
                         type: "infix",
                         mode: t.mode,
-                        replaceWith: u,
-                        token: s
+                        replaceWith: c,
+                        token: a
                     }
                 }
             });
-            let Eo = ["display", "text", "script", "scriptscript"],
-                Do = function(n) {
+            let So = ["display", "text", "script", "scriptscript"],
+                Ao = function(n) {
                     let t = null;
                     return n.length > 0 && (t = n, t = t === "." ? null : t), t
                 };
-            Q({
+            Z({
                 type: "genfrac",
                 names: ["\\genfrac"],
                 props: {
                     numArgs: 6,
                     allowedInArgument: !0,
                     argTypes: ["math", "math", "size", "text", "math", "math"]
                 },
                 handler(n, t) {
                     let {
-                        parser: o
-                    } = n, s = t[4], u = t[5], p = Xr(t[0]), b = p.type === "atom" && p.family === "open" ? Do(p.text) : null, v = Xr(t[1]), S = v.type === "atom" && v.family === "close" ? Do(v.text) : null, E = de(t[2], "size"), z, F = null;
-                    E.isBlank ? z = !0 : (F = E.value, z = F.number > 0);
-                    let N = "auto",
-                        H = t[3];
-                    if (H.type === "ordgroup") {
-                        if (H.body.length > 0) {
-                            let K = de(H.body[0], "textord");
-                            N = Eo[Number(K.text)]
+                        parser: u
+                    } = n, a = t[4], c = t[5], m = cr(t[0]), g = m.type === "atom" && m.family === "open" ? Ao(m.text) : null, v = cr(t[1]), _ = v.type === "atom" && v.family === "close" ? Ao(v.text) : null, D = se(t[2], "size"), z, R = null;
+                    D.isBlank ? z = !0 : (R = D.value, z = R.number > 0);
+                    let L = "auto",
+                        P = t[3];
+                    if (P.type === "ordgroup") {
+                        if (P.body.length > 0) {
+                            let K = se(P.body[0], "textord");
+                            L = So[Number(K.text)]
                         }
-                    } else H = de(H, "textord"), N = Eo[Number(H.text)];
+                    } else P = se(P, "textord"), L = So[Number(P.text)];
                     return {
                         type: "genfrac",
-                        mode: o.mode,
-                        numer: s,
-                        denom: u,
+                        mode: u.mode,
+                        numer: a,
+                        denom: c,
                         continued: !1,
                         hasBarLine: z,
-                        barSize: F,
-                        leftDelim: b,
-                        rightDelim: S,
-                        size: N
+                        barSize: R,
+                        leftDelim: g,
+                        rightDelim: _,
+                        size: L
                     }
                 },
-                htmlBuilder: xn,
-                mathmlBuilder: vn
-            }), Q({
+                htmlBuilder: Ln,
+                mathmlBuilder: Pn
+            }), Z({
                 type: "infix",
                 names: ["\\above"],
                 props: {
                     numArgs: 1,
                     argTypes: ["size"],
                     infix: !0
                 },
                 handler(n, t) {
                     let {
-                        parser: o,
-                        funcName: s,
-                        token: u
+                        parser: u,
+                        funcName: a,
+                        token: c
                     } = n;
                     return {
                         type: "infix",
-                        mode: o.mode,
+                        mode: u.mode,
                         replaceWith: "\\\\abovefrac",
-                        size: de(t[0], "size").value,
-                        token: u
+                        size: se(t[0], "size").value,
+                        token: c
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "genfrac",
                 names: ["\\\\abovefrac"],
                 props: {
                     numArgs: 3,
                     argTypes: ["math", "size", "math"]
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[0], p = A(de(t[1], "infix").size), b = t[2], v = p.number > 0;
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[0], m = E(se(t[1], "infix").size), g = t[2], v = m.number > 0;
                     return {
                         type: "genfrac",
-                        mode: o.mode,
-                        numer: u,
-                        denom: b,
+                        mode: u.mode,
+                        numer: c,
+                        denom: g,
                         continued: !1,
                         hasBarLine: v,
-                        barSize: p,
+                        barSize: m,
                         leftDelim: null,
                         rightDelim: null,
                         size: "auto"
                     }
                 },
-                htmlBuilder: xn,
-                mathmlBuilder: vn
+                htmlBuilder: Ln,
+                mathmlBuilder: Pn
             });
-            let zo = (n, t) => {
-                let o = t.style,
-                    s, u;
-                n.type === "supsub" ? (s = n.sup ? ve(n.sup, t.havingStyle(o.sup()), t) : ve(n.sub, t.havingStyle(o.sub()), t), u = de(n.base, "horizBrace")) : u = de(n, "horizBrace");
-                let p = ve(u.base, t.havingBaseStyle(G.DISPLAY)),
-                    b = Ft.svgSpan(u, t),
+            let To = (n, t) => {
+                let u = t.style,
+                    a, c;
+                n.type === "supsub" ? (a = n.sup ? xe(n.sup, t.havingStyle(u.sup()), t) : xe(n.sub, t.havingStyle(u.sub()), t), c = se(n.base, "horizBrace")) : c = se(n, "horizBrace");
+                let m = xe(c.base, t.havingBaseStyle(O.DISPLAY)),
+                    g = Nt.svgSpan(c, t),
                     v;
-                if (u.isOver ? (v = B.makeVList({
+                if (c.isOver ? (v = B.makeVList({
                         positionType: "firstBaseline",
                         children: [{
                             type: "elem",
-                            elem: p
+                            elem: m
                         }, {
                             type: "kern",
                             size: .1
                         }, {
                             type: "elem",
-                            elem: b
+                            elem: g
                         }]
                     }, t), v.children[0].children[0].children[1].classes.push("svg-align")) : (v = B.makeVList({
                         positionType: "bottom",
-                        positionData: p.depth + .1 + b.height,
+                        positionData: m.depth + .1 + g.height,
                         children: [{
                             type: "elem",
-                            elem: b
+                            elem: g
                         }, {
                             type: "kern",
                             size: .1
                         }, {
                             type: "elem",
-                            elem: p
+                            elem: m
                         }]
-                    }, t), v.children[0].children[0].children[0].classes.push("svg-align")), s) {
-                    let S = B.makeSpan(["mord", u.isOver ? "mover" : "munder"], [v], t);
-                    u.isOver ? v = B.makeVList({
+                    }, t), v.children[0].children[0].children[0].classes.push("svg-align")), a) {
+                    let _ = B.makeSpan(["mord", c.isOver ? "mover" : "munder"], [v], t);
+                    c.isOver ? v = B.makeVList({
                         positionType: "firstBaseline",
                         children: [{
                             type: "elem",
-                            elem: S
+                            elem: _
                         }, {
                             type: "kern",
                             size: .2
                         }, {
                             type: "elem",
-                            elem: s
+                            elem: a
                         }]
                     }, t) : v = B.makeVList({
                         positionType: "bottom",
-                        positionData: S.depth + .2 + s.height + s.depth,
+                        positionData: _.depth + .2 + a.height + a.depth,
                         children: [{
                             type: "elem",
-                            elem: s
+                            elem: a
                         }, {
                             type: "kern",
                             size: .2
                         }, {
                             type: "elem",
-                            elem: S
+                            elem: _
                         }]
                     }, t)
                 }
-                return B.makeSpan(["mord", u.isOver ? "mover" : "munder"], [v], t)
+                return B.makeSpan(["mord", c.isOver ? "mover" : "munder"], [v], t)
             };
-            Q({
+            Z({
                 type: "horizBrace",
                 names: ["\\overbrace", "\\underbrace"],
                 props: {
                     numArgs: 1
                 },
                 handler(n, t) {
                     let {
-                        parser: o,
-                        funcName: s
+                        parser: u,
+                        funcName: a
                     } = n;
                     return {
                         type: "horizBrace",
-                        mode: o.mode,
-                        label: s,
-                        isOver: /^\\over/.test(s),
+                        mode: u.mode,
+                        label: a,
+                        isOver: /^\\over/.test(a),
                         base: t[0]
                     }
                 },
-                htmlBuilder: zo,
+                htmlBuilder: To,
                 mathmlBuilder: (n, t) => {
-                    let o = Ft.mathMLnode(n.label);
-                    return new V.MathNode(n.isOver ? "mover" : "munder", [Ee(n.base, t), o])
+                    let u = Nt.mathMLnode(n.label);
+                    return new H.MathNode(n.isOver ? "mover" : "munder", [Ae(n.base, t), u])
                 }
-            }), Q({
+            }), Z({
                 type: "href",
                 names: ["\\href"],
                 props: {
                     numArgs: 2,
                     argTypes: ["url", "original"],
                     allowedInText: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o
-                    } = n, s = t[1], u = de(t[0], "url").url;
-                    return o.settings.isTrusted({
+                        parser: u
+                    } = n, a = t[1], c = se(t[0], "url").url;
+                    return u.settings.isTrusted({
                         command: "\\href",
-                        url: u
+                        url: c
                     }) ? {
                         type: "href",
-                        mode: o.mode,
-                        href: u,
-                        body: je(s)
-                    } : o.formatUnsupportedCmd("\\href")
+                        mode: u.mode,
+                        href: c,
+                        body: Ge(a)
+                    } : u.formatUnsupportedCmd("\\href")
                 },
                 htmlBuilder: (n, t) => {
-                    let o = Ze(n.body, t, !1);
-                    return B.makeAnchor(n.href, [], o, t)
+                    let u = We(n.body, t, !1);
+                    return B.makeAnchor(n.href, [], u, t)
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = Ht(n.body, t);
-                    return o instanceof ht || (o = new ht("mrow", [o])), o.setAttribute("href", n.href), o
+                    let u = jt(n.body, t);
+                    return u instanceof ht || (u = new ht("mrow", [u])), u.setAttribute("href", n.href), u
                 }
-            }), Q({
+            }), Z({
                 type: "href",
                 names: ["\\url"],
                 props: {
                     numArgs: 1,
                     argTypes: ["url"],
                     allowedInText: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o
-                    } = n, s = de(t[0], "url").url;
-                    if (!o.settings.isTrusted({
+                        parser: u
+                    } = n, a = se(t[0], "url").url;
+                    if (!u.settings.isTrusted({
                             command: "\\url",
-                            url: s
-                        })) return o.formatUnsupportedCmd("\\url");
-                    let u = [];
-                    for (let b = 0; b < s.length; b++) {
-                        let v = s[b];
-                        v === "~" && (v = "\\textasciitilde"), u.push({
+                            url: a
+                        })) return u.formatUnsupportedCmd("\\url");
+                    let c = [];
+                    for (let g = 0; g < a.length; g++) {
+                        let v = a[g];
+                        v === "~" && (v = "\\textasciitilde"), c.push({
                             type: "textord",
                             mode: "text",
                             text: v
                         })
                     }
-                    let p = {
+                    let m = {
                         type: "text",
-                        mode: o.mode,
+                        mode: u.mode,
                         font: "\\texttt",
-                        body: u
+                        body: c
                     };
                     return {
                         type: "href",
-                        mode: o.mode,
-                        href: s,
-                        body: je(p)
+                        mode: u.mode,
+                        href: a,
+                        body: Ge(m)
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "hbox",
                 names: ["\\hbox"],
                 props: {
                     numArgs: 1,
                     argTypes: ["text"],
                     allowedInText: !0,
                     primitive: !0
                 },
                 handler(n, t) {
                     let {
-                        parser: o
+                        parser: u
                     } = n;
                     return {
                         type: "hbox",
-                        mode: o.mode,
-                        body: je(t[0])
+                        mode: u.mode,
+                        body: Ge(t[0])
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = Ze(n.body, t, !1);
-                    return B.makeFragment(o)
+                    let u = We(n.body, t, !1);
+                    return B.makeFragment(u)
                 },
                 mathmlBuilder(n, t) {
-                    return new V.MathNode("mrow", it(n.body, t))
+                    return new H.MathNode("mrow", it(n.body, t))
                 }
-            }), Q({
+            }), Z({
                 type: "html",
                 names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
                 props: {
                     numArgs: 2,
                     argTypes: ["raw", "original"],
                     allowedInText: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o,
-                        funcName: s,
-                        token: u
-                    } = n, p = de(t[0], "raw").string, b = t[1];
-                    o.settings.strict && o.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
-                    let v, S = {};
-                    switch (s) {
+                        parser: u,
+                        funcName: a,
+                        token: c
+                    } = n, m = se(t[0], "raw").string, g = t[1];
+                    u.settings.strict && u.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
+                    let v, _ = {};
+                    switch (a) {
                         case "\\htmlClass":
-                            S.class = p, v = {
+                            _.class = m, v = {
                                 command: "\\htmlClass",
-                                class: p
+                                class: m
                             };
                             break;
                         case "\\htmlId":
-                            S.id = p, v = {
+                            _.id = m, v = {
                                 command: "\\htmlId",
-                                id: p
+                                id: m
                             };
                             break;
                         case "\\htmlStyle":
-                            S.style = p, v = {
+                            _.style = m, v = {
                                 command: "\\htmlStyle",
-                                style: p
+                                style: m
                             };
                             break;
                         case "\\htmlData": {
-                            let E = p.split(",");
-                            for (let z = 0; z < E.length; z++) {
-                                let F = E[z].split("=");
-                                if (F.length !== 2) throw new a("Error parsing key-value for \\htmlData");
-                                S["data-" + F[0].trim()] = F[1].trim()
+                            let D = m.split(",");
+                            for (let z = 0; z < D.length; z++) {
+                                let R = D[z].split("=");
+                                if (R.length !== 2) throw new o("Error parsing key-value for \\htmlData");
+                                _["data-" + R[0].trim()] = R[1].trim()
                             }
                             v = {
                                 command: "\\htmlData",
-                                attributes: S
+                                attributes: _
                             };
                             break
                         }
                         default:
                             throw new Error("Unrecognized html command")
                     }
-                    return o.settings.isTrusted(v) ? {
+                    return u.settings.isTrusted(v) ? {
                         type: "html",
-                        mode: o.mode,
-                        attributes: S,
-                        body: je(b)
-                    } : o.formatUnsupportedCmd(s)
+                        mode: u.mode,
+                        attributes: _,
+                        body: Ge(g)
+                    } : u.formatUnsupportedCmd(a)
                 },
                 htmlBuilder: (n, t) => {
-                    let o = Ze(n.body, t, !1),
-                        s = ["enclosing"];
-                    n.attributes.class && s.push(...n.attributes.class.trim().split(/\s+/));
-                    let u = B.makeSpan(s, o, t);
-                    for (let p in n.attributes) p !== "class" && n.attributes.hasOwnProperty(p) && u.setAttribute(p, n.attributes[p]);
-                    return u
+                    let u = We(n.body, t, !1),
+                        a = ["enclosing"];
+                    n.attributes.class && a.push(...n.attributes.class.trim().split(/\s+/));
+                    let c = B.makeSpan(a, u, t);
+                    for (let m in n.attributes) m !== "class" && n.attributes.hasOwnProperty(m) && c.setAttribute(m, n.attributes[m]);
+                    return c
                 },
-                mathmlBuilder: (n, t) => Ht(n.body, t)
-            }), Q({
+                mathmlBuilder: (n, t) => jt(n.body, t)
+            }), Z({
                 type: "htmlmathml",
                 names: ["\\html@mathml"],
                 props: {
                     numArgs: 2,
                     allowedInText: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o
+                        parser: u
                     } = n;
                     return {
                         type: "htmlmathml",
-                        mode: o.mode,
-                        html: je(t[0]),
-                        mathml: je(t[1])
+                        mode: u.mode,
+                        html: Ge(t[0]),
+                        mathml: Ge(t[1])
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    let o = Ze(n.html, t, !1);
-                    return B.makeFragment(o)
+                    let u = We(n.html, t, !1);
+                    return B.makeFragment(u)
                 },
-                mathmlBuilder: (n, t) => Ht(n.mathml, t)
+                mathmlBuilder: (n, t) => jt(n.mathml, t)
             });
-            let wn = function(n) {
+            let In = function(n) {
                 if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(n)) return {
                     number: +n,
                     unit: "bp"
                 };
                 {
                     let t = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(n);
-                    if (!t) throw new a("Invalid size: '" + n + "' in \\includegraphics");
-                    let o = {
+                    if (!t) throw new o("Invalid size: '" + n + "' in \\includegraphics");
+                    let u = {
                         number: +(t[1] + t[2]),
                         unit: t[3]
                     };
-                    if (!Ni(o)) throw new a("Invalid unit: '" + o.unit + "' in \\includegraphics.");
-                    return o
+                    if (!qi(u)) throw new o("Invalid unit: '" + u.unit + "' in \\includegraphics.");
+                    return u
                 }
             };
-            Q({
+            Z({
                 type: "includegraphics",
                 names: ["\\includegraphics"],
                 props: {
                     numArgs: 1,
                     numOptionalArgs: 1,
                     argTypes: ["raw", "url"],
                     allowedInText: !1
                 },
-                handler: (n, t, o) => {
+                handler: (n, t, u) => {
                     let {
-                        parser: s
-                    } = n, u = {
+                        parser: a
+                    } = n, c = {
                         number: 0,
                         unit: "em"
-                    }, p = {
+                    }, m = {
                         number: .9,
                         unit: "em"
-                    }, b = {
+                    }, g = {
                         number: 0,
                         unit: "em"
                     }, v = "";
-                    if (o[0]) {
-                        let z = de(o[0], "raw").string.split(",");
-                        for (let F = 0; F < z.length; F++) {
-                            let N = z[F].split("=");
-                            if (N.length === 2) {
-                                let H = N[1].trim();
-                                switch (N[0].trim()) {
+                    if (u[0]) {
+                        let z = se(u[0], "raw").string.split(",");
+                        for (let R = 0; R < z.length; R++) {
+                            let L = z[R].split("=");
+                            if (L.length === 2) {
+                                let P = L[1].trim();
+                                switch (L[0].trim()) {
                                     case "alt":
-                                        v = H;
+                                        v = P;
                                         break;
                                     case "width":
-                                        u = wn(H);
+                                        c = In(P);
                                         break;
                                     case "height":
-                                        p = wn(H);
+                                        m = In(P);
                                         break;
                                     case "totalheight":
-                                        b = wn(H);
+                                        g = In(P);
                                         break;
                                     default:
-                                        throw new a("Invalid key: '" + N[0] + "' in \\includegraphics.")
+                                        throw new o("Invalid key: '" + L[0] + "' in \\includegraphics.")
                                 }
                             }
                         }
                     }
-                    let S = de(t[0], "url").url;
-                    return v === "" && (v = S, v = v.replace(/^.*[\\/]/, ""), v = v.substring(0, v.lastIndexOf("."))), s.settings.isTrusted({
+                    let _ = se(t[0], "url").url;
+                    return v === "" && (v = _, v = v.replace(/^.*[\\/]/, ""), v = v.substring(0, v.lastIndexOf("."))), a.settings.isTrusted({
                         command: "\\includegraphics",
-                        url: S
+                        url: _
                     }) ? {
                         type: "includegraphics",
-                        mode: s.mode,
+                        mode: a.mode,
                         alt: v,
-                        width: u,
-                        height: p,
-                        totalheight: b,
-                        src: S
-                    } : s.formatUnsupportedCmd("\\includegraphics")
+                        width: c,
+                        height: m,
+                        totalheight: g,
+                        src: _
+                    } : a.formatUnsupportedCmd("\\includegraphics")
                 },
                 htmlBuilder: (n, t) => {
-                    let o = Ie(n.height, t),
-                        s = 0;
-                    n.totalheight.number > 0 && (s = Ie(n.totalheight, t) - o);
-                    let u = 0;
-                    n.width.number > 0 && (u = Ie(n.width, t));
-                    let p = {
-                        height: Z(o + s)
+                    let u = Le(n.height, t),
+                        a = 0;
+                    n.totalheight.number > 0 && (a = Le(n.totalheight, t) - u);
+                    let c = 0;
+                    n.width.number > 0 && (c = Le(n.width, t));
+                    let m = {
+                        height: j(u + a)
                     };
-                    u > 0 && (p.width = Z(u)), s > 0 && (p.verticalAlign = Z(-s));
-                    let b = new Vu(n.src, n.alt, p);
-                    return b.height = o, b.depth = s, b
+                    c > 0 && (m.width = j(c)), a > 0 && (m.verticalAlign = j(-a));
+                    let g = new Nl(n.src, n.alt, m);
+                    return g.height = u, g.depth = a, g
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = new V.MathNode("mglyph", []);
-                    o.setAttribute("alt", n.alt);
-                    let s = Ie(n.height, t),
-                        u = 0;
-                    if (n.totalheight.number > 0 && (u = Ie(n.totalheight, t) - s, o.setAttribute("valign", Z(-u))), o.setAttribute("height", Z(s + u)), n.width.number > 0) {
-                        let p = Ie(n.width, t);
-                        o.setAttribute("width", Z(p))
+                    let u = new H.MathNode("mglyph", []);
+                    u.setAttribute("alt", n.alt);
+                    let a = Le(n.height, t),
+                        c = 0;
+                    if (n.totalheight.number > 0 && (c = Le(n.totalheight, t) - a, u.setAttribute("valign", j(-c))), u.setAttribute("height", j(a + c)), n.width.number > 0) {
+                        let m = Le(n.width, t);
+                        u.setAttribute("width", j(m))
                     }
-                    return o.setAttribute("src", n.src), o
+                    return u.setAttribute("src", n.src), u
                 }
-            }), Q({
+            }), Z({
                 type: "kern",
                 names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
                 props: {
                     numArgs: 1,
                     argTypes: ["size"],
                     primitive: !0,
                     allowedInText: !0
                 },
                 handler(n, t) {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = de(t[0], "size");
-                    if (o.settings.strict) {
-                        let p = s[1] === "m",
-                            b = u.value.unit === "mu";
-                        p ? (b || o.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + s + " supports only mu units, " + ("not " + u.value.unit + " units")), o.mode !== "math" && o.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + s + " works only in math mode")) : b && o.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + s + " doesn't support mu units")
+                        parser: u,
+                        funcName: a
+                    } = n, c = se(t[0], "size");
+                    if (u.settings.strict) {
+                        let m = a[1] === "m",
+                            g = c.value.unit === "mu";
+                        m ? (g || u.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + a + " supports only mu units, " + ("not " + c.value.unit + " units")), u.mode !== "math" && u.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + a + " works only in math mode")) : g && u.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + a + " doesn't support mu units")
                     }
                     return {
                         type: "kern",
-                        mode: o.mode,
-                        dimension: u.value
+                        mode: u.mode,
+                        dimension: c.value
                     }
                 },
                 htmlBuilder(n, t) {
                     return B.makeGlue(n.dimension, t)
                 },
                 mathmlBuilder(n, t) {
-                    let o = Ie(n.dimension, t);
-                    return new V.SpaceNode(o)
+                    let u = Le(n.dimension, t);
+                    return new H.SpaceNode(u)
                 }
-            }), Q({
+            }), Z({
                 type: "lap",
                 names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
                 props: {
                     numArgs: 1,
                     allowedInText: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[0];
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[0];
                     return {
                         type: "lap",
-                        mode: o.mode,
-                        alignment: s.slice(5),
-                        body: u
+                        mode: u.mode,
+                        alignment: a.slice(5),
+                        body: c
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    let o;
-                    n.alignment === "clap" ? (o = B.makeSpan([], [ve(n.body, t)]), o = B.makeSpan(["inner"], [o], t)) : o = B.makeSpan(["inner"], [ve(n.body, t)]);
-                    let s = B.makeSpan(["fix"], []),
-                        u = B.makeSpan([n.alignment], [o, s], t),
-                        p = B.makeSpan(["strut"]);
-                    return p.style.height = Z(u.height + u.depth), u.depth && (p.style.verticalAlign = Z(-u.depth)), u.children.unshift(p), u = B.makeSpan(["thinbox"], [u], t), B.makeSpan(["mord", "vbox"], [u], t)
+                    let u;
+                    n.alignment === "clap" ? (u = B.makeSpan([], [xe(n.body, t)]), u = B.makeSpan(["inner"], [u], t)) : u = B.makeSpan(["inner"], [xe(n.body, t)]);
+                    let a = B.makeSpan(["fix"], []),
+                        c = B.makeSpan([n.alignment], [u, a], t),
+                        m = B.makeSpan(["strut"]);
+                    return m.style.height = j(c.height + c.depth), c.depth && (m.style.verticalAlign = j(-c.depth)), c.children.unshift(m), c = B.makeSpan(["thinbox"], [c], t), B.makeSpan(["mord", "vbox"], [c], t)
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = new V.MathNode("mpadded", [Ee(n.body, t)]);
+                    let u = new H.MathNode("mpadded", [Ae(n.body, t)]);
                     if (n.alignment !== "rlap") {
-                        let s = n.alignment === "llap" ? "-1" : "-0.5";
-                        o.setAttribute("lspace", s + "width")
+                        let a = n.alignment === "llap" ? "-1" : "-0.5";
+                        u.setAttribute("lspace", a + "width")
                     }
-                    return o.setAttribute("width", "0px"), o
+                    return u.setAttribute("width", "0px"), u
                 }
-            }), Q({
+            }), Z({
                 type: "styling",
                 names: ["\\(", "$"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0,
                     allowedInMath: !1
                 },
                 handler(n, t) {
                     let {
-                        funcName: o,
-                        parser: s
-                    } = n, u = s.mode;
-                    s.switchMode("math");
-                    let p = o === "\\(" ? "\\)" : "$",
-                        b = s.parseExpression(!1, p);
-                    return s.expect(p), s.switchMode(u), {
+                        funcName: u,
+                        parser: a
+                    } = n, c = a.mode;
+                    a.switchMode("math");
+                    let m = u === "\\(" ? "\\)" : "$",
+                        g = a.parseExpression(!1, m);
+                    return a.expect(m), a.switchMode(c), {
                         type: "styling",
-                        mode: s.mode,
+                        mode: a.mode,
                         style: "text",
-                        body: b
+                        body: g
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "text",
                 names: ["\\)", "\\]"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0,
                     allowedInMath: !1
                 },
                 handler(n, t) {
-                    throw new a("Mismatched " + n.funcName)
+                    throw new o("Mismatched " + n.funcName)
                 }
             });
-            let Ro = (n, t) => {
+            let Do = (n, t) => {
                 switch (t.style.size) {
-                    case G.DISPLAY.size:
+                    case O.DISPLAY.size:
                         return n.display;
-                    case G.TEXT.size:
+                    case O.TEXT.size:
                         return n.text;
-                    case G.SCRIPT.size:
+                    case O.SCRIPT.size:
                         return n.script;
-                    case G.SCRIPTSCRIPT.size:
+                    case O.SCRIPTSCRIPT.size:
                         return n.scriptscript;
                     default:
                         return n.text
                 }
             };
-            Q({
+            Z({
                 type: "mathchoice",
                 names: ["\\mathchoice"],
                 props: {
                     numArgs: 4,
                     primitive: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o
+                        parser: u
                     } = n;
                     return {
                         type: "mathchoice",
-                        mode: o.mode,
-                        display: je(t[0]),
-                        text: je(t[1]),
-                        script: je(t[2]),
-                        scriptscript: je(t[3])
+                        mode: u.mode,
+                        display: Ge(t[0]),
+                        text: Ge(t[1]),
+                        script: Ge(t[2]),
+                        scriptscript: Ge(t[3])
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    let o = Ro(n, t),
-                        s = Ze(o, t, !1);
-                    return B.makeFragment(s)
+                    let u = Do(n, t),
+                        a = We(u, t, !1);
+                    return B.makeFragment(a)
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = Ro(n, t);
-                    return Ht(o, t)
+                    let u = Do(n, t);
+                    return jt(u, t)
                 }
             });
-            let Fo = (n, t, o, s, u, p, b) => {
+            let Eo = (n, t, u, a, c, m, g) => {
                     n = B.makeSpan([], [n]);
-                    let v = o && R.isCharacterBox(o),
-                        S, E;
+                    let v = u && N.isCharacterBox(u),
+                        _, D;
                     if (t) {
-                        let N = ve(t, s.havingStyle(u.sup()), s);
-                        E = {
-                            elem: N,
-                            kern: Math.max(s.fontMetrics().bigOpSpacing1, s.fontMetrics().bigOpSpacing3 - N.depth)
+                        let L = xe(t, a.havingStyle(c.sup()), a);
+                        D = {
+                            elem: L,
+                            kern: Math.max(a.fontMetrics().bigOpSpacing1, a.fontMetrics().bigOpSpacing3 - L.depth)
                         }
                     }
-                    if (o) {
-                        let N = ve(o, s.havingStyle(u.sub()), s);
-                        S = {
-                            elem: N,
-                            kern: Math.max(s.fontMetrics().bigOpSpacing2, s.fontMetrics().bigOpSpacing4 - N.height)
+                    if (u) {
+                        let L = xe(u, a.havingStyle(c.sub()), a);
+                        _ = {
+                            elem: L,
+                            kern: Math.max(a.fontMetrics().bigOpSpacing2, a.fontMetrics().bigOpSpacing4 - L.height)
                         }
                     }
                     let z;
-                    if (E && S) {
-                        let N = s.fontMetrics().bigOpSpacing5 + S.elem.height + S.elem.depth + S.kern + n.depth + b;
+                    if (D && _) {
+                        let L = a.fontMetrics().bigOpSpacing5 + _.elem.height + _.elem.depth + _.kern + n.depth + g;
                         z = B.makeVList({
                             positionType: "bottom",
-                            positionData: N,
+                            positionData: L,
                             children: [{
                                 type: "kern",
-                                size: s.fontMetrics().bigOpSpacing5
+                                size: a.fontMetrics().bigOpSpacing5
                             }, {
                                 type: "elem",
-                                elem: S.elem,
-                                marginLeft: Z(-p)
+                                elem: _.elem,
+                                marginLeft: j(-m)
                             }, {
                                 type: "kern",
-                                size: S.kern
+                                size: _.kern
                             }, {
                                 type: "elem",
                                 elem: n
                             }, {
                                 type: "kern",
-                                size: E.kern
+                                size: D.kern
                             }, {
                                 type: "elem",
-                                elem: E.elem,
-                                marginLeft: Z(p)
+                                elem: D.elem,
+                                marginLeft: j(m)
                             }, {
                                 type: "kern",
-                                size: s.fontMetrics().bigOpSpacing5
+                                size: a.fontMetrics().bigOpSpacing5
                             }]
-                        }, s)
-                    } else if (S) {
-                        let N = n.height - b;
+                        }, a)
+                    } else if (_) {
+                        let L = n.height - g;
                         z = B.makeVList({
                             positionType: "top",
-                            positionData: N,
+                            positionData: L,
                             children: [{
                                 type: "kern",
-                                size: s.fontMetrics().bigOpSpacing5
+                                size: a.fontMetrics().bigOpSpacing5
                             }, {
                                 type: "elem",
-                                elem: S.elem,
-                                marginLeft: Z(-p)
+                                elem: _.elem,
+                                marginLeft: j(-m)
                             }, {
                                 type: "kern",
-                                size: S.kern
+                                size: _.kern
                             }, {
                                 type: "elem",
                                 elem: n
                             }]
-                        }, s)
-                    } else if (E) {
-                        let N = n.depth + b;
+                        }, a)
+                    } else if (D) {
+                        let L = n.depth + g;
                         z = B.makeVList({
                             positionType: "bottom",
-                            positionData: N,
+                            positionData: L,
                             children: [{
                                 type: "elem",
                                 elem: n
                             }, {
                                 type: "kern",
-                                size: E.kern
+                                size: D.kern
                             }, {
                                 type: "elem",
-                                elem: E.elem,
-                                marginLeft: Z(p)
+                                elem: D.elem,
+                                marginLeft: j(m)
                             }, {
                                 type: "kern",
-                                size: s.fontMetrics().bigOpSpacing5
+                                size: a.fontMetrics().bigOpSpacing5
                             }]
-                        }, s)
+                        }, a)
                     } else return n;
-                    let F = [z];
-                    if (S && p !== 0 && !v) {
-                        let N = B.makeSpan(["mspace"], [], s);
-                        N.style.marginRight = Z(p), F.unshift(N)
-                    }
-                    return B.makeSpan(["mop", "op-limits"], F, s)
-                },
-                Bo = ["\\smallint"],
-                lr = (n, t) => {
-                    let o, s, u = !1,
-                        p;
-                    n.type === "supsub" ? (o = n.sup, s = n.sub, p = de(n.base, "op"), u = !0) : p = de(n, "op");
-                    let b = t.style,
+                    let R = [z];
+                    if (_ && m !== 0 && !v) {
+                        let L = B.makeSpan(["mspace"], [], a);
+                        L.style.marginRight = j(m), R.unshift(L)
+                    }
+                    return B.makeSpan(["mop", "op-limits"], R, a)
+                },
+                Mo = ["\\smallint"],
+                x0 = (n, t) => {
+                    let u, a, c = !1,
+                        m;
+                    n.type === "supsub" ? (u = n.sup, a = n.sub, m = se(n.base, "op"), c = !0) : m = se(n, "op");
+                    let g = t.style,
                         v = !1;
-                    b.size === G.DISPLAY.size && p.symbol && !R.contains(Bo, p.name) && (v = !0);
-                    let S;
-                    if (p.symbol) {
-                        let F = v ? "Size2-Regular" : "Size1-Regular",
-                            N = "";
-                        if ((p.name === "\\oiint" || p.name === "\\oiiint") && (N = p.name.slice(1), p.name = N === "oiint" ? "\\iint" : "\\iiint"), S = B.makeSymbol(p.name, F, "math", t, ["mop", "op-symbol", v ? "large-op" : "small-op"]), N.length > 0) {
-                            let H = S.italic,
-                                K = B.staticSvg(N + "Size" + (v ? "2" : "1"), t);
-                            S = B.makeVList({
+                    g.size === O.DISPLAY.size && m.symbol && !N.contains(Mo, m.name) && (v = !0);
+                    let _;
+                    if (m.symbol) {
+                        let R = v ? "Size2-Regular" : "Size1-Regular",
+                            L = "";
+                        if ((m.name === "\\oiint" || m.name === "\\oiiint") && (L = m.name.slice(1), m.name = L === "oiint" ? "\\iint" : "\\iiint"), _ = B.makeSymbol(m.name, R, "math", t, ["mop", "op-symbol", v ? "large-op" : "small-op"]), L.length > 0) {
+                            let P = _.italic,
+                                K = B.staticSvg(L + "Size" + (v ? "2" : "1"), t);
+                            _ = B.makeVList({
                                 positionType: "individualShift",
                                 children: [{
                                     type: "elem",
-                                    elem: S,
+                                    elem: _,
                                     shift: 0
                                 }, {
                                     type: "elem",
                                     elem: K,
                                     shift: v ? .08 : 0
                                 }]
-                            }, t), p.name = "\\" + N, S.classes.unshift("mop"), S.italic = H
+                            }, t), m.name = "\\" + L, _.classes.unshift("mop"), _.italic = P
                         }
-                    } else if (p.body) {
-                        let F = Ze(p.body, t, !0);
-                        F.length === 1 && F[0] instanceof ut ? (S = F[0], S.classes[0] = "mop") : S = B.makeSpan(["mop"], F, t)
+                    } else if (m.body) {
+                        let R = We(m.body, t, !0);
+                        R.length === 1 && R[0] instanceof dt ? (_ = R[0], _.classes[0] = "mop") : _ = B.makeSpan(["mop"], R, t)
                     } else {
-                        let F = [];
-                        for (let N = 1; N < p.name.length; N++) F.push(B.mathsym(p.name[N], p.mode, t));
-                        S = B.makeSpan(["mop"], F, t)
+                        let R = [];
+                        for (let L = 1; L < m.name.length; L++) R.push(B.mathsym(m.name[L], m.mode, t));
+                        _ = B.makeSpan(["mop"], R, t)
                     }
-                    let E = 0,
+                    let D = 0,
                         z = 0;
-                    return (S instanceof ut || p.name === "\\oiint" || p.name === "\\oiiint") && !p.suppressBaseShift && (E = (S.height - S.depth) / 2 - t.fontMetrics().axisHeight, z = S.italic), u ? Fo(S, o, s, t, b, z, E) : (E && (S.style.position = "relative", S.style.top = Z(E)), S)
+                    return (_ instanceof dt || m.name === "\\oiint" || m.name === "\\oiiint") && !m.suppressBaseShift && (D = (_.height - _.depth) / 2 - t.fontMetrics().axisHeight, z = _.italic), c ? Eo(_, u, a, t, g, z, D) : (D && (_.style.position = "relative", _.style.top = j(D)), _)
                 },
-                Cr = (n, t) => {
-                    let o;
-                    if (n.symbol) o = new ht("mo", [dt(n.name, n.mode)]), R.contains(Bo, n.name) && o.setAttribute("largeop", "false");
-                    else if (n.body) o = new ht("mo", it(n.body, t));
+                L0 = (n, t) => {
+                    let u;
+                    if (n.symbol) u = new ht("mo", [ft(n.name, n.mode)]), N.contains(Mo, n.name) && u.setAttribute("largeop", "false");
+                    else if (n.body) u = new ht("mo", it(n.body, t));
                     else {
-                        o = new ht("mi", [new kr(n.name.slice(1))]);
-                        let s = new ht("mo", [dt("\u2061", "text")]);
-                        n.parentIsSupSub ? o = new ht("mrow", [o, s]) : o = Xi([o, s])
+                        u = new ht("mi", [new R0(n.name.slice(1))]);
+                        let a = new ht("mo", [ft("\u2061", "text")]);
+                        n.parentIsSupSub ? u = new ht("mrow", [u, a]) : u = ji([u, a])
                     }
-                    return o
+                    return u
                 },
-                I1 = {
+                qc = {
                     "\u220F": "\\prod",
                     "\u2210": "\\coprod",
                     "\u2211": "\\sum",
                     "\u22C0": "\\bigwedge",
                     "\u22C1": "\\bigvee",
                     "\u22C2": "\\bigcap",
                     "\u22C3": "\\bigcup",
                     "\u2A00": "\\bigodot",
                     "\u2A01": "\\bigoplus",
                     "\u2A02": "\\bigotimes",
                     "\u2A04": "\\biguplus",
                     "\u2A06": "\\bigsqcup"
                 };
-            Q({
+            Z({
                 type: "op",
                 names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
                 props: {
                     numArgs: 0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = s;
-                    return u.length === 1 && (u = I1[u]), {
+                        parser: u,
+                        funcName: a
+                    } = n, c = a;
+                    return c.length === 1 && (c = qc[c]), {
                         type: "op",
-                        mode: o.mode,
+                        mode: u.mode,
                         limits: !0,
                         parentIsSupSub: !1,
                         symbol: !0,
-                        name: u
+                        name: c
                     }
                 },
-                htmlBuilder: lr,
-                mathmlBuilder: Cr
-            }), Q({
+                htmlBuilder: x0,
+                mathmlBuilder: L0
+            }), Z({
                 type: "op",
                 names: ["\\mathop"],
                 props: {
                     numArgs: 1,
                     primitive: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o
-                    } = n, s = t[0];
+                        parser: u
+                    } = n, a = t[0];
                     return {
                         type: "op",
-                        mode: o.mode,
+                        mode: u.mode,
                         limits: !1,
                         parentIsSupSub: !1,
                         symbol: !1,
-                        body: je(s)
+                        body: Ge(a)
                     }
                 },
-                htmlBuilder: lr,
-                mathmlBuilder: Cr
+                htmlBuilder: x0,
+                mathmlBuilder: L0
             });
-            let O1 = {
+            let Fc = {
                 "\u222B": "\\int",
                 "\u222C": "\\iint",
                 "\u222D": "\\iiint",
                 "\u222E": "\\oint",
                 "\u222F": "\\oiint",
                 "\u2230": "\\oiiint"
             };
-            Q({
+            Z({
                 type: "op",
                 names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
                 props: {
                     numArgs: 0
                 },
                 handler(n) {
                     let {
                         parser: t,
-                        funcName: o
+                        funcName: u
                     } = n;
                     return {
                         type: "op",
                         mode: t.mode,
                         limits: !1,
                         parentIsSupSub: !1,
                         symbol: !1,
-                        name: o
+                        name: u
                     }
                 },
-                htmlBuilder: lr,
-                mathmlBuilder: Cr
-            }), Q({
+                htmlBuilder: x0,
+                mathmlBuilder: L0
+            }), Z({
                 type: "op",
                 names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
                 props: {
                     numArgs: 0
                 },
                 handler(n) {
                     let {
                         parser: t,
-                        funcName: o
+                        funcName: u
                     } = n;
                     return {
                         type: "op",
                         mode: t.mode,
                         limits: !0,
                         parentIsSupSub: !1,
                         symbol: !1,
-                        name: o
+                        name: u
                     }
                 },
-                htmlBuilder: lr,
-                mathmlBuilder: Cr
-            }), Q({
+                htmlBuilder: x0,
+                mathmlBuilder: L0
+            }), Z({
                 type: "op",
                 names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
                 props: {
                     numArgs: 0
                 },
                 handler(n) {
                     let {
                         parser: t,
-                        funcName: o
-                    } = n, s = o;
-                    return s.length === 1 && (s = O1[s]), {
+                        funcName: u
+                    } = n, a = u;
+                    return a.length === 1 && (a = Fc[a]), {
                         type: "op",
                         mode: t.mode,
                         limits: !1,
                         parentIsSupSub: !1,
                         symbol: !0,
-                        name: s
+                        name: a
                     }
                 },
-                htmlBuilder: lr,
-                mathmlBuilder: Cr
+                htmlBuilder: x0,
+                mathmlBuilder: L0
             });
-            let No = (n, t) => {
-                let o, s, u = !1,
-                    p;
-                n.type === "supsub" ? (o = n.sup, s = n.sub, p = de(n.base, "operatorname"), u = !0) : p = de(n, "operatorname");
-                let b;
-                if (p.body.length > 0) {
-                    let v = p.body.map(E => {
-                            let z = E.text;
+            let qo = (n, t) => {
+                let u, a, c = !1,
+                    m;
+                n.type === "supsub" ? (u = n.sup, a = n.sub, m = se(n.base, "operatorname"), c = !0) : m = se(n, "operatorname");
+                let g;
+                if (m.body.length > 0) {
+                    let v = m.body.map(D => {
+                            let z = D.text;
                             return typeof z == "string" ? {
                                 type: "textord",
-                                mode: E.mode,
+                                mode: D.mode,
                                 text: z
-                            } : E
+                            } : D
                         }),
-                        S = Ze(v, t.withFont("mathrm"), !0);
-                    for (let E = 0; E < S.length; E++) {
-                        let z = S[E];
-                        z instanceof ut && (z.text = z.text.replace(/\u2212/, "-").replace(/\u2217/, "*"))
-                    }
-                    b = B.makeSpan(["mop"], S, t)
-                } else b = B.makeSpan(["mop"], [], t);
-                return u ? Fo(b, o, s, t, t.style, 0, 0) : b
+                        _ = We(v, t.withFont("mathrm"), !0);
+                    for (let D = 0; D < _.length; D++) {
+                        let z = _[D];
+                        z instanceof dt && (z.text = z.text.replace(/\u2212/, "-").replace(/\u2217/, "*"))
+                    }
+                    g = B.makeSpan(["mop"], _, t)
+                } else g = B.makeSpan(["mop"], [], t);
+                return c ? Eo(g, u, a, t, t.style, 0, 0) : g
             };
-            Q({
+            Z({
                 type: "operatorname",
                 names: ["\\operatorname@", "\\operatornamewithlimits"],
                 props: {
                     numArgs: 1
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[0];
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[0];
                     return {
                         type: "operatorname",
-                        mode: o.mode,
-                        body: je(u),
-                        alwaysHandleSupSub: s === "\\operatornamewithlimits",
+                        mode: u.mode,
+                        body: Ge(c),
+                        alwaysHandleSupSub: a === "\\operatornamewithlimits",
                         limits: !1,
                         parentIsSupSub: !1
                     }
                 },
-                htmlBuilder: No,
+                htmlBuilder: qo,
                 mathmlBuilder: (n, t) => {
-                    let o = it(n.body, t.withFont("mathrm")),
-                        s = !0;
-                    for (let b = 0; b < o.length; b++) {
-                        let v = o[b];
-                        if (!(v instanceof V.SpaceNode))
-                            if (v instanceof V.MathNode) switch (v.type) {
+                    let u = it(n.body, t.withFont("mathrm")),
+                        a = !0;
+                    for (let g = 0; g < u.length; g++) {
+                        let v = u[g];
+                        if (!(v instanceof H.SpaceNode))
+                            if (v instanceof H.MathNode) switch (v.type) {
                                 case "mi":
                                 case "mn":
                                 case "ms":
                                 case "mspace":
                                 case "mtext":
                                     break;
                                 case "mo": {
-                                    let S = v.children[0];
-                                    v.children.length === 1 && S instanceof V.TextNode ? S.text = S.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : s = !1;
+                                    let _ = v.children[0];
+                                    v.children.length === 1 && _ instanceof H.TextNode ? _.text = _.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : a = !1;
                                     break
                                 }
                                 default:
-                                    s = !1
-                            } else s = !1
+                                    a = !1
+                            } else a = !1
                     }
-                    if (s) {
-                        let b = o.map(v => v.toText()).join("");
-                        o = [new V.TextNode(b)]
-                    }
-                    let u = new V.MathNode("mi", o);
-                    u.setAttribute("mathvariant", "normal");
-                    let p = new V.MathNode("mo", [dt("\u2061", "text")]);
-                    return n.parentIsSupSub ? new V.MathNode("mrow", [u, p]) : V.newDocumentFragment([u, p])
+                    if (a) {
+                        let g = u.map(v => v.toText()).join("");
+                        u = [new H.TextNode(g)]
+                    }
+                    let c = new H.MathNode("mi", u);
+                    c.setAttribute("mathvariant", "normal");
+                    let m = new H.MathNode("mo", [ft("\u2061", "text")]);
+                    return n.parentIsSupSub ? new H.MathNode("mrow", [c, m]) : H.newDocumentFragment([c, m])
                 }
-            }), k("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@"), Kt({
+            }), w("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@"), o0({
                 type: "ordgroup",
                 htmlBuilder(n, t) {
-                    return n.semisimple ? B.makeFragment(Ze(n.body, t, !1)) : B.makeSpan(["mord"], Ze(n.body, t, !0), t)
+                    return n.semisimple ? B.makeFragment(We(n.body, t, !1)) : B.makeSpan(["mord"], We(n.body, t, !0), t)
                 },
                 mathmlBuilder(n, t) {
-                    return Ht(n.body, t, !0)
+                    return jt(n.body, t, !0)
                 }
-            }), Q({
+            }), Z({
                 type: "overline",
                 names: ["\\overline"],
                 props: {
                     numArgs: 1
                 },
                 handler(n, t) {
                     let {
-                        parser: o
-                    } = n, s = t[0];
+                        parser: u
+                    } = n, a = t[0];
                     return {
                         type: "overline",
-                        mode: o.mode,
-                        body: s
+                        mode: u.mode,
+                        body: a
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = ve(n.body, t.havingCrampedStyle()),
-                        s = B.makeLineSpan("overline-line", t),
-                        u = t.fontMetrics().defaultRuleThickness,
-                        p = B.makeVList({
+                    let u = xe(n.body, t.havingCrampedStyle()),
+                        a = B.makeLineSpan("overline-line", t),
+                        c = t.fontMetrics().defaultRuleThickness,
+                        m = B.makeVList({
                             positionType: "firstBaseline",
                             children: [{
                                 type: "elem",
-                                elem: o
+                                elem: u
                             }, {
                                 type: "kern",
-                                size: 3 * u
+                                size: 3 * c
                             }, {
                                 type: "elem",
-                                elem: s
+                                elem: a
                             }, {
                                 type: "kern",
-                                size: u
+                                size: c
                             }]
                         }, t);
-                    return B.makeSpan(["mord", "overline"], [p], t)
+                    return B.makeSpan(["mord", "overline"], [m], t)
                 },
                 mathmlBuilder(n, t) {
-                    let o = new V.MathNode("mo", [new V.TextNode("\u203E")]);
-                    o.setAttribute("stretchy", "true");
-                    let s = new V.MathNode("mover", [Ee(n.body, t), o]);
-                    return s.setAttribute("accent", "true"), s
+                    let u = new H.MathNode("mo", [new H.TextNode("\u203E")]);
+                    u.setAttribute("stretchy", "true");
+                    let a = new H.MathNode("mover", [Ae(n.body, t), u]);
+                    return a.setAttribute("accent", "true"), a
                 }
-            }), Q({
+            }), Z({
                 type: "phantom",
                 names: ["\\phantom"],
                 props: {
                     numArgs: 1,
                     allowedInText: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o
-                    } = n, s = t[0];
+                        parser: u
+                    } = n, a = t[0];
                     return {
                         type: "phantom",
-                        mode: o.mode,
-                        body: je(s)
+                        mode: u.mode,
+                        body: Ge(a)
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    let o = Ze(n.body, t.withPhantom(), !1);
-                    return B.makeFragment(o)
+                    let u = We(n.body, t.withPhantom(), !1);
+                    return B.makeFragment(u)
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = it(n.body, t);
-                    return new V.MathNode("mphantom", o)
+                    let u = it(n.body, t);
+                    return new H.MathNode("mphantom", u)
                 }
-            }), Q({
+            }), Z({
                 type: "hphantom",
                 names: ["\\hphantom"],
                 props: {
                     numArgs: 1,
                     allowedInText: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o
-                    } = n, s = t[0];
+                        parser: u
+                    } = n, a = t[0];
                     return {
                         type: "hphantom",
-                        mode: o.mode,
-                        body: s
+                        mode: u.mode,
+                        body: a
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    let o = B.makeSpan([], [ve(n.body, t.withPhantom())]);
-                    if (o.height = 0, o.depth = 0, o.children)
-                        for (let s = 0; s < o.children.length; s++) o.children[s].height = 0, o.children[s].depth = 0;
-                    return o = B.makeVList({
+                    let u = B.makeSpan([], [xe(n.body, t.withPhantom())]);
+                    if (u.height = 0, u.depth = 0, u.children)
+                        for (let a = 0; a < u.children.length; a++) u.children[a].height = 0, u.children[a].depth = 0;
+                    return u = B.makeVList({
                         positionType: "firstBaseline",
                         children: [{
                             type: "elem",
-                            elem: o
+                            elem: u
                         }]
-                    }, t), B.makeSpan(["mord"], [o], t)
+                    }, t), B.makeSpan(["mord"], [u], t)
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = it(je(n.body), t),
-                        s = new V.MathNode("mphantom", o),
-                        u = new V.MathNode("mpadded", [s]);
-                    return u.setAttribute("height", "0px"), u.setAttribute("depth", "0px"), u
+                    let u = it(Ge(n.body), t),
+                        a = new H.MathNode("mphantom", u),
+                        c = new H.MathNode("mpadded", [a]);
+                    return c.setAttribute("height", "0px"), c.setAttribute("depth", "0px"), c
                 }
-            }), Q({
+            }), Z({
                 type: "vphantom",
                 names: ["\\vphantom"],
                 props: {
                     numArgs: 1,
                     allowedInText: !0
                 },
                 handler: (n, t) => {
                     let {
-                        parser: o
-                    } = n, s = t[0];
+                        parser: u
+                    } = n, a = t[0];
                     return {
                         type: "vphantom",
-                        mode: o.mode,
-                        body: s
+                        mode: u.mode,
+                        body: a
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    let o = B.makeSpan(["inner"], [ve(n.body, t.withPhantom())]),
-                        s = B.makeSpan(["fix"], []);
-                    return B.makeSpan(["mord", "rlap"], [o, s], t)
+                    let u = B.makeSpan(["inner"], [xe(n.body, t.withPhantom())]),
+                        a = B.makeSpan(["fix"], []);
+                    return B.makeSpan(["mord", "rlap"], [u, a], t)
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = it(je(n.body), t),
-                        s = new V.MathNode("mphantom", o),
-                        u = new V.MathNode("mpadded", [s]);
-                    return u.setAttribute("width", "0px"), u
+                    let u = it(Ge(n.body), t),
+                        a = new H.MathNode("mphantom", u),
+                        c = new H.MathNode("mpadded", [a]);
+                    return c.setAttribute("width", "0px"), c
                 }
-            }), Q({
+            }), Z({
                 type: "raisebox",
                 names: ["\\raisebox"],
                 props: {
                     numArgs: 2,
                     argTypes: ["size", "hbox"],
                     allowedInText: !0
                 },
                 handler(n, t) {
                     let {
-                        parser: o
-                    } = n, s = de(t[0], "size").value, u = t[1];
+                        parser: u
+                    } = n, a = se(t[0], "size").value, c = t[1];
                     return {
                         type: "raisebox",
-                        mode: o.mode,
-                        dy: s,
-                        body: u
+                        mode: u.mode,
+                        dy: a,
+                        body: c
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = ve(n.body, t),
-                        s = Ie(n.dy, t);
+                    let u = xe(n.body, t),
+                        a = Le(n.dy, t);
                     return B.makeVList({
                         positionType: "shift",
-                        positionData: -s,
+                        positionData: -a,
                         children: [{
                             type: "elem",
-                            elem: o
+                            elem: u
                         }]
                     }, t)
                 },
                 mathmlBuilder(n, t) {
-                    let o = new V.MathNode("mpadded", [Ee(n.body, t)]),
-                        s = n.dy.number + n.dy.unit;
-                    return o.setAttribute("voffset", s), o
+                    let u = new H.MathNode("mpadded", [Ae(n.body, t)]),
+                        a = n.dy.number + n.dy.unit;
+                    return u.setAttribute("voffset", a), u
                 }
-            }), Q({
+            }), Z({
                 type: "internal",
                 names: ["\\relax"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0
                 },
                 handler(n) {
@@ -13705,731 +9295,731 @@
                         parser: t
                     } = n;
                     return {
                         type: "internal",
                         mode: t.mode
                     }
                 }
-            }), Q({
+            }), Z({
                 type: "rule",
                 names: ["\\rule"],
                 props: {
                     numArgs: 2,
                     numOptionalArgs: 1,
                     argTypes: ["size", "size", "size"]
                 },
-                handler(n, t, o) {
+                handler(n, t, u) {
                     let {
-                        parser: s
-                    } = n, u = o[0], p = de(t[0], "size"), b = de(t[1], "size");
+                        parser: a
+                    } = n, c = u[0], m = se(t[0], "size"), g = se(t[1], "size");
                     return {
                         type: "rule",
-                        mode: s.mode,
-                        shift: u && de(u, "size").value,
-                        width: p.value,
-                        height: b.value
+                        mode: a.mode,
+                        shift: c && se(c, "size").value,
+                        width: m.value,
+                        height: g.value
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = B.makeSpan(["mord", "rule"], [], t),
-                        s = Ie(n.width, t),
-                        u = Ie(n.height, t),
-                        p = n.shift ? Ie(n.shift, t) : 0;
-                    return o.style.borderRightWidth = Z(s), o.style.borderTopWidth = Z(u), o.style.bottom = Z(p), o.width = s, o.height = u + p, o.depth = -p, o.maxFontSize = u * 1.125 * t.sizeMultiplier, o
+                    let u = B.makeSpan(["mord", "rule"], [], t),
+                        a = Le(n.width, t),
+                        c = Le(n.height, t),
+                        m = n.shift ? Le(n.shift, t) : 0;
+                    return u.style.borderRightWidth = j(a), u.style.borderTopWidth = j(c), u.style.bottom = j(m), u.width = a, u.height = c + m, u.depth = -m, u.maxFontSize = c * 1.125 * t.sizeMultiplier, u
                 },
                 mathmlBuilder(n, t) {
-                    let o = Ie(n.width, t),
-                        s = Ie(n.height, t),
-                        u = n.shift ? Ie(n.shift, t) : 0,
-                        p = t.color && t.getColor() || "black",
-                        b = new V.MathNode("mspace");
-                    b.setAttribute("mathbackground", p), b.setAttribute("width", Z(o)), b.setAttribute("height", Z(s));
-                    let v = new V.MathNode("mpadded", [b]);
-                    return u >= 0 ? v.setAttribute("height", Z(u)) : (v.setAttribute("height", Z(u)), v.setAttribute("depth", Z(-u))), v.setAttribute("voffset", Z(u)), v
+                    let u = Le(n.width, t),
+                        a = Le(n.height, t),
+                        c = n.shift ? Le(n.shift, t) : 0,
+                        m = t.color && t.getColor() || "black",
+                        g = new H.MathNode("mspace");
+                    g.setAttribute("mathbackground", m), g.setAttribute("width", j(u)), g.setAttribute("height", j(a));
+                    let v = new H.MathNode("mpadded", [g]);
+                    return c >= 0 ? v.setAttribute("height", j(c)) : (v.setAttribute("height", j(c)), v.setAttribute("depth", j(-c))), v.setAttribute("voffset", j(c)), v
                 }
             });
 
-            function Lo(n, t, o) {
-                let s = Ze(n, t, !1),
-                    u = t.sizeMultiplier / o.sizeMultiplier;
-                for (let p = 0; p < s.length; p++) {
-                    let b = s[p].classes.indexOf("sizing");
-                    b < 0 ? Array.prototype.push.apply(s[p].classes, t.sizingClasses(o)) : s[p].classes[b + 1] === "reset-size" + t.size && (s[p].classes[b + 1] = "reset-size" + o.size), s[p].height *= u, s[p].depth *= u
+            function Fo(n, t, u) {
+                let a = We(n, t, !1),
+                    c = t.sizeMultiplier / u.sizeMultiplier;
+                for (let m = 0; m < a.length; m++) {
+                    let g = a[m].classes.indexOf("sizing");
+                    g < 0 ? Array.prototype.push.apply(a[m].classes, t.sizingClasses(u)) : a[m].classes[g + 1] === "reset-size" + t.size && (a[m].classes[g + 1] = "reset-size" + u.size), a[m].height *= c, a[m].depth *= c
                 }
-                return B.makeFragment(s)
+                return B.makeFragment(a)
             }
-            let Po = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
-            Q({
+            let zo = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
+            Z({
                 type: "sizing",
-                names: Po,
+                names: zo,
                 props: {
                     numArgs: 0,
                     allowedInText: !0
                 },
                 handler: (n, t) => {
                     let {
-                        breakOnTokenText: o,
-                        funcName: s,
-                        parser: u
-                    } = n, p = u.parseExpression(!1, o);
+                        breakOnTokenText: u,
+                        funcName: a,
+                        parser: c
+                    } = n, m = c.parseExpression(!1, u);
                     return {
                         type: "sizing",
-                        mode: u.mode,
-                        size: Po.indexOf(s) + 1,
-                        body: p
+                        mode: c.mode,
+                        size: zo.indexOf(a) + 1,
+                        body: m
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    let o = t.havingSize(n.size);
-                    return Lo(n.body, o, t)
+                    let u = t.havingSize(n.size);
+                    return Fo(n.body, u, t)
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = t.havingSize(n.size),
-                        s = it(n.body, o),
-                        u = new V.MathNode("mstyle", s);
-                    return u.setAttribute("mathsize", Z(o.sizeMultiplier)), u
+                    let u = t.havingSize(n.size),
+                        a = it(n.body, u),
+                        c = new H.MathNode("mstyle", a);
+                    return c.setAttribute("mathsize", j(u.sizeMultiplier)), c
                 }
-            }), Q({
+            }), Z({
                 type: "smash",
                 names: ["\\smash"],
                 props: {
                     numArgs: 1,
                     numOptionalArgs: 1,
                     allowedInText: !0
                 },
-                handler: (n, t, o) => {
+                handler: (n, t, u) => {
                     let {
-                        parser: s
-                    } = n, u = !1, p = !1, b = o[0] && de(o[0], "ordgroup");
-                    if (b) {
-                        let S = "";
-                        for (let E = 0; E < b.body.length; ++E)
-                            if (S = b.body[E].text, S === "t") u = !0;
-                            else if (S === "b") p = !0;
+                        parser: a
+                    } = n, c = !1, m = !1, g = u[0] && se(u[0], "ordgroup");
+                    if (g) {
+                        let _ = "";
+                        for (let D = 0; D < g.body.length; ++D)
+                            if (_ = g.body[D].text, _ === "t") c = !0;
+                            else if (_ === "b") m = !0;
                         else {
-                            u = !1, p = !1;
+                            c = !1, m = !1;
                             break
                         }
-                    } else u = !0, p = !0;
+                    } else c = !0, m = !0;
                     let v = t[0];
                     return {
                         type: "smash",
-                        mode: s.mode,
+                        mode: a.mode,
                         body: v,
-                        smashHeight: u,
-                        smashDepth: p
+                        smashHeight: c,
+                        smashDepth: m
                     }
                 },
                 htmlBuilder: (n, t) => {
-                    let o = B.makeSpan([], [ve(n.body, t)]);
-                    if (!n.smashHeight && !n.smashDepth) return o;
-                    if (n.smashHeight && (o.height = 0, o.children))
-                        for (let u = 0; u < o.children.length; u++) o.children[u].height = 0;
-                    if (n.smashDepth && (o.depth = 0, o.children))
-                        for (let u = 0; u < o.children.length; u++) o.children[u].depth = 0;
-                    let s = B.makeVList({
+                    let u = B.makeSpan([], [xe(n.body, t)]);
+                    if (!n.smashHeight && !n.smashDepth) return u;
+                    if (n.smashHeight && (u.height = 0, u.children))
+                        for (let c = 0; c < u.children.length; c++) u.children[c].height = 0;
+                    if (n.smashDepth && (u.depth = 0, u.children))
+                        for (let c = 0; c < u.children.length; c++) u.children[c].depth = 0;
+                    let a = B.makeVList({
                         positionType: "firstBaseline",
                         children: [{
                             type: "elem",
-                            elem: o
+                            elem: u
                         }]
                     }, t);
-                    return B.makeSpan(["mord"], [s], t)
+                    return B.makeSpan(["mord"], [a], t)
                 },
                 mathmlBuilder: (n, t) => {
-                    let o = new V.MathNode("mpadded", [Ee(n.body, t)]);
-                    return n.smashHeight && o.setAttribute("height", "0px"), n.smashDepth && o.setAttribute("depth", "0px"), o
+                    let u = new H.MathNode("mpadded", [Ae(n.body, t)]);
+                    return n.smashHeight && u.setAttribute("height", "0px"), n.smashDepth && u.setAttribute("depth", "0px"), u
                 }
-            }), Q({
+            }), Z({
                 type: "sqrt",
                 names: ["\\sqrt"],
                 props: {
                     numArgs: 1,
                     numOptionalArgs: 1
                 },
-                handler(n, t, o) {
+                handler(n, t, u) {
                     let {
-                        parser: s
-                    } = n, u = o[0], p = t[0];
+                        parser: a
+                    } = n, c = u[0], m = t[0];
                     return {
                         type: "sqrt",
-                        mode: s.mode,
-                        body: p,
-                        index: u
+                        mode: a.mode,
+                        body: m,
+                        index: c
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = ve(n.body, t.havingCrampedStyle());
-                    o.height === 0 && (o.height = t.fontMetrics().xHeight), o = B.wrapFragment(o, t);
-                    let u = t.fontMetrics().defaultRuleThickness,
-                        p = u;
-                    t.style.id < G.TEXT.id && (p = t.fontMetrics().xHeight);
-                    let b = u + p / 4,
-                        v = o.height + o.depth + b + u,
+                    let u = xe(n.body, t.havingCrampedStyle());
+                    u.height === 0 && (u.height = t.fontMetrics().xHeight), u = B.wrapFragment(u, t);
+                    let c = t.fontMetrics().defaultRuleThickness,
+                        m = c;
+                    t.style.id < O.TEXT.id && (m = t.fontMetrics().xHeight);
+                    let g = c + m / 4,
+                        v = u.height + u.depth + g + c,
                         {
-                            span: S,
-                            ruleWidth: E,
+                            span: _,
+                            ruleWidth: D,
                             advanceWidth: z
-                        } = Bt.sqrtImage(v, t),
-                        F = S.height - E;
-                    F > o.height + o.depth + b && (b = (b + F - o.height - o.depth) / 2);
-                    let N = S.height - o.height - b - E;
-                    o.style.paddingLeft = Z(z);
-                    let H = B.makeVList({
+                        } = Lt.sqrtImage(v, t),
+                        R = _.height - D;
+                    R > u.height + u.depth + g && (g = (g + R - u.height - u.depth) / 2);
+                    let L = _.height - u.height - g - D;
+                    u.style.paddingLeft = j(z);
+                    let P = B.makeVList({
                         positionType: "firstBaseline",
                         children: [{
                             type: "elem",
-                            elem: o,
+                            elem: u,
                             wrapperClasses: ["svg-align"]
                         }, {
                             type: "kern",
-                            size: -(o.height + N)
+                            size: -(u.height + L)
                         }, {
                             type: "elem",
-                            elem: S
+                            elem: _
                         }, {
                             type: "kern",
-                            size: E
+                            size: D
                         }]
                     }, t);
                     if (n.index) {
-                        let K = t.havingStyle(G.SCRIPTSCRIPT),
-                            ie = ve(n.index, K, t),
-                            ye = .6 * (H.height - H.depth),
-                            ge = B.makeVList({
+                        let K = t.havingStyle(O.SCRIPTSCRIPT),
+                            re = xe(n.index, K, t),
+                            pe = .6 * (P.height - P.depth),
+                            de = B.makeVList({
                                 positionType: "shift",
-                                positionData: -ye,
+                                positionData: -pe,
                                 children: [{
                                     type: "elem",
-                                    elem: ie
+                                    elem: re
                                 }]
                             }, t),
-                            xe = B.makeSpan(["root"], [ge]);
-                        return B.makeSpan(["mord", "sqrt"], [xe, H], t)
-                    } else return B.makeSpan(["mord", "sqrt"], [H], t)
+                            be = B.makeSpan(["root"], [de]);
+                        return B.makeSpan(["mord", "sqrt"], [be, P], t)
+                    } else return B.makeSpan(["mord", "sqrt"], [P], t)
                 },
                 mathmlBuilder(n, t) {
                     let {
-                        body: o,
-                        index: s
+                        body: u,
+                        index: a
                     } = n;
-                    return s ? new V.MathNode("mroot", [Ee(o, t), Ee(s, t)]) : new V.MathNode("msqrt", [Ee(o, t)])
+                    return a ? new H.MathNode("mroot", [Ae(u, t), Ae(a, t)]) : new H.MathNode("msqrt", [Ae(u, t)])
                 }
             });
-            let Io = {
-                display: G.DISPLAY,
-                text: G.TEXT,
-                script: G.SCRIPT,
-                scriptscript: G.SCRIPTSCRIPT
+            let Ro = {
+                display: O.DISPLAY,
+                text: O.TEXT,
+                script: O.SCRIPT,
+                scriptscript: O.SCRIPTSCRIPT
             };
-            Q({
+            Z({
                 type: "styling",
                 names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0,
                     primitive: !0
                 },
                 handler(n, t) {
                     let {
-                        breakOnTokenText: o,
-                        funcName: s,
-                        parser: u
-                    } = n, p = u.parseExpression(!0, o), b = s.slice(1, s.length - 5);
+                        breakOnTokenText: u,
+                        funcName: a,
+                        parser: c
+                    } = n, m = c.parseExpression(!0, u), g = a.slice(1, a.length - 5);
                     return {
                         type: "styling",
-                        mode: u.mode,
-                        style: b,
-                        body: p
+                        mode: c.mode,
+                        style: g,
+                        body: m
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = Io[n.style],
-                        s = t.havingStyle(o).withFont("");
-                    return Lo(n.body, s, t)
+                    let u = Ro[n.style],
+                        a = t.havingStyle(u).withFont("");
+                    return Fo(n.body, a, t)
                 },
                 mathmlBuilder(n, t) {
-                    let o = Io[n.style],
-                        s = t.havingStyle(o),
-                        u = it(n.body, s),
-                        p = new V.MathNode("mstyle", u),
+                    let u = Ro[n.style],
+                        a = t.havingStyle(u),
+                        c = it(n.body, a),
+                        m = new H.MathNode("mstyle", c),
                         v = {
                             display: ["0", "true"],
                             text: ["0", "false"],
                             script: ["1", "false"],
                             scriptscript: ["2", "false"]
                         } [n.style];
-                    return p.setAttribute("scriptlevel", v[0]), p.setAttribute("displaystyle", v[1]), p
+                    return m.setAttribute("scriptlevel", v[0]), m.setAttribute("displaystyle", v[1]), m
                 }
             });
-            let H1 = function(n, t) {
-                let o = n.base;
-                return o ? o.type === "op" ? o.limits && (t.style.size === G.DISPLAY.size || o.alwaysHandleSupSub) ? lr : null : o.type === "operatorname" ? o.alwaysHandleSupSub && (t.style.size === G.DISPLAY.size || o.limits) ? No : null : o.type === "accent" ? R.isCharacterBox(o.base) ? an : null : o.type === "horizBrace" && !n.sub === o.isOver ? zo : null : null
+            let zc = function(n, t) {
+                let u = n.base;
+                return u ? u.type === "op" ? u.limits && (t.style.size === O.DISPLAY.size || u.alwaysHandleSupSub) ? x0 : null : u.type === "operatorname" ? u.alwaysHandleSupSub && (t.style.size === O.DISPLAY.size || u.limits) ? qo : null : u.type === "accent" ? N.isCharacterBox(u.base) ? Cn : null : u.type === "horizBrace" && !n.sub === u.isOver ? To : null : null
             };
-            Kt({
+            o0({
                 type: "supsub",
                 htmlBuilder(n, t) {
-                    let o = H1(n, t);
-                    if (o) return o(n, t);
+                    let u = zc(n, t);
+                    if (u) return u(n, t);
                     let {
-                        base: s,
-                        sup: u,
-                        sub: p
-                    } = n, b = ve(s, t), v, S, E = t.fontMetrics(), z = 0, F = 0, N = s && R.isCharacterBox(s);
-                    if (u) {
-                        let ke = t.havingStyle(t.style.sup());
-                        v = ve(u, ke, t), N || (z = b.height - ke.fontMetrics().supDrop * ke.sizeMultiplier / t.sizeMultiplier)
+                        base: a,
+                        sup: c,
+                        sub: m
+                    } = n, g = xe(a, t), v, _, D = t.fontMetrics(), z = 0, R = 0, L = a && N.isCharacterBox(a);
+                    if (c) {
+                        let ve = t.havingStyle(t.style.sup());
+                        v = xe(c, ve, t), L || (z = g.height - ve.fontMetrics().supDrop * ve.sizeMultiplier / t.sizeMultiplier)
+                    }
+                    if (m) {
+                        let ve = t.havingStyle(t.style.sub());
+                        _ = xe(m, ve, t), L || (R = g.depth + ve.fontMetrics().subDrop * ve.sizeMultiplier / t.sizeMultiplier)
                     }
-                    if (p) {
-                        let ke = t.havingStyle(t.style.sub());
-                        S = ve(p, ke, t), N || (F = b.depth + ke.fontMetrics().subDrop * ke.sizeMultiplier / t.sizeMultiplier)
-                    }
-                    let H;
-                    t.style === G.DISPLAY ? H = E.sup1 : t.style.cramped ? H = E.sup3 : H = E.sup2;
+                    let P;
+                    t.style === O.DISPLAY ? P = D.sup1 : t.style.cramped ? P = D.sup3 : P = D.sup2;
                     let K = t.sizeMultiplier,
-                        ie = Z(.5 / E.ptPerEm / K),
-                        ye = null;
-                    if (S) {
-                        let ke = n.base && n.base.type === "op" && n.base.name && (n.base.name === "\\oiint" || n.base.name === "\\oiiint");
-                        (b instanceof ut || ke) && (ye = Z(-b.italic))
-                    }
-                    let ge;
-                    if (v && S) {
-                        z = Math.max(z, H, v.depth + .25 * E.xHeight), F = Math.max(F, E.sub2);
-                        let ze = 4 * E.defaultRuleThickness;
-                        if (z - v.depth - (S.height - F) < ze) {
-                            F = ze - (z - v.depth) + S.height;
-                            let Qe = .8 * E.xHeight - (z - v.depth);
-                            Qe > 0 && (z += Qe, F -= Qe)
+                        re = j(.5 / D.ptPerEm / K),
+                        pe = null;
+                    if (_) {
+                        let ve = n.base && n.base.type === "op" && n.base.name && (n.base.name === "\\oiint" || n.base.name === "\\oiiint");
+                        (g instanceof dt || ve) && (pe = j(-g.italic))
+                    }
+                    let de;
+                    if (v && _) {
+                        z = Math.max(z, P, v.depth + .25 * D.xHeight), R = Math.max(R, D.sub2);
+                        let Te = 4 * D.defaultRuleThickness;
+                        if (z - v.depth - (_.height - R) < Te) {
+                            R = Te - (z - v.depth) + _.height;
+                            let Ye = .8 * D.xHeight - (z - v.depth);
+                            Ye > 0 && (z += Ye, R -= Ye)
                         }
                         let tt = [{
                             type: "elem",
-                            elem: S,
-                            shift: F,
-                            marginRight: ie,
-                            marginLeft: ye
+                            elem: _,
+                            shift: R,
+                            marginRight: re,
+                            marginLeft: pe
                         }, {
                             type: "elem",
                             elem: v,
                             shift: -z,
-                            marginRight: ie
+                            marginRight: re
                         }];
-                        ge = B.makeVList({
+                        de = B.makeVList({
                             positionType: "individualShift",
                             children: tt
                         }, t)
-                    } else if (S) {
-                        F = Math.max(F, E.sub1, S.height - .8 * E.xHeight);
-                        let ke = [{
+                    } else if (_) {
+                        R = Math.max(R, D.sub1, _.height - .8 * D.xHeight);
+                        let ve = [{
                             type: "elem",
-                            elem: S,
-                            marginLeft: ye,
-                            marginRight: ie
+                            elem: _,
+                            marginLeft: pe,
+                            marginRight: re
                         }];
-                        ge = B.makeVList({
+                        de = B.makeVList({
                             positionType: "shift",
-                            positionData: F,
-                            children: ke
+                            positionData: R,
+                            children: ve
                         }, t)
-                    } else if (v) z = Math.max(z, H, v.depth + .25 * E.xHeight), ge = B.makeVList({
+                    } else if (v) z = Math.max(z, P, v.depth + .25 * D.xHeight), de = B.makeVList({
                         positionType: "shift",
                         positionData: -z,
                         children: [{
                             type: "elem",
                             elem: v,
-                            marginRight: ie
+                            marginRight: re
                         }]
                     }, t);
                     else throw new Error("supsub must have either sup or sub.");
-                    let xe = en(b, "right") || "mord";
-                    return B.makeSpan([xe], [b, B.makeSpan(["msupsub"], [ge])], t)
+                    let be = yn(g, "right") || "mord";
+                    return B.makeSpan([be], [g, B.makeSpan(["msupsub"], [de])], t)
                 },
                 mathmlBuilder(n, t) {
-                    let o = !1,
-                        s, u;
-                    n.base && n.base.type === "horizBrace" && (u = !!n.sup, u === n.base.isOver && (o = !0, s = n.base.isOver)), n.base && (n.base.type === "op" || n.base.type === "operatorname") && (n.base.parentIsSupSub = !0);
-                    let p = [Ee(n.base, t)];
-                    n.sub && p.push(Ee(n.sub, t)), n.sup && p.push(Ee(n.sup, t));
-                    let b;
-                    if (o) b = s ? "mover" : "munder";
+                    let u = !1,
+                        a, c;
+                    n.base && n.base.type === "horizBrace" && (c = !!n.sup, c === n.base.isOver && (u = !0, a = n.base.isOver)), n.base && (n.base.type === "op" || n.base.type === "operatorname") && (n.base.parentIsSupSub = !0);
+                    let m = [Ae(n.base, t)];
+                    n.sub && m.push(Ae(n.sub, t)), n.sup && m.push(Ae(n.sup, t));
+                    let g;
+                    if (u) g = a ? "mover" : "munder";
                     else if (n.sub)
                         if (n.sup) {
                             let v = n.base;
-                            v && v.type === "op" && v.limits && t.style === G.DISPLAY || v && v.type === "operatorname" && v.alwaysHandleSupSub && (t.style === G.DISPLAY || v.limits) ? b = "munderover" : b = "msubsup"
+                            v && v.type === "op" && v.limits && t.style === O.DISPLAY || v && v.type === "operatorname" && v.alwaysHandleSupSub && (t.style === O.DISPLAY || v.limits) ? g = "munderover" : g = "msubsup"
                         } else {
                             let v = n.base;
-                            v && v.type === "op" && v.limits && (t.style === G.DISPLAY || v.alwaysHandleSupSub) || v && v.type === "operatorname" && v.alwaysHandleSupSub && (v.limits || t.style === G.DISPLAY) ? b = "munder" : b = "msub"
+                            v && v.type === "op" && v.limits && (t.style === O.DISPLAY || v.alwaysHandleSupSub) || v && v.type === "operatorname" && v.alwaysHandleSupSub && (v.limits || t.style === O.DISPLAY) ? g = "munder" : g = "msub"
                         }
                     else {
                         let v = n.base;
-                        v && v.type === "op" && v.limits && (t.style === G.DISPLAY || v.alwaysHandleSupSub) || v && v.type === "operatorname" && v.alwaysHandleSupSub && (v.limits || t.style === G.DISPLAY) ? b = "mover" : b = "msup"
+                        v && v.type === "op" && v.limits && (t.style === O.DISPLAY || v.alwaysHandleSupSub) || v && v.type === "operatorname" && v.alwaysHandleSupSub && (v.limits || t.style === O.DISPLAY) ? g = "mover" : g = "msup"
                     }
-                    return new V.MathNode(b, p)
+                    return new H.MathNode(g, m)
                 }
-            }), Kt({
+            }), o0({
                 type: "atom",
                 htmlBuilder(n, t) {
                     return B.mathsym(n.text, n.mode, t, ["m" + n.family])
                 },
                 mathmlBuilder(n, t) {
-                    let o = new V.MathNode("mo", [dt(n.text, n.mode)]);
+                    let u = new H.MathNode("mo", [ft(n.text, n.mode)]);
                     if (n.family === "bin") {
-                        let s = nn(n, t);
-                        s === "bold-italic" && o.setAttribute("mathvariant", s)
-                    } else n.family === "punct" ? o.setAttribute("separator", "true") : (n.family === "open" || n.family === "close") && o.setAttribute("stretchy", "false");
-                    return o
+                        let a = kn(n, t);
+                        a === "bold-italic" && u.setAttribute("mathvariant", a)
+                    } else n.family === "punct" ? u.setAttribute("separator", "true") : (n.family === "open" || n.family === "close") && u.setAttribute("stretchy", "false");
+                    return u
                 }
             });
-            let Oo = {
+            let Bo = {
                 mi: "italic",
                 mn: "normal",
                 mtext: "normal"
             };
-            Kt({
+            o0({
                 type: "mathord",
                 htmlBuilder(n, t) {
                     return B.makeOrd(n, t, "mathord")
                 },
                 mathmlBuilder(n, t) {
-                    let o = new V.MathNode("mi", [dt(n.text, n.mode, t)]),
-                        s = nn(n, t) || "italic";
-                    return s !== Oo[o.type] && o.setAttribute("mathvariant", s), o
+                    let u = new H.MathNode("mi", [ft(n.text, n.mode, t)]),
+                        a = kn(n, t) || "italic";
+                    return a !== Bo[u.type] && u.setAttribute("mathvariant", a), u
                 }
-            }), Kt({
+            }), o0({
                 type: "textord",
                 htmlBuilder(n, t) {
                     return B.makeOrd(n, t, "textord")
                 },
                 mathmlBuilder(n, t) {
-                    let o = dt(n.text, n.mode, t),
-                        s = nn(n, t) || "normal",
-                        u;
-                    return n.mode === "text" ? u = new V.MathNode("mtext", [o]) : /[0-9]/.test(n.text) ? u = new V.MathNode("mn", [o]) : n.text === "\\prime" ? u = new V.MathNode("mo", [o]) : u = new V.MathNode("mi", [o]), s !== Oo[u.type] && u.setAttribute("mathvariant", s), u
+                    let u = ft(n.text, n.mode, t),
+                        a = kn(n, t) || "normal",
+                        c;
+                    return n.mode === "text" ? c = new H.MathNode("mtext", [u]) : /[0-9]/.test(n.text) ? c = new H.MathNode("mn", [u]) : n.text === "\\prime" ? c = new H.MathNode("mo", [u]) : c = new H.MathNode("mi", [u]), a !== Bo[c.type] && c.setAttribute("mathvariant", a), c
                 }
             });
-            let kn = {
+            let On = {
                     "\\nobreak": "nobreak",
                     "\\allowbreak": "allowbreak"
                 },
-                _n = {
+                Hn = {
                     " ": {},
                     "\\ ": {},
                     "~": {
                         className: "nobreak"
                     },
                     "\\space": {},
                     "\\nobreakspace": {
                         className: "nobreak"
                     }
                 };
-            Kt({
+            o0({
                 type: "spacing",
                 htmlBuilder(n, t) {
-                    if (_n.hasOwnProperty(n.text)) {
-                        let o = _n[n.text].className || "";
+                    if (Hn.hasOwnProperty(n.text)) {
+                        let u = Hn[n.text].className || "";
                         if (n.mode === "text") {
-                            let s = B.makeOrd(n, t, "textord");
-                            return s.classes.push(o), s
-                        } else return B.makeSpan(["mspace", o], [B.mathsym(n.text, n.mode, t)], t)
+                            let a = B.makeOrd(n, t, "textord");
+                            return a.classes.push(u), a
+                        } else return B.makeSpan(["mspace", u], [B.mathsym(n.text, n.mode, t)], t)
                     } else {
-                        if (kn.hasOwnProperty(n.text)) return B.makeSpan(["mspace", kn[n.text]], [], t);
-                        throw new a('Unknown type of space "' + n.text + '"')
+                        if (On.hasOwnProperty(n.text)) return B.makeSpan(["mspace", On[n.text]], [], t);
+                        throw new o('Unknown type of space "' + n.text + '"')
                     }
                 },
                 mathmlBuilder(n, t) {
-                    let o;
-                    if (_n.hasOwnProperty(n.text)) o = new V.MathNode("mtext", [new V.TextNode("\xA0")]);
+                    let u;
+                    if (Hn.hasOwnProperty(n.text)) u = new H.MathNode("mtext", [new H.TextNode("\xA0")]);
                     else {
-                        if (kn.hasOwnProperty(n.text)) return new V.MathNode("mspace");
-                        throw new a('Unknown type of space "' + n.text + '"')
+                        if (On.hasOwnProperty(n.text)) return new H.MathNode("mspace");
+                        throw new o('Unknown type of space "' + n.text + '"')
                     }
-                    return o
+                    return u
                 }
             });
-            let Ho = () => {
-                let n = new V.MathNode("mtd", []);
+            let No = () => {
+                let n = new H.MathNode("mtd", []);
                 return n.setAttribute("width", "50%"), n
             };
-            Kt({
+            o0({
                 type: "tag",
                 mathmlBuilder(n, t) {
-                    let o = new V.MathNode("mtable", [new V.MathNode("mtr", [Ho(), new V.MathNode("mtd", [Ht(n.body, t)]), Ho(), new V.MathNode("mtd", [Ht(n.tag, t)])])]);
-                    return o.setAttribute("width", "100%"), o
+                    let u = new H.MathNode("mtable", [new H.MathNode("mtr", [No(), new H.MathNode("mtd", [jt(n.body, t)]), No(), new H.MathNode("mtd", [jt(n.tag, t)])])]);
+                    return u.setAttribute("width", "100%"), u
                 }
             });
-            let $o = {
+            let Lo = {
                     "\\text": void 0,
                     "\\textrm": "textrm",
                     "\\textsf": "textsf",
                     "\\texttt": "texttt",
                     "\\textnormal": "textrm"
                 },
-                Go = {
+                Po = {
                     "\\textbf": "textbf",
                     "\\textmd": "textmd"
                 },
-                $1 = {
+                Rc = {
                     "\\textit": "textit",
                     "\\textup": "textup"
                 },
-                Vo = (n, t) => {
-                    let o = n.font;
-                    return o ? $o[o] ? t.withTextFontFamily($o[o]) : Go[o] ? t.withTextFontWeight(Go[o]) : t.withTextFontShape($1[o]) : t
+                Io = (n, t) => {
+                    let u = n.font;
+                    return u ? Lo[u] ? t.withTextFontFamily(Lo[u]) : Po[u] ? t.withTextFontWeight(Po[u]) : t.withTextFontShape(Rc[u]) : t
                 };
-            Q({
+            Z({
                 type: "text",
                 names: ["\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal", "\\textbf", "\\textmd", "\\textit", "\\textup"],
                 props: {
                     numArgs: 1,
                     argTypes: ["text"],
                     allowedInArgument: !0,
                     allowedInText: !0
                 },
                 handler(n, t) {
                     let {
-                        parser: o,
-                        funcName: s
-                    } = n, u = t[0];
+                        parser: u,
+                        funcName: a
+                    } = n, c = t[0];
                     return {
                         type: "text",
-                        mode: o.mode,
-                        body: je(u),
-                        font: s
+                        mode: u.mode,
+                        body: Ge(c),
+                        font: a
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = Vo(n, t),
-                        s = Ze(n.body, o, !0);
-                    return B.makeSpan(["mord", "text"], s, o)
+                    let u = Io(n, t),
+                        a = We(n.body, u, !0);
+                    return B.makeSpan(["mord", "text"], a, u)
                 },
                 mathmlBuilder(n, t) {
-                    let o = Vo(n, t);
-                    return Ht(n.body, o)
+                    let u = Io(n, t);
+                    return jt(n.body, u)
                 }
-            }), Q({
+            }), Z({
                 type: "underline",
                 names: ["\\underline"],
                 props: {
                     numArgs: 1,
                     allowedInText: !0
                 },
                 handler(n, t) {
                     let {
-                        parser: o
+                        parser: u
                     } = n;
                     return {
                         type: "underline",
-                        mode: o.mode,
+                        mode: u.mode,
                         body: t[0]
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = ve(n.body, t),
-                        s = B.makeLineSpan("underline-line", t),
-                        u = t.fontMetrics().defaultRuleThickness,
-                        p = B.makeVList({
+                    let u = xe(n.body, t),
+                        a = B.makeLineSpan("underline-line", t),
+                        c = t.fontMetrics().defaultRuleThickness,
+                        m = B.makeVList({
                             positionType: "top",
-                            positionData: o.height,
+                            positionData: u.height,
                             children: [{
                                 type: "kern",
-                                size: u
+                                size: c
                             }, {
                                 type: "elem",
-                                elem: s
+                                elem: a
                             }, {
                                 type: "kern",
-                                size: 3 * u
+                                size: 3 * c
                             }, {
                                 type: "elem",
-                                elem: o
+                                elem: u
                             }]
                         }, t);
-                    return B.makeSpan(["mord", "underline"], [p], t)
+                    return B.makeSpan(["mord", "underline"], [m], t)
                 },
                 mathmlBuilder(n, t) {
-                    let o = new V.MathNode("mo", [new V.TextNode("\u203E")]);
-                    o.setAttribute("stretchy", "true");
-                    let s = new V.MathNode("munder", [Ee(n.body, t), o]);
-                    return s.setAttribute("accentunder", "true"), s
+                    let u = new H.MathNode("mo", [new H.TextNode("\u203E")]);
+                    u.setAttribute("stretchy", "true");
+                    let a = new H.MathNode("munder", [Ae(n.body, t), u]);
+                    return a.setAttribute("accentunder", "true"), a
                 }
-            }), Q({
+            }), Z({
                 type: "vcenter",
                 names: ["\\vcenter"],
                 props: {
                     numArgs: 1,
                     argTypes: ["original"],
                     allowedInText: !1
                 },
                 handler(n, t) {
                     let {
-                        parser: o
+                        parser: u
                     } = n;
                     return {
                         type: "vcenter",
-                        mode: o.mode,
+                        mode: u.mode,
                         body: t[0]
                     }
                 },
                 htmlBuilder(n, t) {
-                    let o = ve(n.body, t),
-                        s = t.fontMetrics().axisHeight,
-                        u = .5 * (o.height - s - (o.depth + s));
+                    let u = xe(n.body, t),
+                        a = t.fontMetrics().axisHeight,
+                        c = .5 * (u.height - a - (u.depth + a));
                     return B.makeVList({
                         positionType: "shift",
-                        positionData: u,
+                        positionData: c,
                         children: [{
                             type: "elem",
-                            elem: o
+                            elem: u
                         }]
                     }, t)
                 },
                 mathmlBuilder(n, t) {
-                    return new V.MathNode("mpadded", [Ee(n.body, t)], ["vcenter"])
+                    return new H.MathNode("mpadded", [Ae(n.body, t)], ["vcenter"])
                 }
-            }), Q({
+            }), Z({
                 type: "verb",
                 names: ["\\verb"],
                 props: {
                     numArgs: 0,
                     allowedInText: !0
                 },
-                handler(n, t, o) {
-                    throw new a("\\verb ended by end of line instead of matching delimiter")
+                handler(n, t, u) {
+                    throw new o("\\verb ended by end of line instead of matching delimiter")
                 },
                 htmlBuilder(n, t) {
-                    let o = jo(n),
-                        s = [],
-                        u = t.havingStyle(t.style.text());
-                    for (let p = 0; p < o.length; p++) {
-                        let b = o[p];
-                        b === "~" && (b = "\\textasciitilde"), s.push(B.makeSymbol(b, "Typewriter-Regular", n.mode, u, ["mord", "texttt"]))
+                    let u = Oo(n),
+                        a = [],
+                        c = t.havingStyle(t.style.text());
+                    for (let m = 0; m < u.length; m++) {
+                        let g = u[m];
+                        g === "~" && (g = "\\textasciitilde"), a.push(B.makeSymbol(g, "Typewriter-Regular", n.mode, c, ["mord", "texttt"]))
                     }
-                    return B.makeSpan(["mord", "text"].concat(u.sizingClasses(t)), B.tryCombineChars(s), u)
+                    return B.makeSpan(["mord", "text"].concat(c.sizingClasses(t)), B.tryCombineChars(a), c)
                 },
                 mathmlBuilder(n, t) {
-                    let o = new V.TextNode(jo(n)),
-                        s = new V.MathNode("mtext", [o]);
-                    return s.setAttribute("mathvariant", "monospace"), s
+                    let u = new H.TextNode(Oo(n)),
+                        a = new H.MathNode("mtext", [u]);
+                    return a.setAttribute("mathvariant", "monospace"), a
                 }
             });
-            let jo = n => n.body.replace(/ /g, n.star ? "\u2423" : "\xA0");
-            var Gt = Zi;
-            let Uo = `[ \r
+            let Oo = n => n.body.replace(/ /g, n.star ? "\u2423" : "\xA0");
+            var Yt = Vi;
+            let Ho = `[ \r
 	]`,
-                G1 = "\\\\[a-zA-Z@]+",
-                V1 = "\\\\[^\uD800-\uDFFF]",
-                j1 = "(" + G1 + ")" + Uo + "*",
-                U1 = `\\\\(
+                Bc = "\\\\[a-zA-Z@]+",
+                Nc = "\\\\[^\uD800-\uDFFF]",
+                Lc = "(" + Bc + ")" + Ho + "*",
+                Pc = `\\\\(
 |[ \r	]+
 ?)[ \r	]*`,
-                Sn = "[\u0300-\u036F]",
-                W1 = new RegExp(Sn + "+$"),
-                Y1 = "(" + Uo + "+)|" + (U1 + "|") + "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + (Sn + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (Sn + "*") + "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + ("|" + j1) + ("|" + V1 + ")");
-            class Wo {
-                constructor(t, o) {
-                    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = t, this.settings = o, this.tokenRegex = new RegExp(Y1, "g"), this.catcodes = {
+                $n = "[\u0300-\u036F]",
+                Ic = new RegExp($n + "+$"),
+                Oc = "(" + Ho + "+)|" + (Pc + "|") + "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + ($n + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + ($n + "*") + "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + ("|" + Lc) + ("|" + Nc + ")");
+            class $o {
+                constructor(t, u) {
+                    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = t, this.settings = u, this.tokenRegex = new RegExp(Oc, "g"), this.catcodes = {
                         "%": 14,
                         "~": 13
                     }
                 }
-                setCatcode(t, o) {
-                    this.catcodes[t] = o
+                setCatcode(t, u) {
+                    this.catcodes[t] = u
                 }
                 lex() {
                     let t = this.input,
-                        o = this.tokenRegex.lastIndex;
-                    if (o === t.length) return new mt("EOF", new st(this, o, o));
-                    let s = this.tokenRegex.exec(t);
-                    if (s === null || s.index !== o) throw new a("Unexpected character: '" + t[o] + "'", new mt(t[o], new st(this, o, o + 1)));
-                    let u = s[6] || s[3] || (s[2] ? "\\ " : " ");
-                    if (this.catcodes[u] === 14) {
-                        let p = t.indexOf(`
+                        u = this.tokenRegex.lastIndex;
+                    if (u === t.length) return new mt("EOF", new st(this, u, u));
+                    let a = this.tokenRegex.exec(t);
+                    if (a === null || a.index !== u) throw new o("Unexpected character: '" + t[u] + "'", new mt(t[u], new st(this, u, u + 1)));
+                    let c = a[6] || a[3] || (a[2] ? "\\ " : " ");
+                    if (this.catcodes[c] === 14) {
+                        let m = t.indexOf(`
 `, this.tokenRegex.lastIndex);
-                        return p === -1 ? (this.tokenRegex.lastIndex = t.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = p + 1, this.lex()
+                        return m === -1 ? (this.tokenRegex.lastIndex = t.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = m + 1, this.lex()
                     }
-                    return new mt(u, new st(this, o, this.tokenRegex.lastIndex))
+                    return new mt(c, new st(this, u, this.tokenRegex.lastIndex))
                 }
             }
-            class Z1 {
-                constructor(t, o) {
-                    t === void 0 && (t = {}), o === void 0 && (o = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = o, this.builtins = t, this.undefStack = []
+            class Hc {
+                constructor(t, u) {
+                    t === void 0 && (t = {}), u === void 0 && (u = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = u, this.builtins = t, this.undefStack = []
                 }
                 beginGroup() {
                     this.undefStack.push({})
                 }
                 endGroup() {
-                    if (this.undefStack.length === 0) throw new a("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
+                    if (this.undefStack.length === 0) throw new o("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
                     let t = this.undefStack.pop();
-                    for (let o in t) t.hasOwnProperty(o) && (t[o] == null ? delete this.current[o] : this.current[o] = t[o])
+                    for (let u in t) t.hasOwnProperty(u) && (t[u] == null ? delete this.current[u] : this.current[u] = t[u])
                 }
                 endGroups() {
                     for (; this.undefStack.length > 0;) this.endGroup()
                 }
                 has(t) {
                     return this.current.hasOwnProperty(t) || this.builtins.hasOwnProperty(t)
                 }
                 get(t) {
                     return this.current.hasOwnProperty(t) ? this.current[t] : this.builtins[t]
                 }
-                set(t, o, s) {
-                    if (s === void 0 && (s = !1), s) {
-                        for (let u = 0; u < this.undefStack.length; u++) delete this.undefStack[u][t];
-                        this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][t] = o)
+                set(t, u, a) {
+                    if (a === void 0 && (a = !1), a) {
+                        for (let c = 0; c < this.undefStack.length; c++) delete this.undefStack[c][t];
+                        this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][t] = u)
                     } else {
-                        let u = this.undefStack[this.undefStack.length - 1];
-                        u && !u.hasOwnProperty(t) && (u[t] = this.current[t])
+                        let c = this.undefStack[this.undefStack.length - 1];
+                        c && !c.hasOwnProperty(t) && (c[t] = this.current[t])
                     }
-                    o == null ? delete this.current[t] : this.current[t] = o
+                    u == null ? delete this.current[t] : this.current[t] = u
                 }
             }
-            var Q1 = ko;
-            k("\\noexpand", function(n) {
+            var $c = go;
+            w("\\noexpand", function(n) {
                 let t = n.popToken();
                 return n.isExpandable(t.text) && (t.noexpand = !0, t.treatAsRelax = !0), {
                     tokens: [t],
                     numArgs: 0
                 }
-            }), k("\\expandafter", function(n) {
+            }), w("\\expandafter", function(n) {
                 let t = n.popToken();
                 return n.expandOnce(!0), {
                     tokens: [t],
                     numArgs: 0
                 }
-            }), k("\\@firstoftwo", function(n) {
+            }), w("\\@firstoftwo", function(n) {
                 return {
                     tokens: n.consumeArgs(2)[0],
                     numArgs: 0
                 }
-            }), k("\\@secondoftwo", function(n) {
+            }), w("\\@secondoftwo", function(n) {
                 return {
                     tokens: n.consumeArgs(2)[1],
                     numArgs: 0
                 }
-            }), k("\\@ifnextchar", function(n) {
+            }), w("\\@ifnextchar", function(n) {
                 let t = n.consumeArgs(3);
                 n.consumeSpaces();
-                let o = n.future();
-                return t[0].length === 1 && t[0][0].text === o.text ? {
+                let u = n.future();
+                return t[0].length === 1 && t[0][0].text === u.text ? {
                     tokens: t[1],
                     numArgs: 0
                 } : {
                     tokens: t[2],
                     numArgs: 0
                 }
-            }), k("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"), k("\\TextOrMath", function(n) {
+            }), w("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"), w("\\TextOrMath", function(n) {
                 let t = n.consumeArgs(2);
                 return n.mode === "text" ? {
                     tokens: t[0],
                     numArgs: 0
                 } : {
                     tokens: t[1],
                     numArgs: 0
                 }
             });
-            let Yo = {
+            let Go = {
                 0: 0,
                 1: 1,
                 2: 2,
                 3: 3,
                 4: 4,
                 5: 5,
                 6: 6,
@@ -14445,66 +10035,66 @@
                 d: 13,
                 D: 13,
                 e: 14,
                 E: 14,
                 f: 15,
                 F: 15
             };
-            k("\\char", function(n) {
+            w("\\char", function(n) {
                 let t = n.popToken(),
-                    o, s = "";
-                if (t.text === "'") o = 8, t = n.popToken();
-                else if (t.text === '"') o = 16, t = n.popToken();
+                    u, a = "";
+                if (t.text === "'") u = 8, t = n.popToken();
+                else if (t.text === '"') u = 16, t = n.popToken();
                 else if (t.text === "`")
-                    if (t = n.popToken(), t.text[0] === "\\") s = t.text.charCodeAt(1);
+                    if (t = n.popToken(), t.text[0] === "\\") a = t.text.charCodeAt(1);
                     else {
-                        if (t.text === "EOF") throw new a("\\char` missing argument");
-                        s = t.text.charCodeAt(0)
+                        if (t.text === "EOF") throw new o("\\char` missing argument");
+                        a = t.text.charCodeAt(0)
                     }
-                else o = 10;
-                if (o) {
-                    if (s = Yo[t.text], s == null || s >= o) throw new a("Invalid base-" + o + " digit " + t.text);
-                    let u;
+                else u = 10;
+                if (u) {
+                    if (a = Go[t.text], a == null || a >= u) throw new o("Invalid base-" + u + " digit " + t.text);
+                    let c;
                     for (;
-                        (u = Yo[n.future().text]) != null && u < o;) s *= o, s += u, n.popToken()
+                        (c = Go[n.future().text]) != null && c < u;) a *= u, a += c, n.popToken()
                 }
-                return "\\@char{" + s + "}"
+                return "\\@char{" + a + "}"
             });
-            let Cn = (n, t, o) => {
-                let s = n.consumeArg().tokens;
-                if (s.length !== 1) throw new a("\\newcommand's first argument must be a macro name");
-                let u = s[0].text,
-                    p = n.isDefined(u);
-                if (p && !t) throw new a("\\newcommand{" + u + "} attempting to redefine " + (u + "; use \\renewcommand"));
-                if (!p && !o) throw new a("\\renewcommand{" + u + "} when command " + u + " does not yet exist; use \\newcommand");
-                let b = 0;
-                if (s = n.consumeArg().tokens, s.length === 1 && s[0].text === "[") {
+            let Gn = (n, t, u) => {
+                let a = n.consumeArg().tokens;
+                if (a.length !== 1) throw new o("\\newcommand's first argument must be a macro name");
+                let c = a[0].text,
+                    m = n.isDefined(c);
+                if (m && !t) throw new o("\\newcommand{" + c + "} attempting to redefine " + (c + "; use \\renewcommand"));
+                if (!m && !u) throw new o("\\renewcommand{" + c + "} when command " + c + " does not yet exist; use \\newcommand");
+                let g = 0;
+                if (a = n.consumeArg().tokens, a.length === 1 && a[0].text === "[") {
                     let v = "",
-                        S = n.expandNextToken();
-                    for (; S.text !== "]" && S.text !== "EOF";) v += S.text, S = n.expandNextToken();
-                    if (!v.match(/^\s*[0-9]+\s*$/)) throw new a("Invalid number of arguments: " + v);
-                    b = parseInt(v), s = n.consumeArg().tokens
-                }
-                return n.macros.set(u, {
-                    tokens: s,
-                    numArgs: b
+                        _ = n.expandNextToken();
+                    for (; _.text !== "]" && _.text !== "EOF";) v += _.text, _ = n.expandNextToken();
+                    if (!v.match(/^\s*[0-9]+\s*$/)) throw new o("Invalid number of arguments: " + v);
+                    g = parseInt(v), a = n.consumeArg().tokens
+                }
+                return n.macros.set(c, {
+                    tokens: a,
+                    numArgs: g
                 }), ""
             };
-            k("\\newcommand", n => Cn(n, !1, !0)), k("\\renewcommand", n => Cn(n, !0, !1)), k("\\providecommand", n => Cn(n, !0, !0)), k("\\message", n => {
+            w("\\newcommand", n => Gn(n, !1, !0)), w("\\renewcommand", n => Gn(n, !0, !1)), w("\\providecommand", n => Gn(n, !0, !0)), w("\\message", n => {
                 let t = n.consumeArgs(1)[0];
-                return console.log(t.reverse().map(o => o.text).join("")), ""
-            }), k("\\errmessage", n => {
+                return console.log(t.reverse().map(u => u.text).join("")), ""
+            }), w("\\errmessage", n => {
                 let t = n.consumeArgs(1)[0];
-                return console.error(t.reverse().map(o => o.text).join("")), ""
-            }), k("\\show", n => {
+                return console.error(t.reverse().map(u => u.text).join("")), ""
+            }), w("\\show", n => {
                 let t = n.popToken(),
-                    o = t.text;
-                return console.log(t, n.macros.get(o), Gt[o], Oe.math[o], Oe.text[o]), ""
-            }), k("\\bgroup", "{"), k("\\egroup", "}"), k("~", "\\nobreakspace"), k("\\lq", "`"), k("\\rq", "'"), k("\\aa", "\\r a"), k("\\AA", "\\r A"), k("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}"), k("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}"), k("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}"), k("\u212C", "\\mathscr{B}"), k("\u2130", "\\mathscr{E}"), k("\u2131", "\\mathscr{F}"), k("\u210B", "\\mathscr{H}"), k("\u2110", "\\mathscr{I}"), k("\u2112", "\\mathscr{L}"), k("\u2133", "\\mathscr{M}"), k("\u211B", "\\mathscr{R}"), k("\u212D", "\\mathfrak{C}"), k("\u210C", "\\mathfrak{H}"), k("\u2128", "\\mathfrak{Z}"), k("\\Bbbk", "\\Bbb{k}"), k("\xB7", "\\cdotp"), k("\\llap", "\\mathllap{\\textrm{#1}}"), k("\\rlap", "\\mathrlap{\\textrm{#1}}"), k("\\clap", "\\mathclap{\\textrm{#1}}"), k("\\mathstrut", "\\vphantom{(}"), k("\\underbar", "\\underline{\\text{#1}}"), k("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'), k("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}"), k("\\ne", "\\neq"), k("\u2260", "\\neq"), k("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}"), k("\u2209", "\\notin"), k("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}"), k("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}"), k("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}"), k("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}"), k("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}"), k("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}"), k("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}"), k("\u27C2", "\\perp"), k("\u203C", "\\mathclose{!\\mkern-0.8mu!}"), k("\u220C", "\\notni"), k("\u231C", "\\ulcorner"), k("\u231D", "\\urcorner"), k("\u231E", "\\llcorner"), k("\u231F", "\\lrcorner"), k("\xA9", "\\copyright"), k("\xAE", "\\textregistered"), k("\uFE0F", "\\textregistered"), k("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}'), k("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}'), k("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}'), k("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}'), k("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}"), k("\u22EE", "\\vdots"), k("\\varGamma", "\\mathit{\\Gamma}"), k("\\varDelta", "\\mathit{\\Delta}"), k("\\varTheta", "\\mathit{\\Theta}"), k("\\varLambda", "\\mathit{\\Lambda}"), k("\\varXi", "\\mathit{\\Xi}"), k("\\varPi", "\\mathit{\\Pi}"), k("\\varSigma", "\\mathit{\\Sigma}"), k("\\varUpsilon", "\\mathit{\\Upsilon}"), k("\\varPhi", "\\mathit{\\Phi}"), k("\\varPsi", "\\mathit{\\Psi}"), k("\\varOmega", "\\mathit{\\Omega}"), k("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"), k("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax"), k("\\boxed", "\\fbox{$\\displaystyle{#1}$}"), k("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;"), k("\\implies", "\\DOTSB\\;\\Longrightarrow\\;"), k("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
-            let Zo = {
+                    u = t.text;
+                return console.log(t, n.macros.get(u), Yt[u], Pe.math[u], Pe.text[u]), ""
+            }), w("\\bgroup", "{"), w("\\egroup", "}"), w("~", "\\nobreakspace"), w("\\lq", "`"), w("\\rq", "'"), w("\\aa", "\\r a"), w("\\AA", "\\r A"), w("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}"), w("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}"), w("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}"), w("\u212C", "\\mathscr{B}"), w("\u2130", "\\mathscr{E}"), w("\u2131", "\\mathscr{F}"), w("\u210B", "\\mathscr{H}"), w("\u2110", "\\mathscr{I}"), w("\u2112", "\\mathscr{L}"), w("\u2133", "\\mathscr{M}"), w("\u211B", "\\mathscr{R}"), w("\u212D", "\\mathfrak{C}"), w("\u210C", "\\mathfrak{H}"), w("\u2128", "\\mathfrak{Z}"), w("\\Bbbk", "\\Bbb{k}"), w("\xB7", "\\cdotp"), w("\\llap", "\\mathllap{\\textrm{#1}}"), w("\\rlap", "\\mathrlap{\\textrm{#1}}"), w("\\clap", "\\mathclap{\\textrm{#1}}"), w("\\mathstrut", "\\vphantom{(}"), w("\\underbar", "\\underline{\\text{#1}}"), w("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'), w("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}"), w("\\ne", "\\neq"), w("\u2260", "\\neq"), w("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}"), w("\u2209", "\\notin"), w("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}"), w("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}"), w("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}"), w("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}"), w("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}"), w("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}"), w("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}"), w("\u27C2", "\\perp"), w("\u203C", "\\mathclose{!\\mkern-0.8mu!}"), w("\u220C", "\\notni"), w("\u231C", "\\ulcorner"), w("\u231D", "\\urcorner"), w("\u231E", "\\llcorner"), w("\u231F", "\\lrcorner"), w("\xA9", "\\copyright"), w("\xAE", "\\textregistered"), w("\uFE0F", "\\textregistered"), w("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}'), w("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}'), w("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}'), w("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}'), w("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}"), w("\u22EE", "\\vdots"), w("\\varGamma", "\\mathit{\\Gamma}"), w("\\varDelta", "\\mathit{\\Delta}"), w("\\varTheta", "\\mathit{\\Theta}"), w("\\varLambda", "\\mathit{\\Lambda}"), w("\\varXi", "\\mathit{\\Xi}"), w("\\varPi", "\\mathit{\\Pi}"), w("\\varSigma", "\\mathit{\\Sigma}"), w("\\varUpsilon", "\\mathit{\\Upsilon}"), w("\\varPhi", "\\mathit{\\Phi}"), w("\\varPsi", "\\mathit{\\Psi}"), w("\\varOmega", "\\mathit{\\Omega}"), w("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"), w("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax"), w("\\boxed", "\\fbox{$\\displaystyle{#1}$}"), w("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;"), w("\\implies", "\\DOTSB\\;\\Longrightarrow\\;"), w("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
+            let Vo = {
                 ",": "\\dotsc",
                 "\\not": "\\dotsb",
                 "+": "\\dotsb",
                 "=": "\\dotsb",
                 "<": "\\dotsb",
                 ">": "\\dotsb",
                 "-": "\\dotsb",
@@ -14545,20 +10135,20 @@
                 "\\oint": "\\dotsi",
                 "\\iint": "\\dotsi",
                 "\\iiint": "\\dotsi",
                 "\\iiiint": "\\dotsi",
                 "\\idotsint": "\\dotsi",
                 "\\DOTSX": "\\dotsx"
             };
-            k("\\dots", function(n) {
+            w("\\dots", function(n) {
                 let t = "\\dotso",
-                    o = n.expandAfterFuture().text;
-                return o in Zo ? t = Zo[o] : (o.slice(0, 4) === "\\not" || o in Oe.math && R.contains(["bin", "rel"], Oe.math[o].group)) && (t = "\\dotsb"), t
+                    u = n.expandAfterFuture().text;
+                return u in Vo ? t = Vo[u] : (u.slice(0, 4) === "\\not" || u in Pe.math && N.contains(["bin", "rel"], Pe.math[u].group)) && (t = "\\dotsb"), t
             });
-            let Tn = {
+            let Vn = {
                 ")": !0,
                 "]": !0,
                 "\\rbrack": !0,
                 "\\}": !0,
                 "\\rbrace": !0,
                 "\\rangle": !0,
                 "\\rceil": !0,
@@ -14571,64 +10161,64 @@
                 "\\Bigr": !0,
                 "\\Biggr": !0,
                 $: !0,
                 ";": !0,
                 ".": !0,
                 ",": !0
             };
-            k("\\dotso", function(n) {
-                return n.future().text in Tn ? "\\ldots\\," : "\\ldots"
-            }), k("\\dotsc", function(n) {
+            w("\\dotso", function(n) {
+                return n.future().text in Vn ? "\\ldots\\," : "\\ldots"
+            }), w("\\dotsc", function(n) {
                 let t = n.future().text;
-                return t in Tn && t !== "," ? "\\ldots\\," : "\\ldots"
-            }), k("\\cdots", function(n) {
-                return n.future().text in Tn ? "\\@cdots\\," : "\\@cdots"
-            }), k("\\dotsb", "\\cdots"), k("\\dotsm", "\\cdots"), k("\\dotsi", "\\!\\cdots"), k("\\dotsx", "\\ldots\\,"), k("\\DOTSI", "\\relax"), k("\\DOTSB", "\\relax"), k("\\DOTSX", "\\relax"), k("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"), k("\\,", "\\tmspace+{3mu}{.1667em}"), k("\\thinspace", "\\,"), k("\\>", "\\mskip{4mu}"), k("\\:", "\\tmspace+{4mu}{.2222em}"), k("\\medspace", "\\:"), k("\\;", "\\tmspace+{5mu}{.2777em}"), k("\\thickspace", "\\;"), k("\\!", "\\tmspace-{3mu}{.1667em}"), k("\\negthinspace", "\\!"), k("\\negmedspace", "\\tmspace-{4mu}{.2222em}"), k("\\negthickspace", "\\tmspace-{5mu}{.277em}"), k("\\enspace", "\\kern.5em "), k("\\enskip", "\\hskip.5em\\relax"), k("\\quad", "\\hskip1em\\relax"), k("\\qquad", "\\hskip2em\\relax"), k("\\tag", "\\@ifstar\\tag@literal\\tag@paren"), k("\\tag@paren", "\\tag@literal{({#1})}"), k("\\tag@literal", n => {
-                if (n.macros.get("\\df@tag")) throw new a("Multiple \\tag");
+                return t in Vn && t !== "," ? "\\ldots\\," : "\\ldots"
+            }), w("\\cdots", function(n) {
+                return n.future().text in Vn ? "\\@cdots\\," : "\\@cdots"
+            }), w("\\dotsb", "\\cdots"), w("\\dotsm", "\\cdots"), w("\\dotsi", "\\!\\cdots"), w("\\dotsx", "\\ldots\\,"), w("\\DOTSI", "\\relax"), w("\\DOTSB", "\\relax"), w("\\DOTSX", "\\relax"), w("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"), w("\\,", "\\tmspace+{3mu}{.1667em}"), w("\\thinspace", "\\,"), w("\\>", "\\mskip{4mu}"), w("\\:", "\\tmspace+{4mu}{.2222em}"), w("\\medspace", "\\:"), w("\\;", "\\tmspace+{5mu}{.2777em}"), w("\\thickspace", "\\;"), w("\\!", "\\tmspace-{3mu}{.1667em}"), w("\\negthinspace", "\\!"), w("\\negmedspace", "\\tmspace-{4mu}{.2222em}"), w("\\negthickspace", "\\tmspace-{5mu}{.277em}"), w("\\enspace", "\\kern.5em "), w("\\enskip", "\\hskip.5em\\relax"), w("\\quad", "\\hskip1em\\relax"), w("\\qquad", "\\hskip2em\\relax"), w("\\tag", "\\@ifstar\\tag@literal\\tag@paren"), w("\\tag@paren", "\\tag@literal{({#1})}"), w("\\tag@literal", n => {
+                if (n.macros.get("\\df@tag")) throw new o("Multiple \\tag");
                 return "\\gdef\\df@tag{\\text{#1}}"
-            }), k("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}"), k("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"), k("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}"), k("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1"), k("\\newline", "\\\\\\relax"), k("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
-            let Qo = Z(vt["Main-Regular"][84][1] - .7 * vt["Main-Regular"][65][1]);
-            k("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + Qo + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}"), k("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + Qo + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}"), k("\\hspace", "\\@ifstar\\@hspacer\\@hspace"), k("\\@hspace", "\\hskip #1\\relax"), k("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"), k("\\ordinarycolon", ":"), k("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"), k("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}'), k("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}'), k("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}'), k("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}'), k("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}'), k("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}'), k("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}'), k("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}'), k("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}'), k("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}'), k("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}'), k("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}'), k("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}'), k("\u2237", "\\dblcolon"), k("\u2239", "\\eqcolon"), k("\u2254", "\\coloneqq"), k("\u2255", "\\eqqcolon"), k("\u2A74", "\\Coloneqq"), k("\\ratio", "\\vcentcolon"), k("\\coloncolon", "\\dblcolon"), k("\\colonequals", "\\coloneqq"), k("\\coloncolonequals", "\\Coloneqq"), k("\\equalscolon", "\\eqqcolon"), k("\\equalscoloncolon", "\\Eqqcolon"), k("\\colonminus", "\\coloneq"), k("\\coloncolonminus", "\\Coloneq"), k("\\minuscolon", "\\eqcolon"), k("\\minuscoloncolon", "\\Eqcolon"), k("\\coloncolonapprox", "\\Colonapprox"), k("\\coloncolonsim", "\\Colonsim"), k("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), k("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}"), k("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), k("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"), k("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}"), k("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}"), k("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"), k("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}"), k("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}"), k("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}"), k("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}"), k("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}"), k("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"), k("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}"), k("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}"), k("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}"), k("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}"), k("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}"), k("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}"), k("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}"), k("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}"), k("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}"), k("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}"), k("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}"), k("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}"), k("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}"), k("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}"), k("\\imath", "\\html@mathml{\\@imath}{\u0131}"), k("\\jmath", "\\html@mathml{\\@jmath}{\u0237}"), k("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}"), k("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}"), k("\u27E6", "\\llbracket"), k("\u27E7", "\\rrbracket"), k("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}"), k("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}"), k("\u2983", "\\lBrace"), k("\u2984", "\\rBrace"), k("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}"), k("\u29B5", "\\minuso"), k("\\darr", "\\downarrow"), k("\\dArr", "\\Downarrow"), k("\\Darr", "\\Downarrow"), k("\\lang", "\\langle"), k("\\rang", "\\rangle"), k("\\uarr", "\\uparrow"), k("\\uArr", "\\Uparrow"), k("\\Uarr", "\\Uparrow"), k("\\N", "\\mathbb{N}"), k("\\R", "\\mathbb{R}"), k("\\Z", "\\mathbb{Z}"), k("\\alef", "\\aleph"), k("\\alefsym", "\\aleph"), k("\\Alpha", "\\mathrm{A}"), k("\\Beta", "\\mathrm{B}"), k("\\bull", "\\bullet"), k("\\Chi", "\\mathrm{X}"), k("\\clubs", "\\clubsuit"), k("\\cnums", "\\mathbb{C}"), k("\\Complex", "\\mathbb{C}"), k("\\Dagger", "\\ddagger"), k("\\diamonds", "\\diamondsuit"), k("\\empty", "\\emptyset"), k("\\Epsilon", "\\mathrm{E}"), k("\\Eta", "\\mathrm{H}"), k("\\exist", "\\exists"), k("\\harr", "\\leftrightarrow"), k("\\hArr", "\\Leftrightarrow"), k("\\Harr", "\\Leftrightarrow"), k("\\hearts", "\\heartsuit"), k("\\image", "\\Im"), k("\\infin", "\\infty"), k("\\Iota", "\\mathrm{I}"), k("\\isin", "\\in"), k("\\Kappa", "\\mathrm{K}"), k("\\larr", "\\leftarrow"), k("\\lArr", "\\Leftarrow"), k("\\Larr", "\\Leftarrow"), k("\\lrarr", "\\leftrightarrow"), k("\\lrArr", "\\Leftrightarrow"), k("\\Lrarr", "\\Leftrightarrow"), k("\\Mu", "\\mathrm{M}"), k("\\natnums", "\\mathbb{N}"), k("\\Nu", "\\mathrm{N}"), k("\\Omicron", "\\mathrm{O}"), k("\\plusmn", "\\pm"), k("\\rarr", "\\rightarrow"), k("\\rArr", "\\Rightarrow"), k("\\Rarr", "\\Rightarrow"), k("\\real", "\\Re"), k("\\reals", "\\mathbb{R}"), k("\\Reals", "\\mathbb{R}"), k("\\Rho", "\\mathrm{P}"), k("\\sdot", "\\cdot"), k("\\sect", "\\S"), k("\\spades", "\\spadesuit"), k("\\sub", "\\subset"), k("\\sube", "\\subseteq"), k("\\supe", "\\supseteq"), k("\\Tau", "\\mathrm{T}"), k("\\thetasym", "\\vartheta"), k("\\weierp", "\\wp"), k("\\Zeta", "\\mathrm{Z}"), k("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}"), k("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}"), k("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"), k("\\bra", "\\mathinner{\\langle{#1}|}"), k("\\ket", "\\mathinner{|{#1}\\rangle}"), k("\\braket", "\\mathinner{\\langle{#1}\\rangle}"), k("\\Bra", "\\left\\langle#1\\right|"), k("\\Ket", "\\left|#1\\right\\rangle");
-            let Xo = n => t => {
-                let o = t.consumeArg().tokens,
-                    s = t.consumeArg().tokens,
-                    u = t.consumeArg().tokens,
-                    p = t.consumeArg().tokens,
-                    b = t.macros.get("|"),
+            }), w("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}"), w("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"), w("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}"), w("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1"), w("\\newline", "\\\\\\relax"), w("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
+            let Uo = j(wt["Main-Regular"][84][1] - .7 * wt["Main-Regular"][65][1]);
+            w("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + Uo + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}"), w("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + Uo + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}"), w("\\hspace", "\\@ifstar\\@hspacer\\@hspace"), w("\\@hspace", "\\hskip #1\\relax"), w("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"), w("\\ordinarycolon", ":"), w("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"), w("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}'), w("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}'), w("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}'), w("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}'), w("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}'), w("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}'), w("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}'), w("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}'), w("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}'), w("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}'), w("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}'), w("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}'), w("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}'), w("\u2237", "\\dblcolon"), w("\u2239", "\\eqcolon"), w("\u2254", "\\coloneqq"), w("\u2255", "\\eqqcolon"), w("\u2A74", "\\Coloneqq"), w("\\ratio", "\\vcentcolon"), w("\\coloncolon", "\\dblcolon"), w("\\colonequals", "\\coloneqq"), w("\\coloncolonequals", "\\Coloneqq"), w("\\equalscolon", "\\eqqcolon"), w("\\equalscoloncolon", "\\Eqqcolon"), w("\\colonminus", "\\coloneq"), w("\\coloncolonminus", "\\Coloneq"), w("\\minuscolon", "\\eqcolon"), w("\\minuscoloncolon", "\\Eqcolon"), w("\\coloncolonapprox", "\\Colonapprox"), w("\\coloncolonsim", "\\Colonsim"), w("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), w("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}"), w("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), w("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"), w("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}"), w("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}"), w("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"), w("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}"), w("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}"), w("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}"), w("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}"), w("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}"), w("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"), w("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}"), w("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}"), w("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}"), w("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}"), w("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}"), w("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}"), w("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}"), w("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}"), w("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}"), w("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}"), w("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}"), w("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}"), w("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}"), w("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}"), w("\\imath", "\\html@mathml{\\@imath}{\u0131}"), w("\\jmath", "\\html@mathml{\\@jmath}{\u0237}"), w("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}"), w("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}"), w("\u27E6", "\\llbracket"), w("\u27E7", "\\rrbracket"), w("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}"), w("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}"), w("\u2983", "\\lBrace"), w("\u2984", "\\rBrace"), w("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}"), w("\u29B5", "\\minuso"), w("\\darr", "\\downarrow"), w("\\dArr", "\\Downarrow"), w("\\Darr", "\\Downarrow"), w("\\lang", "\\langle"), w("\\rang", "\\rangle"), w("\\uarr", "\\uparrow"), w("\\uArr", "\\Uparrow"), w("\\Uarr", "\\Uparrow"), w("\\N", "\\mathbb{N}"), w("\\R", "\\mathbb{R}"), w("\\Z", "\\mathbb{Z}"), w("\\alef", "\\aleph"), w("\\alefsym", "\\aleph"), w("\\Alpha", "\\mathrm{A}"), w("\\Beta", "\\mathrm{B}"), w("\\bull", "\\bullet"), w("\\Chi", "\\mathrm{X}"), w("\\clubs", "\\clubsuit"), w("\\cnums", "\\mathbb{C}"), w("\\Complex", "\\mathbb{C}"), w("\\Dagger", "\\ddagger"), w("\\diamonds", "\\diamondsuit"), w("\\empty", "\\emptyset"), w("\\Epsilon", "\\mathrm{E}"), w("\\Eta", "\\mathrm{H}"), w("\\exist", "\\exists"), w("\\harr", "\\leftrightarrow"), w("\\hArr", "\\Leftrightarrow"), w("\\Harr", "\\Leftrightarrow"), w("\\hearts", "\\heartsuit"), w("\\image", "\\Im"), w("\\infin", "\\infty"), w("\\Iota", "\\mathrm{I}"), w("\\isin", "\\in"), w("\\Kappa", "\\mathrm{K}"), w("\\larr", "\\leftarrow"), w("\\lArr", "\\Leftarrow"), w("\\Larr", "\\Leftarrow"), w("\\lrarr", "\\leftrightarrow"), w("\\lrArr", "\\Leftrightarrow"), w("\\Lrarr", "\\Leftrightarrow"), w("\\Mu", "\\mathrm{M}"), w("\\natnums", "\\mathbb{N}"), w("\\Nu", "\\mathrm{N}"), w("\\Omicron", "\\mathrm{O}"), w("\\plusmn", "\\pm"), w("\\rarr", "\\rightarrow"), w("\\rArr", "\\Rightarrow"), w("\\Rarr", "\\Rightarrow"), w("\\real", "\\Re"), w("\\reals", "\\mathbb{R}"), w("\\Reals", "\\mathbb{R}"), w("\\Rho", "\\mathrm{P}"), w("\\sdot", "\\cdot"), w("\\sect", "\\S"), w("\\spades", "\\spadesuit"), w("\\sub", "\\subset"), w("\\sube", "\\subseteq"), w("\\supe", "\\supseteq"), w("\\Tau", "\\mathrm{T}"), w("\\thetasym", "\\vartheta"), w("\\weierp", "\\wp"), w("\\Zeta", "\\mathrm{Z}"), w("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}"), w("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}"), w("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"), w("\\bra", "\\mathinner{\\langle{#1}|}"), w("\\ket", "\\mathinner{|{#1}\\rangle}"), w("\\braket", "\\mathinner{\\langle{#1}\\rangle}"), w("\\Bra", "\\left\\langle#1\\right|"), w("\\Ket", "\\left|#1\\right\\rangle");
+            let jo = n => t => {
+                let u = t.consumeArg().tokens,
+                    a = t.consumeArg().tokens,
+                    c = t.consumeArg().tokens,
+                    m = t.consumeArg().tokens,
+                    g = t.macros.get("|"),
                     v = t.macros.get("\\|");
                 t.macros.beginGroup();
-                let S = F => N => {
-                    n && (N.macros.set("|", b), u.length && N.macros.set("\\|", v));
-                    let H = F;
-                    return !F && u.length && N.future().text === "|" && (N.popToken(), H = !0), {
-                        tokens: H ? u : s,
+                let _ = R => L => {
+                    n && (L.macros.set("|", g), c.length && L.macros.set("\\|", v));
+                    let P = R;
+                    return !R && c.length && L.future().text === "|" && (L.popToken(), P = !0), {
+                        tokens: P ? c : a,
                         numArgs: 0
                     }
                 };
-                t.macros.set("|", S(!1)), u.length && t.macros.set("\\|", S(!0));
-                let E = t.consumeArg().tokens,
-                    z = t.expandTokens([...p, ...E, ...o]);
+                t.macros.set("|", _(!1)), c.length && t.macros.set("\\|", _(!0));
+                let D = t.consumeArg().tokens,
+                    z = t.expandTokens([...m, ...D, ...u]);
                 return t.macros.endGroup(), {
                     tokens: z.reverse(),
                     numArgs: 0
                 }
             };
-            k("\\bra@ket", Xo(!1)), k("\\bra@set", Xo(!0)), k("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}"), k("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}"), k("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}"), k("\\angln", "{\\angl n}"), k("\\blue", "\\textcolor{##6495ed}{#1}"), k("\\orange", "\\textcolor{##ffa500}{#1}"), k("\\pink", "\\textcolor{##ff00af}{#1}"), k("\\red", "\\textcolor{##df0030}{#1}"), k("\\green", "\\textcolor{##28ae7b}{#1}"), k("\\gray", "\\textcolor{gray}{#1}"), k("\\purple", "\\textcolor{##9d38bd}{#1}"), k("\\blueA", "\\textcolor{##ccfaff}{#1}"), k("\\blueB", "\\textcolor{##80f6ff}{#1}"), k("\\blueC", "\\textcolor{##63d9ea}{#1}"), k("\\blueD", "\\textcolor{##11accd}{#1}"), k("\\blueE", "\\textcolor{##0c7f99}{#1}"), k("\\tealA", "\\textcolor{##94fff5}{#1}"), k("\\tealB", "\\textcolor{##26edd5}{#1}"), k("\\tealC", "\\textcolor{##01d1c1}{#1}"), k("\\tealD", "\\textcolor{##01a995}{#1}"), k("\\tealE", "\\textcolor{##208170}{#1}"), k("\\greenA", "\\textcolor{##b6ffb0}{#1}"), k("\\greenB", "\\textcolor{##8af281}{#1}"), k("\\greenC", "\\textcolor{##74cf70}{#1}"), k("\\greenD", "\\textcolor{##1fab54}{#1}"), k("\\greenE", "\\textcolor{##0d923f}{#1}"), k("\\goldA", "\\textcolor{##ffd0a9}{#1}"), k("\\goldB", "\\textcolor{##ffbb71}{#1}"), k("\\goldC", "\\textcolor{##ff9c39}{#1}"), k("\\goldD", "\\textcolor{##e07d10}{#1}"), k("\\goldE", "\\textcolor{##a75a05}{#1}"), k("\\redA", "\\textcolor{##fca9a9}{#1}"), k("\\redB", "\\textcolor{##ff8482}{#1}"), k("\\redC", "\\textcolor{##f9685d}{#1}"), k("\\redD", "\\textcolor{##e84d39}{#1}"), k("\\redE", "\\textcolor{##bc2612}{#1}"), k("\\maroonA", "\\textcolor{##ffbde0}{#1}"), k("\\maroonB", "\\textcolor{##ff92c6}{#1}"), k("\\maroonC", "\\textcolor{##ed5fa6}{#1}"), k("\\maroonD", "\\textcolor{##ca337c}{#1}"), k("\\maroonE", "\\textcolor{##9e034e}{#1}"), k("\\purpleA", "\\textcolor{##ddd7ff}{#1}"), k("\\purpleB", "\\textcolor{##c6b9fc}{#1}"), k("\\purpleC", "\\textcolor{##aa87ff}{#1}"), k("\\purpleD", "\\textcolor{##7854ab}{#1}"), k("\\purpleE", "\\textcolor{##543b78}{#1}"), k("\\mintA", "\\textcolor{##f5f9e8}{#1}"), k("\\mintB", "\\textcolor{##edf2df}{#1}"), k("\\mintC", "\\textcolor{##e0e5cc}{#1}"), k("\\grayA", "\\textcolor{##f6f7f7}{#1}"), k("\\grayB", "\\textcolor{##f0f1f2}{#1}"), k("\\grayC", "\\textcolor{##e3e5e6}{#1}"), k("\\grayD", "\\textcolor{##d6d8da}{#1}"), k("\\grayE", "\\textcolor{##babec2}{#1}"), k("\\grayF", "\\textcolor{##888d93}{#1}"), k("\\grayG", "\\textcolor{##626569}{#1}"), k("\\grayH", "\\textcolor{##3b3e40}{#1}"), k("\\grayI", "\\textcolor{##21242c}{#1}"), k("\\kaBlue", "\\textcolor{##314453}{#1}"), k("\\kaGreen", "\\textcolor{##71B307}{#1}");
-            let Jo = {
+            w("\\bra@ket", jo(!1)), w("\\bra@set", jo(!0)), w("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}"), w("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}"), w("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}"), w("\\angln", "{\\angl n}"), w("\\blue", "\\textcolor{##6495ed}{#1}"), w("\\orange", "\\textcolor{##ffa500}{#1}"), w("\\pink", "\\textcolor{##ff00af}{#1}"), w("\\red", "\\textcolor{##df0030}{#1}"), w("\\green", "\\textcolor{##28ae7b}{#1}"), w("\\gray", "\\textcolor{gray}{#1}"), w("\\purple", "\\textcolor{##9d38bd}{#1}"), w("\\blueA", "\\textcolor{##ccfaff}{#1}"), w("\\blueB", "\\textcolor{##80f6ff}{#1}"), w("\\blueC", "\\textcolor{##63d9ea}{#1}"), w("\\blueD", "\\textcolor{##11accd}{#1}"), w("\\blueE", "\\textcolor{##0c7f99}{#1}"), w("\\tealA", "\\textcolor{##94fff5}{#1}"), w("\\tealB", "\\textcolor{##26edd5}{#1}"), w("\\tealC", "\\textcolor{##01d1c1}{#1}"), w("\\tealD", "\\textcolor{##01a995}{#1}"), w("\\tealE", "\\textcolor{##208170}{#1}"), w("\\greenA", "\\textcolor{##b6ffb0}{#1}"), w("\\greenB", "\\textcolor{##8af281}{#1}"), w("\\greenC", "\\textcolor{##74cf70}{#1}"), w("\\greenD", "\\textcolor{##1fab54}{#1}"), w("\\greenE", "\\textcolor{##0d923f}{#1}"), w("\\goldA", "\\textcolor{##ffd0a9}{#1}"), w("\\goldB", "\\textcolor{##ffbb71}{#1}"), w("\\goldC", "\\textcolor{##ff9c39}{#1}"), w("\\goldD", "\\textcolor{##e07d10}{#1}"), w("\\goldE", "\\textcolor{##a75a05}{#1}"), w("\\redA", "\\textcolor{##fca9a9}{#1}"), w("\\redB", "\\textcolor{##ff8482}{#1}"), w("\\redC", "\\textcolor{##f9685d}{#1}"), w("\\redD", "\\textcolor{##e84d39}{#1}"), w("\\redE", "\\textcolor{##bc2612}{#1}"), w("\\maroonA", "\\textcolor{##ffbde0}{#1}"), w("\\maroonB", "\\textcolor{##ff92c6}{#1}"), w("\\maroonC", "\\textcolor{##ed5fa6}{#1}"), w("\\maroonD", "\\textcolor{##ca337c}{#1}"), w("\\maroonE", "\\textcolor{##9e034e}{#1}"), w("\\purpleA", "\\textcolor{##ddd7ff}{#1}"), w("\\purpleB", "\\textcolor{##c6b9fc}{#1}"), w("\\purpleC", "\\textcolor{##aa87ff}{#1}"), w("\\purpleD", "\\textcolor{##7854ab}{#1}"), w("\\purpleE", "\\textcolor{##543b78}{#1}"), w("\\mintA", "\\textcolor{##f5f9e8}{#1}"), w("\\mintB", "\\textcolor{##edf2df}{#1}"), w("\\mintC", "\\textcolor{##e0e5cc}{#1}"), w("\\grayA", "\\textcolor{##f6f7f7}{#1}"), w("\\grayB", "\\textcolor{##f0f1f2}{#1}"), w("\\grayC", "\\textcolor{##e3e5e6}{#1}"), w("\\grayD", "\\textcolor{##d6d8da}{#1}"), w("\\grayE", "\\textcolor{##babec2}{#1}"), w("\\grayF", "\\textcolor{##888d93}{#1}"), w("\\grayG", "\\textcolor{##626569}{#1}"), w("\\grayH", "\\textcolor{##3b3e40}{#1}"), w("\\grayI", "\\textcolor{##21242c}{#1}"), w("\\kaBlue", "\\textcolor{##314453}{#1}"), w("\\kaGreen", "\\textcolor{##71B307}{#1}");
+            let Wo = {
                 "^": !0,
                 _: !0,
                 "\\limits": !0,
                 "\\nolimits": !0
             };
-            class X1 {
-                constructor(t, o, s) {
-                    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = o, this.expansionCount = 0, this.feed(t), this.macros = new Z1(Q1, o.macros), this.mode = s, this.stack = []
+            class Gc {
+                constructor(t, u, a) {
+                    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = u, this.expansionCount = 0, this.feed(t), this.macros = new Hc($c, u.macros), this.mode = a, this.stack = []
                 }
                 feed(t) {
-                    this.lexer = new Wo(t, this.settings)
+                    this.lexer = new $o(t, this.settings)
                 }
                 switchMode(t) {
                     this.mode = t
                 }
                 beginGroup() {
                     this.macros.beginGroup()
                 }
@@ -14647,97 +10237,97 @@
                 pushToken(t) {
                     this.stack.push(t)
                 }
                 pushTokens(t) {
                     this.stack.push(...t)
                 }
                 scanArgument(t) {
-                    let o, s, u;
+                    let u, a, c;
                     if (t) {
                         if (this.consumeSpaces(), this.future().text !== "[") return null;
-                        o = this.popToken(), {
-                            tokens: u,
-                            end: s
+                        u = this.popToken(), {
+                            tokens: c,
+                            end: a
                         } = this.consumeArg(["]"])
                     } else({
-                        tokens: u,
-                        start: o,
-                        end: s
+                        tokens: c,
+                        start: u,
+                        end: a
                     } = this.consumeArg());
-                    return this.pushToken(new mt("EOF", s.loc)), this.pushTokens(u), o.range(s, "")
+                    return this.pushToken(new mt("EOF", a.loc)), this.pushTokens(c), u.range(a, "")
                 }
                 consumeSpaces() {
                     for (; this.future().text === " ";) this.stack.pop()
                 }
                 consumeArg(t) {
-                    let o = [],
-                        s = t && t.length > 0;
-                    s || this.consumeSpaces();
-                    let u = this.future(),
-                        p, b = 0,
+                    let u = [],
+                        a = t && t.length > 0;
+                    a || this.consumeSpaces();
+                    let c = this.future(),
+                        m, g = 0,
                         v = 0;
                     do {
-                        if (p = this.popToken(), o.push(p), p.text === "{") ++b;
-                        else if (p.text === "}") {
-                            if (--b, b === -1) throw new a("Extra }", p)
-                        } else if (p.text === "EOF") throw new a("Unexpected end of input in a macro argument, expected '" + (t && s ? t[v] : "}") + "'", p);
-                        if (t && s)
-                            if ((b === 0 || b === 1 && t[v] === "{") && p.text === t[v]) {
+                        if (m = this.popToken(), u.push(m), m.text === "{") ++g;
+                        else if (m.text === "}") {
+                            if (--g, g === -1) throw new o("Extra }", m)
+                        } else if (m.text === "EOF") throw new o("Unexpected end of input in a macro argument, expected '" + (t && a ? t[v] : "}") + "'", m);
+                        if (t && a)
+                            if ((g === 0 || g === 1 && t[v] === "{") && m.text === t[v]) {
                                 if (++v, v === t.length) {
-                                    o.splice(-v, v);
+                                    u.splice(-v, v);
                                     break
                                 }
                             } else v = 0
-                    } while (b !== 0 || s);
-                    return u.text === "{" && o[o.length - 1].text === "}" && (o.pop(), o.shift()), o.reverse(), {
-                        tokens: o,
-                        start: u,
-                        end: p
+                    } while (g !== 0 || a);
+                    return c.text === "{" && u[u.length - 1].text === "}" && (u.pop(), u.shift()), u.reverse(), {
+                        tokens: u,
+                        start: c,
+                        end: m
                     }
                 }
-                consumeArgs(t, o) {
-                    if (o) {
-                        if (o.length !== t + 1) throw new a("The length of delimiters doesn't match the number of args!");
-                        let u = o[0];
-                        for (let p = 0; p < u.length; p++) {
-                            let b = this.popToken();
-                            if (u[p] !== b.text) throw new a("Use of the macro doesn't match its definition", b)
+                consumeArgs(t, u) {
+                    if (u) {
+                        if (u.length !== t + 1) throw new o("The length of delimiters doesn't match the number of args!");
+                        let c = u[0];
+                        for (let m = 0; m < c.length; m++) {
+                            let g = this.popToken();
+                            if (c[m] !== g.text) throw new o("Use of the macro doesn't match its definition", g)
                         }
                     }
-                    let s = [];
-                    for (let u = 0; u < t; u++) s.push(this.consumeArg(o && o[u + 1]).tokens);
-                    return s
+                    let a = [];
+                    for (let c = 0; c < t; c++) a.push(this.consumeArg(u && u[c + 1]).tokens);
+                    return a
                 }
                 countExpansion(t) {
-                    if (this.expansionCount += t, this.expansionCount > this.settings.maxExpand) throw new a("Too many expansions: infinite loop or need to increase maxExpand setting")
+                    if (this.expansionCount += t, this.expansionCount > this.settings.maxExpand) throw new o("Too many expansions: infinite loop or need to increase maxExpand setting")
                 }
                 expandOnce(t) {
-                    let o = this.popToken(),
-                        s = o.text,
-                        u = o.noexpand ? null : this._getExpansion(s);
-                    if (u == null || t && u.unexpandable) {
-                        if (t && u == null && s[0] === "\\" && !this.isDefined(s)) throw new a("Undefined control sequence: " + s);
-                        return this.pushToken(o), !1
+                    let u = this.popToken(),
+                        a = u.text,
+                        c = u.noexpand ? null : this._getExpansion(a);
+                    if (c == null || t && c.unexpandable) {
+                        if (t && c == null && a[0] === "\\" && !this.isDefined(a)) throw new o("Undefined control sequence: " + a);
+                        return this.pushToken(u), !1
                     }
                     this.countExpansion(1);
-                    let p = u.tokens,
-                        b = this.consumeArgs(u.numArgs, u.delimiters);
-                    if (u.numArgs) {
-                        p = p.slice();
-                        for (let v = p.length - 1; v >= 0; --v) {
-                            let S = p[v];
-                            if (S.text === "#") {
-                                if (v === 0) throw new a("Incomplete placeholder at end of macro body", S);
-                                if (S = p[--v], S.text === "#") p.splice(v + 1, 1);
-                                else if (/^[1-9]$/.test(S.text)) p.splice(v, 2, ...b[+S.text - 1]);
-                                else throw new a("Not a valid argument number", S)
+                    let m = c.tokens,
+                        g = this.consumeArgs(c.numArgs, c.delimiters);
+                    if (c.numArgs) {
+                        m = m.slice();
+                        for (let v = m.length - 1; v >= 0; --v) {
+                            let _ = m[v];
+                            if (_.text === "#") {
+                                if (v === 0) throw new o("Incomplete placeholder at end of macro body", _);
+                                if (_ = m[--v], _.text === "#") m.splice(v + 1, 1);
+                                else if (/^[1-9]$/.test(_.text)) m.splice(v, 2, ...g[+_.text - 1]);
+                                else throw new o("Not a valid argument number", _)
                             }
                         }
                     }
-                    return this.pushTokens(p), p.length
+                    return this.pushTokens(m), m.length
                 }
                 expandAfterFuture() {
                     return this.expandOnce(), this.future()
                 }
                 expandNextToken() {
                     for (;;)
                         if (this.expandOnce() === !1) {
@@ -14745,61 +10335,61 @@
                             return t.treatAsRelax && (t.text = "\\relax"), t
                         } throw new Error
                 }
                 expandMacro(t) {
                     return this.macros.has(t) ? this.expandTokens([new mt(t)]) : void 0
                 }
                 expandTokens(t) {
-                    let o = [],
-                        s = this.stack.length;
-                    for (this.pushTokens(t); this.stack.length > s;)
+                    let u = [],
+                        a = this.stack.length;
+                    for (this.pushTokens(t); this.stack.length > a;)
                         if (this.expandOnce(!0) === !1) {
-                            let u = this.stack.pop();
-                            u.treatAsRelax && (u.noexpand = !1, u.treatAsRelax = !1), o.push(u)
-                        } return this.countExpansion(o.length), o
+                            let c = this.stack.pop();
+                            c.treatAsRelax && (c.noexpand = !1, c.treatAsRelax = !1), u.push(c)
+                        } return this.countExpansion(u.length), u
                 }
                 expandMacroAsText(t) {
-                    let o = this.expandMacro(t);
-                    return o && o.map(s => s.text).join("")
+                    let u = this.expandMacro(t);
+                    return u && u.map(a => a.text).join("")
                 }
                 _getExpansion(t) {
-                    let o = this.macros.get(t);
-                    if (o == null) return o;
+                    let u = this.macros.get(t);
+                    if (u == null) return u;
                     if (t.length === 1) {
-                        let u = this.lexer.catcodes[t];
-                        if (u != null && u !== 13) return
+                        let c = this.lexer.catcodes[t];
+                        if (c != null && c !== 13) return
                     }
-                    let s = typeof o == "function" ? o(this) : o;
-                    if (typeof s == "string") {
-                        let u = 0;
-                        if (s.indexOf("#") !== -1) {
-                            let E = s.replace(/##/g, "");
-                            for (; E.indexOf("#" + (u + 1)) !== -1;) ++u
+                    let a = typeof u == "function" ? u(this) : u;
+                    if (typeof a == "string") {
+                        let c = 0;
+                        if (a.indexOf("#") !== -1) {
+                            let D = a.replace(/##/g, "");
+                            for (; D.indexOf("#" + (c + 1)) !== -1;) ++c
                         }
-                        let p = new Wo(s, this.settings),
-                            b = [],
-                            v = p.lex();
-                        for (; v.text !== "EOF";) b.push(v), v = p.lex();
-                        return b.reverse(), {
-                            tokens: b,
-                            numArgs: u
+                        let m = new $o(a, this.settings),
+                            g = [],
+                            v = m.lex();
+                        for (; v.text !== "EOF";) g.push(v), v = m.lex();
+                        return g.reverse(), {
+                            tokens: g,
+                            numArgs: c
                         }
                     }
-                    return s
+                    return a
                 }
                 isDefined(t) {
-                    return this.macros.has(t) || Gt.hasOwnProperty(t) || Oe.math.hasOwnProperty(t) || Oe.text.hasOwnProperty(t) || Jo.hasOwnProperty(t)
+                    return this.macros.has(t) || Yt.hasOwnProperty(t) || Pe.math.hasOwnProperty(t) || Pe.text.hasOwnProperty(t) || Wo.hasOwnProperty(t)
                 }
                 isExpandable(t) {
-                    let o = this.macros.get(t);
-                    return o != null ? typeof o == "string" || typeof o == "function" || !o.unexpandable : Gt.hasOwnProperty(t) && !Gt[t].primitive
+                    let u = this.macros.get(t);
+                    return u != null ? typeof u == "string" || typeof u == "function" || !u.unexpandable : Yt.hasOwnProperty(t) && !Yt[t].primitive
                 }
             }
-            let Ko = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/,
-                o0 = Object.freeze({
+            let Yo = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/,
+                xr = Object.freeze({
                     "\u208A": "+",
                     "\u208B": "-",
                     "\u208C": "=",
                     "\u208D": "(",
                     "\u208E": ")",
                     "\u2080": "0",
                     "\u2081": "1",
@@ -14895,15 +10485,15 @@
                     "\u1D5D": "\u03B2",
                     "\u1D5E": "\u03B3",
                     "\u1D5F": "\u03B4",
                     "\u1D60": "\u03D5",
                     "\u1D61": "\u03C7",
                     "\u1DBF": "\u03B8"
                 }),
-                An = {
+                Un = {
                     "\u0301": {
                         text: "\\'",
                         math: "\\acute"
                     },
                     "\u0300": {
                         text: "\\`",
                         math: "\\grave"
@@ -14943,15 +10533,15 @@
                     "\u030B": {
                         text: "\\H"
                     },
                     "\u0327": {
                         text: "\\c"
                     }
                 },
-                ea = {
+                Zo = {
                     \u00E1: "a\u0301",
                     \u00E0: "a\u0300",
                     \u00E4: "a\u0308",
                     \u01DF: "a\u0308\u0304",
                     \u00E3: "a\u0303",
                     \u0101: "a\u0304",
                     \u0103: "a\u0306",
@@ -15289,21 +10879,21 @@
                     \u1FEA: "\u03A5\u0300",
                     \u03AB: "\u03A5\u0308",
                     \u1FE9: "\u03A5\u0304",
                     \u1FE8: "\u03A5\u0306",
                     \u038F: "\u03A9\u0301",
                     \u1FFA: "\u03A9\u0300"
                 };
-            class a0 {
-                constructor(t, o) {
-                    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new X1(t, o, this.mode), this.settings = o, this.leftrightDepth = 0
-                }
-                expect(t, o) {
-                    if (o === void 0 && (o = !0), this.fetch().text !== t) throw new a("Expected '" + t + "', got '" + this.fetch().text + "'", this.fetch());
-                    o && this.consume()
+            class yr {
+                constructor(t, u) {
+                    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new Gc(t, u, this.mode), this.settings = u, this.leftrightDepth = 0
+                }
+                expect(t, u) {
+                    if (u === void 0 && (u = !0), this.fetch().text !== t) throw new o("Expected '" + t + "', got '" + this.fetch().text + "'", this.fetch());
+                    u && this.consume()
                 }
                 consume() {
                     this.nextToken = null
                 }
                 fetch() {
                     return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken
                 }
@@ -15316,1704 +10906,1704 @@
                         let t = this.parseExpression(!1);
                         return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), t
                     } finally {
                         this.gullet.endGroups()
                     }
                 }
                 subparse(t) {
-                    let o = this.nextToken;
+                    let u = this.nextToken;
                     this.consume(), this.gullet.pushToken(new mt("}")), this.gullet.pushTokens(t);
-                    let s = this.parseExpression(!1);
-                    return this.expect("}"), this.nextToken = o, s
+                    let a = this.parseExpression(!1);
+                    return this.expect("}"), this.nextToken = u, a
                 }
-                parseExpression(t, o) {
-                    let s = [];
+                parseExpression(t, u) {
+                    let a = [];
                     for (;;) {
                         this.mode === "math" && this.consumeSpaces();
-                        let u = this.fetch();
-                        if (a0.endOfExpression.indexOf(u.text) !== -1 || o && u.text === o || t && Gt[u.text] && Gt[u.text].infix) break;
-                        let p = this.parseAtom(o);
-                        if (p) {
-                            if (p.type === "internal") continue
+                        let c = this.fetch();
+                        if (yr.endOfExpression.indexOf(c.text) !== -1 || u && c.text === u || t && Yt[c.text] && Yt[c.text].infix) break;
+                        let m = this.parseAtom(u);
+                        if (m) {
+                            if (m.type === "internal") continue
                         } else break;
-                        s.push(p)
+                        a.push(m)
                     }
-                    return this.mode === "text" && this.formLigatures(s), this.handleInfixNodes(s)
+                    return this.mode === "text" && this.formLigatures(a), this.handleInfixNodes(a)
                 }
                 handleInfixNodes(t) {
-                    let o = -1,
-                        s;
-                    for (let u = 0; u < t.length; u++)
-                        if (t[u].type === "infix") {
-                            if (o !== -1) throw new a("only one infix operator per group", t[u].token);
-                            o = u, s = t[u].replaceWith
-                        } if (o !== -1 && s) {
-                        let u, p, b = t.slice(0, o),
-                            v = t.slice(o + 1);
-                        b.length === 1 && b[0].type === "ordgroup" ? u = b[0] : u = {
+                    let u = -1,
+                        a;
+                    for (let c = 0; c < t.length; c++)
+                        if (t[c].type === "infix") {
+                            if (u !== -1) throw new o("only one infix operator per group", t[c].token);
+                            u = c, a = t[c].replaceWith
+                        } if (u !== -1 && a) {
+                        let c, m, g = t.slice(0, u),
+                            v = t.slice(u + 1);
+                        g.length === 1 && g[0].type === "ordgroup" ? c = g[0] : c = {
                             type: "ordgroup",
                             mode: this.mode,
-                            body: b
-                        }, v.length === 1 && v[0].type === "ordgroup" ? p = v[0] : p = {
+                            body: g
+                        }, v.length === 1 && v[0].type === "ordgroup" ? m = v[0] : m = {
                             type: "ordgroup",
                             mode: this.mode,
                             body: v
                         };
-                        let S;
-                        return s === "\\\\abovefrac" ? S = this.callFunction(s, [u, t[o], p], []) : S = this.callFunction(s, [u, p], []), [S]
+                        let _;
+                        return a === "\\\\abovefrac" ? _ = this.callFunction(a, [c, t[u], m], []) : _ = this.callFunction(a, [c, m], []), [_]
                     } else return t
                 }
                 handleSupSubscript(t) {
-                    let o = this.fetch(),
-                        s = o.text;
+                    let u = this.fetch(),
+                        a = u.text;
                     this.consume(), this.consumeSpaces();
-                    let u = this.parseGroup(t);
-                    if (!u) throw new a("Expected group after '" + s + "'", o);
-                    return u
+                    let c = this.parseGroup(t);
+                    if (!c) throw new o("Expected group after '" + a + "'", u);
+                    return c
                 }
                 formatUnsupportedCmd(t) {
-                    let o = [];
-                    for (let p = 0; p < t.length; p++) o.push({
+                    let u = [];
+                    for (let m = 0; m < t.length; m++) u.push({
                         type: "textord",
                         mode: "text",
-                        text: t[p]
+                        text: t[m]
                     });
-                    let s = {
+                    let a = {
                         type: "text",
                         mode: this.mode,
-                        body: o
+                        body: u
                     };
                     return {
                         type: "color",
                         mode: this.mode,
                         color: this.settings.errorColor,
-                        body: [s]
+                        body: [a]
                     }
                 }
                 parseAtom(t) {
-                    let o = this.parseGroup("atom", t);
-                    if (this.mode === "text") return o;
-                    let s, u;
+                    let u = this.parseGroup("atom", t);
+                    if (this.mode === "text") return u;
+                    let a, c;
                     for (;;) {
                         this.consumeSpaces();
-                        let p = this.fetch();
-                        if (p.text === "\\limits" || p.text === "\\nolimits") {
-                            if (o && o.type === "op") {
-                                let b = p.text === "\\limits";
-                                o.limits = b, o.alwaysHandleSupSub = !0
-                            } else if (o && o.type === "operatorname") o.alwaysHandleSupSub && (o.limits = p.text === "\\limits");
-                            else throw new a("Limit controls must follow a math operator", p);
+                        let m = this.fetch();
+                        if (m.text === "\\limits" || m.text === "\\nolimits") {
+                            if (u && u.type === "op") {
+                                let g = m.text === "\\limits";
+                                u.limits = g, u.alwaysHandleSupSub = !0
+                            } else if (u && u.type === "operatorname") u.alwaysHandleSupSub && (u.limits = m.text === "\\limits");
+                            else throw new o("Limit controls must follow a math operator", m);
                             this.consume()
-                        } else if (p.text === "^") {
-                            if (s) throw new a("Double superscript", p);
-                            s = this.handleSupSubscript("superscript")
-                        } else if (p.text === "_") {
-                            if (u) throw new a("Double subscript", p);
-                            u = this.handleSupSubscript("subscript")
-                        } else if (p.text === "'") {
-                            if (s) throw new a("Double superscript", p);
-                            let b = {
+                        } else if (m.text === "^") {
+                            if (a) throw new o("Double superscript", m);
+                            a = this.handleSupSubscript("superscript")
+                        } else if (m.text === "_") {
+                            if (c) throw new o("Double subscript", m);
+                            c = this.handleSupSubscript("subscript")
+                        } else if (m.text === "'") {
+                            if (a) throw new o("Double superscript", m);
+                            let g = {
                                     type: "textord",
                                     mode: this.mode,
                                     text: "\\prime"
                                 },
-                                v = [b];
-                            for (this.consume(); this.fetch().text === "'";) v.push(b), this.consume();
-                            this.fetch().text === "^" && v.push(this.handleSupSubscript("superscript")), s = {
+                                v = [g];
+                            for (this.consume(); this.fetch().text === "'";) v.push(g), this.consume();
+                            this.fetch().text === "^" && v.push(this.handleSupSubscript("superscript")), a = {
                                 type: "ordgroup",
                                 mode: this.mode,
                                 body: v
                             }
-                        } else if (o0[p.text]) {
-                            let b = Ko.test(p.text),
+                        } else if (xr[m.text]) {
+                            let g = Yo.test(m.text),
                                 v = [];
-                            for (v.push(new mt(o0[p.text])), this.consume();;) {
-                                let E = this.fetch().text;
-                                if (!o0[E] || Ko.test(E) !== b) break;
-                                v.unshift(new mt(o0[E])), this.consume()
+                            for (v.push(new mt(xr[m.text])), this.consume();;) {
+                                let D = this.fetch().text;
+                                if (!xr[D] || Yo.test(D) !== g) break;
+                                v.unshift(new mt(xr[D])), this.consume()
                             }
-                            let S = this.subparse(v);
-                            b ? u = {
+                            let _ = this.subparse(v);
+                            g ? c = {
                                 type: "ordgroup",
                                 mode: "math",
-                                body: S
-                            } : s = {
+                                body: _
+                            } : a = {
                                 type: "ordgroup",
                                 mode: "math",
-                                body: S
+                                body: _
                             }
                         } else break
                     }
-                    return s || u ? {
+                    return a || c ? {
                         type: "supsub",
                         mode: this.mode,
-                        base: o,
-                        sup: s,
-                        sub: u
-                    } : o
-                }
-                parseFunction(t, o) {
-                    let s = this.fetch(),
-                        u = s.text,
-                        p = Gt[u];
-                    if (!p) return null;
-                    if (this.consume(), o && o !== "atom" && !p.allowedInArgument) throw new a("Got function '" + u + "' with no arguments" + (o ? " as " + o : ""), s);
-                    if (this.mode === "text" && !p.allowedInText) throw new a("Can't use function '" + u + "' in text mode", s);
-                    if (this.mode === "math" && p.allowedInMath === !1) throw new a("Can't use function '" + u + "' in math mode", s);
+                        base: u,
+                        sup: a,
+                        sub: c
+                    } : u
+                }
+                parseFunction(t, u) {
+                    let a = this.fetch(),
+                        c = a.text,
+                        m = Yt[c];
+                    if (!m) return null;
+                    if (this.consume(), u && u !== "atom" && !m.allowedInArgument) throw new o("Got function '" + c + "' with no arguments" + (u ? " as " + u : ""), a);
+                    if (this.mode === "text" && !m.allowedInText) throw new o("Can't use function '" + c + "' in text mode", a);
+                    if (this.mode === "math" && m.allowedInMath === !1) throw new o("Can't use function '" + c + "' in math mode", a);
                     let {
-                        args: b,
+                        args: g,
                         optArgs: v
-                    } = this.parseArguments(u, p);
-                    return this.callFunction(u, b, v, s, t)
+                    } = this.parseArguments(c, m);
+                    return this.callFunction(c, g, v, a, t)
                 }
-                callFunction(t, o, s, u, p) {
-                    let b = {
+                callFunction(t, u, a, c, m) {
+                    let g = {
                             funcName: t,
                             parser: this,
-                            token: u,
-                            breakOnTokenText: p
+                            token: c,
+                            breakOnTokenText: m
                         },
-                        v = Gt[t];
-                    if (v && v.handler) return v.handler(b, o, s);
-                    throw new a("No function handler for " + t)
-                }
-                parseArguments(t, o) {
-                    let s = o.numArgs + o.numOptionalArgs;
-                    if (s === 0) return {
+                        v = Yt[t];
+                    if (v && v.handler) return v.handler(g, u, a);
+                    throw new o("No function handler for " + t)
+                }
+                parseArguments(t, u) {
+                    let a = u.numArgs + u.numOptionalArgs;
+                    if (a === 0) return {
                         args: [],
                         optArgs: []
                     };
-                    let u = [],
-                        p = [];
-                    for (let b = 0; b < s; b++) {
-                        let v = o.argTypes && o.argTypes[b],
-                            S = b < o.numOptionalArgs;
-                        (o.primitive && v == null || o.type === "sqrt" && b === 1 && p[0] == null) && (v = "primitive");
-                        let E = this.parseGroupOfType("argument to '" + t + "'", v, S);
-                        if (S) p.push(E);
-                        else if (E != null) u.push(E);
-                        else throw new a("Null argument, please report this as a bug")
+                    let c = [],
+                        m = [];
+                    for (let g = 0; g < a; g++) {
+                        let v = u.argTypes && u.argTypes[g],
+                            _ = g < u.numOptionalArgs;
+                        (u.primitive && v == null || u.type === "sqrt" && g === 1 && m[0] == null) && (v = "primitive");
+                        let D = this.parseGroupOfType("argument to '" + t + "'", v, _);
+                        if (_) m.push(D);
+                        else if (D != null) c.push(D);
+                        else throw new o("Null argument, please report this as a bug")
                     }
                     return {
-                        args: u,
-                        optArgs: p
+                        args: c,
+                        optArgs: m
                     }
                 }
-                parseGroupOfType(t, o, s) {
-                    switch (o) {
+                parseGroupOfType(t, u, a) {
+                    switch (u) {
                         case "color":
-                            return this.parseColorGroup(s);
+                            return this.parseColorGroup(a);
                         case "size":
-                            return this.parseSizeGroup(s);
+                            return this.parseSizeGroup(a);
                         case "url":
-                            return this.parseUrlGroup(s);
+                            return this.parseUrlGroup(a);
                         case "math":
                         case "text":
-                            return this.parseArgumentGroup(s, o);
+                            return this.parseArgumentGroup(a, u);
                         case "hbox": {
-                            let u = this.parseArgumentGroup(s, "text");
-                            return u != null ? {
+                            let c = this.parseArgumentGroup(a, "text");
+                            return c != null ? {
                                 type: "styling",
-                                mode: u.mode,
-                                body: [u],
+                                mode: c.mode,
+                                body: [c],
                                 style: "text"
                             } : null
                         }
                         case "raw": {
-                            let u = this.parseStringGroup("raw", s);
-                            return u != null ? {
+                            let c = this.parseStringGroup("raw", a);
+                            return c != null ? {
                                 type: "raw",
                                 mode: "text",
-                                string: u.text
+                                string: c.text
                             } : null
                         }
                         case "primitive": {
-                            if (s) throw new a("A primitive argument cannot be optional");
-                            let u = this.parseGroup(t);
-                            if (u == null) throw new a("Expected group as " + t, this.fetch());
-                            return u
+                            if (a) throw new o("A primitive argument cannot be optional");
+                            let c = this.parseGroup(t);
+                            if (c == null) throw new o("Expected group as " + t, this.fetch());
+                            return c
                         }
                         case "original":
                         case null:
                         case void 0:
-                            return this.parseArgumentGroup(s);
+                            return this.parseArgumentGroup(a);
                         default:
-                            throw new a("Unknown group type as " + t, this.fetch())
+                            throw new o("Unknown group type as " + t, this.fetch())
                     }
                 }
                 consumeSpaces() {
                     for (; this.fetch().text === " ";) this.consume()
                 }
-                parseStringGroup(t, o) {
-                    let s = this.gullet.scanArgument(o);
-                    if (s == null) return null;
-                    let u = "",
-                        p;
+                parseStringGroup(t, u) {
+                    let a = this.gullet.scanArgument(u);
+                    if (a == null) return null;
+                    let c = "",
+                        m;
                     for (;
-                        (p = this.fetch()).text !== "EOF";) u += p.text, this.consume();
-                    return this.consume(), s.text = u, s
+                        (m = this.fetch()).text !== "EOF";) c += m.text, this.consume();
+                    return this.consume(), a.text = c, a
                 }
-                parseRegexGroup(t, o) {
-                    let s = this.fetch(),
-                        u = s,
-                        p = "",
-                        b;
+                parseRegexGroup(t, u) {
+                    let a = this.fetch(),
+                        c = a,
+                        m = "",
+                        g;
                     for (;
-                        (b = this.fetch()).text !== "EOF" && t.test(p + b.text);) u = b, p += u.text, this.consume();
-                    if (p === "") throw new a("Invalid " + o + ": '" + s.text + "'", s);
-                    return s.range(u, p)
+                        (g = this.fetch()).text !== "EOF" && t.test(m + g.text);) c = g, m += c.text, this.consume();
+                    if (m === "") throw new o("Invalid " + u + ": '" + a.text + "'", a);
+                    return a.range(c, m)
                 }
                 parseColorGroup(t) {
-                    let o = this.parseStringGroup("color", t);
-                    if (o == null) return null;
-                    let s = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(o.text);
-                    if (!s) throw new a("Invalid color: '" + o.text + "'", o);
-                    let u = s[0];
-                    return /^[0-9a-f]{6}$/i.test(u) && (u = "#" + u), {
+                    let u = this.parseStringGroup("color", t);
+                    if (u == null) return null;
+                    let a = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(u.text);
+                    if (!a) throw new o("Invalid color: '" + u.text + "'", u);
+                    let c = a[0];
+                    return /^[0-9a-f]{6}$/i.test(c) && (c = "#" + c), {
                         type: "color-token",
                         mode: this.mode,
-                        color: u
+                        color: c
                     }
                 }
                 parseSizeGroup(t) {
-                    let o, s = !1;
-                    if (this.gullet.consumeSpaces(), !t && this.gullet.future().text !== "{" ? o = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : o = this.parseStringGroup("size", t), !o) return null;
-                    !t && o.text.length === 0 && (o.text = "0pt", s = !0);
-                    let u = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(o.text);
-                    if (!u) throw new a("Invalid size: '" + o.text + "'", o);
-                    let p = {
-                        number: +(u[1] + u[2]),
-                        unit: u[3]
+                    let u, a = !1;
+                    if (this.gullet.consumeSpaces(), !t && this.gullet.future().text !== "{" ? u = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : u = this.parseStringGroup("size", t), !u) return null;
+                    !t && u.text.length === 0 && (u.text = "0pt", a = !0);
+                    let c = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(u.text);
+                    if (!c) throw new o("Invalid size: '" + u.text + "'", u);
+                    let m = {
+                        number: +(c[1] + c[2]),
+                        unit: c[3]
                     };
-                    if (!Ni(p)) throw new a("Invalid unit: '" + p.unit + "'", o);
+                    if (!qi(m)) throw new o("Invalid unit: '" + m.unit + "'", u);
                     return {
                         type: "size",
                         mode: this.mode,
-                        value: p,
-                        isBlank: s
+                        value: m,
+                        isBlank: a
                     }
                 }
                 parseUrlGroup(t) {
                     this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
-                    let o = this.parseStringGroup("url", t);
-                    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), o == null) return null;
-                    let s = o.text.replace(/\\([#$%&~_^{}])/g, "$1");
+                    let u = this.parseStringGroup("url", t);
+                    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), u == null) return null;
+                    let a = u.text.replace(/\\([#$%&~_^{}])/g, "$1");
                     return {
                         type: "url",
                         mode: this.mode,
-                        url: s
+                        url: a
                     }
                 }
-                parseArgumentGroup(t, o) {
-                    let s = this.gullet.scanArgument(t);
-                    if (s == null) return null;
-                    let u = this.mode;
-                    o && this.switchMode(o), this.gullet.beginGroup();
-                    let p = this.parseExpression(!1, "EOF");
+                parseArgumentGroup(t, u) {
+                    let a = this.gullet.scanArgument(t);
+                    if (a == null) return null;
+                    let c = this.mode;
+                    u && this.switchMode(u), this.gullet.beginGroup();
+                    let m = this.parseExpression(!1, "EOF");
                     this.expect("EOF"), this.gullet.endGroup();
-                    let b = {
+                    let g = {
                         type: "ordgroup",
                         mode: this.mode,
-                        loc: s.loc,
-                        body: p
+                        loc: a.loc,
+                        body: m
                     };
-                    return o && this.switchMode(u), b
+                    return u && this.switchMode(c), g
                 }
-                parseGroup(t, o) {
-                    let s = this.fetch(),
-                        u = s.text,
-                        p;
-                    if (u === "{" || u === "\\begingroup") {
+                parseGroup(t, u) {
+                    let a = this.fetch(),
+                        c = a.text,
+                        m;
+                    if (c === "{" || c === "\\begingroup") {
                         this.consume();
-                        let b = u === "{" ? "}" : "\\endgroup";
+                        let g = c === "{" ? "}" : "\\endgroup";
                         this.gullet.beginGroup();
-                        let v = this.parseExpression(!1, b),
-                            S = this.fetch();
-                        this.expect(b), this.gullet.endGroup(), p = {
+                        let v = this.parseExpression(!1, g),
+                            _ = this.fetch();
+                        this.expect(g), this.gullet.endGroup(), m = {
                             type: "ordgroup",
                             mode: this.mode,
-                            loc: st.range(s, S),
+                            loc: st.range(a, _),
                             body: v,
-                            semisimple: u === "\\begingroup" || void 0
+                            semisimple: c === "\\begingroup" || void 0
                         }
-                    } else if (p = this.parseFunction(o, t) || this.parseSymbol(), p == null && u[0] === "\\" && !Jo.hasOwnProperty(u)) {
-                        if (this.settings.throwOnError) throw new a("Undefined control sequence: " + u, s);
-                        p = this.formatUnsupportedCmd(u), this.consume()
+                    } else if (m = this.parseFunction(u, t) || this.parseSymbol(), m == null && c[0] === "\\" && !Wo.hasOwnProperty(c)) {
+                        if (this.settings.throwOnError) throw new o("Undefined control sequence: " + c, a);
+                        m = this.formatUnsupportedCmd(c), this.consume()
                     }
-                    return p
+                    return m
                 }
                 formLigatures(t) {
-                    let o = t.length - 1;
-                    for (let s = 0; s < o; ++s) {
-                        let u = t[s],
-                            p = u.text;
-                        p === "-" && t[s + 1].text === "-" && (s + 1 < o && t[s + 2].text === "-" ? (t.splice(s, 3, {
+                    let u = t.length - 1;
+                    for (let a = 0; a < u; ++a) {
+                        let c = t[a],
+                            m = c.text;
+                        m === "-" && t[a + 1].text === "-" && (a + 1 < u && t[a + 2].text === "-" ? (t.splice(a, 3, {
                             type: "textord",
                             mode: "text",
-                            loc: st.range(u, t[s + 2]),
+                            loc: st.range(c, t[a + 2]),
                             text: "---"
-                        }), o -= 2) : (t.splice(s, 2, {
+                        }), u -= 2) : (t.splice(a, 2, {
                             type: "textord",
                             mode: "text",
-                            loc: st.range(u, t[s + 1]),
+                            loc: st.range(c, t[a + 1]),
                             text: "--"
-                        }), o -= 1)), (p === "'" || p === "`") && t[s + 1].text === p && (t.splice(s, 2, {
+                        }), u -= 1)), (m === "'" || m === "`") && t[a + 1].text === m && (t.splice(a, 2, {
                             type: "textord",
                             mode: "text",
-                            loc: st.range(u, t[s + 1]),
-                            text: p + p
-                        }), o -= 1)
+                            loc: st.range(c, t[a + 1]),
+                            text: m + m
+                        }), u -= 1)
                     }
                 }
                 parseSymbol() {
                     let t = this.fetch(),
-                        o = t.text;
-                    if (/^\\verb[^a-zA-Z]/.test(o)) {
+                        u = t.text;
+                    if (/^\\verb[^a-zA-Z]/.test(u)) {
                         this.consume();
-                        let p = o.slice(5),
-                            b = p.charAt(0) === "*";
-                        if (b && (p = p.slice(1)), p.length < 2 || p.charAt(0) !== p.slice(-1)) throw new a(`\\verb assertion failed --
+                        let m = u.slice(5),
+                            g = m.charAt(0) === "*";
+                        if (g && (m = m.slice(1)), m.length < 2 || m.charAt(0) !== m.slice(-1)) throw new o(`\\verb assertion failed --
                     please report what input caused this bug`);
-                        return p = p.slice(1, -1), {
+                        return m = m.slice(1, -1), {
                             type: "verb",
                             mode: "text",
-                            body: p,
-                            star: b
+                            body: m,
+                            star: g
                         }
                     }
-                    ea.hasOwnProperty(o[0]) && !Oe[this.mode][o[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + o[0] + '" used in math mode', t), o = ea[o[0]] + o.slice(1));
-                    let s = W1.exec(o);
-                    s && (o = o.substring(0, s.index), o === "i" ? o = "\u0131" : o === "j" && (o = "\u0237"));
-                    let u;
-                    if (Oe[this.mode][o]) {
-                        this.settings.strict && this.mode === "math" && Q0.indexOf(o) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + o[0] + '" used in math mode', t);
-                        let p = Oe[this.mode][o].group,
-                            b = st.range(t),
+                    Zo.hasOwnProperty(u[0]) && !Pe[this.mode][u[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + u[0] + '" used in math mode', t), u = Zo[u[0]] + u.slice(1));
+                    let a = Ic.exec(u);
+                    a && (u = u.substring(0, a.index), u === "i" ? u = "\u0131" : u === "j" && (u = "\u0237"));
+                    let c;
+                    if (Pe[this.mode][u]) {
+                        this.settings.strict && this.mode === "math" && pn.indexOf(u) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + u[0] + '" used in math mode', t);
+                        let m = Pe[this.mode][u].group,
+                            g = st.range(t),
                             v;
-                        if (Wu.hasOwnProperty(p)) {
-                            let S = p;
+                        if (Il.hasOwnProperty(m)) {
+                            let _ = m;
                             v = {
                                 type: "atom",
                                 mode: this.mode,
-                                family: S,
-                                loc: b,
-                                text: o
+                                family: _,
+                                loc: g,
+                                text: u
                             }
                         } else v = {
-                            type: p,
+                            type: m,
                             mode: this.mode,
-                            loc: b,
-                            text: o
+                            loc: g,
+                            text: u
                         };
-                        u = v
-                    } else if (o.charCodeAt(0) >= 128) this.settings.strict && (qt(o.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + o[0] + '" used in math mode', t) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + o[0] + '"' + (" (" + o.charCodeAt(0) + ")"), t)), u = {
+                        c = v
+                    } else if (u.charCodeAt(0) >= 128) this.settings.strict && (Mt(u.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + u[0] + '" used in math mode', t) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + u[0] + '"' + (" (" + u.charCodeAt(0) + ")"), t)), c = {
                         type: "textord",
                         mode: "text",
                         loc: st.range(t),
-                        text: o
+                        text: u
                     };
                     else return null;
-                    if (this.consume(), s)
-                        for (let p = 0; p < s[0].length; p++) {
-                            let b = s[0][p];
-                            if (!An[b]) throw new a("Unknown accent ' " + b + "'", t);
-                            let v = An[b][this.mode] || An[b].text;
-                            if (!v) throw new a("Accent " + b + " unsupported in " + this.mode + " mode", t);
-                            u = {
+                    if (this.consume(), a)
+                        for (let m = 0; m < a[0].length; m++) {
+                            let g = a[0][m];
+                            if (!Un[g]) throw new o("Unknown accent ' " + g + "'", t);
+                            let v = Un[g][this.mode] || Un[g].text;
+                            if (!v) throw new o("Accent " + g + " unsupported in " + this.mode + " mode", t);
+                            c = {
                                 type: "accent",
                                 mode: this.mode,
                                 loc: st.range(t),
                                 label: v,
                                 isStretchy: !1,
                                 isShifty: !0,
-                                base: u
+                                base: c
                             }
                         }
-                    return u
+                    return c
                 }
             }
-            a0.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
-            var qn = function(n, t) {
+            yr.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
+            var jn = function(n, t) {
                 if (!(typeof n == "string" || n instanceof String)) throw new TypeError("KaTeX can only parse string typed expression");
-                let o = new a0(n, t);
-                delete o.gullet.macros.current["\\df@tag"];
-                let s = o.parse();
-                if (delete o.gullet.macros.current["\\current@color"], delete o.gullet.macros.current["\\color"], o.gullet.macros.get("\\df@tag")) {
-                    if (!t.displayMode) throw new a("\\tag works only in display equations");
-                    s = [{
+                let u = new yr(n, t);
+                delete u.gullet.macros.current["\\df@tag"];
+                let a = u.parse();
+                if (delete u.gullet.macros.current["\\current@color"], delete u.gullet.macros.current["\\color"], u.gullet.macros.get("\\df@tag")) {
+                    if (!t.displayMode) throw new o("\\tag works only in display equations");
+                    a = [{
                         type: "tag",
                         mode: "text",
-                        body: s,
-                        tag: o.subparse([new mt("\\df@tag")])
+                        body: a,
+                        tag: u.subparse([new mt("\\df@tag")])
                     }]
                 }
-                return s
+                return a
             };
-            let ta = function(n, t, o) {
+            let Xo = function(n, t, u) {
                 t.textContent = "";
-                let s = Mn(n, o).toNode();
-                t.appendChild(s)
+                let a = Wn(n, u).toNode();
+                t.appendChild(a)
             };
-            typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), ta = function() {
-                throw new a("KaTeX doesn't work in quirks mode.")
+            typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), Xo = function() {
+                throw new o("KaTeX doesn't work in quirks mode.")
             });
-            let J1 = function(n, t) {
-                    return Mn(n, t).toMarkup()
+            let Vc = function(n, t) {
+                    return Wn(n, t).toMarkup()
                 },
-                K1 = function(n, t) {
-                    let o = new I(t);
-                    return qn(n, o)
-                },
-                ra = function(n, t, o) {
-                    if (o.throwOnError || !(n instanceof a)) throw n;
-                    let s = B.makeSpan(["katex-error"], [new ut(t)]);
-                    return s.setAttribute("title", n.toString()), s.setAttribute("style", "color:" + o.errorColor), s
+                Uc = function(n, t) {
+                    let u = new $(t);
+                    return jn(n, u)
+                },
+                Qo = function(n, t, u) {
+                    if (u.throwOnError || !(n instanceof o)) throw n;
+                    let a = B.makeSpan(["katex-error"], [new dt(t)]);
+                    return a.setAttribute("title", n.toString()), a.setAttribute("style", "color:" + u.errorColor), a
                 },
-                Mn = function(n, t) {
-                    let o = new I(t);
+                Wn = function(n, t) {
+                    let u = new $(t);
                     try {
-                        let s = qn(n, o);
-                        return p1(s, n, o)
-                    } catch (s) {
-                        return ra(s, n, o)
+                        let a = jn(n, u);
+                        return oc(a, n, u)
+                    } catch (a) {
+                        return Qo(a, n, u)
                     }
                 };
-            var eh = {
+            var jc = {
                     version: "0.16.10",
-                    render: ta,
-                    renderToString: J1,
-                    ParseError: a,
-                    SETTINGS_SCHEMA: O,
-                    __parse: K1,
-                    __renderToDomTree: Mn,
+                    render: Xo,
+                    renderToString: Vc,
+                    ParseError: o,
+                    SETTINGS_SCHEMA: G,
+                    __parse: Uc,
+                    __renderToDomTree: Wn,
                     __renderToHTMLTree: function(n, t) {
-                        let o = new I(t);
+                        let u = new $(t);
                         try {
-                            let s = qn(n, o);
-                            return f1(s, n, o)
-                        } catch (s) {
-                            return ra(s, n, o)
+                            let a = jn(n, u);
+                            return ac(a, n, u)
+                        } catch (a) {
+                            return Qo(a, n, u)
                         }
                     },
-                    __setFontMetrics: Iu,
-                    __defineSymbol: h,
-                    __defineFunction: Q,
-                    __defineMacro: k,
+                    __setFontMetrics: ql,
+                    __defineSymbol: d,
+                    __defineFunction: Z,
+                    __defineMacro: w,
                     __domTree: {
-                        Span: vr,
-                        Anchor: Y0,
-                        SymbolNode: ut,
-                        SvgNode: Et,
-                        PathNode: Ot,
-                        LineNode: Z0
+                        Span: F0,
+                        Anchor: fn,
+                        SymbolNode: dt,
+                        SvgNode: Ft,
+                        PathNode: Ut,
+                        LineNode: mn
                     }
                 },
-                th = eh;
-            return e = e.default, e
+                Wc = jc;
+            return r = r.default, r
         }()
     })
 });
-var qu = W(Hr => {
+var wl = rt(er => {
     "use strict";
-    var Ip = Hr && Hr.__importDefault || function(r) {
-        return r && r.__esModule ? r : {
-            default: r
+    var d2 = er && er.__importDefault || function(e) {
+        return e && e.__esModule ? e : {
+            default: e
         }
     };
-    Object.defineProperty(Hr, "__esModule", {
+    Object.defineProperty(er, "__esModule", {
         value: !0
     });
-    var ku = Ip(wu());
+    var pl = d2(ml());
 
-    function _u(r, e) {
-        let i = r.src[e - 1],
-            a = r.src[e],
-            l = r.src[e + 1];
-        if (a !== "$") return {
+    function bl(e, r) {
+        let i = e.src[r - 1],
+            o = e.src[r],
+            s = e.src[r + 1];
+        if (o !== "$") return {
             can_open: !1,
             can_close: !1
         };
-        let c = !1,
-            d = !1;
-        return i !== "$" && i !== "\\" && (i === void 0 || Su(i) || !Cu(i)) && (c = !0), l !== "$" && (l == null || Su(l) || !Cu(l)) && (d = !0), {
-            can_open: c,
-            can_close: d
+        let l = !1,
+            h = !1;
+        return i !== "$" && i !== "\\" && (i === void 0 || gl(i) || !xl(i)) && (l = !0), s !== "$" && (s == null || gl(s) || !xl(s)) && (h = !0), {
+            can_open: l,
+            can_close: h
         }
     }
 
-    function Su(r) {
-        return /^\s$/u.test(r)
+    function gl(e) {
+        return /^\s$/u.test(e)
     }
 
-    function Cu(r) {
-        return /^[\w\d]$/u.test(r)
+    function xl(e) {
+        return /^[\w\d]$/u.test(e)
     }
 
-    function Tu(r, e) {
-        let i = r.src[e - 1],
-            a = r.src[e],
-            l = r.src[e + 1],
-            c = r.src[e + 2];
-        return a === "$" && i !== "$" && i !== "\\" && l === "$" && c !== "$" ? {
+    function yl(e, r) {
+        let i = e.src[r - 1],
+            o = e.src[r],
+            s = e.src[r + 1],
+            l = e.src[r + 2];
+        return o === "$" && i !== "$" && i !== "\\" && s === "$" && l !== "$" ? {
             can_open: !0,
             can_close: !0
         } : {
             can_open: !1,
             can_close: !1
         }
     }
 
-    function Op(r, e) {
-        if (r.src[r.pos] !== "$") return !1;
-        let i = r.tokens.at(-1);
+    function h2(e, r) {
+        if (e.src[e.pos] !== "$") return !1;
+        let i = e.tokens.at(-1);
         if (i?.type === "html_inline" && /^<\w+.+[^/]>$/.test(i.content)) return !1;
-        let a = _u(r, r.pos);
-        if (!a.can_open) return e || (r.pending += "$"), r.pos += 1, !0;
-        let l = r.pos + 1,
-            c = l,
-            d;
+        let o = bl(e, e.pos);
+        if (!o.can_open) return r || (e.pending += "$"), e.pos += 1, !0;
+        let s = e.pos + 1,
+            l = s,
+            h;
         for (;
-            (c = r.src.indexOf("$", c)) !== -1;) {
-            for (d = c - 1; r.src[d] === "\\";) d -= 1;
-            if ((c - d) % 2 == 1) break;
-            c += 1
-        }
-        if (c === -1) return e || (r.pending += "$"), r.pos = l, !0;
-        if (c - l === 0) return e || (r.pending += "$$"), r.pos = l + 1, !0;
-        if (a = _u(r, c), !a.can_close) return e || (r.pending += "$"), r.pos = l, !0;
-        if (!e) {
-            let f = r.push("math_inline", "math", 0);
-            f.markup = "$", f.content = r.src.slice(l, c)
-        }
-        return r.pos = c + 1, !0
-    }
-
-    function Hp(r, e, i, a) {
-        var l, c, d, f = !1,
-            g, y = r.bMarks[e] + r.tShift[e],
-            _ = r.eMarks[e];
-        if (y + 2 > _ || r.src.slice(y, y + 2) !== "$$") return !1;
-        y += 2;
-        let w = r.src.slice(y, _);
-        if (a) return !0;
-        for (w.trim().slice(-2) === "$$" && (w = w.trim().slice(0, -2), f = !0), c = e; !f && (c++, !(c >= i || (y = r.bMarks[c] + r.tShift[c], _ = r.eMarks[c], y < _ && r.tShift[c] < r.blkIndent)));) r.src.slice(y, _).trim().slice(-2) === "$$" ? (d = r.src.slice(0, _).lastIndexOf("$$"), l = r.src.slice(y, d), f = !0) : r.src.slice(y, _).trim().includes("$$") && (d = r.src.slice(0, _).trim().indexOf("$$"), l = r.src.slice(y, d), f = !0);
-        return r.line = c + 1, g = r.push("math_block", "math", 0), g.block = !0, g.content = (w && w.trim() ? w + `
-` : "") + r.getLines(e + 1, c, r.tShift[e], !0) + (l && l.trim() ? l : ""), g.map = [e, r.line], g.markup = "$$", !0
-    }
-
-    function $p(r, e, i, a) {
-        let l = r.bMarks[e] + r.tShift[e],
-            c = r.eMarks[e];
-        if (!r.src.slice(l, c).match(/^\s*\\begin\s*\{([^{}]+)\}/)) return !1;
-        if (e > 0) {
-            let A = r.bMarks[e - 1] + r.tShift[e - 1],
-                L = r.eMarks[e - 1],
-                R = r.src.slice(A, L);
-            if (!/^\s*$/.test(R)) return !1
-        }
-        if (a) return !0;
-        let g = [],
-            y = e,
-            _, w = !1;
-        e: for (; !w && !(y >= i); y++) {
-            let A = r.bMarks[y] + r.tShift[y],
-                L = r.eMarks[y];
-            if (A < L && r.tShift[y] < r.blkIndent) break;
-            let R = r.src.slice(A, L);
-            for (let O of R.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
-                if (O[1] === "\\begin") g.push(O[2].trim());
-                else if (O[1] === "\\end" && (g.pop(), !g.length)) {
-                _ = r.src.slice(A, L), w = !0;
+            (l = e.src.indexOf("$", l)) !== -1;) {
+            for (h = l - 1; e.src[h] === "\\";) h -= 1;
+            if ((l - h) % 2 == 1) break;
+            l += 1
+        }
+        if (l === -1) return r || (e.pending += "$"), e.pos = s, !0;
+        if (l - s === 0) return r || (e.pending += "$$"), e.pos = s + 1, !0;
+        if (o = bl(e, l), !o.can_close) return r || (e.pending += "$"), e.pos = s, !0;
+        if (!r) {
+            let p = e.push("math_inline", "math", 0);
+            p.markup = "$", p.content = e.src.slice(s, l)
+        }
+        return e.pos = l + 1, !0
+    }
+
+    function f2(e, r, i, o) {
+        var s, l, h, p = !1,
+            b, x = e.bMarks[r] + e.tShift[r],
+            C = e.eMarks[r];
+        if (x + 2 > C || e.src.slice(x, x + 2) !== "$$") return !1;
+        x += 2;
+        let k = e.src.slice(x, C);
+        if (o) return !0;
+        for (k.trim().slice(-2) === "$$" && (k = k.trim().slice(0, -2), p = !0), l = r; !p && (l++, !(l >= i || (x = e.bMarks[l] + e.tShift[l], C = e.eMarks[l], x < C && e.tShift[l] < e.blkIndent)));) e.src.slice(x, C).trim().slice(-2) === "$$" ? (h = e.src.slice(0, C).lastIndexOf("$$"), s = e.src.slice(x, h), p = !0) : e.src.slice(x, C).trim().includes("$$") && (h = e.src.slice(0, C).trim().indexOf("$$"), s = e.src.slice(x, h), p = !0);
+        return e.line = l + 1, b = e.push("math_block", "math", 0), b.block = !0, b.content = (k && k.trim() ? k + `
+` : "") + e.getLines(r + 1, l, e.tShift[r], !0) + (s && s.trim() ? s : ""), b.map = [r, e.line], b.markup = "$$", !0
+    }
+
+    function m2(e, r, i, o) {
+        let s = e.bMarks[r] + e.tShift[r],
+            l = e.eMarks[r];
+        if (!e.src.slice(s, l).match(/^\s*\\begin\s*\{([^{}]+)\}/)) return !1;
+        if (r > 0) {
+            let E = e.bMarks[r - 1] + e.tShift[r - 1],
+                M = e.eMarks[r - 1],
+                N = e.src.slice(E, M);
+            if (!/^\s*$/.test(N)) return !1
+        }
+        if (o) return !0;
+        let b = [],
+            x = r,
+            C, k = !1;
+        e: for (; !k && !(x >= i); x++) {
+            let E = e.bMarks[x] + e.tShift[x],
+                M = e.eMarks[x];
+            if (E < M && e.tShift[x] < e.blkIndent) break;
+            let N = e.src.slice(E, M);
+            for (let G of N.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
+                if (G[1] === "\\begin") b.push(G[2].trim());
+                else if (G[1] === "\\end" && (b.pop(), !b.length)) {
+                C = e.src.slice(E, M), k = !0;
                 break e
             }
         }
-        r.line = y + 1;
-        let T = r.push("math_block", "math", 0);
-        return T.block = !0, T.content = (r.getLines(e, y, r.tShift[e], !0) + (_ ?? "")).trim(), T.map = [e, r.line], T.markup = "$$", !0
-    }
-
-    function Gp(r, e) {
-        var i, a, l, c, d;
-        if (r.src.slice(r.pos, r.pos + 2) !== "$$") return !1;
-        if (c = Tu(r, r.pos), !c.can_open) return e || (r.pending += "$$"), r.pos += 2, !0;
-        for (i = r.pos + 2, a = i;
-            (a = r.src.indexOf("$$", a)) !== -1;) {
-            for (d = a - 1; r.src[d] === "\\";) d -= 1;
-            if ((a - d) % 2 == 1) break;
-            a += 2
+        e.line = x + 1;
+        let F = e.push("math_block", "math", 0);
+        return F.block = !0, F.content = (e.getLines(r, x, e.tShift[r], !0) + (C ?? "")).trim(), F.map = [r, e.line], F.markup = "$$", !0
+    }
+
+    function p2(e, r) {
+        var i, o, s, l, h;
+        if (e.src.slice(e.pos, e.pos + 2) !== "$$") return !1;
+        if (l = yl(e, e.pos), !l.can_open) return r || (e.pending += "$$"), e.pos += 2, !0;
+        for (i = e.pos + 2, o = i;
+            (o = e.src.indexOf("$$", o)) !== -1;) {
+            for (h = o - 1; e.src[h] === "\\";) h -= 1;
+            if ((o - h) % 2 == 1) break;
+            o += 2
         }
-        return a === -1 ? (e || (r.pending += "$$"), r.pos = i, !0) : a - i === 0 ? (e || (r.pending += "$$$$"), r.pos = i + 2, !0) : (c = Tu(r, a), c.can_close ? (e || (l = r.push("math_block", "math", 0), l.block = !0, l.markup = "$$", l.content = r.src.slice(i, a)), r.pos = a + 2, !0) : (e || (r.pending += "$$"), r.pos = i, !0))
+        return o === -1 ? (r || (e.pending += "$$"), e.pos = i, !0) : o - i === 0 ? (r || (e.pending += "$$$$"), e.pos = i + 2, !0) : (l = yl(e, o), l.can_close ? (r || (s = e.push("math_block", "math", 0), s.block = !0, s.markup = "$$", s.content = e.src.slice(i, o)), e.pos = o + 2, !0) : (r || (e.pending += "$$"), e.pos = i, !0))
     }
 
-    function Vp(r, e) {
-        let i = r.src.slice(r.pos);
+    function b2(e, r) {
+        let i = e.src.slice(e.pos);
         if (!/^\n\\begin/.test(i)) return !1;
-        if (r.pos += 1, e) return !0;
-        let a = i.split(/\n/g).slice(1),
-            l, c = [];
-        e: for (var d = 0; d < a.length; ++d) {
-            let y = a[d];
-            for (let _ of y.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
-                if (_[1] === "\\begin") c.push(_[2].trim());
-                else if (_[1] === "\\end" && (c.pop(), !c.length)) {
-                l = d;
+        if (e.pos += 1, r) return !0;
+        let o = i.split(/\n/g).slice(1),
+            s, l = [];
+        e: for (var h = 0; h < o.length; ++h) {
+            let x = o[h];
+            for (let C of x.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
+                if (C[1] === "\\begin") l.push(C[2].trim());
+                else if (C[1] === "\\end" && (l.pop(), !l.length)) {
+                s = h;
                 break e
             }
         }
-        if (typeof l > "u") return !1;
-        let f = a.slice(0, l + 1).reduce((y, _) => y + _.length, 0) + l + 1,
-            g = r.push("math_inline_bare_block", "math", 0);
-        return g.block = !0, g.markup = "$$", g.content = i.slice(1, f), r.pos = r.pos + f, !0
-    }
-
-    function Au(r, e, i, a) {
-        let l = r.tokens;
-        for (let c = l.length - 1; c >= 0; c--) {
-            let d = l[c],
-                f = [];
-            if (d.type !== "html_block") continue;
-            let g = d.content;
-            for (let y of g.matchAll(a)) {
-                if (!y.groups) continue;
-                let _ = y.groups.html_before_math,
-                    w = y.groups.math,
-                    T = y.groups.html_after_math;
-                _ && f.push({
-                    ...d,
+        if (typeof s > "u") return !1;
+        let p = o.slice(0, s + 1).reduce((x, C) => x + C.length, 0) + s + 1,
+            b = e.push("math_inline_bare_block", "math", 0);
+        return b.block = !0, b.markup = "$$", b.content = i.slice(1, p), e.pos = e.pos + p, !0
+    }
+
+    function vl(e, r, i, o) {
+        let s = e.tokens;
+        for (let l = s.length - 1; l >= 0; l--) {
+            let h = s[l],
+                p = [];
+            if (h.type !== "html_block") continue;
+            let b = h.content;
+            for (let x of b.matchAll(o)) {
+                if (!x.groups) continue;
+                let C = x.groups.html_before_math,
+                    k = x.groups.math,
+                    F = x.groups.html_after_math;
+                C && p.push({
+                    ...h,
                     type: "html_block",
                     map: null,
-                    content: _
-                }), w && f.push({
-                    ...d,
-                    type: e,
+                    content: C
+                }), k && p.push({
+                    ...h,
+                    type: r,
                     map: null,
-                    content: w,
+                    content: k,
                     markup: i,
                     block: !0,
                     tag: "math"
-                }), T && f.push({
-                    ...d,
+                }), F && p.push({
+                    ...h,
                     type: "html_block",
                     map: null,
-                    content: T
+                    content: F
                 })
             }
-            f.length > 0 && l.splice(c, 1, ...f)
+            p.length > 0 && s.splice(l, 1, ...p)
         }
         return !0
     }
 
-    function H0(r) {
-        return r.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;")
+    function on(e) {
+        return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;")
     }
 
-    function jp(r, e) {
-        let i = e?.enableBareBlocks,
-            a = e?.enableMathBlockInHtml,
-            l = e?.enableMathInlineInHtml,
-            c = w => {
-                let T = /\\begin\{(align|equation|gather|cd|alignat)\}/ig.test(w);
+    function g2(e, r) {
+        let i = r?.enableBareBlocks,
+            o = r?.enableMathBlockInHtml,
+            s = r?.enableMathInlineInHtml,
+            l = k => {
+                let F = /\\begin\{(align|equation|gather|cd|alignat)\}/ig.test(k);
                 try {
-                    return ku.default.renderToString(w, {
-                        ...e,
-                        displayMode: T
+                    return pl.default.renderToString(k, {
+                        ...r,
+                        displayMode: F
                     })
-                } catch (A) {
-                    return e?.throwOnError && console.log(A), `<span class="katex-error" title="${H0(w)}">${H0(A+"")}</span>`
+                } catch (E) {
+                    return r?.throwOnError && console.log(E), `<span class="katex-error" title="${on(k)}">${on(E+"")}</span>`
                 }
             },
-            d = (w, T) => c(w[T].content),
-            f = w => {
+            h = (k, F) => l(k[F].content),
+            p = k => {
                 try {
-                    return `<p class="katex-block">${ku.default.renderToString(w,{...e,displayMode:!0})}</p>`
-                } catch (T) {
-                    return e?.throwOnError && console.log(T), `<p class="katex-block katex-error" title="${H0(w)}">${H0(T+"")}</p>`
+                    return `<p class="katex-block">${pl.default.renderToString(k,{...r,displayMode:!0})}</p>`
+                } catch (F) {
+                    return r?.throwOnError && console.log(F), `<p class="katex-block katex-error" title="${on(k)}">${on(F+"")}</p>`
                 }
             },
-            g = (w, T) => f(w[T].content) + `
+            b = (k, F) => p(k[F].content) + `
 `;
-        r.inline.ruler.after("escape", "math_inline", Op), r.inline.ruler.after("escape", "math_inline_block", Gp), i && r.inline.ruler.before("text", "math_inline_bare_block", Vp), r.block.ruler.after("blockquote", "math_block", (w, T, A, L) => i && $p(w, T, A, L) ? !0 : Hp(w, T, A, L), {
+        e.inline.ruler.after("escape", "math_inline", h2), e.inline.ruler.after("escape", "math_inline_block", p2), i && e.inline.ruler.before("text", "math_inline_bare_block", b2), e.block.ruler.after("blockquote", "math_block", (k, F, E, M) => i && m2(k, F, E, M) ? !0 : f2(k, F, E, M), {
             alt: ["paragraph", "reference", "blockquote", "list"]
         });
-        let y = /(?<html_before_math>[\s\S]*?)\$\$(?<math>[\s\S]+?)\$\$(?<html_after_math>(?:(?!\$\$[\s\S]+?\$\$)[\s\S])*)/gm,
-            _ = /(?<html_before_math>[\s\S]*?)\$(?<math>.*?)\$(?<html_after_math>(?:(?!\$.*?\$)[\s\S])*)/gm;
-        a && r.core.ruler.push("math_block_in_html_block", w => Au(w, "math_block", "$$", y)), l && r.core.ruler.push("math_inline_in_html_block", w => Au(w, "math_inline", "$", _)), r.renderer.rules.math_inline = d, r.renderer.rules.math_inline_block = g, r.renderer.rules.math_inline_bare_block = g, r.renderer.rules.math_block = g
-    }
-    Hr.default = jp
-});
-var d0, Me, ha, uh, er, aa, da, Dn, hh, Tr = {},
-    ma = [],
-    dh = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
-    Rn = Array.isArray;
+        let x = /(?<html_before_math>[\s\S]*?)\$\$(?<math>[\s\S]+?)\$\$(?<html_after_math>(?:(?!\$\$[\s\S]+?\$\$)[\s\S])*)/gm,
+            C = /(?<html_before_math>[\s\S]*?)\$(?<math>.*?)\$(?<html_after_math>(?:(?!\$.*?\$)[\s\S])*)/gm;
+        o && e.core.ruler.push("math_block_in_html_block", k => vl(k, "math_block", "$$", x)), s && e.core.ruler.push("math_inline_in_html_block", k => vl(k, "math_inline", "$", C)), e.renderer.rules.math_inline = h, e.renderer.rules.math_inline_block = b, e.renderer.rules.math_inline_bare_block = b, e.renderer.rules.math_block = b
+    }
+    er.default = g2
+});
+var Ar, Se, oa, r1, a0, ta, aa, Zn, n1, P0 = {},
+    sa = [],
+    u1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
+    Qn = Array.isArray;
 
-function Vt(r, e) {
-    for (var i in e) r[i] = e[i];
-    return r
+function Zt(e, r) {
+    for (var i in r) e[i] = r[i];
+    return e
+}
+
+function la(e) {
+    var r = e.parentNode;
+    r && r.removeChild(e)
+}
+
+function Jn(e, r, i) {
+    var o, s, l, h = {};
+    for (l in r) l == "key" ? o = r[l] : l == "ref" ? s = r[l] : h[l] = r[l];
+    if (arguments.length > 2 && (h.children = arguments.length > 3 ? Ar.call(arguments, 2) : i), typeof e == "function" && e.defaultProps != null)
+        for (l in e.defaultProps) h[l] === void 0 && (h[l] = e.defaultProps[l]);
+    return _r(e, h, o, s, null)
 }
 
-function pa(r) {
-    var e = r.parentNode;
-    e && e.removeChild(r)
-}
-
-function Fn(r, e, i) {
-    var a, l, c, d = {};
-    for (c in e) c == "key" ? a = e[c] : c == "ref" ? l = e[c] : d[c] = e[c];
-    if (arguments.length > 2 && (d.children = arguments.length > 3 ? d0.call(arguments, 2) : i), typeof r == "function" && r.defaultProps != null)
-        for (c in r.defaultProps) d[c] === void 0 && (d[c] = r.defaultProps[c]);
-    return c0(r, d, a, l, null)
-}
-
-function c0(r, e, i, a, l) {
-    var c = {
-        type: r,
-        props: e,
+function _r(e, r, i, o, s) {
+    var l = {
+        type: e,
+        props: r,
         key: i,
-        ref: a,
+        ref: o,
         __k: null,
         __: null,
         __b: 0,
         __e: null,
         __d: void 0,
         __c: null,
         constructor: void 0,
-        __v: l ?? ++ha,
+        __v: s ?? ++oa,
         __i: -1,
         __u: 0
     };
-    return l == null && Me.vnode != null && Me.vnode(c), c
+    return s == null && Se.vnode != null && Se.vnode(l), l
 }
 
-function Ge(r) {
-    return r.children
+function He(e) {
+    return e.children
 }
 
-function u0(r, e) {
-    this.props = r, this.context = e
+function Cr(e, r) {
+    this.props = e, this.context = r
 }
 
-function tr(r, e) {
-    if (e == null) return r.__ ? tr(r.__, r.__i + 1) : null;
-    for (var i; e < r.__k.length; e++)
-        if ((i = r.__k[e]) != null && i.__e != null) return i.__e;
-    return typeof r.type == "function" ? tr(r) : null
+function s0(e, r) {
+    if (r == null) return e.__ ? s0(e.__, e.__i + 1) : null;
+    for (var i; r < e.__k.length; r++)
+        if ((i = e.__k[r]) != null && i.__e != null) return i.__e;
+    return typeof e.type == "function" ? s0(e) : null
 }
 
-function fa(r) {
-    var e, i;
-    if ((r = r.__) != null && r.__c != null) {
-        for (r.__e = r.__c.base = null, e = 0; e < r.__k.length; e++)
-            if ((i = r.__k[e]) != null && i.__e != null) {
-                r.__e = r.__c.base = i.__e;
+function ca(e) {
+    var r, i;
+    if ((e = e.__) != null && e.__c != null) {
+        for (e.__e = e.__c.base = null, r = 0; r < e.__k.length; r++)
+            if ((i = e.__k[r]) != null && i.__e != null) {
+                e.__e = e.__c.base = i.__e;
                 break
-            } return fa(r)
+            } return ca(e)
     }
 }
 
-function sa(r) {
-    (!r.__d && (r.__d = !0) && er.push(r) && !h0.__r++ || aa !== Me.debounceRendering) && ((aa = Me.debounceRendering) || da)(h0)
+function ra(e) {
+    (!e.__d && (e.__d = !0) && a0.push(e) && !Sr.__r++ || ta !== Se.debounceRendering) && ((ta = Se.debounceRendering) || aa)(Sr)
 }
 
-function h0() {
-    var r, e, i, a, l, c, d, f, g;
-    for (er.sort(Dn); r = er.shift();) r.__d && (e = er.length, a = void 0, c = (l = (i = r).__v).__e, f = [], g = [], (d = i.__P) && ((a = Vt({}, l)).__v = l.__v + 1, Me.vnode && Me.vnode(a), Bn(d, a, l, i.__n, d.ownerSVGElement !== void 0, 32 & l.__u ? [c] : null, f, c ?? tr(l), !!(32 & l.__u), g), a.__v = l.__v, a.__.__k[a.__i] = a, ya(f, a, g), a.__e != c && fa(a)), er.length > e && er.sort(Dn));
-    h0.__r = 0
+function Sr() {
+    var e, r, i, o, s, l, h, p, b;
+    for (a0.sort(Zn); e = a0.shift();) e.__d && (r = a0.length, o = void 0, l = (s = (i = e).__v).__e, p = [], b = [], (h = i.__P) && ((o = Zt({}, s)).__v = s.__v + 1, Se.vnode && Se.vnode(o), Kn(h, o, s, i.__n, h.ownerSVGElement !== void 0, 32 & s.__u ? [l] : null, p, l ?? s0(s), !!(32 & s.__u), b), o.__v = s.__v, o.__.__k[o.__i] = o, fa(p, o, b), o.__e != l && ca(o)), a0.length > r && a0.sort(Zn));
+    Sr.__r = 0
 }
 
-function ga(r, e, i, a, l, c, d, f, g, y, _) {
-    var w, T, A, L, R, O = a && a.__k || ma,
-        P = e.length;
-    for (i.__d = g, mh(i, e, O), g = i.__d, w = 0; w < P; w++)(A = i.__k[w]) != null && typeof A != "boolean" && typeof A != "function" && (T = A.__i === -1 ? Tr : O[A.__i] || Tr, A.__i = w, Bn(r, A, T, l, c, d, f, g, y, _), L = A.__e, A.ref && T.ref != A.ref && (T.ref && Nn(T.ref, null, A), _.push(A.ref, A.__c || L, A)), R == null && L != null && (R = L), 65536 & A.__u || T.__k === A.__k ? (L || T.__e != g || (g = tr(T)), g = ba(A, g, r)) : typeof A.type == "function" && A.__d !== void 0 ? g = A.__d : L && (g = L.nextSibling), A.__d = void 0, A.__u &= -196609);
-    i.__d = g, i.__e = R
+function da(e, r, i, o, s, l, h, p, b, x, C) {
+    var k, F, E, M, N, G = o && o.__k || sa,
+        U = r.length;
+    for (i.__d = b, i1(i, r, G), b = i.__d, k = 0; k < U; k++)(E = i.__k[k]) != null && typeof E != "boolean" && typeof E != "function" && (F = E.__i === -1 ? P0 : G[E.__i] || P0, E.__i = k, Kn(e, E, F, s, l, h, p, b, x, C), M = E.__e, E.ref && F.ref != E.ref && (F.ref && eu(F.ref, null, E), C.push(E.ref, E.__c || M, E)), N == null && M != null && (N = M), 65536 & E.__u || F.__k === E.__k ? (M || F.__e != b || (b = s0(F)), b = ha(E, b, e)) : typeof E.type == "function" && E.__d !== void 0 ? b = E.__d : M && (b = M.nextSibling), E.__d = void 0, E.__u &= -196609);
+    i.__d = b, i.__e = N
 }
 
-function mh(r, e, i) {
-    var a, l, c, d, f, g = e.length,
-        y = i.length,
-        _ = y,
-        w = 0;
-    for (r.__k = [], a = 0; a < g; a++) d = a + w, (l = r.__k[a] = (l = e[a]) == null || typeof l == "boolean" || typeof l == "function" ? null : typeof l == "string" || typeof l == "number" || typeof l == "bigint" || l.constructor == String ? c0(null, l, null, null, null) : Rn(l) ? c0(Ge, {
-        children: l
-    }, null, null, null) : l.constructor === void 0 && l.__b > 0 ? c0(l.type, l.props, l.key, l.ref ? l.ref : null, l.__v) : l) != null ? (l.__ = r, l.__b = r.__b + 1, f = ph(l, i, d, _), l.__i = f, c = null, f !== -1 && (_--, (c = i[f]) && (c.__u |= 131072)), c == null || c.__v === null ? (f == -1 && w--, typeof l.type != "function" && (l.__u |= 65536)) : f !== d && (f === d + 1 ? w++ : f > d ? _ > g - d ? w += f - d : w-- : f < d ? f == d - 1 && (w = f - d) : w = 0, f !== a + w && (l.__u |= 65536))) : (c = i[d]) && c.key == null && c.__e && !(131072 & c.__u) && (c.__e == r.__d && (r.__d = tr(c)), zn(c, c, !1), i[d] = null, _--);
-    if (_)
-        for (a = 0; a < y; a++)(c = i[a]) != null && !(131072 & c.__u) && (c.__e == r.__d && (r.__d = tr(c)), zn(c, c))
+function i1(e, r, i) {
+    var o, s, l, h, p, b = r.length,
+        x = i.length,
+        C = x,
+        k = 0;
+    for (e.__k = [], o = 0; o < b; o++) h = o + k, (s = e.__k[o] = (s = r[o]) == null || typeof s == "boolean" || typeof s == "function" ? null : typeof s == "string" || typeof s == "number" || typeof s == "bigint" || s.constructor == String ? _r(null, s, null, null, null) : Qn(s) ? _r(He, {
+        children: s
+    }, null, null, null) : s.constructor === void 0 && s.__b > 0 ? _r(s.type, s.props, s.key, s.ref ? s.ref : null, s.__v) : s) != null ? (s.__ = e, s.__b = e.__b + 1, p = o1(s, i, h, C), s.__i = p, l = null, p !== -1 && (C--, (l = i[p]) && (l.__u |= 131072)), l == null || l.__v === null ? (p == -1 && k--, typeof s.type != "function" && (s.__u |= 65536)) : p !== h && (p === h + 1 ? k++ : p > h ? C > b - h ? k += p - h : k-- : p < h ? p == h - 1 && (k = p - h) : k = 0, p !== o + k && (s.__u |= 65536))) : (l = i[h]) && l.key == null && l.__e && !(131072 & l.__u) && (l.__e == e.__d && (e.__d = s0(l)), Xn(l, l, !1), i[h] = null, C--);
+    if (C)
+        for (o = 0; o < x; o++)(l = i[o]) != null && !(131072 & l.__u) && (l.__e == e.__d && (e.__d = s0(l)), Xn(l, l))
 }
 
-function ba(r, e, i) {
-    var a, l;
-    if (typeof r.type == "function") {
-        for (a = r.__k, l = 0; a && l < a.length; l++) a[l] && (a[l].__ = r, e = ba(a[l], e, i));
-        return e
+function ha(e, r, i) {
+    var o, s;
+    if (typeof e.type == "function") {
+        for (o = e.__k, s = 0; o && s < o.length; s++) o[s] && (o[s].__ = e, r = ha(o[s], r, i));
+        return r
     }
-    r.__e != e && (i.insertBefore(r.__e, e || null), e = r.__e);
-    do e = e && e.nextSibling; while (e != null && e.nodeType === 8);
-    return e
+    e.__e != r && (i.insertBefore(e.__e, r || null), r = e.__e);
+    do r = r && r.nextSibling; while (r != null && r.nodeType === 8);
+    return r
 }
 
-function ph(r, e, i, a) {
-    var l = r.key,
-        c = r.type,
-        d = i - 1,
-        f = i + 1,
-        g = e[i];
-    if (g === null || g && l == g.key && c === g.type && !(131072 & g.__u)) return i;
-    if (a > (g != null && !(131072 & g.__u) ? 1 : 0))
-        for (; d >= 0 || f < e.length;) {
-            if (d >= 0) {
-                if ((g = e[d]) && !(131072 & g.__u) && l == g.key && c === g.type) return d;
-                d--
-            }
-            if (f < e.length) {
-                if ((g = e[f]) && !(131072 & g.__u) && l == g.key && c === g.type) return f;
-                f++
+function o1(e, r, i, o) {
+    var s = e.key,
+        l = e.type,
+        h = i - 1,
+        p = i + 1,
+        b = r[i];
+    if (b === null || b && s == b.key && l === b.type && !(131072 & b.__u)) return i;
+    if (o > (b != null && !(131072 & b.__u) ? 1 : 0))
+        for (; h >= 0 || p < r.length;) {
+            if (h >= 0) {
+                if ((b = r[h]) && !(131072 & b.__u) && s == b.key && l === b.type) return h;
+                h--
+            }
+            if (p < r.length) {
+                if ((b = r[p]) && !(131072 & b.__u) && s == b.key && l === b.type) return p;
+                p++
             }
         }
     return -1
 }
 
-function la(r, e, i) {
-    e[0] === "-" ? r.setProperty(e, i ?? "") : r[e] = i == null ? "" : typeof i != "number" || dh.test(e) ? i : i + "px"
+function na(e, r, i) {
+    r[0] === "-" ? e.setProperty(r, i ?? "") : e[r] = i == null ? "" : typeof i != "number" || u1.test(r) ? i : i + "px"
 }
 
-function l0(r, e, i, a, l) {
-    var c;
-    e: if (e === "style")
-        if (typeof i == "string") r.style.cssText = i;
+function kr(e, r, i, o, s) {
+    var l;
+    e: if (r === "style")
+        if (typeof i == "string") e.style.cssText = i;
         else {
-            if (typeof a == "string" && (r.style.cssText = a = ""), a)
-                for (e in a) i && e in i || la(r.style, e, "");
+            if (typeof o == "string" && (e.style.cssText = o = ""), o)
+                for (r in o) i && r in i || na(e.style, r, "");
             if (i)
-                for (e in i) a && i[e] === a[e] || la(r.style, e, i[e])
+                for (r in i) o && i[r] === o[r] || na(e.style, r, i[r])
         }
-    else if (e[0] === "o" && e[1] === "n") c = e !== (e = e.replace(/(PointerCapture)$|Capture$/i, "$1")), e = e.toLowerCase() in r || e === "onFocusOut" || e === "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), r.l || (r.l = {}), r.l[e + c] = i, i ? a ? i.u = a.u : (i.u = Date.now(), r.addEventListener(e, c ? ua : ca, c)) : r.removeEventListener(e, c ? ua : ca, c);
+    else if (r[0] === "o" && r[1] === "n") l = r !== (r = r.replace(/(PointerCapture)$|Capture$/i, "$1")), r = r.toLowerCase() in e || r === "onFocusOut" || r === "onFocusIn" ? r.toLowerCase().slice(2) : r.slice(2), e.l || (e.l = {}), e.l[r + l] = i, i ? o ? i.u = o.u : (i.u = Date.now(), e.addEventListener(r, l ? ia : ua, l)) : e.removeEventListener(r, l ? ia : ua, l);
     else {
-        if (l) e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
-        else if (e !== "width" && e !== "height" && e !== "href" && e !== "list" && e !== "form" && e !== "tabIndex" && e !== "download" && e !== "rowSpan" && e !== "colSpan" && e !== "role" && e in r) try {
-            r[e] = i ?? "";
+        if (s) r = r.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
+        else if (r !== "width" && r !== "height" && r !== "href" && r !== "list" && r !== "form" && r !== "tabIndex" && r !== "download" && r !== "rowSpan" && r !== "colSpan" && r !== "role" && r in e) try {
+            e[r] = i ?? "";
             break e
         } catch {}
-        typeof i == "function" || (i == null || i === !1 && e[4] !== "-" ? r.removeAttribute(e) : r.setAttribute(e, i))
+        typeof i == "function" || (i == null || i === !1 && r[4] !== "-" ? e.removeAttribute(r) : e.setAttribute(r, i))
     }
 }
 
-function ca(r) {
+function ua(e) {
     if (this.l) {
-        var e = this.l[r.type + !1];
-        if (r.t) {
-            if (r.t <= e.u) return
-        } else r.t = Date.now();
-        return e(Me.event ? Me.event(r) : r)
+        var r = this.l[e.type + !1];
+        if (e.t) {
+            if (e.t <= r.u) return
+        } else e.t = Date.now();
+        return r(Se.event ? Se.event(e) : e)
     }
 }
 
-function ua(r) {
-    if (this.l) return this.l[r.type + !0](Me.event ? Me.event(r) : r)
+function ia(e) {
+    if (this.l) return this.l[e.type + !0](Se.event ? Se.event(e) : e)
 }
 
-function Bn(r, e, i, a, l, c, d, f, g, y) {
-    var _, w, T, A, L, R, O, P, I, Y, re, te, j, ne, pe, ue = e.type;
-    if (e.constructor !== void 0) return null;
-    128 & i.__u && (g = !!(32 & i.__u), c = [f = e.__e = i.__e]), (_ = Me.__b) && _(e);
-    e: if (typeof ue == "function") try {
-        if (P = e.props, I = (_ = ue.contextType) && a[_.__c], Y = _ ? I ? I.props.value : _.__ : a, i.__c ? O = (w = e.__c = i.__c).__ = w.__E : ("prototype" in ue && ue.prototype.render ? e.__c = w = new ue(P, Y) : (e.__c = w = new u0(P, Y), w.constructor = ue, w.render = gh), I && I.sub(w), w.props = P, w.state || (w.state = {}), w.context = Y, w.__n = a, T = w.__d = !0, w.__h = [], w._sb = []), w.__s == null && (w.__s = w.state), ue.getDerivedStateFromProps != null && (w.__s == w.state && (w.__s = Vt({}, w.__s)), Vt(w.__s, ue.getDerivedStateFromProps(P, w.__s))), A = w.props, L = w.state, w.__v = e, T) ue.getDerivedStateFromProps == null && w.componentWillMount != null && w.componentWillMount(), w.componentDidMount != null && w.__h.push(w.componentDidMount);
+function Kn(e, r, i, o, s, l, h, p, b, x) {
+    var C, k, F, E, M, N, G, U, $, V, Y, X, te, ie, ge, ae = r.type;
+    if (r.constructor !== void 0) return null;
+    128 & i.__u && (b = !!(32 & i.__u), l = [p = r.__e = i.__e]), (C = Se.__b) && C(r);
+    e: if (typeof ae == "function") try {
+        if (U = r.props, $ = (C = ae.contextType) && o[C.__c], V = C ? $ ? $.props.value : C.__ : o, i.__c ? G = (k = r.__c = i.__c).__ = k.__E : ("prototype" in ae && ae.prototype.render ? r.__c = k = new ae(U, V) : (r.__c = k = new Cr(U, V), k.constructor = ae, k.render = s1), $ && $.sub(k), k.props = U, k.state || (k.state = {}), k.context = V, k.__n = o, F = k.__d = !0, k.__h = [], k._sb = []), k.__s == null && (k.__s = k.state), ae.getDerivedStateFromProps != null && (k.__s == k.state && (k.__s = Zt({}, k.__s)), Zt(k.__s, ae.getDerivedStateFromProps(U, k.__s))), E = k.props, M = k.state, k.__v = r, F) ae.getDerivedStateFromProps == null && k.componentWillMount != null && k.componentWillMount(), k.componentDidMount != null && k.__h.push(k.componentDidMount);
         else {
-            if (ue.getDerivedStateFromProps == null && P !== A && w.componentWillReceiveProps != null && w.componentWillReceiveProps(P, Y), !w.__e && (w.shouldComponentUpdate != null && w.shouldComponentUpdate(P, w.__s, Y) === !1 || e.__v === i.__v)) {
-                for (e.__v !== i.__v && (w.props = P, w.state = w.__s, w.__d = !1), e.__e = i.__e, e.__k = i.__k, e.__k.forEach(function(ce) {
-                        ce && (ce.__ = e)
-                    }), re = 0; re < w._sb.length; re++) w.__h.push(w._sb[re]);
-                w._sb = [], w.__h.length && d.push(w);
+            if (ae.getDerivedStateFromProps == null && U !== E && k.componentWillReceiveProps != null && k.componentWillReceiveProps(U, V), !k.__e && (k.shouldComponentUpdate != null && k.shouldComponentUpdate(U, k.__s, V) === !1 || r.__v === i.__v)) {
+                for (r.__v !== i.__v && (k.props = U, k.state = k.__s, k.__d = !1), r.__e = i.__e, r.__k = i.__k, r.__k.forEach(function(qe) {
+                        qe && (qe.__ = r)
+                    }), Y = 0; Y < k._sb.length; Y++) k.__h.push(k._sb[Y]);
+                k._sb = [], k.__h.length && h.push(k);
                 break e
             }
-            w.componentWillUpdate != null && w.componentWillUpdate(P, w.__s, Y), w.componentDidUpdate != null && w.__h.push(function() {
-                w.componentDidUpdate(A, L, R)
+            k.componentWillUpdate != null && k.componentWillUpdate(U, k.__s, V), k.componentDidUpdate != null && k.__h.push(function() {
+                k.componentDidUpdate(E, M, N)
             })
         }
-        if (w.context = Y, w.props = P, w.__P = r, w.__e = !1, te = Me.__r, j = 0, "prototype" in ue && ue.prototype.render) {
-            for (w.state = w.__s, w.__d = !1, te && te(e), _ = w.render(w.props, w.state, w.context), ne = 0; ne < w._sb.length; ne++) w.__h.push(w._sb[ne]);
-            w._sb = []
+        if (k.context = V, k.props = U, k.__P = e, k.__e = !1, X = Se.__r, te = 0, "prototype" in ae && ae.prototype.render) {
+            for (k.state = k.__s, k.__d = !1, X && X(r), C = k.render(k.props, k.state, k.context), ie = 0; ie < k._sb.length; ie++) k.__h.push(k._sb[ie]);
+            k._sb = []
         } else
-            do w.__d = !1, te && te(e), _ = w.render(w.props, w.state, w.context), w.state = w.__s; while (w.__d && ++j < 25);
-        w.state = w.__s, w.getChildContext != null && (a = Vt(Vt({}, a), w.getChildContext())), T || w.getSnapshotBeforeUpdate == null || (R = w.getSnapshotBeforeUpdate(A, L)), ga(r, Rn(pe = _ != null && _.type === Ge && _.key == null ? _.props.children : _) ? pe : [pe], e, i, a, l, c, d, f, g, y), w.base = e.__e, e.__u &= -161, w.__h.length && d.push(w), O && (w.__E = w.__ = null)
-    } catch (ce) {
-        e.__v = null, g || c != null ? (e.__e = f, e.__u |= g ? 160 : 32, c[c.indexOf(f)] = null) : (e.__e = i.__e, e.__k = i.__k), Me.__e(ce, e, i)
-    } else c == null && e.__v === i.__v ? (e.__k = i.__k, e.__e = i.__e) : e.__e = fh(i.__e, e, i, a, l, c, d, g, y);
-    (_ = Me.diffed) && _(e)
+            do k.__d = !1, X && X(r), C = k.render(k.props, k.state, k.context), k.state = k.__s; while (k.__d && ++te < 25);
+        k.state = k.__s, k.getChildContext != null && (o = Zt(Zt({}, o), k.getChildContext())), F || k.getSnapshotBeforeUpdate == null || (N = k.getSnapshotBeforeUpdate(E, M)), da(e, Qn(ge = C != null && C.type === He && C.key == null ? C.props.children : C) ? ge : [ge], r, i, o, s, l, h, p, b, x), k.base = r.__e, r.__u &= -161, k.__h.length && h.push(k), G && (k.__E = k.__ = null)
+    } catch (qe) {
+        r.__v = null, b || l != null ? (r.__e = p, r.__u |= b ? 160 : 32, l[l.indexOf(p)] = null) : (r.__e = i.__e, r.__k = i.__k), Se.__e(qe, r, i)
+    } else l == null && r.__v === i.__v ? (r.__k = i.__k, r.__e = i.__e) : r.__e = a1(i.__e, r, i, o, s, l, h, b, x);
+    (C = Se.diffed) && C(r)
 }
 
-function ya(r, e, i) {
-    e.__d = void 0;
-    for (var a = 0; a < i.length; a++) Nn(i[a], i[++a], i[++a]);
-    Me.__c && Me.__c(e, r), r.some(function(l) {
+function fa(e, r, i) {
+    r.__d = void 0;
+    for (var o = 0; o < i.length; o++) eu(i[o], i[++o], i[++o]);
+    Se.__c && Se.__c(r, e), e.some(function(s) {
         try {
-            r = l.__h, l.__h = [], r.some(function(c) {
-                c.call(l)
+            e = s.__h, s.__h = [], e.some(function(l) {
+                l.call(s)
             })
-        } catch (c) {
-            Me.__e(c, l.__v)
+        } catch (l) {
+            Se.__e(l, s.__v)
         }
     })
 }
 
-function fh(r, e, i, a, l, c, d, f, g) {
-    var y, _, w, T, A, L, R, O = i.props,
-        P = e.props,
-        I = e.type;
-    if (I === "svg" && (l = !0), c != null) {
-        for (y = 0; y < c.length; y++)
-            if ((A = c[y]) && "setAttribute" in A == !!I && (I ? A.localName === I : A.nodeType === 3)) {
-                r = A, c[y] = null;
+function a1(e, r, i, o, s, l, h, p, b) {
+    var x, C, k, F, E, M, N, G = i.props,
+        U = r.props,
+        $ = r.type;
+    if ($ === "svg" && (s = !0), l != null) {
+        for (x = 0; x < l.length; x++)
+            if ((E = l[x]) && "setAttribute" in E == !!$ && ($ ? E.localName === $ : E.nodeType === 3)) {
+                e = E, l[x] = null;
                 break
             }
     }
-    if (r == null) {
-        if (I === null) return document.createTextNode(P);
-        r = l ? document.createElementNS("http://www.w3.org/2000/svg", I) : document.createElement(I, P.is && P), c = null, f = !1
+    if (e == null) {
+        if ($ === null) return document.createTextNode(U);
+        e = s ? document.createElementNS("http://www.w3.org/2000/svg", $) : document.createElement($, U.is && U), l = null, p = !1
     }
-    if (I === null) O === P || f && r.data === P || (r.data = P);
+    if ($ === null) G === U || p && e.data === U || (e.data = U);
     else {
-        if (c = c && d0.call(r.childNodes), O = i.props || Tr, !f && c != null)
-            for (O = {}, y = 0; y < r.attributes.length; y++) O[(A = r.attributes[y]).name] = A.value;
-        for (y in O) A = O[y], y == "children" || (y == "dangerouslySetInnerHTML" ? w = A : y === "key" || y in P || l0(r, y, null, A, l));
-        for (y in P) A = P[y], y == "children" ? T = A : y == "dangerouslySetInnerHTML" ? _ = A : y == "value" ? L = A : y == "checked" ? R = A : y === "key" || f && typeof A != "function" || O[y] === A || l0(r, y, A, O[y], l);
-        if (_) f || w && (_.__html === w.__html || _.__html === r.innerHTML) || (r.innerHTML = _.__html), e.__k = [];
-        else if (w && (r.innerHTML = ""), ga(r, Rn(T) ? T : [T], e, i, a, l && I !== "foreignObject", c, d, c ? c[0] : i.__k && tr(i, 0), f, g), c != null)
-            for (y = c.length; y--;) c[y] != null && pa(c[y]);
-        f || (y = "value", L !== void 0 && (L !== r[y] || I === "progress" && !L || I === "option" && L !== O[y]) && l0(r, y, L, O[y], !1), y = "checked", R !== void 0 && R !== r[y] && l0(r, y, R, O[y], !1))
+        if (l = l && Ar.call(e.childNodes), G = i.props || P0, !p && l != null)
+            for (G = {}, x = 0; x < e.attributes.length; x++) G[(E = e.attributes[x]).name] = E.value;
+        for (x in G) E = G[x], x == "children" || (x == "dangerouslySetInnerHTML" ? k = E : x === "key" || x in U || kr(e, x, null, E, s));
+        for (x in U) E = U[x], x == "children" ? F = E : x == "dangerouslySetInnerHTML" ? C = E : x == "value" ? M = E : x == "checked" ? N = E : x === "key" || p && typeof E != "function" || G[x] === E || kr(e, x, E, G[x], s);
+        if (C) p || k && (C.__html === k.__html || C.__html === e.innerHTML) || (e.innerHTML = C.__html), r.__k = [];
+        else if (k && (e.innerHTML = ""), da(e, Qn(F) ? F : [F], r, i, o, s && $ !== "foreignObject", l, h, l ? l[0] : i.__k && s0(i, 0), p, b), l != null)
+            for (x = l.length; x--;) l[x] != null && la(l[x]);
+        p || (x = "value", M !== void 0 && (M !== e[x] || $ === "progress" && !M || $ === "option" && M !== G[x]) && kr(e, x, M, G[x], !1), x = "checked", N !== void 0 && N !== e[x] && kr(e, x, N, G[x], !1))
     }
-    return r
+    return e
 }
 
-function Nn(r, e, i) {
+function eu(e, r, i) {
     try {
-        typeof r == "function" ? r(e) : r.current = e
-    } catch (a) {
-        Me.__e(a, i)
+        typeof e == "function" ? e(r) : e.current = r
+    } catch (o) {
+        Se.__e(o, i)
     }
 }
 
-function zn(r, e, i) {
-    var a, l;
-    if (Me.unmount && Me.unmount(r), (a = r.ref) && (a.current && a.current !== r.__e || Nn(a, null, e)), (a = r.__c) != null) {
-        if (a.componentWillUnmount) try {
-            a.componentWillUnmount()
-        } catch (c) {
-            Me.__e(c, e)
+function Xn(e, r, i) {
+    var o, s;
+    if (Se.unmount && Se.unmount(e), (o = e.ref) && (o.current && o.current !== e.__e || eu(o, null, r)), (o = e.__c) != null) {
+        if (o.componentWillUnmount) try {
+            o.componentWillUnmount()
+        } catch (l) {
+            Se.__e(l, r)
         }
-        a.base = a.__P = null, r.__c = void 0
+        o.base = o.__P = null, e.__c = void 0
     }
-    if (a = r.__k)
-        for (l = 0; l < a.length; l++) a[l] && zn(a[l], e, i || typeof r.type != "function");
-    i || r.__e == null || pa(r.__e), r.__ = r.__e = r.__d = void 0
+    if (o = e.__k)
+        for (s = 0; s < o.length; s++) o[s] && Xn(o[s], r, i || typeof e.type != "function");
+    i || e.__e == null || la(e.__e), e.__ = e.__e = e.__d = void 0
 }
 
-function gh(r, e, i) {
-    return this.constructor(r, i)
+function s1(e, r, i) {
+    return this.constructor(e, i)
 }
 
-function rr(r, e, i) {
-    var a, l, c, d;
-    Me.__ && Me.__(r, e), l = (a = typeof i == "function") ? null : i && i.__k || e.__k, c = [], d = [], Bn(e, r = (!a && i || e).__k = Fn(Ge, null, [r]), l || Tr, Tr, e.ownerSVGElement !== void 0, !a && i ? [i] : l ? null : e.firstChild ? d0.call(e.childNodes) : null, c, !a && i ? i : l ? l.__e : e.firstChild, a, d), ya(c, r, d)
+function l0(e, r, i) {
+    var o, s, l, h;
+    Se.__ && Se.__(e, r), s = (o = typeof i == "function") ? null : i && i.__k || r.__k, l = [], h = [], Kn(r, e = (!o && i || r).__k = Jn(He, null, [e]), s || P0, P0, r.ownerSVGElement !== void 0, !o && i ? [i] : s ? null : r.firstChild ? Ar.call(r.childNodes) : null, l, !o && i ? i : s ? s.__e : r.firstChild, o, h), fa(l, e, h)
 }
-d0 = ma.slice, Me = {
-    __e: function(r, e, i, a) {
-        for (var l, c, d; e = e.__;)
-            if ((l = e.__c) && !l.__) try {
-                if ((c = l.constructor) && c.getDerivedStateFromError != null && (l.setState(c.getDerivedStateFromError(r)), d = l.__d), l.componentDidCatch != null && (l.componentDidCatch(r, a || {}), d = l.__d), d) return l.__E = l
-            } catch (f) {
-                r = f
-            }
-        throw r
-    }
-}, ha = 0, uh = function(r) {
-    return r != null && r.constructor == null
-}, u0.prototype.setState = function(r, e) {
+Ar = sa.slice, Se = {
+    __e: function(e, r, i, o) {
+        for (var s, l, h; r = r.__;)
+            if ((s = r.__c) && !s.__) try {
+                if ((l = s.constructor) && l.getDerivedStateFromError != null && (s.setState(l.getDerivedStateFromError(e)), h = s.__d), s.componentDidCatch != null && (s.componentDidCatch(e, o || {}), h = s.__d), h) return s.__E = s
+            } catch (p) {
+                e = p
+            }
+        throw e
+    }
+}, oa = 0, r1 = function(e) {
+    return e != null && e.constructor == null
+}, Cr.prototype.setState = function(e, r) {
     var i;
-    i = this.__s != null && this.__s !== this.state ? this.__s : this.__s = Vt({}, this.state), typeof r == "function" && (r = r(Vt({}, i), this.props)), r && Vt(i, r), r != null && this.__v && (e && this._sb.push(e), sa(this))
-}, u0.prototype.forceUpdate = function(r) {
-    this.__v && (this.__e = !0, r && this.__h.push(r), sa(this))
-}, u0.prototype.render = Ge, er = [], da = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, Dn = function(r, e) {
-    return r.__v.__b - e.__v.__b
-}, h0.__r = 0, hh = 0;
+    i = this.__s != null && this.__s !== this.state ? this.__s : this.__s = Zt({}, this.state), typeof e == "function" && (e = e(Zt({}, i), this.props)), e && Zt(i, e), e != null && this.__v && (r && this._sb.push(r), ra(this))
+}, Cr.prototype.forceUpdate = function(e) {
+    this.__v && (this.__e = !0, e && this.__h.push(e), ra(this))
+}, Cr.prototype.render = He, a0 = [], aa = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, Zn = function(e, r) {
+    return e.__v.__b - r.__v.__b
+}, Sr.__r = 0, n1 = 0;
 
-function jt(r, e) {
-    if (e == null || r.frontierEntries == null || r.frontierEntries.length === 0) return r;
+function Xt(e, r) {
+    if (r == null || e.frontierEntries == null || e.frontierEntries.length === 0) return e;
     {
-        (e < 0 || e >= r.frontierEntries.length) && (e = 0);
-        let i = r.frontierEntries[e];
+        (r < 0 || r >= e.frontierEntries.length) && (r = 0);
+        let i = e.frontierEntries[r];
         return {
-            status: r.status,
-            jobParams: r.jobParams,
+            status: e.status,
+            jobParams: e.jobParams,
             physicalCounts: i.physicalCounts,
             physicalCountsFormatted: i.physicalCountsFormatted,
             logicalQubit: i.logicalQubit,
             tfactory: i.tfactory,
             errorBudget: i.errorBudget,
-            logicalCounts: r.logicalCounts
+            logicalCounts: e.logicalCounts
         }
     }
 }
-var Ar, Ue, Ln, xa, f0 = 0,
-    Aa = [],
-    m0 = [],
-    Ye = Me,
-    va = Ye.__b,
-    wa = Ye.__r,
-    ka = Ye.diffed,
-    _a = Ye.__c,
-    Sa = Ye.unmount,
-    Ca = Ye.__;
-
-function In(r, e) {
-    Ye.__h && Ye.__h(Ue, r, f0 || e), f0 = 0;
-    var i = Ue.__H || (Ue.__H = {
+var I0, Ve, tu, ma, Er = 0,
+    ka = [],
+    Tr = [],
+    je = Se,
+    pa = je.__b,
+    ba = je.__r,
+    ga = je.diffed,
+    xa = je.__c,
+    ya = je.unmount,
+    va = je.__;
+
+function nu(e, r) {
+    je.__h && je.__h(Ve, e, Er || r), Er = 0;
+    var i = Ve.__H || (Ve.__H = {
         __: [],
         __h: []
     });
-    return r >= i.__.length && i.__.push({
-        __V: m0
-    }), i.__[r]
-}
-
-function Xe(r) {
-    return f0 = 1, bh(Ma, r)
-}
-
-function bh(r, e, i) {
-    var a = In(Ar++, 2);
-    if (a.t = r, !a.__c && (a.__ = [i ? i(e) : Ma(void 0, e), function(f) {
-            var g = a.__N ? a.__N[0] : a.__[0],
-                y = a.t(g, f);
-            g !== y && (a.__N = [y, a.__[1]], a.__c.setState({}))
-        }], a.__c = Ue, !Ue.u)) {
-        var l = function(f, g, y) {
-            if (!a.__c.__H) return !0;
-            var _ = a.__c.__H.__.filter(function(T) {
-                return !!T.__c
+    return e >= i.__.length && i.__.push({
+        __V: Tr
+    }), i.__[e]
+}
+
+function Ze(e) {
+    return Er = 1, l1(Ca, e)
+}
+
+function l1(e, r, i) {
+    var o = nu(I0++, 2);
+    if (o.t = e, !o.__c && (o.__ = [i ? i(r) : Ca(void 0, r), function(p) {
+            var b = o.__N ? o.__N[0] : o.__[0],
+                x = o.t(b, p);
+            b !== x && (o.__N = [x, o.__[1]], o.__c.setState({}))
+        }], o.__c = Ve, !Ve.u)) {
+        var s = function(p, b, x) {
+            if (!o.__c.__H) return !0;
+            var C = o.__c.__H.__.filter(function(F) {
+                return !!F.__c
             });
-            if (_.every(function(T) {
-                    return !T.__N
-                })) return !c || c.call(this, f, g, y);
-            var w = !1;
-            return _.forEach(function(T) {
-                if (T.__N) {
-                    var A = T.__[0];
-                    T.__ = T.__N, T.__N = void 0, A !== T.__[0] && (w = !0)
+            if (C.every(function(F) {
+                    return !F.__N
+                })) return !l || l.call(this, p, b, x);
+            var k = !1;
+            return C.forEach(function(F) {
+                if (F.__N) {
+                    var E = F.__[0];
+                    F.__ = F.__N, F.__N = void 0, E !== F.__[0] && (k = !0)
                 }
-            }), !(!w && a.__c.props === f) && (!c || c.call(this, f, g, y))
+            }), !(!k && o.__c.props === p) && (!l || l.call(this, p, b, x))
         };
-        Ue.u = !0;
-        var c = Ue.shouldComponentUpdate,
-            d = Ue.componentWillUpdate;
-        Ue.componentWillUpdate = function(f, g, y) {
+        Ve.u = !0;
+        var l = Ve.shouldComponentUpdate,
+            h = Ve.componentWillUpdate;
+        Ve.componentWillUpdate = function(p, b, x) {
             if (this.__e) {
-                var _ = c;
-                c = void 0, l(f, g, y), c = _
+                var C = l;
+                l = void 0, s(p, b, x), l = C
             }
-            d && d.call(this, f, g, y)
-        }, Ue.shouldComponentUpdate = l
+            h && h.call(this, p, b, x)
+        }, Ve.shouldComponentUpdate = s
     }
-    return a.__N || a.__
+    return o.__N || o.__
 }
 
-function Ut(r, e) {
-    var i = In(Ar++, 3);
-    !Ye.__s && qa(i.__H, e) && (i.__ = r, i.i = e, Ue.__H.__h.push(i))
+function Qt(e, r) {
+    var i = nu(I0++, 3);
+    !je.__s && _a(i.__H, r) && (i.__ = e, i.i = r, Ve.__H.__h.push(i))
 }
 
-function St(r) {
-    return f0 = 5, yh(function() {
+function St(e) {
+    return Er = 5, c1(function() {
         return {
-            current: r
+            current: e
         }
     }, [])
 }
 
-function yh(r, e) {
-    var i = In(Ar++, 7);
-    return qa(i.__H, e) ? (i.__V = r(), i.i = e, i.__h = r, i.__V) : i.__
-}
-
-function xh() {
-    for (var r; r = Aa.shift();)
-        if (r.__P && r.__H) try {
-            r.__H.__h.forEach(p0), r.__H.__h.forEach(Pn), r.__H.__h = []
-        } catch (e) {
-            r.__H.__h = [], Ye.__e(e, r.__v)
-        }
-}
-Ye.__b = function(r) {
-    Ue = null, va && va(r)
-}, Ye.__ = function(r, e) {
-    r && e.__k && e.__k.__m && (r.__m = e.__k.__m), Ca && Ca(r, e)
-}, Ye.__r = function(r) {
-    wa && wa(r), Ar = 0;
-    var e = (Ue = r.__c).__H;
-    e && (Ln === Ue ? (e.__h = [], Ue.__h = [], e.__.forEach(function(i) {
-        i.__N && (i.__ = i.__N), i.__V = m0, i.__N = i.i = void 0
-    })) : (e.__h.forEach(p0), e.__h.forEach(Pn), e.__h = [], Ar = 0)), Ln = Ue
-}, Ye.diffed = function(r) {
-    ka && ka(r);
-    var e = r.__c;
-    e && e.__H && (e.__H.__h.length && (Aa.push(e) !== 1 && xa === Ye.requestAnimationFrame || ((xa = Ye.requestAnimationFrame) || vh)(xh)), e.__H.__.forEach(function(i) {
-        i.i && (i.__H = i.i), i.__V !== m0 && (i.__ = i.__V), i.i = void 0, i.__V = m0
-    })), Ln = Ue = null
-}, Ye.__c = function(r, e) {
-    e.some(function(i) {
+function c1(e, r) {
+    var i = nu(I0++, 7);
+    return _a(i.__H, r) ? (i.__V = e(), i.i = r, i.__h = e, i.__V) : i.__
+}
+
+function d1() {
+    for (var e; e = ka.shift();)
+        if (e.__P && e.__H) try {
+            e.__H.__h.forEach(Dr), e.__H.__h.forEach(ru), e.__H.__h = []
+        } catch (r) {
+            e.__H.__h = [], je.__e(r, e.__v)
+        }
+}
+je.__b = function(e) {
+    Ve = null, pa && pa(e)
+}, je.__ = function(e, r) {
+    e && r.__k && r.__k.__m && (e.__m = r.__k.__m), va && va(e, r)
+}, je.__r = function(e) {
+    ba && ba(e), I0 = 0;
+    var r = (Ve = e.__c).__H;
+    r && (tu === Ve ? (r.__h = [], Ve.__h = [], r.__.forEach(function(i) {
+        i.__N && (i.__ = i.__N), i.__V = Tr, i.__N = i.i = void 0
+    })) : (r.__h.forEach(Dr), r.__h.forEach(ru), r.__h = [], I0 = 0)), tu = Ve
+}, je.diffed = function(e) {
+    ga && ga(e);
+    var r = e.__c;
+    r && r.__H && (r.__H.__h.length && (ka.push(r) !== 1 && ma === je.requestAnimationFrame || ((ma = je.requestAnimationFrame) || h1)(d1)), r.__H.__.forEach(function(i) {
+        i.i && (i.__H = i.i), i.__V !== Tr && (i.__ = i.__V), i.i = void 0, i.__V = Tr
+    })), tu = Ve = null
+}, je.__c = function(e, r) {
+    r.some(function(i) {
         try {
-            i.__h.forEach(p0), i.__h = i.__h.filter(function(a) {
-                return !a.__ || Pn(a)
+            i.__h.forEach(Dr), i.__h = i.__h.filter(function(o) {
+                return !o.__ || ru(o)
             })
-        } catch (a) {
-            e.some(function(l) {
-                l.__h && (l.__h = [])
-            }), e = [], Ye.__e(a, i.__v)
-        }
-    }), _a && _a(r, e)
-}, Ye.unmount = function(r) {
-    Sa && Sa(r);
-    var e, i = r.__c;
-    i && i.__H && (i.__H.__.forEach(function(a) {
+        } catch (o) {
+            r.some(function(s) {
+                s.__h && (s.__h = [])
+            }), r = [], je.__e(o, i.__v)
+        }
+    }), xa && xa(e, r)
+}, je.unmount = function(e) {
+    ya && ya(e);
+    var r, i = e.__c;
+    i && i.__H && (i.__H.__.forEach(function(o) {
         try {
-            p0(a)
-        } catch (l) {
-            e = l
+            Dr(o)
+        } catch (s) {
+            r = s
         }
-    }), i.__H = void 0, e && Ye.__e(e, i.__v))
+    }), i.__H = void 0, r && je.__e(r, i.__v))
 };
-var Ta = typeof requestAnimationFrame == "function";
+var wa = typeof requestAnimationFrame == "function";
 
-function vh(r) {
-    var e, i = function() {
-            clearTimeout(a), Ta && cancelAnimationFrame(e), setTimeout(r)
+function h1(e) {
+    var r, i = function() {
+            clearTimeout(o), wa && cancelAnimationFrame(r), setTimeout(e)
         },
-        a = setTimeout(i, 100);
-    Ta && (e = requestAnimationFrame(i))
+        o = setTimeout(i, 100);
+    wa && (r = requestAnimationFrame(i))
 }
 
-function p0(r) {
-    var e = Ue,
-        i = r.__c;
-    typeof i == "function" && (r.__c = void 0, i()), Ue = e
+function Dr(e) {
+    var r = Ve,
+        i = e.__c;
+    typeof i == "function" && (e.__c = void 0, i()), Ve = r
 }
 
-function Pn(r) {
-    var e = Ue;
-    r.__c = r.__(), Ue = e
+function ru(e) {
+    var r = Ve;
+    e.__c = e.__(), Ve = r
 }
 
-function qa(r, e) {
-    return !r || r.length !== e.length || e.some(function(i, a) {
-        return i !== r[a]
+function _a(e, r) {
+    return !e || e.length !== r.length || r.some(function(i, o) {
+        return i !== e[o]
     })
 }
 
-function Ma(r, e) {
-    return typeof e == "function" ? e(r) : e
+function Ca(e, r) {
+    return typeof r == "function" ? r(e) : r
 }
-var wh = 0,
-    kf = Array.isArray;
+var f1 = 0,
+    W2 = Array.isArray;
 
-function M(r, e, i, a, l, c) {
-    var d, f, g = {};
-    for (f in e) f == "ref" ? d = e[f] : g[f] = e[f];
-    var y = {
-        type: r,
-        props: g,
+function T(e, r, i, o, s, l) {
+    var h, p, b = {};
+    for (p in r) p == "ref" ? h = r[p] : b[p] = r[p];
+    var x = {
+        type: e,
+        props: b,
         key: i,
-        ref: d,
+        ref: h,
         __k: null,
         __: null,
         __b: 0,
         __e: null,
         __d: void 0,
         __c: null,
         constructor: void 0,
-        __v: --wh,
+        __v: --f1,
         __i: -1,
         __u: 0,
-        __source: l,
-        __self: c
+        __source: s,
+        __self: l
     };
-    if (typeof r == "function" && (d = r.defaultProps))
-        for (f in d) g[f] === void 0 && (g[f] = d[f]);
-    return Me.vnode && Me.vnode(y), y
-}
-var Ea = !1,
-    Da = !0,
-    g0 = [{
+    if (typeof e == "function" && (h = e.defaultProps))
+        for (p in h) b[p] === void 0 && (b[p] = h[p]);
+    return Se.vnode && Se.vnode(x), x
+}
+var Sa = !1,
+    Aa = !0,
+    Mr = [{
         category: "itemCount",
         options: ["Show all", "Top 10", "Top 25"]
     }, {
         category: "sortOrder",
         options: ["Sort a-z", "High to low", "Low to high"]
     }, {
         category: "labels",
         options: ["Raw labels", "Ket labels", "No labels"]
     }],
-    za = 3,
-    kh = {
+    Ta = 3,
+    m1 = {
         itemCount: 0,
         sortOrder: 0,
         labels: 0
     },
-    _h = /^\[(?:(Zero|One), *)*(Zero|One)\]$/;
+    p1 = /^\[(?:(Zero|One), *)*(Zero|One)\]$/;
 
-function Ra(r) {
-    if (typeof r != "string") return "ERROR";
-    if (_h.test(r)) {
-        let e = r.match(/(One|Zero)/g),
+function Da(e) {
+    if (typeof e != "string") return "ERROR";
+    if (p1.test(e)) {
+        let r = e.match(/(One|Zero)/g),
             i = "|";
-        return e?.forEach(a => i += a == "One" ? "1" : "0"), i += "\u27E9", i
-    } else return r
+        return r?.forEach(o => i += o == "One" ? "1" : "0"), i += "\u27E9", i
+    } else return e
 }
 
-function On(r) {
-    let [e, i] = Xe(""), [a, l] = Xe({
+function uu(e) {
+    let [r, i] = Ze(""), [o, s] = Ze({
         zoom: 1,
         offset: 1
-    }), [c, d] = Xe(kh), f = St(null), g = St(null), y = 0;
-    switch (c.itemCount) {
+    }), [l, h] = Ze(m1), p = St(null), b = St(null), x = 0;
+    switch (l.itemCount) {
         case 1:
-            y = 10;
+            x = 10;
             break;
         case 2:
-            y = 25;
+            x = 25;
             break
     }
-    let _ = c.labels === 1,
-        w = [...r.data],
-        T = 0,
-        A = 0;
-    w.forEach(ee => {
-        T += ee[1], A = Math.max(ee[1], A)
+    let C = l.labels === 1,
+        k = [...e.data],
+        F = 0,
+        E = 0;
+    k.forEach(ee => {
+        F += ee[1], E = Math.max(ee[1], E)
     });
-    let L = `${w.length} unique results`;
-    y > 0 && (w.sort((ee, G) => ee[1] < G[1] ? 1 : -1), w.length > y && (L = `Top ${y} of ${L}`, w.length = y)), r.filter && (L += `. Shot filter: ${_?Ra(r.filter):r.filter}`), w.sort((ee, G) => {
-        let fe = Number(ee[0]),
-            Te = Number(G[0]);
-        switch (c.sortOrder) {
+    let M = `${k.length} unique results`;
+    x > 0 && (k.sort((ee, O) => ee[1] < O[1] ? 1 : -1), k.length > x && (M = `Top ${x} of ${M}`, k.length = x)), e.filter && (M += `. Shot filter: ${C?Da(e.filter):e.filter}`), k.sort((ee, O) => {
+        let ce = Number(ee[0]),
+            ke = Number(O[0]);
+        switch (l.sortOrder) {
             case 1:
-                return ee[1] < G[1] ? 1 : -1;
+                return ee[1] < O[1] ? 1 : -1;
             case 2:
-                return ee[1] > G[1] ? 1 : -1;
+                return ee[1] > O[1] ? 1 : -1;
             default:
-                return !isNaN(fe) && !isNaN(Te) ? fe < Te ? -1 : 1 : ee[0] < G[0] ? -1 : 1
+                return !isNaN(ce) && !isNaN(ke) ? ce < ke ? -1 : 1 : ee[0] < O[0] ? -1 : 1
         }
     });
 
-    function R(ee) {
-        let fe = ee.target.querySelector("title")?.textContent;
-        i(fe || "")
+    function N(ee) {
+        let ce = ee.target.querySelector("title")?.textContent;
+        i(ce || "")
     }
 
-    function O() {
+    function G() {
         i("")
     }
 
-    function P(ee) {
-        let fe = ee.target.getAttribute("data-raw-label");
-        fe === r.filter ? r.onFilter("") : r.onFilter(fe || "")
+    function U(ee) {
+        let ce = ee.target.getAttribute("data-raw-label");
+        ce === e.filter ? e.onFilter("") : e.onFilter(ce || "")
     }
 
-    function I() {
-        f.current && (f.current.style.display === "inline" ? f.current.style.display = "none" : (f.current.style.display = "inline", g.current && (g.current.style.display = "none")))
+    function $() {
+        p.current && (p.current.style.display === "inline" ? p.current.style.display = "none" : (p.current.style.display = "inline", b.current && (b.current.style.display = "none")))
     }
 
-    function Y(ee, G) {
-        if (!f.current) return;
-        let fe = {
-            ...c
+    function V(ee, O) {
+        if (!p.current) return;
+        let ce = {
+            ...l
         };
-        fe[ee] = G, d(fe), ee === "itemCount" && l({
+        ce[ee] = O, h(ce), ee === "itemCount" && s({
             zoom: 1,
             offset: 1
-        }), f.current.style.display = "none"
+        }), p.current.style.display = "none"
     }
 
-    function re() {
-        g.current && (g.current.style.display === "inline" ? g.current.style.display = "none" : g.current.style.display = "inline")
+    function Y() {
+        b.current && (b.current.style.display === "inline" ? b.current.style.display = "none" : b.current.style.display = "inline")
     }
-    let te = 38,
-        j = 11,
-        ne = g0.length * te - 2,
-        pe = za * j + 3,
-        ue = 163,
-        ce = 72,
-        Ce = 1.2,
-        De = ue * a.zoom / w.length,
-        X = De * .1,
-        he = De - 2 * X,
-        oe = De > 5 && c.labels !== 2;
+    let X = 38,
+        te = 11,
+        ie = Mr.length * X - 2,
+        ge = Ta * te + 3,
+        ae = 163,
+        qe = 72,
+        Ee = 1.2,
+        Ne = ae * o.zoom / k.length,
+        Q = Ne * .1,
+        fe = Ne - 2 * Q,
+        Qe = Ne > 5 && l.labels !== 2;
 
-    function ae(ee) {
+    function ne(ee) {
         ee.preventDefault();
-        let G = ee.currentTarget,
-            fe = new DOMPoint(ee.clientX, ee.clientY).matrixTransform(G.getScreenCTM()?.inverse()),
-            Te = a.offset,
-            Ae = a.zoom;
-        if (!Da || !ee.altKey) {
-            Ae = a.zoom + ee.deltaY * .05, Ae = Math.min(Math.max(1, Ae), 50);
-            let Pt = ue * a.zoom,
-                $0 = (0 - a.offset + fe.x) / Pt,
-                G0 = Ae * ue - a.zoom * ue,
-                V0 = $0 * G0;
-            Te = a.offset - V0
-        }
-        Ea && (Te -= ee.deltaX), !Ea && Da && ee.altKey && (Te -= ee.deltaY);
-        let qt = 1 - (ue * Ae - ue),
-            ct = Math.min(Math.max(Te, qt), 1);
-        l({
-            zoom: Ae,
+        let O = ee.currentTarget,
+            ce = new DOMPoint(ee.clientX, ee.clientY).matrixTransform(O.getScreenCTM()?.inverse()),
+            ke = o.offset,
+            _e = o.zoom;
+        if (!Aa || !ee.altKey) {
+            _e = o.zoom + ee.deltaY * .05, _e = Math.min(Math.max(1, _e), 50);
+            let Gt = ae * o.zoom,
+                an = (0 - o.offset + ce.x) / Gt,
+                sn = _e * ae - o.zoom * ae,
+                ln = an * sn;
+            ke = o.offset - ln
+        }
+        Sa && (ke -= ee.deltaX), !Sa && Aa && ee.altKey && (ke -= ee.deltaY);
+        let Mt = 1 - (ae * _e - ae),
+            ct = Math.min(Math.max(ke, Mt), 1);
+        s({
+            zoom: _e,
             offset: ct
         })
     }
-    return M(Ge, {
-        children: [r.shotsHeader ? M("h4", {
+    return T(He, {
+        children: [e.shotsHeader ? T("h4", {
             style: "margin: 8px 0px",
-            children: ["Total shots: ", r.shotCount]
-        }) : null, M("svg", {
+            children: ["Total shots: ", e.shotCount]
+        }) : null, T("svg", {
             class: "histogram",
             viewBox: "0 0 165 100",
-            onWheel: ae,
-            children: [M("g", {
-                transform: `translate(${a.offset},4)`,
-                children: w.map((ee, G) => {
-                    let fe = _ ? Ra(ee[0]) : ee[0],
-                        Te = ce * (ee[1] / A),
-                        Ae = De * G + X,
-                        qt = De * G + De / 2 - Ce,
-                        ct = ce + 15 - Te,
-                        Pt = `${fe} at ${(ee[1]/T*100).toFixed(2)}%`,
-                        yr = "bar";
-                    return ee[0] === r.filter && (yr += " bar-selected"), M(Ge, {
-                        children: [M("rect", {
-                            class: yr,
-                            x: Ae,
+            onWheel: ne,
+            children: [T("g", {
+                transform: `translate(${o.offset},4)`,
+                children: k.map((ee, O) => {
+                    let ce = C ? Da(ee[0]) : ee[0],
+                        ke = qe * (ee[1] / E),
+                        _e = Ne * O + Q,
+                        Mt = Ne * O + Ne / 2 - Ee,
+                        ct = qe + 15 - ke,
+                        Gt = `${ce} at ${(ee[1]/F*100).toFixed(2)}%`,
+                        M0 = "bar";
+                    return ee[0] === e.filter && (M0 += " bar-selected"), T(He, {
+                        children: [T("rect", {
+                            class: M0,
+                            x: _e,
                             y: ct,
-                            width: he,
-                            height: Te,
-                            onMouseOver: R,
-                            onMouseOut: O,
-                            onClick: P,
+                            width: fe,
+                            height: ke,
+                            onMouseOver: N,
+                            onMouseOut: G,
+                            onClick: U,
                             "data-raw-label": ee[0],
-                            children: M("title", {
-                                children: Pt
+                            children: T("title", {
+                                children: Gt
                             })
-                        }), M("text", {
+                        }), T("text", {
                             class: "bar-label",
-                            x: qt,
+                            x: Mt,
                             y: "85",
-                            visibility: oe ? "visible" : "hidden",
-                            transform: `rotate(90, ${qt}, 85)`,
-                            children: fe
+                            visibility: Qe ? "visible" : "hidden",
+                            transform: `rotate(90, ${Mt}, 85)`,
+                            children: ce
                         })]
                     })
                 })
-            }), M("text", {
+            }), T("text", {
                 class: "histo-label",
                 x: "2",
                 y: "97",
-                children: L
-            }), M("text", {
+                children: M
+            }), T("text", {
                 class: "hover-text",
                 x: "85",
                 y: "6",
-                children: e
-            }), M("g", {
+                children: r
+            }), T("g", {
                 class: "menu-icon",
                 transform: "translate(2, 2) scale(0.3 0.3)",
-                onClick: I,
-                children: [M("rect", {
+                onClick: $,
+                children: [T("rect", {
                     width: "24",
                     height: "24",
                     fill: "white",
                     "stroke-widths": "0.5"
-                }), M("path", {
+                }), T("path", {
                     d: "M3 5 H21 M3 12 H21 M3 19 H21",
                     "stroke-width": "1.75",
                     "stroke-linecap": "round"
-                }), M("rect", {
+                }), T("rect", {
                     x: "6",
                     y: "3",
                     width: "4",
                     height: "4",
                     rx: "1",
                     "stroke-width": "1.5"
-                }), M("rect", {
+                }), T("rect", {
                     x: "15",
                     y: "10",
                     width: "4",
                     height: "4",
                     rx: "1",
                     "stroke-width": "1.5"
-                }), M("rect", {
+                }), T("rect", {
                     x: "9",
                     y: "17",
                     width: "4",
                     height: "4",
                     rx: "1",
                     "stroke-width": "1.5"
                 })]
-            }), M("g", {
+            }), T("g", {
                 class: "menu-icon",
                 transform: "translate(156, 2) scale(0.3 0.3)",
-                onClick: re,
-                children: [M("rect", {
+                onClick: Y,
+                children: [T("rect", {
                     width: "24",
                     height: "24",
                     "stroke-width": "0"
-                }), M("circle", {
+                }), T("circle", {
                     cx: "12",
                     cy: "13",
                     r: "10",
                     "stroke-width": "1.5"
-                }), M("path", {
+                }), T("path", {
                     "stroke-width": "2.5",
                     "stroke-linecap": "round",
                     d: "M12 8 V8 M12 12.5 V18"
                 })]
-            }), M("g", {
+            }), T("g", {
                 id: "menu",
-                ref: f,
+                ref: p,
                 transform: "translate(8, 2)",
                 style: "display: none;",
-                children: [M("rect", {
+                children: [T("rect", {
                     x: "0",
                     y: "0",
                     rx: "2",
-                    width: ne,
-                    height: pe,
+                    width: ie,
+                    height: ge,
                     class: "menu-box"
-                }), g0.map((ee, G) => ee.options.map((fe, Te) => {
-                    let Ae = "menu-item";
-                    return c[ee.category] === Te && (Ae += " menu-selected"), M(Ge, {
-                        children: [M("rect", {
-                            x: 2 + G * te,
-                            y: 2 + Te * j,
+                }), Mr.map((ee, O) => ee.options.map((ce, ke) => {
+                    let _e = "menu-item";
+                    return l[ee.category] === ke && (_e += " menu-selected"), T(He, {
+                        children: [T("rect", {
+                            x: 2 + O * X,
+                            y: 2 + ke * te,
                             rx: "1",
-                            class: Ae,
-                            onClick: () => Y(ee.category, Te)
-                        }), M("text", {
-                            x: 5 + G * te,
-                            y: 9 + Te * j,
+                            class: _e,
+                            onClick: () => V(ee.category, ke)
+                        }), T("text", {
+                            x: 5 + O * X,
+                            y: 9 + ke * te,
                             class: "menu-text",
-                            children: fe
+                            children: ce
                         })]
                     })
-                })), g0.map((ee, G) => G >= g0.length - 1 ? null : M("line", {
+                })), Mr.map((ee, O) => O >= Mr.length - 1 ? null : T("line", {
                     class: "menu-separator",
-                    x1: 37 + G * te,
+                    x1: 37 + O * X,
                     y1: "2",
-                    x2: 37 + G * te,
-                    y2: za * j + 1
+                    x2: 37 + O * X,
+                    y2: Ta * te + 1
                 }))]
-            }), M("g", {
-                ref: g,
+            }), T("g", {
+                ref: b,
                 style: "display: none;",
-                children: [M("rect", {
+                children: [T("rect", {
                     width: "155",
                     height: "76",
                     rx: "5",
                     x: "5",
                     y: "6",
                     class: "help-info",
-                    onClick: re
-                }), M("text", {
+                    onClick: Y
+                }), T("text", {
                     y: "6",
                     class: "help-info-text",
-                    children: [M("tspan", {
+                    children: [T("tspan", {
                         x: "10",
                         dy: "10",
                         children: "This histogram shows the frequency of unique 'shot' results."
-                    }), M("tspan", {
+                    }), T("tspan", {
                         x: "10",
                         dy: "10",
                         children: "Click the top-left 'settings' icon for display options."
-                    }), M("tspan", {
+                    }), T("tspan", {
                         x: "10",
                         dy: "10",
                         children: "You can zoom the chart using the mouse scroll wheel."
-                    }), M("tspan", {
+                    }), T("tspan", {
                         x: "10",
                         dy: "7",
                         children: "(Or using a trackpad gesture)."
-                    }), M("tspan", {
+                    }), T("tspan", {
                         x: "10",
                         dy: "10",
                         children: "When zoomed, to pan left & right, press 'Alt' while scrolling."
-                    }), M("tspan", {
+                    }), T("tspan", {
                         x: "10",
                         dy: "10",
                         children: "Click on a bar to filter the shot details to that result."
-                    }), M("tspan", {
+                    }), T("tspan", {
                         x: "10",
                         dy: "12",
                         children: "Click anywhere in this box to dismiss it."
                     })]
                 })]
             })]
         })]
     })
 }
 
-function Fa(r) {
-    let e = [],
+function Ea(e) {
+    let r = [],
         i = [],
-        a = new Intl.NumberFormat,
-        l = new Intl.NumberFormat(void 0, {
+        o = new Intl.NumberFormat,
+        s = new Intl.NumberFormat(void 0, {
             maximumFractionDigits: 2,
             minimumFractionDigits: 2
         });
     return i = [], i.push({
         path: "physicalCountsFormatted/runtime",
         label: "Runtime",
         description: "Total runtime",
-        explanation: `This is a runtime estimate for the execution time of the algorithm. In general, the execution time corresponds to the duration of one logical cycle (${a.format(r.logicalQubit.logicalCycleTime)} nanosecs) multiplied by the ${a.format(r.physicalCounts.breakdown.algorithmicLogicalDepth)} logical cycles to run the algorithm. If however the duration of a single T factory (here: ${a.format(r.tfactory==null?0:r.tfactory.runtime)} nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory.`
+        explanation: `This is a runtime estimate for the execution time of the algorithm. In general, the execution time corresponds to the duration of one logical cycle (${o.format(e.logicalQubit.logicalCycleTime)} nanosecs) multiplied by the ${o.format(e.physicalCounts.breakdown.algorithmicLogicalDepth)} logical cycles to run the algorithm. If however the duration of a single T factory (here: ${o.format(e.tfactory==null?0:e.tfactory.runtime)} nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory.`
     }), i.push({
         path: "physicalCountsFormatted/rqops",
         label: "rQOPS",
         description: "Reliable quantum operations per second",
-        explanation: `The value is computed as the number of logical qubits after layout (${a.format(r.physicalCounts.breakdown.algorithmicLogicalQubits)}) (with a logical error rate of ${r.physicalCountsFormatted.requiredLogicalQubitErrorRate}) multiplied by the clock frequency (${l.format(r.physicalCounts.breakdown.clockFrequency)}), which is the number of logical cycles per second.`
+        explanation: `The value is computed as the number of logical qubits after layout (${o.format(e.physicalCounts.breakdown.algorithmicLogicalQubits)}) (with a logical error rate of ${e.physicalCountsFormatted.requiredLogicalQubitErrorRate}) multiplied by the clock frequency (${s.format(e.physicalCounts.breakdown.clockFrequency)}), which is the number of logical cycles per second.`
     }), i.push({
         path: "physicalCountsFormatted/physicalQubits",
         label: "Physical qubits",
         description: "Number of physical qubits",
-        explanation: `This value represents the total number of physical qubits, which is the sum of ${a.format(r.physicalCounts.breakdown.physicalQubitsForAlgorithm)} physical qubits to implement the algorithm logic, and ${a.format(r.physicalCounts.breakdown.physicalQubitsForTfactories)} physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm.`
-    }), e.push({
+        explanation: `This value represents the total number of physical qubits, which is the sum of ${o.format(e.physicalCounts.breakdown.physicalQubitsForAlgorithm)} physical qubits to implement the algorithm logic, and ${o.format(e.physicalCounts.breakdown.physicalQubitsForTfactories)} physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm.`
+    }), r.push({
         title: "Physical resource estimates",
         alwaysVisible: !0,
         entries: i
     }), i = [], i.push({
         path: "physicalCountsFormatted/algorithmicLogicalQubits",
         label: "Logical algorithmic qubits",
         description: "Number of logical qubits for the algorithm after layout",
-        explanation: `Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits. In particular, to layout the $Q_{\\rm alg} = ${a.format(r.logicalCounts.numQubits)}$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = ${a.format(r.physicalCounts.breakdown.algorithmicLogicalQubits)}$ logical qubits.`
+        explanation: `Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits. In particular, to layout the $Q_{\\rm alg} = ${o.format(e.logicalCounts.numQubits)}$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = ${o.format(e.physicalCounts.breakdown.algorithmicLogicalQubits)}$ logical qubits.`
     }), i.push({
         path: "physicalCountsFormatted/algorithmicLogicalDepth",
         label: "Algorithmic depth",
         description: "Number of logical cycles for the algorithm",
-        explanation: `To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle. Based on the input algorithm, we require one multi-qubit measurement for the ${a.format(r.logicalCounts.measurementCount)} single-qubit measurements, the ${a.format(r.logicalCounts.rotationCount)} arbitrary single-qubit rotations, and the ${a.format(r.logicalCounts.tCount)} T gates, three multi-qubit measurements for each of the ${a.format(r.logicalCounts.cczCount)} CCZ and ${a.format(r.logicalCounts.ccixCount)} CCiX gates in the input program, as well as ${r.physicalCountsFormatted.numTsPerRotation} multi-qubit measurements for each of the ${a.format(r.logicalCounts.rotationDepth)} non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation.`
+        explanation: `To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle. Based on the input algorithm, we require one multi-qubit measurement for the ${o.format(e.logicalCounts.measurementCount)} single-qubit measurements, the ${o.format(e.logicalCounts.rotationCount)} arbitrary single-qubit rotations, and the ${o.format(e.logicalCounts.tCount)} T gates, three multi-qubit measurements for each of the ${o.format(e.logicalCounts.cczCount)} CCZ and ${o.format(e.logicalCounts.ccixCount)} CCiX gates in the input program, as well as ${e.physicalCountsFormatted.numTsPerRotation} multi-qubit measurements for each of the ${o.format(e.logicalCounts.rotationDepth)} non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation.`
     }), i.push({
         path: "physicalCountsFormatted/logicalDepth",
         label: "Logical depth",
         description: "Number of logical cycles performed",
-        explanation: `This number is usually equal to the logical depth of the algorithm, which is ${a.format(r.physicalCounts.breakdown.algorithmicLogicalDepth)}. However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time.`
+        explanation: `This number is usually equal to the logical depth of the algorithm, which is ${o.format(e.physicalCounts.breakdown.algorithmicLogicalDepth)}. However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time.`
     }), i.push({
         path: "physicalCountsFormatted/clockFrequency",
         label: "Clock frequency",
         description: "Number of logical cycles per second",
-        explanation: `This is the number of logical cycles that can be performed within one second. The logical cycle time is ${r.physicalCountsFormatted.logicalCycleTime}.`
+        explanation: `This is the number of logical cycles that can be performed within one second. The logical cycle time is ${e.physicalCountsFormatted.logicalCycleTime}.`
     }), i.push({
         path: "physicalCountsFormatted/numTstates",
         label: "Number of T states",
         description: "Number of T states consumed by the algorithm",
-        explanation: `To execute the algorithm, we require one T state for each of the ${a.format(r.logicalCounts.tCount)} T gates, four T states for each of the ${a.format(r.logicalCounts.cczCount)} CCZ and ${a.format(r.logicalCounts.ccixCount)} CCiX gates, as well as ${r.physicalCountsFormatted.numTsPerRotation} for each of the ${a.format(r.logicalCounts.rotationCount)} single-qubit rotation gates with arbitrary angle rotation.`
+        explanation: `To execute the algorithm, we require one T state for each of the ${o.format(e.logicalCounts.tCount)} T gates, four T states for each of the ${o.format(e.logicalCounts.cczCount)} CCZ and ${o.format(e.logicalCounts.ccixCount)} CCiX gates, as well as ${e.physicalCountsFormatted.numTsPerRotation} for each of the ${o.format(e.logicalCounts.rotationCount)} single-qubit rotation gates with arbitrary angle rotation.`
     }), i.push({
         path: "physicalCountsFormatted/numTfactories",
         label: "Number of T factories",
-        description: `Number of T factories capable of producing the demanded ${a.format(r.physicalCounts.breakdown.numTstates)} T states during the algorithm's runtime`,
-        explanation: `The total number of T factories ${a.format(r.physicalCounts.breakdown.numTfactories)} that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{${a.format(r.physicalCounts.breakdown.numTstates)} \\cdot ${a.format(r.tfactory==null?0:r.tfactory.runtime)}\\;\\text{ns}}{${a.format(r.tfactory==null?0:r.tfactory.numTstates)} \\cdot ${a.format(r.physicalCounts.runtime)}\\;\\text{ns}}\\right\\rceil$`
+        description: `Number of T factories capable of producing the demanded ${o.format(e.physicalCounts.breakdown.numTstates)} T states during the algorithm's runtime`,
+        explanation: `The total number of T factories ${o.format(e.physicalCounts.breakdown.numTfactories)} that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{${o.format(e.physicalCounts.breakdown.numTstates)} \\cdot ${o.format(e.tfactory==null?0:e.tfactory.runtime)}\\;\\text{ns}}{${o.format(e.tfactory==null?0:e.tfactory.numTstates)} \\cdot ${o.format(e.physicalCounts.runtime)}\\;\\text{ns}}\\right\\rceil$`
     }), i.push({
         path: "physicalCountsFormatted/numTfactoryRuns",
         label: "Number of T factory invocations",
         description: "Number of times all T factories are invoked",
-        explanation: `In order to prepare the ${a.format(r.physicalCounts.breakdown.numTstates)} T states, the ${a.format(r.physicalCounts.breakdown.numTfactories)} copies of the T factory are repeatedly invoked ${a.format(r.physicalCounts.breakdown.numTfactoryRuns)} times.`
+        explanation: `In order to prepare the ${o.format(e.physicalCounts.breakdown.numTstates)} T states, the ${o.format(e.physicalCounts.breakdown.numTfactories)} copies of the T factory are repeatedly invoked ${o.format(e.physicalCounts.breakdown.numTfactoryRuns)} times.`
     }), i.push({
         path: "physicalCountsFormatted/physicalQubitsForAlgorithm",
         label: "Physical algorithmic qubits",
         description: "Number of physical qubits for the algorithm after layout",
-        explanation: `The ${a.format(r.physicalCounts.breakdown.physicalQubitsForAlgorithm)} are the product of the ${a.format(r.physicalCounts.breakdown.algorithmicLogicalQubits)} logical qubits after layout and the ${a.format(r.logicalQubit.physicalQubits)} physical qubits that encode a single logical qubit.`
+        explanation: `The ${o.format(e.physicalCounts.breakdown.physicalQubitsForAlgorithm)} are the product of the ${o.format(e.physicalCounts.breakdown.algorithmicLogicalQubits)} logical qubits after layout and the ${o.format(e.logicalQubit.physicalQubits)} physical qubits that encode a single logical qubit.`
     }), i.push({
         path: "physicalCountsFormatted/physicalQubitsForTfactories",
         label: "Physical T factory qubits",
         description: "Number of physical qubits for the T factories",
-        explanation: `Each T factory requires ${a.format(r.tfactory==null?0:r.tfactory.physicalQubits)} physical qubits and we run ${a.format(r.physicalCounts.breakdown.numTfactories)} in parallel, therefore we need $${a.format(r.physicalCounts.breakdown.physicalQubitsForTfactories)} = ${a.format(r.tfactory==null?0:r.tfactory.physicalQubits)} \\cdot ${a.format(r.physicalCounts.breakdown.numTfactories)}$ qubits.`
+        explanation: `Each T factory requires ${o.format(e.tfactory==null?0:e.tfactory.physicalQubits)} physical qubits and we run ${o.format(e.physicalCounts.breakdown.numTfactories)} in parallel, therefore we need $${o.format(e.physicalCounts.breakdown.physicalQubitsForTfactories)} = ${o.format(e.tfactory==null?0:e.tfactory.physicalQubits)} \\cdot ${o.format(e.physicalCounts.breakdown.numTfactories)}$ qubits.`
     }), i.push({
         path: "physicalCountsFormatted/requiredLogicalQubitErrorRate",
         label: "Required logical qubit error rate",
         description: "The minimum logical qubit error rate required to run the algorithm within the error budget",
-        explanation: `The minimum logical qubit error rate is obtained by dividing the logical error probability ${r.physicalCountsFormatted.errorBudgetLogical} by the product of ${a.format(r.physicalCounts.breakdown.algorithmicLogicalQubits)} logical qubits and the total cycle count ${a.format(r.physicalCounts.breakdown.logicalDepth)}.`
+        explanation: `The minimum logical qubit error rate is obtained by dividing the logical error probability ${e.physicalCountsFormatted.errorBudgetLogical} by the product of ${o.format(e.physicalCounts.breakdown.algorithmicLogicalQubits)} logical qubits and the total cycle count ${o.format(e.physicalCounts.breakdown.logicalDepth)}.`
     }), i.push({
         path: "physicalCountsFormatted/requiredLogicalTstateErrorRate",
         label: "Required logical T state error rate",
         description: "The minimum T state error rate required for distilled T states",
-        explanation: `The minimum T state error rate is obtained by dividing the T distillation error probability ${r.physicalCountsFormatted.errorBudgetTstates} by the total number of T states ${a.format(r.physicalCounts.breakdown.numTstates)}.`
+        explanation: `The minimum T state error rate is obtained by dividing the T distillation error probability ${e.physicalCountsFormatted.errorBudgetTstates} by the total number of T states ${o.format(e.physicalCounts.breakdown.numTstates)}.`
     }), i.push({
         path: "physicalCountsFormatted/numTsPerRotation",
         label: "Number of T states per rotation",
         description: "Number of T states to implement a rotation with an arbitrary angle",
-        explanation: `The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(${a.format(r.logicalCounts.rotationCount)} / ${r.errorBudget.rotations}) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)]. For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases.`
-    }), e.push({
+        explanation: `The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(${o.format(e.logicalCounts.rotationCount)} / ${e.errorBudget.rotations}) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)]. For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases.`
+    }), r.push({
         title: "Resource estimates breakdown",
         alwaysVisible: !1,
         entries: i
     }), i = [], i.push({
         path: "jobParams/qecScheme/name",
         label: "QEC scheme",
         description: "Name of QEC scheme",
         explanation: "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
     }), i.push({
         path: "logicalQubit/codeDistance",
         label: "Code distance",
         description: "Required code distance for error correction",
-        explanation: `The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(${r.jobParams.qecScheme.crossingPrefactor} / ${r.physicalCounts.breakdown.requiredLogicalQubitErrorRate})}{\\log(${r.jobParams.qecScheme.errorCorrectionThreshold}/${r.physicalCounts.breakdown.cliffordErrorRate})} - 1$`
+        explanation: `The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(${e.jobParams.qecScheme.crossingPrefactor} / ${e.physicalCounts.breakdown.requiredLogicalQubitErrorRate})}{\\log(${e.jobParams.qecScheme.errorCorrectionThreshold}/${e.physicalCounts.breakdown.cliffordErrorRate})} - 1$`
     }), i.push({
         path: "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
         label: "Physical qubits",
         description: "Number of physical qubits per logical qubit",
-        explanation: `The number of physical qubits per logical qubit are evaluated using the formula ${r.jobParams.qecScheme.physicalQubitsPerLogicalQubit} that can be user-specified.`
+        explanation: `The number of physical qubits per logical qubit are evaluated using the formula ${e.jobParams.qecScheme.physicalQubitsPerLogicalQubit} that can be user-specified.`
     }), i.push({
         path: "physicalCountsFormatted/logicalCycleTime",
         label: "Logical cycle time",
         description: "Duration of a logical cycle in nanoseconds",
-        explanation: `The runtime of one logical cycle in nanoseconds is evaluated using the formula ${r.jobParams.qecScheme.logicalCycleTime} that can be user-specified.`
+        explanation: `The runtime of one logical cycle in nanoseconds is evaluated using the formula ${e.jobParams.qecScheme.logicalCycleTime} that can be user-specified.`
     }), i.push({
         path: "physicalCountsFormatted/logicalErrorRate",
         label: "Logical qubit error rate",
         description: "Logical qubit error rate",
-        explanation: `The logical qubit error rate is computed as $${r.jobParams.qecScheme.crossingPrefactor} \\cdot \\left(\\dfrac{${r.physicalCounts.breakdown.cliffordErrorRate}}{${r.jobParams.qecScheme.errorCorrectionThreshold}}\\right)^\\frac{${r.logicalQubit.codeDistance} + 1}{2}$`
+        explanation: `The logical qubit error rate is computed as $${e.jobParams.qecScheme.crossingPrefactor} \\cdot \\left(\\dfrac{${e.physicalCounts.breakdown.cliffordErrorRate}}{${e.jobParams.qecScheme.errorCorrectionThreshold}}\\right)^\\frac{${e.logicalQubit.codeDistance} + 1}{2}$`
     }), i.push({
         path: "jobParams/qecScheme/crossingPrefactor",
         label: "Crossing prefactor",
         description: "Crossing prefactor used in QEC scheme",
         explanation: "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
     }), i.push({
         path: "jobParams/qecScheme/errorCorrectionThreshold",
         label: "Error correction threshold",
         description: "Error correction threshold used in QEC scheme",
         explanation: "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it. This value is usually extracted numerically from simulations of the logical error rate."
     }), i.push({
         path: "jobParams/qecScheme/logicalCycleTime",
         label: "Logical cycle time formula",
         description: "QEC scheme formula used to compute logical cycle time",
-        explanation: `This is the formula that is used to compute the logical cycle time ${a.format(r.logicalQubit.logicalCycleTime)} ns.`
+        explanation: `This is the formula that is used to compute the logical cycle time ${o.format(e.logicalQubit.logicalCycleTime)} ns.`
     }), i.push({
         path: "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
         label: "Physical qubits formula",
         description: "QEC scheme formula used to compute number of physical qubits per logical qubit",
-        explanation: `This is the formula that is used to compute the number of physical qubits per logical qubits ${a.format(r.logicalQubit.physicalQubits)}.`
-    }), e.push({
+        explanation: `This is the formula that is used to compute the number of physical qubits per logical qubits ${o.format(e.logicalQubit.physicalQubits)}.`
+    }), r.push({
         title: "Logical qubit parameters",
         alwaysVisible: !1,
         entries: i
-    }), r.tfactory != null && (i = [], i.push({
+    }), e.tfactory != null && (i = [], i.push({
         path: "physicalCountsFormatted/tfactoryPhysicalQubits",
         label: "Physical qubits",
         description: "Number of physical qubits for a single T factory",
         explanation: "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory. A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
     }), i.push({
         path: "physicalCountsFormatted/tfactoryRuntime",
         label: "Runtime",
         description: "Runtime of a single T factory",
         explanation: "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
     }), i.push({
         path: "tfactory/numTstates",
         label: "Number of output T states per run",
         description: "Number of output T states produced in a single run of T factory",
-        explanation: `The T factory takes as input ${a.format(r.tfactory==null?0:r.tfactory.numInputTstates)} noisy physical T states with an error rate of ${r.jobParams.qubitParams.tGateErrorRate} and produces ${a.format(r.tfactory==null?0:r.tfactory.numTstates)} T states with an error rate of ${r.physicalCountsFormatted.tstateLogicalErrorRate}.`
+        explanation: `The T factory takes as input ${o.format(e.tfactory==null?0:e.tfactory.numInputTstates)} noisy physical T states with an error rate of ${e.jobParams.qubitParams.tGateErrorRate} and produces ${o.format(e.tfactory==null?0:e.tfactory.numTstates)} T states with an error rate of ${e.physicalCountsFormatted.tstateLogicalErrorRate}.`
     }), i.push({
         path: "physicalCountsFormatted/numInputTstates",
         label: "Number of input T states per run",
         description: "Number of physical input T states consumed in a single run of a T factory",
         explanation: "This value includes the physical input T states of all copies of the distillation unit in the first round."
     }), i.push({
         path: "tfactory/numRounds",
@@ -17045,24 +12635,24 @@
         label: "Runtime per round",
         description: "The runtime of each distillation round",
         explanation: "The runtime of the T factory is the sum of the runtimes in all rounds."
     }), i.push({
         path: "physicalCountsFormatted/tstateLogicalErrorRate",
         label: "Logical T state error rate",
         description: "Logical T state error rate",
-        explanation: `This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate ${r.physicalCountsFormatted.requiredLogicalTstateErrorRate}.`
-    }), e.push({
+        explanation: `This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate ${e.physicalCountsFormatted.requiredLogicalTstateErrorRate}.`
+    }), r.push({
         title: "T factory parameters",
         alwaysVisible: !1,
         entries: i
     })), i = [], i.push({
         path: "physicalCountsFormatted/logicalCountsNumQubits",
         label: "Logical qubits (pre-layout)",
         description: "Number of logical qubits in the input quantum program",
-        explanation: `We determine ${a.format(r.physicalCounts.breakdown.algorithmicLogicalQubits)} algorithmic logical qubits from this number by assuming to align them in a 2D grid. Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits.`
+        explanation: `We determine ${o.format(e.physicalCounts.breakdown.algorithmicLogicalQubits)} algorithmic logical qubits from this number by assuming to align them in a 2D grid. Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits.`
     }), i.push({
         path: "physicalCountsFormatted/logicalCountsTCount",
         label: "T gates",
         description: "Number of T gates in the input quantum program",
         explanation: "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
     }), i.push({
         path: "physicalCountsFormatted/logicalCountsRotationCount",
@@ -17085,39 +12675,39 @@
         description: "Number of CCiX-gates in the input quantum program",
         explanation: "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
     }), i.push({
         path: "physicalCountsFormatted/logicalCountsMeasurementCount",
         label: "Measurement operations",
         description: "Number of single qubit measurements in the input quantum program",
         explanation: "This is the number of single qubit measurements in Pauli basis that are used in the input program. Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
-    }), e.push({
+    }), r.push({
         title: "Pre-layout logical resources",
         alwaysVisible: !1,
         entries: i
     }), i = [], i.push({
         path: "physicalCountsFormatted/errorBudget",
         label: "Total error budget",
         description: "Total error budget for the algorithm",
         explanation: "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail. Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions. This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input. On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified. This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles. Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
     }), i.push({
         path: "physicalCountsFormatted/errorBudgetLogical",
         label: "Logical error probability",
         description: "Probability of at least one logical error",
-        explanation: `This is one third of the total error budget ${r.physicalCountsFormatted.errorBudget} if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise.`
+        explanation: `This is one third of the total error budget ${e.physicalCountsFormatted.errorBudget} if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise.`
     }), i.push({
         path: "physicalCountsFormatted/errorBudgetTstates",
         label: "T distillation error probability",
         description: "Probability of at least one faulty T distillation",
-        explanation: `This is one third of the total error budget ${r.physicalCountsFormatted.errorBudget} if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise.`
+        explanation: `This is one third of the total error budget ${e.physicalCountsFormatted.errorBudget} if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise.`
     }), i.push({
         path: "physicalCountsFormatted/errorBudgetRotations",
         label: "Rotation synthesis error probability",
         description: "Probability of at least one failed rotation synthesis",
-        explanation: `This is one third of the total error budget ${r.physicalCountsFormatted.errorBudget}.`
-    }), e.push({
+        explanation: `This is one third of the total error budget ${e.physicalCountsFormatted.errorBudget}.`
+    }), r.push({
         title: "Assumed error budget",
         alwaysVisible: !1,
         entries: i
     }), i = [], i.push({
         path: "jobParams/qubitParams/name",
         label: "Qubit name",
         description: "Some descriptive name for the qubit model",
@@ -17128,60 +12718,60 @@
         description: "Underlying qubit technology (gate-based or Majorana)",
         explanation: "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits. The physical instruction set can be either _gate-based_ or _Majorana_. A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates. A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
     }), i.push({
         path: "jobParams/qubitParams/oneQubitMeasurementTime",
         label: "Single-qubit measurement time",
         description: "Operation time for single-qubit measurement (t_meas) in ns",
         explanation: "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
-    }), r.jobParams.qubitParams.instructionSet == "Majorana" && i.push({
+    }), e.jobParams.qubitParams.instructionSet == "Majorana" && i.push({
         path: "jobParams/qubitParams/twoQubitJointMeasurementTime",
         label: "Two-qubit measurement time",
         description: "Operation time for two-qubit measurement in ns",
         explanation: "This is the operation time in nanoseconds to perform a non-destructive two-qubit joint Pauli measurement."
-    }), r.jobParams.qubitParams.instructionSet == "GateBased" && i.push({
+    }), e.jobParams.qubitParams.instructionSet == "GateBased" && i.push({
         path: "jobParams/qubitParams/oneQubitGateTime",
         label: "Single-qubit gate time",
         description: "Operation time for single-qubit gate (t_gate) in ns",
         explanation: "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
-    }), r.jobParams.qubitParams.instructionSet == "GateBased" && i.push({
+    }), e.jobParams.qubitParams.instructionSet == "GateBased" && i.push({
         path: "jobParams/qubitParams/twoQubitGateTime",
         label: "Two-qubit gate time",
         description: "Operation time for two-qubit gate in ns",
         explanation: "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
     }), i.push({
         path: "jobParams/qubitParams/tGateTime",
         label: "T gate time",
         description: "Operation time for a T gate",
         explanation: "This is the operation time in nanoseconds to execute a T gate."
     }), i.push({
         path: "jobParams/qubitParams/oneQubitMeasurementErrorRate",
         label: "Single-qubit measurement error rate",
         description: "Error rate for single-qubit measurement",
         explanation: "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
-    }), r.jobParams.qubitParams.instructionSet == "Majorana" && i.push({
+    }), e.jobParams.qubitParams.instructionSet == "Majorana" && i.push({
         path: "jobParams/qubitParams/twoQubitJointMeasurementErrorRate",
         label: "Two-qubit measurement error rate",
         description: "Error rate for two-qubit measurement",
         explanation: "This is the probability in which a non-destructive two-qubit joint Pauli measurement may fail."
-    }), r.jobParams.qubitParams.instructionSet == "GateBased" && i.push({
+    }), e.jobParams.qubitParams.instructionSet == "GateBased" && i.push({
         path: "jobParams/qubitParams/oneQubitGateErrorRate",
         label: "Single-qubit error rate",
         description: "Error rate for single-qubit Clifford gate (p)",
         explanation: "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
-    }), r.jobParams.qubitParams.instructionSet == "GateBased" && i.push({
+    }), e.jobParams.qubitParams.instructionSet == "GateBased" && i.push({
         path: "jobParams/qubitParams/twoQubitGateErrorRate",
         label: "Two-qubit error rate",
         description: "Error rate for two-qubit Clifford gate",
         explanation: "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
     }), i.push({
         path: "jobParams/qubitParams/tGateErrorRate",
         label: "T gate error rate",
         description: "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
         explanation: "This is the probability in which executing a single T gate may fail."
-    }), e.push({
+    }), r.push({
         title: "Physical qubit parameters",
         alwaysVisible: !1,
         entries: i
     }), i = [], i.push({
         path: "physicalCountsFormatted/logicalDepthFactor",
         label: "Logical depth factor",
         description: "Factor the initial number of logical cycles is multiplied by",
@@ -17197,297 +12787,297 @@
         description: "The maximum runtime duration allowed for the algorithm runtime",
         explanation: "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
     }), i.push({
         path: "physicalCountsFormatted/maxPhysicalQubits",
         label: "Maximum number of physical qubits",
         description: "The maximum number of physical qubits allowed for utilization to the algorithm",
         explanation: "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
-    }), e.push({
+    }), r.push({
         title: "Constraints",
         alwaysVisible: !1,
         entries: i
     }), {
-        groups: e,
+        groups: r,
         assumptions: ["_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._", "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.", "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.", "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).", "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.", "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.", "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."]
     }
 }
-var Sh = function(r) {
-    let e = "ERROR: Rendered has not been set";
-    return console.error(e), e + ". " + r
+var b1 = function(e) {
+    let r = "ERROR: Rendered has not been set";
+    return console.error(r), r + ". " + e
 };
 
-function b0(r) {
-    let e = r.tagName || "div",
+function qr(e) {
+    let r = e.tagName || "div",
         i = {
-            className: r.className,
+            className: e.className,
             dangerouslySetInnerHTML: {
-                __html: Sh(r.markdown)
+                __html: b1(e.markdown)
             }
         };
-    return Fn(e, i)
+    return Jn(r, i)
 }
 
-function qr(r) {
-    let [e, i] = Xe(!1), a = () => {
-        i(!e)
-    }, l = Fa(r.estimatesData);
-    return M("div", {
-        children: [M("div", {
-            children: [M("input", {
+function O0(e) {
+    let [r, i] = Ze(!1), o = () => {
+        i(!r)
+    }, s = Ea(e.estimatesData);
+    return T("div", {
+        children: [T("div", {
+            children: [T("input", {
                 type: "checkbox",
                 id: "showDetail",
-                checked: e,
-                onClick: a
-            }), M("label", {
+                checked: r,
+                onClick: o
+            }), T("label", {
                 htmlFor: "showDetail",
                 children: " Show detailed rows"
             })]
-        }), l.groups.map(c => M("details", {
+        }), s.groups.map(l => T("details", {
             className: "estimate-details",
-            children: [M("summary", {
-                children: M("strong", {
-                    children: c.title
+            children: [T("summary", {
+                children: T("strong", {
+                    children: l.title
                 })
-            }), M("table", {
+            }), T("table", {
                 className: "estimate-table",
-                children: c.entries.map(d => {
-                    let g = d.path.split("/").reduce((y, _) => y[_], r.estimatesData);
-                    return typeof g == "object" && (g = JSON.stringify(g)), M("tr", {
-                        children: [M("td", {
+                children: l.entries.map(h => {
+                    let b = h.path.split("/").reduce((x, C) => x[C], e.estimatesData);
+                    return typeof b == "object" && (b = JSON.stringify(b)), T("tr", {
+                        children: [T("td", {
                             className: "estimate-cell title-cell",
-                            children: d.label
-                        }), M("td", {
+                            children: h.label
+                        }), T("td", {
                             className: "estimate-cell value-cell",
-                            children: g
-                        }), M("td", {
+                            children: b
+                        }), T("td", {
                             className: "estimate-cell",
-                            children: e ? M(Ge, {
-                                children: [M("strong", {
-                                    children: d.description
-                                }), M("hr", {}), M(b0, {
+                            children: r ? T(He, {
+                                children: [T("strong", {
+                                    children: h.description
+                                }), T("hr", {}), T(qr, {
                                     className: "estimate-explanation",
-                                    markdown: d.explanation
+                                    markdown: h.explanation
                                 })]
-                            }) : M(Ge, {
-                                children: M("span", {
-                                    children: d.description
+                            }) : T(He, {
+                                children: T("span", {
+                                    children: h.description
                                 })
                             })
                         })]
                     })
                 })
             })]
-        })), M("details", {
+        })), T("details", {
             className: "estimate-details",
-            children: [M("summary", {
-                children: M("strong", {
+            children: [T("summary", {
+                children: T("strong", {
                     children: "Assumptions"
                 })
-            }), M("ul", {
+            }), T("ul", {
                 className: "estimate-table",
-                children: l.assumptions.map(c => M(b0, {
+                children: s.assumptions.map(l => T(qr, {
                     className: "estimate-assumption",
-                    markdown: c,
+                    markdown: l,
                     tagName: "li"
                 }))
             })]
         })]
     })
 }
 
-function Ba(r, e, i, a, l, c) {
-    let d = l - a <= 180 ? "0" : "1",
-        f = r + i * Math.cos(Math.PI * a / 180),
-        g = e + i * Math.sin(Math.PI * a / 180),
-        y = r + i * Math.cos(Math.PI * l / 180),
-        _ = e + i * Math.sin(Math.PI * l / 180),
-        w = r + c * Math.cos(Math.PI * a / 180),
-        T = e + c * Math.sin(Math.PI * a / 180),
-        A = r + c * Math.cos(Math.PI * l / 180),
-        L = e + c * Math.sin(Math.PI * l / 180);
-    return `M ${f} ${g} A ${i} ${i} 0 ${d} 1 ${y} ${_} L ${A} ${L} A ${c} ${c} 0 ${d} 0 ${w} ${T} Z`
-}
-
-function Mr(r) {
-    let e = r.estimatesData.physicalCounts.breakdown,
-        i = e.physicalQubitsForAlgorithm,
-        a = e.physicalQubitsForTfactories,
-        c = 360 * (i / (i + a)),
-        d = c >= 360 ? 359.9 : c <= 0 ? .1 : c,
-        f = e.numTfactories,
-        g = Math.round(a / f);
-    return M("div", {
+function Ma(e, r, i, o, s, l) {
+    let h = s - o <= 180 ? "0" : "1",
+        p = e + i * Math.cos(Math.PI * o / 180),
+        b = r + i * Math.sin(Math.PI * o / 180),
+        x = e + i * Math.cos(Math.PI * s / 180),
+        C = r + i * Math.sin(Math.PI * s / 180),
+        k = e + l * Math.cos(Math.PI * o / 180),
+        F = r + l * Math.sin(Math.PI * o / 180),
+        E = e + l * Math.cos(Math.PI * s / 180),
+        M = r + l * Math.sin(Math.PI * s / 180);
+    return `M ${p} ${b} A ${i} ${i} 0 ${h} 1 ${x} ${C} L ${E} ${M} A ${l} ${l} 0 ${h} 0 ${k} ${F} Z`
+}
+
+function H0(e) {
+    let r = e.estimatesData.physicalCounts.breakdown,
+        i = r.physicalQubitsForAlgorithm,
+        o = r.physicalQubitsForTfactories,
+        l = 360 * (i / (i + o)),
+        h = l >= 360 ? 359.9 : l <= 0 ? .1 : l,
+        p = r.numTfactories,
+        b = Math.round(o / p);
+    return T("div", {
         style: "display: flex; flex-wrap: wrap; margin-top: 8px;",
-        children: [M("svg", {
+        children: [T("svg", {
             class: "qs-widget-spaceChart",
             width: "400",
             height: "400",
             viewBox: "50 0 450 450",
             id: "pieChart",
-            children: [M("path", {
-                d: Ba(250, 185, 180, 0, d, 120),
+            children: [T("path", {
+                d: Ma(250, 185, 180, 0, h, 120),
                 fill: "var(--vscode-charts-orange, orange)",
                 stroke: "white"
-            }), M("path", {
-                d: Ba(250, 185, 180, d, 360, 120),
+            }), T("path", {
+                d: Ma(250, 185, 180, h, 360, 120),
                 fill: "var(--vscode-charts-blue, blue)",
                 stroke: "white"
-            }), M("text", {
+            }), T("text", {
                 x: "250",
                 y: "180",
                 "text-anchor": "middle",
                 "font-size": "16",
                 children: "Total physical qubits"
-            }), M("text", {
+            }), T("text", {
                 x: "250",
                 y: "220",
                 "text-anchor": "middle",
                 "font-size": "32",
-                children: r.estimatesData.physicalCountsFormatted.physicalQubits
-            }), M("rect", {
+                children: e.estimatesData.physicalCountsFormatted.physicalQubits
+            }), T("rect", {
                 x: "125",
                 y: "400",
                 width: "25",
                 height: "25",
                 fill: "var(--vscode-charts-orange, orange)",
                 stroke: "white",
                 "stroke-width": "1"
-            }), M("text", {
+            }), T("text", {
                 x: "155",
                 y: "408",
                 "text-anchor": "start",
                 "font-size": "12",
                 children: "Algorithm qubits"
-            }), M("text", {
+            }), T("text", {
                 x: "155",
                 y: "425",
                 "text-anchor": "start",
                 "font-size": "16",
                 children: i.toLocaleString()
-            }), M("rect", {
+            }), T("rect", {
                 x: "275",
                 y: "400",
                 width: "25",
                 height: "25",
                 fill: "var(--vscode-charts-blue, blue)",
                 stroke: "white",
                 "stroke-width": "1"
-            }), M("text", {
+            }), T("text", {
                 x: "305",
                 y: "408",
                 "text-anchor": "start",
                 "font-size": "12",
                 children: "T factory qubits"
-            }), M("text", {
+            }), T("text", {
                 x: "305",
                 y: "425",
                 "text-anchor": "start",
                 "font-size": "16",
-                children: a.toLocaleString()
+                children: o.toLocaleString()
             })]
-        }), M("div", {
+        }), T("div", {
             class: "spaceReport",
-            children: [M("div", {
+            children: [T("div", {
                 class: "spaceReportHeader",
                 children: "Physical resource estimates"
-            }), M("div", {
+            }), T("div", {
                 class: "spaceReportRow",
-                children: [M("div", {
+                children: [T("div", {
                     class: "spaceDetailText",
                     children: "Total physical qubits"
-                }), M("div", {
-                    children: r.estimatesData.physicalCounts.physicalQubits.toLocaleString()
+                }), T("div", {
+                    children: e.estimatesData.physicalCounts.physicalQubits.toLocaleString()
                 })]
-            }), M("div", {
+            }), T("div", {
                 class: "spaceReportHeader",
                 children: "T factory parameters"
-            }), M("div", {
+            }), T("div", {
                 class: "spaceReportRow",
-                children: [M("div", {
+                children: [T("div", {
                     class: "spaceDetailText",
                     children: "Physical T factory qubits"
-                }), M("div", {
-                    children: e.physicalQubitsForTfactories.toLocaleString()
+                }), T("div", {
+                    children: r.physicalQubitsForTfactories.toLocaleString()
                 })]
-            }), M("div", {
+            }), T("div", {
                 class: "spaceReportHeader",
                 children: "Resource estimation breakdown"
-            }), M("div", {
+            }), T("div", {
                 class: "spaceReportRow",
-                children: [M("div", {
+                children: [T("div", {
                     class: "spaceDetailText",
                     children: "T factory copies"
-                }), M("div", {
-                    children: e.numTfactories.toLocaleString()
+                }), T("div", {
+                    children: r.numTfactories.toLocaleString()
                 })]
-            }), M("div", {
+            }), T("div", {
                 class: "spaceReportRow",
-                children: [M("div", {
+                children: [T("div", {
                     class: "spaceDetailText",
                     children: "Physical qubits per T factory"
-                }), M("div", {
-                    children: g.toLocaleString()
+                }), T("div", {
+                    children: b.toLocaleString()
                 })]
-            }), M("div", {
+            }), T("div", {
                 class: "spaceReportRow",
-                children: [M("div", {
+                children: [T("div", {
                     class: "spaceDetailText",
                     children: "Physical algorithmic qubits"
-                }), M("div", {
+                }), T("div", {
                     children: i.toLocaleString()
                 })]
-            }), M("div", {
+            }), T("div", {
                 class: "spaceReportRow",
-                children: [M("div", {
+                children: [T("div", {
                     class: "spaceDetailText",
                     children: "Logical algorithmic qubits"
-                }), M("div", {
-                    children: e.algorithmicLogicalQubits.toLocaleString()
+                }), T("div", {
+                    children: r.algorithmicLogicalQubits.toLocaleString()
                 })]
-            }), M("div", {
+            }), T("div", {
                 class: "spaceReportHeader",
                 children: "Logical qubit parameters"
-            }), M("div", {
+            }), T("div", {
                 class: "spaceReportRow",
-                children: [M("div", {
+                children: [T("div", {
                     class: "spaceDetailText",
                     children: "Physical qubits"
-                }), M("div", {
-                    children: r.estimatesData.logicalQubit.physicalQubits.toLocaleString()
+                }), T("div", {
+                    children: e.estimatesData.logicalQubit.physicalQubits.toLocaleString()
                 })]
             })]
         })]
     })
 }
 
-function Na(r, e) {
-    if (e < r || r <= 0) return [];
+function qa(e, r) {
+    if (r < e || e <= 0) return [];
     let i = new Intl.NumberFormat,
-        a = Math.round(10 ** Math.floor(Math.log10(r))),
-        l = Math.round(10 ** Math.ceil(Math.log10(e))),
-        c = [];
-    for (let d = a; d <= l; d *= 10) d >= r && d <= e && c.push({
-        value: d,
-        label: i.format(d)
+        o = Math.round(10 ** Math.floor(Math.log10(e))),
+        s = Math.round(10 ** Math.ceil(Math.log10(r))),
+        l = [];
+    for (let h = o; h <= s; h *= 10) h >= e && h <= r && l.push({
+        value: h,
+        label: i.format(h)
     });
-    if (c.length == 0) {
-        let d = a;
-        for (; d >= 1;) {
-            let f = Math.ceil(r / d) * d;
-            for (; f <= e;) c.push({
-                value: f,
-                label: i.format(f)
-            }), f += d;
-            if (c.length > 0) break;
-            d /= 10
+    if (l.length == 0) {
+        let h = o;
+        for (; h >= 1;) {
+            let p = Math.ceil(e / h) * h;
+            for (; p <= r;) l.push({
+                value: p,
+                label: i.format(p)
+            }), p += h;
+            if (l.length > 0) break;
+            h /= 10
         }
     }
-    return c
+    return l
 }
-var Je = [{
+var Xe = [{
     tick: {
         value: 1,
         label: "1 nanosecond"
     },
     plural: "nanoseconds"
 }, {
     tick: {
@@ -17553,1069 +13143,5713 @@
     tick: {
         value: 31536e14,
         label: "1 century"
     },
     plural: "centuries"
 }];
 
-function La(r, e) {
-    if (e < r || r <= 0) return [];
+function Fa(e, r) {
+    if (r < e || e <= 0) return [];
     let i = 0;
-    for (; i < Je.length && Je[i].tick.value <= r;) i++;
-    let a = i;
-    for (i > 0 && i--, a >= Je.length && (a = Je.length - 1); a < Je.length - 1 && Je[a].tick.value <= e;) a++;
-    let l = [];
-    for (let c = i; c <= a; c++) Je[c].tick.value >= r && Je[c].tick.value <= e && l.push(Je[c].tick);
-    if (l.length == 0)
-        if (i < Je.length - 1) {
-            let c = 10 ** Math.floor(Math.log10(Je[i + 1].tick.value / Je[i].tick.value));
+    for (; i < Xe.length && Xe[i].tick.value <= e;) i++;
+    let o = i;
+    for (i > 0 && i--, o >= Xe.length && (o = Xe.length - 1); o < Xe.length - 1 && Xe[o].tick.value <= r;) o++;
+    let s = [];
+    for (let l = i; l <= o; l++) Xe[l].tick.value >= e && Xe[l].tick.value <= r && s.push(Xe[l].tick);
+    if (s.length == 0)
+        if (i < Xe.length - 1) {
+            let l = 10 ** Math.floor(Math.log10(Xe[i + 1].tick.value / Xe[i].tick.value));
             do {
-                let d = 1,
-                    f = 0;
-                do f = Je[i].tick.value * d * c, f >= r && f <= e && l.push({
-                    value: f,
-                    label: (d * c).toString() + " " + Je[i].plural
-                }), d++; while ((d > 2 || l.length < 1) && f < Je[i + 1].tick.value);
-                c /= 10
-            } while (l.length < 1 && c >= 1)
+                let h = 1,
+                    p = 0;
+                do p = Xe[i].tick.value * h * l, p >= e && p <= r && s.push({
+                    value: p,
+                    label: (h * l).toString() + " " + Xe[i].plural
+                }), h++; while ((h > 2 || s.length < 1) && p < Xe[i + 1].tick.value);
+                l /= 10
+            } while (s.length < 1 && l >= 1)
         } else {
-            let c = Je.length - 1;
+            let l = Xe.length - 1;
             do {
-                let d = 10 ** Math.floor(Math.log10(e / Je[c].tick.value));
+                let h = 10 ** Math.floor(Math.log10(r / Xe[l].tick.value));
                 do {
-                    let f = 1,
-                        g = 0;
-                    do g = Je[c].tick.value * f * d, g >= r && g <= e && l.push({
-                        value: g,
-                        label: (f * d).toString() + " " + Je[c].plural
-                    }), f++; while ((f > 2 || l.length < 1) && g < e);
-                    d /= 10
-                } while (l.length < 1 && d >= 1);
-                c--
-            } while (l.length < 1 && c >= 0)
-        } return l
-}
-
-function Ch(r) {
-    return r.reduce((e, i) => i.items.reduce((a, l) => [Math.min(a[0], l.x), Math.max(a[1], l.x), Math.min(a[2], l.y), Math.max(a[3], l.y)], e), [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE])
-}
-
-function Pa(r, e) {
-    let [i, a, l, c] = Ch(r), d = {
-        min: i / e,
-        max: a * e
-    }, f = {
-        min: l / e,
-        max: c * e
+                    let p = 1,
+                        b = 0;
+                    do b = Xe[l].tick.value * p * h, b >= e && b <= r && s.push({
+                        value: b,
+                        label: (p * h).toString() + " " + Xe[l].plural
+                    }), p++; while ((p > 2 || s.length < 1) && b < r);
+                    h /= 10
+                } while (s.length < 1 && h >= 1);
+                l--
+            } while (s.length < 1 && l >= 0)
+        } return s
+}
+
+function g1(e) {
+    return e.reduce((r, i) => i.items.reduce((o, s) => [Math.min(o[0], s.x), Math.max(o[1], s.x), Math.min(o[2], s.y), Math.max(o[3], s.y)], r), [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE])
+}
+
+function za(e, r) {
+    let [i, o, s, l] = g1(e), h = {
+        min: i / r,
+        max: o * r
+    }, p = {
+        min: s / r,
+        max: l * r
     };
     return {
-        rangeX: d,
-        rangeY: f
+        rangeX: h,
+        rangeY: p
     }
 }
 
-function Hn(r) {
-    let e = St(null),
+function iu(e) {
+    let r = St(null),
         {
             rangeX: i,
-            rangeY: a
-        } = Pa(r.data, 2);
+            rangeY: o
+        } = za(e.data, 2);
 
-    function l(ae, ee) {
-        return ee ? La(ae.min, ae.max) : Na(ae.min, ae.max)
+    function s(ne, ee) {
+        return ee ? Fa(ne.min, ne.max) : qa(ne.min, ne.max)
     }
-    let c = l(i, r.xAxis.isTime),
-        d = l(a, r.yAxis.isTime);
+    let l = s(i, e.xAxis.isTime),
+        h = s(o, e.yAxis.isTime);
 
-    function f(ae, ee) {
-        return (Math.log(ae) - Math.log(ee.min)) / (Math.log(ee.max) - Math.log(ee.min))
-    }
-
-    function g(ae) {
-        return f(ae, i) * pe
-    }
-
-    function y(ae) {
-        return -f(ae, a) * ue
-    }
-    let _ = 20,
-        w = 100,
-        T = 5,
-        A = 1,
-        L = _ + w + T + A,
-        R = 160,
-        O = 20,
-        P = 16,
-        I = O + P + T + A,
-        Y = 960,
-        re = 50,
-        te = 480,
-        j = 10,
-        ne = -L,
-        pe = Y - L - R,
-        ue = te - I,
-        ce = `${ne} ${-ue-j} ${Y+re} ${te+j}`,
-        Ce = 5,
-        De = 4;
-
-    function U(ae, ee, G) {
-        let fe = ee.getAttribute("data-label");
-        G.textContent = fe;
-        let Te = G.offsetWidth / 2,
-            Ae = ee.getBoundingClientRect(),
-            qt = (Ae.top + Ae.bottom) / 2,
-            ct = (Ae.left + Ae.right) / 2,
-            Pt = ae.getBoundingClientRect();
-        G.style.left = `${ct-Pt.left-Te}px`, G.style.top = `${qt-Pt.top+12}px`, G.style.visibility = "visible"
-    }
-
-    function X(ae, ee) {
-        if (!(ae.target instanceof SVGCircleElement)) return;
-        let G = ae.target;
-        if (!G.classList.contains("qs-scatterChart-point")) return;
-        let fe = G.closest("div"),
-            Te = fe.querySelector(".qs-scatterChart-tooltip");
+    function p(ne, ee) {
+        return (Math.log(ne) - Math.log(ee.min)) / (Math.log(ee.max) - Math.log(ee.min))
+    }
+
+    function b(ne) {
+        return p(ne, i) * ge
+    }
+
+    function x(ne) {
+        return -p(ne, o) * ae
+    }
+    let C = 20,
+        k = 100,
+        F = 5,
+        E = 1,
+        M = C + k + F + E,
+        N = 160,
+        G = 20,
+        U = 16,
+        $ = G + U + F + E,
+        V = 960,
+        Y = 50,
+        X = 480,
+        te = 10,
+        ie = -M,
+        ge = V - M - N,
+        ae = X - $,
+        qe = `${ie} ${-ae-te} ${V+Y} ${X+te}`,
+        Ee = 5,
+        Ne = 4;
+
+    function W(ne, ee, O) {
+        let ce = ee.getAttribute("data-label");
+        O.textContent = ce;
+        let ke = O.offsetWidth / 2,
+            _e = ee.getBoundingClientRect(),
+            Mt = (_e.top + _e.bottom) / 2,
+            ct = (_e.left + _e.right) / 2,
+            Gt = ne.getBoundingClientRect();
+        O.style.left = `${ct-Gt.left-ke}px`, O.style.top = `${Mt-Gt.top+12}px`, O.style.visibility = "visible"
+    }
+
+    function Q(ne, ee) {
+        if (!(ne.target instanceof SVGCircleElement)) return;
+        let O = ne.target;
+        if (!O.classList.contains("qs-scatterChart-point")) return;
+        let ce = O.closest("div"),
+            ke = ce.querySelector(".qs-scatterChart-tooltip");
         switch (ee) {
             case "over":
-                U(fe, G, Te);
+                W(ce, O, ke);
                 break;
             case "out":
-                Te.style.visibility = "hidden";
+                ke.style.visibility = "hidden";
                 break;
             case "click":
-                if (G.classList.contains("qs-scatterChart-point-selected")) r.onPointSelected(-1, 0);
+                if (O.classList.contains("qs-scatterChart-point-selected")) e.onPointSelected(-1, 0);
                 else {
-                    let Ae = JSON.parse(G.getAttribute("data-index"));
-                    r.onPointSelected(Ae[0], Ae[1])
+                    let _e = JSON.parse(O.getAttribute("data-index"));
+                    e.onPointSelected(_e[0], _e[1])
                 }
                 break;
             default:
                 console.error("Unknown event type: ", ee)
         }
     }
 
-    function he() {
-        if (!r.selectedPoint) return null;
-        let ae = r.data[r.selectedPoint[0]];
+    function fe() {
+        if (!e.selectedPoint) return null;
+        let ne = e.data[e.selectedPoint[0]];
         return {
-            ...ae.items[r.selectedPoint[1]],
-            color: ae.color
+            ...ne.items[e.selectedPoint[1]],
+            color: ne.color
         }
     }
-    let oe = he();
-    return Ut(() => {
-        if (e.current)
-            if (!r.selectedPoint) e.current.style.visibility = "hidden";
+    let Qe = fe();
+    return Qt(() => {
+        if (r.current)
+            if (!e.selectedPoint) r.current.style.visibility = "hidden";
             else {
-                let ae = e.current.parentElement,
-                    ee = ae?.querySelector(".qs-scatterChart-point-selected");
+                let ne = r.current.parentElement,
+                    ee = ne?.querySelector(".qs-scatterChart-point-selected");
                 if (!ee) return;
-                U(ae, ee, e.current)
+                W(ne, ee, r.current)
             }
-    }), M("div", {
+    }), T("div", {
         style: "position: relative",
-        children: [M("svg", {
+        children: [T("svg", {
             style: "margin-top: 12px",
-            viewBox: ce,
-            width: Y,
-            height: te,
-            onMouseOver: ae => X(ae, "over"),
-            onMouseOut: ae => X(ae, "out"),
-            onClick: ae => X(ae, "click"),
-            children: [M("line", {
+            viewBox: qe,
+            width: V,
+            height: X,
+            onMouseOver: ne => Q(ne, "over"),
+            onMouseOut: ne => Q(ne, "out"),
+            onClick: ne => Q(ne, "click"),
+            children: [T("line", {
                 class: "qs-scatterChart-axis",
                 x1: "0",
                 y1: "0",
-                x2: pe,
+                x2: ge,
                 y2: "0"
-            }), c.map(ae => M(Ge, {
-                children: [M("line", {
+            }), l.map(ne => T(He, {
+                children: [T("line", {
                     y1: "1",
-                    y2: T,
-                    x1: g(ae.value),
-                    x2: g(ae.value),
+                    y2: F,
+                    x1: b(ne.value),
+                    x2: b(ne.value),
                     class: "qs-scatterChart-tick-line"
-                }), M("text", {
-                    y: T + P,
-                    x: g(ae.value),
+                }), T("text", {
+                    y: F + U,
+                    x: b(ne.value),
                     class: "qs-scatterChart-x-tick-text",
-                    children: ae.label
+                    children: ne.label
                 })]
-            })), M("line", {
+            })), T("line", {
                 class: "qs-scatterChart-axis",
                 x1: "0",
                 y1: "0",
                 x2: "0",
-                y2: -te
-            }), d.map(ae => M(Ge, {
-                children: [M("line", {
+                y2: -X
+            }), h.map(ne => T(He, {
+                children: [T("line", {
                     x1: "0",
-                    x2: -T,
-                    y1: y(ae.value),
-                    y2: y(ae.value),
+                    x2: -F,
+                    y1: x(ne.value),
+                    y2: x(ne.value),
                     class: "qs-scatterChart-tick-line"
-                }), M("text", {
-                    x: -T - Ce,
-                    y: y(ae.value) + De,
+                }), T("text", {
+                    x: -F - Ee,
+                    y: x(ne.value) + Ne,
                     class: "qs-scatterChart-y-tick-text",
-                    children: ae.label
+                    children: ne.label
                 })]
-            })), M("text", {
-                x: pe / 2,
-                y: I,
+            })), T("text", {
+                x: ge / 2,
+                y: $,
                 class: "qs-scatterChart-x-axisTitle",
-                children: [r.xAxis.label, " (logarithmic)"]
-            }), M("text", {
-                x: L - O,
-                y: ue / 2,
+                children: [e.xAxis.label, " (logarithmic)"]
+            }), T("text", {
+                x: M - G,
+                y: ae / 2,
                 class: "qs-scatterChart-y-axisTitle",
-                children: [r.yAxis.label, " (logarithmic)"]
-            }), M("text", {
+                children: [e.yAxis.label, " (logarithmic)"]
+            }), T("text", {
                 class: "qs-scatterChart-watermark",
-                x: L - O,
-                y: -te + I,
+                x: M - G,
+                y: -X + $,
                 children: "Created with Azure Quantum Resource Estimator"
-            }), M("g", {
-                children: r.data.map((ae, ee) => {
-                    let G = ae.items.map(Te => ({
-                            x: g(Te.x),
-                            y: y(Te.y)
+            }), T("g", {
+                children: e.data.map((ne, ee) => {
+                    let O = ne.items.map(ke => ({
+                            x: b(ke.x),
+                            y: x(ke.y)
                         })),
-                        fe = G.map(Te => `${Te.x},${Te.y}`).join(" ");
-                    return M(Ge, {
-                        children: [ae.items.map((Te, Ae) => M("circle", {
-                            "data-index": JSON.stringify([ee, Ae]),
-                            "data-label": Te.label,
+                        ce = O.map(ke => `${ke.x},${ke.y}`).join(" ");
+                    return T(He, {
+                        children: [ne.items.map((ke, _e) => T("circle", {
+                            "data-index": JSON.stringify([ee, _e]),
+                            "data-label": ke.label,
                             className: "qs-scatterChart-point qs-scatterChart-hover",
-                            cx: G[Ae].x,
-                            cy: G[Ae].y,
-                            stroke: ae.color
-                        }, Ae)), M("polyline", {
-                            points: fe,
-                            stroke: ae.color,
+                            cx: O[_e].x,
+                            cy: O[_e].y,
+                            stroke: ne.color
+                        }, _e)), T("polyline", {
+                            points: ce,
+                            stroke: ne.color,
                             fill: "none"
                         })]
                     })
                 })
-            }), oe ? M("circle", {
+            }), Qe ? T("circle", {
                 class: "qs-scatterChart-point qs-scatterChart-point-selected",
-                "data-label": oe.label,
-                cx: g(oe.x),
-                cy: y(oe.y),
-                stroke: oe.color
+                "data-label": Qe.label,
+                cx: b(Qe.x),
+                cy: x(Qe.y),
+                stroke: Qe.color
             }) : null]
-        }), M("div", {
+        }), T("div", {
             class: "qs-scatterChart-selectedInfo",
-            ref: e
-        }), M("div", {
+            ref: r
+        }), T("div", {
             class: "qs-scatterChart-tooltip"
         })]
     })
 }
 
-function Ia(r) {
-    let e = [],
+function Ra(e) {
+    let r = [],
         i = 1.4142135623730951,
-        a = .618033988749895,
-        l = 2.718281828459045;
-    for (let c = 0; c < r; c++) {
-        let d = c * a % 1,
-            f = (1 - c * i % 1) * .5 + .5,
-            g = c * l % 1 * .3 + .35,
-            y = Ah(d, f, g),
-            _ = qh(y[0], y[1], y[2]);
-        e.push(_)
+        o = .618033988749895,
+        s = 2.718281828459045;
+    for (let l = 0; l < e; l++) {
+        let h = l * o % 1,
+            p = (1 - l * i % 1) * .5 + .5,
+            b = l * s % 1 * .3 + .35,
+            x = y1(h, p, b),
+            C = v1(x[0], x[1], x[2]);
+        r.push(C)
     }
-    return e
+    return r
 }
 
-function Ah(r, e, i) {
-    let a, l, c;
-    if (e === 0) a = l = c = i;
+function y1(e, r, i) {
+    let o, s, l;
+    if (r === 0) o = s = l = i;
     else {
-        let d = (y, _, w) => (w < 0 && (w += 1), w > 1 && (w -= 1), w < .16666666666666666 ? y + (_ - y) * 6 * w : w < .5 ? _ : w < .6666666666666666 ? y + (_ - y) * (.6666666666666666 - w) * 6 : y),
-            f = i < .5 ? i * (1 + e) : i + e - i * e,
-            g = 2 * i - f;
-        a = d(g, f, r + 1 / 3), l = d(g, f, r), c = d(g, f, r - 1 / 3)
+        let h = (x, C, k) => (k < 0 && (k += 1), k > 1 && (k -= 1), k < .16666666666666666 ? x + (C - x) * 6 * k : k < .5 ? C : k < .6666666666666666 ? x + (C - x) * (.6666666666666666 - k) * 6 : x),
+            p = i < .5 ? i * (1 + r) : i + r - i * r,
+            b = 2 * i - p;
+        o = h(b, p, e + 1 / 3), s = h(b, p, e), l = h(b, p, e - 1 / 3)
     }
-    return [Math.round(a * 255), Math.round(l * 255), Math.round(c * 255)]
+    return [Math.round(o * 255), Math.round(s * 255), Math.round(l * 255)]
 }
 
-function qh(r, e, i) {
-    return `#${(1<<24|r<<16|e<<8|i).toString(16).slice(1).toUpperCase()}`
+function v1(e, r, i) {
+    return `#${(1<<24|e<<16|r<<8|i).toString(16).slice(1).toUpperCase()}`
 }
 
-function Oa(r) {
-    let [e, i] = Xe(r.initialColumns), [a, l] = Xe(null), [c, d] = Xe(!1), [f, g] = Xe(""), y = St(""), _ = St(null);
+function Ba(e) {
+    let [r, i] = Ze(e.initialColumns), [o, s] = Ze(null), [l, h] = Ze(!1), [p, b] = Ze(""), x = St(""), C = St(null);
 
-    function w(U) {
-        if (!(U.target instanceof HTMLElement)) return;
-        let X = U.target.closest("th")?.dataset.colid;
-        y.current = X, U.dataTransfer.dropEffect = "move"
+    function k(W) {
+        if (!(W.target instanceof HTMLElement)) return;
+        let Q = W.target.closest("th")?.dataset.colid;
+        x.current = Q, W.dataTransfer.dropEffect = "move"
     }
 
-    function T(U) {
-        if (!(U.target instanceof HTMLElement)) return;
-        let X = U.target.closest("th")?.dataset.colid;
-        !X || !y.current || y.current !== X && (U.preventDefault(), U.dataTransfer.dropEffect = "move", U.target.closest("table").querySelectorAll(`[data-colid="${X}"]`).forEach(he => he.classList.add("qs-resultsTable-dragEnter")))
+    function F(W) {
+        if (!(W.target instanceof HTMLElement)) return;
+        let Q = W.target.closest("th")?.dataset.colid;
+        !Q || !x.current || x.current !== Q && (W.preventDefault(), W.dataTransfer.dropEffect = "move", W.target.closest("table").querySelectorAll(`[data-colid="${Q}"]`).forEach(fe => fe.classList.add("qs-resultsTable-dragEnter")))
     }
 
-    function A(U) {
-        r.onRowSelected(U)
+    function E(W) {
+        e.onRowSelected(W)
     }
 
-    function L(U) {
-        if (!(U.target instanceof HTMLElement)) return;
-        let X = U.target.closest("th")?.dataset.colid;
-        !X || !y.current || y.current !== X && (U.dataTransfer.dropEffect = "move", U.preventDefault())
+    function M(W) {
+        if (!(W.target instanceof HTMLElement)) return;
+        let Q = W.target.closest("th")?.dataset.colid;
+        !Q || !x.current || x.current !== Q && (W.dataTransfer.dropEffect = "move", W.preventDefault())
     }
 
-    function R(U) {
-        if (!(U.target instanceof HTMLElement)) return;
-        let X = U.target.closest("th")?.dataset.colid;
-        X && (U.target.closest("table").querySelectorAll(`[data-colid="${X}"]`).forEach(he => he.classList.remove("qs-resultsTable-dragEnter")), U.preventDefault())
+    function N(W) {
+        if (!(W.target instanceof HTMLElement)) return;
+        let Q = W.target.closest("th")?.dataset.colid;
+        Q && (W.target.closest("table").querySelectorAll(`[data-colid="${Q}"]`).forEach(fe => fe.classList.remove("qs-resultsTable-dragEnter")), W.preventDefault())
     }
 
-    function O(U) {
-        if (!(U.target instanceof HTMLElement)) return;
-        let X = U.target.closest("th")?.dataset.colid;
-        X && y.current && (I(parseInt(y.current), parseInt(X)), U.preventDefault())
+    function G(W) {
+        if (!(W.target instanceof HTMLElement)) return;
+        let Q = W.target.closest("th")?.dataset.colid;
+        Q && x.current && ($(parseInt(x.current), parseInt(Q)), W.preventDefault())
     }
 
-    function P(U) {
-        U.target.closest("table").querySelectorAll("th, td").forEach(X => X.classList.remove("qs-resultsTable-dragEnter")), y.current = ""
+    function U(W) {
+        W.target.closest("table").querySelectorAll("th, td").forEach(Q => Q.classList.remove("qs-resultsTable-dragEnter")), x.current = ""
     }
 
-    function I(U, X) {
-        let he = e.indexOf(U),
-            oe = e.indexOf(X),
-            ae = [...e],
-            ee = ae.splice(he, 1);
-        ae.splice(oe, 0, ...ee), i(ae)
+    function $(W, Q) {
+        let fe = r.indexOf(W),
+            Qe = r.indexOf(Q),
+            ne = [...r],
+            ee = ne.splice(fe, 1);
+        ne.splice(Qe, 0, ...ee), i(ne)
     }
 
-    function Y(U) {
-        if (!(U.currentTarget instanceof HTMLTableCellElement)) return;
-        let X = U.currentTarget.dataset.colid;
-        a && X === a.columnId.toString() ? l({
-            columnId: a.columnId,
-            ascending: !a.ascending
-        }) : l({
-            columnId: parseInt(X),
+    function V(W) {
+        if (!(W.currentTarget instanceof HTMLTableCellElement)) return;
+        let Q = W.currentTarget.dataset.colid;
+        o && Q === o.columnId.toString() ? s({
+            columnId: o.columnId,
+            ascending: !o.ascending
+        }) : s({
+            columnId: parseInt(Q),
             ascending: !0
         })
     }
 
-    function re(U) {
-        if (!a) return U;
-        let X = a.columnId,
-            he = a.ascending,
-            oe = [...U];
-        return oe.sort((ae, ee) => {
-            let G = ae.cells[X],
-                fe = ee.cells[X];
-            return typeof G == "string" && typeof fe == "string" ? he ? G.localeCompare(fe) : fe.localeCompare(G) : typeof G == "number" && typeof fe == "number" ? he ? G - fe : fe - G : typeof G == "object" && typeof fe == "object" ? he ? G.sortBy - fe.sortBy : fe.sortBy - G.sortBy : 0
-        }), oe
+    function Y(W) {
+        if (!o) return W;
+        let Q = o.columnId,
+            fe = o.ascending,
+            Qe = [...W];
+        return Qe.sort((ne, ee) => {
+            let O = ne.cells[Q],
+                ce = ee.cells[Q];
+            return typeof O == "string" && typeof ce == "string" ? fe ? O.localeCompare(ce) : ce.localeCompare(O) : typeof O == "number" && typeof ce == "number" ? fe ? O - ce : ce - O : typeof O == "object" && typeof ce == "object" ? fe ? O.sortBy - ce.sortBy : ce.sortBy - O.sortBy : 0
+        }), Qe
     }
 
-    function te(U) {
-        return typeof U == "object" ? U.value : typeof U == "number" ? U.toLocaleString() : U || ""
+    function X(W) {
+        return typeof W == "object" ? W.value : typeof W == "number" ? W.toLocaleString() : W || ""
     }
 
-    function j(U) {
-        let X = r.selectedRow === U ? "" : U;
-        A(X)
+    function te(W) {
+        let Q = e.selectedRow === W ? "" : W;
+        E(Q)
     }
 
-    function ne(U, X) {
-        U.stopPropagation(), g(f === X ? "" : X)
+    function ie(W, Q) {
+        W.stopPropagation(), b(p === Q ? "" : Q)
     }
 
-    function pe(U) {
-        U.stopPropagation(), g(""), d(!c)
+    function ge(W) {
+        W.stopPropagation(), b(""), h(!l)
     }
 
-    function ue() {
-        return r.columnNames.map((U, X) => ({
-            name: U,
-            idx: X,
-            show: e.includes(X)
+    function ae() {
+        return e.columnNames.map((W, Q) => ({
+            name: W,
+            idx: Q,
+            show: r.includes(Q)
         }))
     }
 
-    function ce(U) {
-        let X = [...e],
-            he = X.indexOf(U);
-        he === -1 ? U > X.length ? X.push(U) : X.splice(U, 0, U) : X.splice(he, 1), i(X)
+    function qe(W) {
+        let Q = [...r],
+            fe = Q.indexOf(W);
+        fe === -1 ? W > Q.length ? Q.push(W) : Q.splice(W, 0, W) : Q.splice(fe, 1), i(Q)
     }
 
-    function Ce(U, X) {
-        U.stopPropagation(), g(""), r.selectedRow === X && A(""), r.onRowDeleted(X)
+    function Ee(W, Q) {
+        W.stopPropagation(), b(""), e.selectedRow === Q && E(""), e.onRowDeleted(Q)
     }
 
-    function De(U) {
-        if (!r.selectedRow) return;
-        let X = re(r.rows).map(oe => oe.cells[0].toString()),
-            he = X.indexOf(r.selectedRow);
-        switch (U.code) {
+    function Ne(W) {
+        if (!e.selectedRow) return;
+        let Q = Y(e.rows).map(Qe => Qe.cells[0].toString()),
+            fe = Q.indexOf(e.selectedRow);
+        switch (W.code) {
             case "ArrowDown":
-                he < X.length - 1 && (U.preventDefault(), r.onRowSelected(X[he + 1]));
+                fe < Q.length - 1 && (W.preventDefault(), e.onRowSelected(Q[fe + 1]));
                 break;
             case "ArrowUp":
-                he > 0 && (U.preventDefault(), r.onRowSelected(X[he - 1]));
+                fe > 0 && (W.preventDefault(), e.onRowSelected(Q[fe - 1]));
                 break;
             default:
         }
     }
-    return Ut(() => {
-        c && _.current && _.current.focus()
-    }), M("table", {
+    return Qt(() => {
+        l && C.current && C.current.focus()
+    }), T("table", {
         class: "qs-resultsTable-sortedTable",
         tabIndex: 0,
-        onKeyDown: De,
-        children: [M("thead", {
-            children: M("tr", {
-                children: [M("th", {
-                    children: M("div", {
+        onKeyDown: Ne,
+        children: [T("thead", {
+            children: T("tr", {
+                children: [T("th", {
+                    children: T("div", {
                         style: "position: relative",
                         tabIndex: 0,
-                        onBlur: () => d(!1),
-                        children: [M("svg", {
+                        onBlur: () => h(!1),
+                        children: [T("svg", {
                             width: "16",
                             height: "16",
                             style: "position: relative;",
-                            onClick: pe,
-                            children: [M("rect", {
+                            onClick: ge,
+                            children: [T("rect", {
                                 x: "1",
                                 y: "3.5",
                                 width: "14",
                                 height: "2",
                                 fill: "black"
-                            }), M("rect", {
+                            }), T("rect", {
                                 x: "1",
                                 y: "3",
                                 width: "14",
                                 height: "12",
                                 stroke: "gray",
                                 "stroke-width": "1",
                                 fill: "none",
                                 rx: "2"
-                            }), M("path", {
+                            }), T("path", {
                                 stroke: "gray",
                                 "stroke-width": "1",
                                 d: "M4.5,3 V15 M8,3 V15 M11.5,3 V15"
                             })]
-                        }), M("div", {
-                            ref: _,
-                            class: c ? "qs-resultsTable-columnMenu qs-resultsTable-showColumnMenu" : "qs-resultsTable-columnMenu",
+                        }), T("div", {
+                            ref: C,
+                            class: l ? "qs-resultsTable-columnMenu qs-resultsTable-showColumnMenu" : "qs-resultsTable-columnMenu",
                             style: "position: absolute; top: 16; left: 0;",
-                            children: ue().map(U => M("div", {
+                            children: ae().map(W => T("div", {
                                 width: "100px",
                                 height: "20px",
-                                class: U.show ? "qs-resultsTable-columnSelected" : "qs-resultsTable-menuItem",
-                                onClick: () => ce(U.idx),
-                                children: U.name
+                                class: W.show ? "qs-resultsTable-columnSelected" : "qs-resultsTable-menuItem",
+                                onClick: () => qe(W.idx),
+                                children: W.name
                             }))
                         })]
                     })
-                }), e.map(U => {
-                    let X = a?.columnId === U;
-                    return M("th", {
-                        onClick: Y,
-                        "data-colid": U.toString(),
-                        children: [M("span", {
-                            class: X ? "qs-resultsTable-sortHeaderCell" : "qs-resultsTable-headerCell",
+                }), r.map(W => {
+                    let Q = o?.columnId === W;
+                    return T("th", {
+                        onClick: V,
+                        "data-colid": W.toString(),
+                        children: [T("span", {
+                            class: Q ? "qs-resultsTable-sortHeaderCell" : "qs-resultsTable-headerCell",
                             draggable: !0,
-                            onDragStart: w,
-                            onDragEnter: T,
-                            onDragOver: L,
-                            onDragLeave: R,
-                            onDragEnd: P,
-                            onDrop: O,
-                            children: r.columnNames[U]
-                        }), X ? M("svg", {
+                            onDragStart: k,
+                            onDragEnter: F,
+                            onDragOver: M,
+                            onDragLeave: N,
+                            onDragEnd: U,
+                            onDrop: G,
+                            children: e.columnNames[W]
+                        }), Q ? T("svg", {
                             width: "16",
                             height: "16",
-                            style: `transform: rotate(${a.ascending?"0":"180"}deg)`,
-                            children: M("polygon", {
+                            style: `transform: rotate(${o.ascending?"0":"180"}deg)`,
+                            children: T("polygon", {
                                 fill: "gray",
                                 points: "2,10 8,4 14,10"
                             })
                         }) : null]
                     })
                 })]
             })
-        }), M("tbody", {
-            children: re(r.rows).map(U => {
-                let X = U.cells[0].toString();
-                return M("tr", {
-                    onClick: () => j(X),
-                    "data-rowid": X,
-                    class: X === r.selectedRow ? "qs-resultsTable-sortedTableSelectedRow" : void 0,
-                    children: [M("td", {
-                        children: M("div", {
+        }), T("tbody", {
+            children: Y(e.rows).map(W => {
+                let Q = W.cells[0].toString();
+                return T("tr", {
+                    onClick: () => te(Q),
+                    "data-rowid": Q,
+                    class: Q === e.selectedRow ? "qs-resultsTable-sortedTableSelectedRow" : void 0,
+                    children: [T("td", {
+                        children: T("div", {
                             style: "position: relative",
-                            onClick: he => ne(he, X),
-                            children: [M("svg", {
+                            onClick: fe => ie(fe, Q),
+                            children: [T("svg", {
                                 width: "16",
                                 height: "16",
                                 style: "position: relative;",
-                                children: M("path", {
+                                children: T("path", {
                                     "stroke-width": "1.5",
-                                    stroke: U.color,
+                                    stroke: W.color,
                                     "stroke-linecap": "round",
                                     d: "M4,5 h8 M4,8 h8 M4,11 h8"
                                 })
-                            }), f === X ? M("div", {
+                            }), p === Q ? T("div", {
                                 class: "qs-resultsTable-showColumnMenu",
                                 style: "top: 16px; left: 0px;",
-                                children: M("div", {
+                                children: T("div", {
                                     class: "qs-resultsTable-menuItem",
-                                    onClick: he => Ce(he, X),
+                                    onClick: fe => Ee(fe, Q),
                                     children: "Delete"
                                 })
                             }) : null]
                         })
-                    }), e.map(he => M("td", {
-                        "data-colid": he.toString(),
-                        children: te(U.cells[he])
+                    }), r.map(fe => T("td", {
+                        "data-colid": fe.toString(),
+                        children: X(W.cells[fe])
                     }))]
                 })
             })
         })]
     })
 }
-var Mh = ["Run name", "Estimate type", "Qubit type", "QEC scheme", "Error budget", "Logical qubits", "Logical depth", "Code distance", "T states", "T factories", "T factory fraction", "Runtime", "rQOPS", "Physical qubits"],
-    Eh = [0, 10, 13, 11, 12],
-    Dh = {
+var w1 = ["Run name", "Estimate type", "Qubit type", "QEC scheme", "Error budget", "Logical qubits", "Logical depth", "Code distance", "T states", "T factories", "T factory fraction", "Runtime", "rQOPS", "Physical qubits"],
+    k1 = [0, 10, 13, 11, 12],
+    _1 = {
         isTime: !0,
         label: "Runtime"
     },
-    zh = {
+    C1 = {
         isTime: !1,
         label: "Physical qubits"
     };
 
-function Rh(r, e) {
-    let i = jt(r, 0),
-        a = r.frontierEntries == null ? "Single" : "Frontier (" + r.frontierEntries.length + "  items)";
+function S1(e, r) {
+    let i = Xt(e, 0),
+        o = e.frontierEntries == null ? "Single" : "Frontier (" + e.frontierEntries.length + "  items)";
     return {
-        cells: [i.jobParams.runName, a, i.jobParams.qubitParams.name, i.jobParams.qecScheme.name, i.jobParams.errorBudget, i.physicalCounts.breakdown.algorithmicLogicalQubits, i.physicalCounts.breakdown.algorithmicLogicalDepth, i.logicalQubit.codeDistance, i.physicalCounts.breakdown.numTstates, i.physicalCounts.breakdown.numTfactories, i.physicalCountsFormatted.physicalQubitsForTfactoriesPercentage, {
+        cells: [i.jobParams.runName, o, i.jobParams.qubitParams.name, i.jobParams.qecScheme.name, i.jobParams.errorBudget, i.physicalCounts.breakdown.algorithmicLogicalQubits, i.physicalCounts.breakdown.algorithmicLogicalDepth, i.logicalQubit.codeDistance, i.physicalCounts.breakdown.numTstates, i.physicalCounts.breakdown.numTfactories, i.physicalCountsFormatted.physicalQubitsForTfactoriesPercentage, {
             value: i.physicalCountsFormatted.runtime,
             sortBy: i.physicalCounts.runtime
         }, i.physicalCounts.rqops, i.physicalCounts.physicalQubits],
-        color: e
+        color: r
     }
 }
 
-function Fh(r) {
+function A1(e) {
     return {
-        x: r.physicalCounts.runtime,
-        y: r.physicalCounts.physicalQubits,
-        label: r.physicalCountsFormatted.runtime + ", physical qubits: " + r.physicalCountsFormatted.physicalQubits + ", code distance: " + r.logicalQubit.codeDistance
+        x: e.physicalCounts.runtime,
+        y: e.physicalCounts.physicalQubits,
+        label: e.physicalCountsFormatted.runtime + ", physical qubits: " + e.physicalCountsFormatted.physicalQubits + ", code distance: " + e.logicalQubit.codeDistance
     }
 }
 
-function Bh(r, e) {
-    return r.frontierEntries == null || r.frontierEntries.length === 0 ? {
-        color: e,
+function T1(e, r) {
+    return e.frontierEntries == null || e.frontierEntries.length === 0 ? {
+        color: r,
         items: [{
-            x: r.physicalCounts.runtime,
-            y: r.physicalCounts.physicalQubits,
-            label: r.physicalCountsFormatted.runtime + ", physical qubits: " + r.physicalCountsFormatted.physicalQubits + ", code distance: " + r.logicalQubit.codeDistance
+            x: e.physicalCounts.runtime,
+            y: e.physicalCounts.physicalQubits,
+            label: e.physicalCountsFormatted.runtime + ", physical qubits: " + e.physicalCountsFormatted.physicalQubits + ", code distance: " + e.logicalQubit.codeDistance
         }]
     } : {
-        color: e,
-        items: r.frontierEntries.map(Fh)
+        color: r,
+        items: e.frontierEntries.map(A1)
     }
 }
 
-function Nh(r) {
-    if (r.length === 1) return [r[0].jobParams.sharedRunName ?? r[0].jobParams.qubitParams.name ?? r[0].jobParams.qecScheme.name ?? "estimate"];
-    let e = [];
-    r.forEach(() => {
-        e.push([])
-    }), y0(e, r, a => a.jobParams.sharedRunName), y0(e, r, a => a.jobParams.qubitParams.name), y0(e, r, a => a.jobParams.qecScheme.name), y0(e, r, a => String(a.jobParams.errorBudget));
-    let i = e.map(a => a.join(", "));
-    return new Set(i).size != i.length ? i.map((a, l) => a + " (" + l + ")") : i
+function D1(e) {
+    if (e.length === 1) return [e[0].jobParams.sharedRunName ?? e[0].jobParams.qubitParams.name ?? e[0].jobParams.qecScheme.name ?? "estimate"];
+    let r = [];
+    e.forEach(() => {
+        r.push([])
+    }), Fr(r, e, o => o.jobParams.sharedRunName), Fr(r, e, o => o.jobParams.qubitParams.name), Fr(r, e, o => o.jobParams.qecScheme.name), Fr(r, e, o => String(o.jobParams.errorBudget));
+    let i = r.map(o => o.join(", "));
+    return new Set(i).size != i.length ? i.map((o, s) => o + " (" + s + ")") : i
 }
 
-function y0(r, e, i) {
-    let a = e.map(i);
-    new Set(a).size > 1 && a.forEach((c, d) => {
-        r[d].push(c)
+function Fr(e, r, i) {
+    let o = r.map(i);
+    new Set(o).size > 1 && o.forEach((l, h) => {
+        e[h].push(l)
     })
 }
 
-function Er(r) {
-    let [e, i] = Xe(null), [a, l] = Xe(), c = r.runNames != null && r.runNames.length > 0 && r.runNames.length != r.estimatesData.length ? "Warning: The number of runNames does not match the number of estimates. Ignoring provided runNames." : "", d = r.runNames != null && r.runNames.length == r.estimatesData.length ? r.runNames : Nh(r.estimatesData);
-    r.estimatesData.forEach((A, L) => {
-        A.jobParams.runName = d[L]
+function $0(e) {
+    let [r, i] = Ze(null), [o, s] = Ze(), l = e.runNames != null && e.runNames.length > 0 && e.runNames.length != e.estimatesData.length ? "Warning: The number of runNames does not match the number of estimates. Ignoring provided runNames." : "", h = e.runNames != null && e.runNames.length == e.estimatesData.length ? e.runNames : D1(e.estimatesData);
+    e.estimatesData.forEach((E, M) => {
+        E.jobParams.runName = h[M]
     });
 
-    function f(A, L) {
-        if (A < 0) {
-            g("");
+    function p(E, M) {
+        if (E < 0) {
+            b("");
             return
         }
-        let R = r.estimatesData[A];
-        r.setEstimate(jt(R, L));
-        let O = r.estimatesData[A].jobParams.runName;
-        i(O), l([A, L])
+        let N = e.estimatesData[E];
+        e.setEstimate(Xt(N, M));
+        let G = e.estimatesData[E].jobParams.runName;
+        i(G), s([E, M])
     }
 
-    function g(A) {
-        if (i(A), !A) r.setEstimate(null), l(void 0);
+    function b(E) {
+        if (i(E), !E) e.setEstimate(null), s(void 0);
         else {
-            let L = r.estimatesData.findIndex(R => R.jobParams.runName === A);
-            if (L == -1) r.setEstimate(null), l(void 0);
+            let M = e.estimatesData.findIndex(N => N.jobParams.runName === E);
+            if (M == -1) e.setEstimate(null), s(void 0);
             else {
-                let R = r.estimatesData[L];
-                l([L, 0]), r.setEstimate(jt(R, 0))
+                let N = e.estimatesData[M];
+                s([M, 0]), e.setEstimate(Xt(N, 0))
             }
         }
     }
-    let y = r.colors != null && r.colors.length > 0 && r.colors.length != r.estimatesData.length ? "Warning: The number of colors does not match the number of estimates. Ignoring provided colors." : "",
-        _ = r.colors != null && r.colors.length == r.estimatesData.length ? r.colors : Ia(r.estimatesData.length);
+    let x = e.colors != null && e.colors.length > 0 && e.colors.length != e.estimatesData.length ? "Warning: The number of colors does not match the number of estimates. Ignoring provided colors." : "",
+        C = e.colors != null && e.colors.length == e.estimatesData.length ? e.colors : Ra(e.estimatesData.length);
 
-    function w() {
-        return M(Oa, {
-            columnNames: Mh,
-            rows: r.estimatesData.map((A, L) => Rh(A, _[L])),
-            initialColumns: Eh,
-            selectedRow: e,
-            onRowSelected: g,
-            onRowDeleted: r.onRowDeleted
+    function k() {
+        return T(Ba, {
+            columnNames: w1,
+            rows: e.estimatesData.map((E, M) => S1(E, C[M])),
+            initialColumns: k1,
+            selectedRow: r,
+            onRowSelected: b,
+            onRowDeleted: e.onRowDeleted
         })
     }
 
-    function T() {
-        return M(Hn, {
-            xAxis: Dh,
-            yAxis: zh,
-            data: r.estimatesData.map((A, L) => Bh(A, _[L])),
-            onPointSelected: f,
-            selectedPoint: a
+    function F() {
+        return T(iu, {
+            xAxis: _1,
+            yAxis: C1,
+            data: e.estimatesData.map((E, M) => T1(E, C[M])),
+            onPointSelected: p,
+            selectedPoint: o
         })
     }
-    return M("div", {
+    return T("div", {
         className: "qs-estimatesOverview",
-        children: [c != "" && M("div", {
+        children: [l != "" && T("div", {
             class: "qs-estimatesOverview-error",
-            children: c
-        }), y != "" && M("div", {
+            children: l
+        }), x != "" && T("div", {
             class: "qs-estimatesOverview-error",
-            children: y
-        }), r.isSimplifiedView ? M(Ge, {
-            children: [w(), T()]
-        }) : M(Ge, {
-            children: [M("details", {
+            children: x
+        }), e.isSimplifiedView ? T(He, {
+            children: [k(), F()]
+        }) : T(He, {
+            children: [T("details", {
                 open: !0,
-                children: [M("summary", {
+                children: [T("summary", {
                     style: "font-size: 1.5em; font-weight: bold; margin: 24px 8px;",
                     children: "Results"
-                }), w()]
-            }), M("details", {
+                }), k()]
+            }), T("details", {
                 open: !0,
-                children: [M("summary", {
+                children: [T("summary", {
                     style: "font-size: 1.5em; font-weight: bold; margin: 24px 8px;",
                     children: "Space-time diagram"
-                }), T()]
+                }), F()]
             })]
         })]
     })
 }
 
-function $n(r) {
-    return M("svg", {
+function ou(e) {
+    return T("svg", {
         width: "40",
         height: "40",
         viewBox: "0 0 16 16",
         xmlns: "http://www.w3.org/2000/svg",
         class: "codicon-modifier-spin",
-        style: r.style,
-        children: M("path", {
+        style: e.style,
+        children: T("path", {
             d: "M2.006 8.267L.78 9.5 0 8.73l2.09-2.07.76.01 2.09 2.12-.76.76-1.167-1.18a5 5 0 0 0 9.4 1.983l.813.597a6 6 0 0 1-11.22-2.683zm10.99-.466L11.76 6.55l-.76.76 2.09 2.11.76.01 2.09-2.07-.75-.76-1.194 1.18a6 6 0 0 0-11.11-2.92l.81.594a5 5 0 0 1 9.3 2.346z"
         })
     })
 }
 
-function Gn(r) {
-    let [e, i] = Xe(null);
-    return M(Ge, {
-        children: [M("div", {
+function au(e) {
+    let [r, i] = Ze(null);
+    return T(He, {
+        children: [T("div", {
             style: "display:flex; height:64px; align-items: center; position: relative",
-            children: [M("svg", {
+            children: [T("svg", {
                 width: "48",
                 height: "48",
                 viewBox: "96 96 828 828",
                 xmlns: "http://www.w3.org/2000/svg",
-                children: M("g", {
+                children: T("g", {
                     fill: "none",
                     stroke: "gray",
                     "stroke-width": "8",
-                    children: [M("path", {
+                    children: [T("path", {
                         d: "M 512 135 L 819 313 L 819 667 L 512 845 L 205 667 L 205 313 L 512 135 Z"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 205 580 L 742 890 L 819 845 L 818 756 L 205 402"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 204 579 L 743 268"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 664 224 L 207 489"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 206 400 L 588 180"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 205 667 L 818 313"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 205 490 L 820 845"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 207 314 L 818 667"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 282 269 L 820 580"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 820 490 L 357 223"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 435 180 L 818 400"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 281 710 L 281 271"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 357 755 L 357 223"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 283 711 L 820 400"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 434 797 L 434 181"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 511 136 L 511 844"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 588 799 L 588 182"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 665 223 L 665 845"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 742 887 L 742 267"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 665 845 L 816 758"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 433 801 L 820 577"
-                    }), M("path", {
+                    }), T("path", {
                         d: "M 820 489 L 360 755"
                     })]
                 })
-            }), r.calculating ? M($n, {
+            }), e.calculating ? T(ou, {
                 style: "position: absolute; top: 11px; left: 4px;"
-            }) : null, M("h1", {
+            }) : null, T("h1", {
                 children: "Azure Quantum Resource Estimator"
             })]
-        }), M(Er, {
-            estimatesData: r.estimatesData,
+        }), T($0, {
+            estimatesData: e.estimatesData,
             isSimplifiedView: !1,
-            onRowDeleted: r.onRowDeleted,
+            onRowDeleted: e.onRowDeleted,
             setEstimate: i,
-            runNames: r.runNames,
-            colors: r.colors
-        }), e ? M(Ge, {
-            children: [M("details", {
+            runNames: e.runNames,
+            colors: e.colors
+        }), r ? T(He, {
+            children: [T("details", {
                 open: !0,
-                children: [M("summary", {
+                children: [T("summary", {
                     style: "font-size: 1.5em; font-weight: bold; margin: 24px 8px;",
                     children: "Space diagram"
-                }), M(Mr, {
-                    estimatesData: e
+                }), T(H0, {
+                    estimatesData: r
                 })]
-            }), M("details", {
+            }), T("details", {
                 open: !0,
-                children: [M("summary", {
+                children: [T("summary", {
                     style: "font-size: 1.5em; font-weight: bold; margin: 24px 8px;",
                     children: "Resource Estimates"
-                }), M(qr, {
-                    estimatesData: e
+                }), T(O0, {
+                    estimatesData: r
                 })]
             })]
         }) : null]
     })
 }
-var fs = En(ps(), 1);
-var ri = 1e4,
-    ni = 1e3;
-
-function ii(r) {
-    let e = r.circuit,
-        i = e.qubits.length === 0 || e.operations.length > ri || e.qubits.length > ni;
-    return M("div", {
-        children: i ? M(_d, {
-            qubits: r.circuit.qubits.length,
-            operations: r.circuit.operations.length
-        }) : M(kd, {
-            circuit: r.circuit
+var cs = ea(ls(), 1);
+var vu = 1e4,
+    wu = 1e3;
+
+function ku(e) {
+    let r = e.circuit,
+        i = r.qubits.length === 0 || r.operations.length > vu || r.qubits.length > wu;
+    return T("div", {
+        children: i ? T(pd, {
+            qubits: e.circuit.qubits.length,
+            operations: e.circuit.operations.length
+        }) : T(md, {
+            circuit: e.circuit
         })
     })
 }
 
-function kd(r) {
-    let e = St(null),
-        [i, a] = Xe(100),
-        [l, c] = Xe(!0);
-    return Ut(() => {
-        c(!0);
-        let y = e.current;
-        y.innerHTML = ""
-    }, [r.circuit]), Ut(() => {
-        if (l) {
-            let y = e.current,
-                _ = f(r.circuit, y),
-                w = g(y, _);
-            a(w), d(), c(!1)
-        }
-    }, [l]), Ut(() => {
-        d()
-    }, [i]), M("div", {
-        children: [M("div", {
-            children: l ? null : M(Sd, {
+function md(e) {
+    let r = St(null),
+        [i, o] = Ze(100),
+        [s, l] = Ze(!0);
+    return Qt(() => {
+        l(!0);
+        let x = r.current;
+        x.innerHTML = ""
+    }, [e.circuit]), Qt(() => {
+        if (s) {
+            let x = r.current,
+                C = p(e.circuit, x),
+                k = b(x, C);
+            o(k), h(), l(!1)
+        }
+    }, [s]), Qt(() => {
+        h()
+    }, [i]), T("div", {
+        children: [T("div", {
+            children: s ? null : T(bd, {
                 zoom: i,
-                onChange: a
+                onChange: o
             })
-        }), M("div", {
-            children: l ? `Rendering diagram with ${r.circuit.operations.length} gates...` : ""
-        }), M("div", {
+        }), T("div", {
+            children: s ? `Rendering diagram with ${e.circuit.operations.length} gates...` : ""
+        }), T("div", {
             class: "qs-circuit",
-            ref: e
+            ref: r
         })]
     });
 
-    function d() {
-        let y = e.current?.querySelector(".qviz");
-        if (y) {
-            let _ = y.getAttribute("width");
-            y.setAttribute("style", `max-width: ${_}; width: ${parseInt(_)*(i||100)/100}; height: auto`)
+    function h() {
+        let x = r.current?.querySelector(".qviz");
+        if (x) {
+            let C = x.getAttribute("width");
+            x.setAttribute("style", `max-width: ${C}; width: ${parseInt(C)*(i||100)/100}; height: auto`)
         }
     }
 
-    function f(y, _) {
-        return fs.draw(y, _), _.querySelectorAll("style")?.forEach(T => T.remove()), _.getElementsByClassName("qviz")[0]
+    function p(x, C) {
+        return cs.draw(x, C), C.querySelectorAll("style")?.forEach(F => F.remove()), C.getElementsByClassName("qviz")[0]
     }
 
-    function g(y, _) {
-        let w = y.clientWidth,
-            T = parseInt(_.getAttribute("width")),
-            A = _.getAttribute("height");
-        return _.setAttribute("viewBox", `0 0 ${T} ${A}`), Math.min(Math.ceil(w / T * 100), 100)
+    function b(x, C) {
+        let k = x.clientWidth,
+            F = parseInt(C.getAttribute("width")),
+            E = C.getAttribute("height");
+        return C.setAttribute("viewBox", `0 0 ${F} ${E}`), Math.min(Math.ceil(k / F * 100), 100)
     }
 }
 
-function _d(r) {
-    let e = r.qubits === 0 ? M("div", {
-        children: M("p", {
+function pd(e) {
+    let r = e.qubits === 0 ? T("div", {
+        children: T("p", {
             children: "No circuit to display. No qubits have been allocated."
         })
-    }) : r.operations > ri ? M("div", {
-        children: M("p", {
-            children: ["This circuit has too many gates to display. It has ", r.operations, " ", "gates, but the maximum supported is ", ri, "."]
+    }) : e.operations > vu ? T("div", {
+        children: T("p", {
+            children: ["This circuit has too many gates to display. It has ", e.operations, " ", "gates, but the maximum supported is ", vu, "."]
         })
-    }) : r.qubits > ni ? M("div", {
-        children: M("p", {
-            children: ["This circuit has too many qubits to display. It has ", r.qubits, " ", "qubits, but the maximum supported is ", ni, "."]
+    }) : e.qubits > wu ? T("div", {
+        children: T("p", {
+            children: ["This circuit has too many qubits to display. It has ", e.qubits, " ", "qubits, but the maximum supported is ", wu, "."]
         })
     }) : void 0;
-    return M("div", {
+    return T("div", {
         class: "qs-circuit-error",
-        children: e
+        children: r
     })
 }
 
-function Sd(r) {
-    return M("p", {
-        children: [M("label", {
+function bd(e) {
+    return T("p", {
+        children: [T("label", {
             htmlFor: "qs-circuit-zoom",
             children: "Zoom "
-        }), M("input", {
+        }), T("input", {
             id: "qs-circuit-zoom",
             type: "number",
             min: "10",
             max: "100",
             step: "10",
-            value: r.zoom,
-            onInput: e => r.onChange(parseInt(e.target.value) || 0)
+            value: e.zoom,
+            onInput: r => e.onChange(parseInt(r.target.value) || 0)
         }), "%"]
     })
 }
-var Mu = En(vu()),
-    Eu = En(qu());
-var Du = (0, Mu.default)();
-Du.use(Eu.default);
-
-function zu(r) {
-    return Du.render(r.replace(/\\\\/g, "\\"))
+var qu = {};
+wr(qu, {
+    arrayReplaceAt: () => Mu,
+    assign: () => A0,
+    escapeHtml: () => Ht,
+    escapeRE: () => Kd,
+    fromCodePoint: () => X0,
+    has: () => $d,
+    isMdAsciiPunct: () => m0,
+    isPunctChar: () => f0,
+    isSpace: () => me,
+    isString: () => Jr,
+    isValidEntityCode: () => Kr,
+    isWhiteSpace: () => h0,
+    lib: () => eh,
+    normalizeReference: () => p0,
+    unescapeAll: () => Ot,
+    unescapeMd: () => Wd
+});
+var Ur = {};
+wr(Ur, {
+    decode: () => Y0,
+    encode: () => Gr,
+    format: () => C0,
+    parse: () => Z0
+});
+var ds = {};
+
+function gd(e) {
+    let r = ds[e];
+    if (r) return r;
+    r = ds[e] = [];
+    for (let i = 0; i < 128; i++) {
+        let o = String.fromCharCode(i);
+        r.push(o)
+    }
+    for (let i = 0; i < e.length; i++) {
+        let o = e.charCodeAt(i);
+        r[o] = "%" + ("0" + o.toString(16).toUpperCase()).slice(-2)
+    }
+    return r
+}
+
+function Hr(e, r) {
+    typeof r != "string" && (r = Hr.defaultChars);
+    let i = gd(r);
+    return e.replace(/(%[a-f0-9]{2})+/gi, function(o) {
+        let s = "";
+        for (let l = 0, h = o.length; l < h; l += 3) {
+            let p = parseInt(o.slice(l + 1, l + 3), 16);
+            if (p < 128) {
+                s += i[p];
+                continue
+            }
+            if ((p & 224) === 192 && l + 3 < h) {
+                let b = parseInt(o.slice(l + 4, l + 6), 16);
+                if ((b & 192) === 128) {
+                    let x = p << 6 & 1984 | b & 63;
+                    x < 128 ? s += "\uFFFD\uFFFD" : s += String.fromCharCode(x), l += 3;
+                    continue
+                }
+            }
+            if ((p & 240) === 224 && l + 6 < h) {
+                let b = parseInt(o.slice(l + 4, l + 6), 16),
+                    x = parseInt(o.slice(l + 7, l + 9), 16);
+                if ((b & 192) === 128 && (x & 192) === 128) {
+                    let C = p << 12 & 61440 | b << 6 & 4032 | x & 63;
+                    C < 2048 || C >= 55296 && C <= 57343 ? s += "\uFFFD\uFFFD\uFFFD" : s += String.fromCharCode(C), l += 6;
+                    continue
+                }
+            }
+            if ((p & 248) === 240 && l + 9 < h) {
+                let b = parseInt(o.slice(l + 4, l + 6), 16),
+                    x = parseInt(o.slice(l + 7, l + 9), 16),
+                    C = parseInt(o.slice(l + 10, l + 12), 16);
+                if ((b & 192) === 128 && (x & 192) === 128 && (C & 192) === 128) {
+                    let k = p << 18 & 1835008 | b << 12 & 258048 | x << 6 & 4032 | C & 63;
+                    k < 65536 || k > 1114111 ? s += "\uFFFD\uFFFD\uFFFD\uFFFD" : (k -= 65536, s += String.fromCharCode(55296 + (k >> 10), 56320 + (k & 1023))), l += 9;
+                    continue
+                }
+            }
+            s += "\uFFFD"
+        }
+        return s
+    })
+}
+Hr.defaultChars = ";/?:@&=+$,#";
+Hr.componentChars = "";
+var Y0 = Hr;
+var hs = {};
+
+function xd(e) {
+    let r = hs[e];
+    if (r) return r;
+    r = hs[e] = [];
+    for (let i = 0; i < 128; i++) {
+        let o = String.fromCharCode(i);
+        /^[0-9a-z]$/i.test(o) ? r.push(o) : r.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2))
+    }
+    for (let i = 0; i < e.length; i++) r[e.charCodeAt(i)] = e[i];
+    return r
+}
+
+function $r(e, r, i) {
+    typeof r != "string" && (i = r, r = $r.defaultChars), typeof i > "u" && (i = !0);
+    let o = xd(r),
+        s = "";
+    for (let l = 0, h = e.length; l < h; l++) {
+        let p = e.charCodeAt(l);
+        if (i && p === 37 && l + 2 < h && /^[0-9a-f]{2}$/i.test(e.slice(l + 1, l + 3))) {
+            s += e.slice(l, l + 3), l += 2;
+            continue
+        }
+        if (p < 128) {
+            s += o[p];
+            continue
+        }
+        if (p >= 55296 && p <= 57343) {
+            if (p >= 55296 && p <= 56319 && l + 1 < h) {
+                let b = e.charCodeAt(l + 1);
+                if (b >= 56320 && b <= 57343) {
+                    s += encodeURIComponent(e[l] + e[l + 1]), l++;
+                    continue
+                }
+            }
+            s += "%EF%BF%BD";
+            continue
+        }
+        s += encodeURIComponent(e[l])
+    }
+    return s
+}
+$r.defaultChars = ";/?:@&=+$,-_.!~*'()#";
+$r.componentChars = "-_.!~*'()";
+var Gr = $r;
+
+function C0(e) {
+    let r = "";
+    return r += e.protocol || "", r += e.slashes ? "//" : "", r += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? r += "[" + e.hostname + "]" : r += e.hostname || "", r += e.port ? ":" + e.port : "", r += e.pathname || "", r += e.search || "", r += e.hash || "", r
+}
+
+function Vr() {
+    this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null
+}
+var yd = /^([a-z0-9.+-]+:)/i,
+    vd = /:[0-9]*$/,
+    wd = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
+    kd = ["<", ">", '"', "`", " ", "\r", `
+`, "	"],
+    _d = ["{", "}", "|", "\\", "^", "`"].concat(kd),
+    Cd = ["'"].concat(_d),
+    fs = ["%", "/", "?", ";", "#"].concat(Cd),
+    ms = ["/", "?", "#"],
+    Sd = 255,
+    ps = /^[+a-z0-9A-Z_-]{0,63}$/,
+    Ad = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
+    bs = {
+        javascript: !0,
+        "javascript:": !0
+    },
+    gs = {
+        http: !0,
+        https: !0,
+        ftp: !0,
+        gopher: !0,
+        file: !0,
+        "http:": !0,
+        "https:": !0,
+        "ftp:": !0,
+        "gopher:": !0,
+        "file:": !0
+    };
+
+function Td(e, r) {
+    if (e && e instanceof Vr) return e;
+    let i = new Vr;
+    return i.parse(e, r), i
+}
+Vr.prototype.parse = function(e, r) {
+    let i, o, s, l = e;
+    if (l = l.trim(), !r && e.split("#").length === 1) {
+        let x = wd.exec(l);
+        if (x) return this.pathname = x[1], x[2] && (this.search = x[2]), this
+    }
+    let h = yd.exec(l);
+    if (h && (h = h[0], i = h.toLowerCase(), this.protocol = h, l = l.substr(h.length)), (r || h || l.match(/^\/\/[^@\/]+@[^@\/]+/)) && (s = l.substr(0, 2) === "//", s && !(h && bs[h]) && (l = l.substr(2), this.slashes = !0)), !bs[h] && (s || h && !gs[h])) {
+        let x = -1;
+        for (let M = 0; M < ms.length; M++) o = l.indexOf(ms[M]), o !== -1 && (x === -1 || o < x) && (x = o);
+        let C, k;
+        x === -1 ? k = l.lastIndexOf("@") : k = l.lastIndexOf("@", x), k !== -1 && (C = l.slice(0, k), l = l.slice(k + 1), this.auth = C), x = -1;
+        for (let M = 0; M < fs.length; M++) o = l.indexOf(fs[M]), o !== -1 && (x === -1 || o < x) && (x = o);
+        x === -1 && (x = l.length), l[x - 1] === ":" && x--;
+        let F = l.slice(0, x);
+        l = l.slice(x), this.parseHost(F), this.hostname = this.hostname || "";
+        let E = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
+        if (!E) {
+            let M = this.hostname.split(/\./);
+            for (let N = 0, G = M.length; N < G; N++) {
+                let U = M[N];
+                if (U && !U.match(ps)) {
+                    let $ = "";
+                    for (let V = 0, Y = U.length; V < Y; V++) U.charCodeAt(V) > 127 ? $ += "x" : $ += U[V];
+                    if (!$.match(ps)) {
+                        let V = M.slice(0, N),
+                            Y = M.slice(N + 1),
+                            X = U.match(Ad);
+                        X && (V.push(X[1]), Y.unshift(X[2])), Y.length && (l = Y.join(".") + l), this.hostname = V.join(".");
+                        break
+                    }
+                }
+            }
+        }
+        this.hostname.length > Sd && (this.hostname = ""), E && (this.hostname = this.hostname.substr(1, this.hostname.length - 2))
+    }
+    let p = l.indexOf("#");
+    p !== -1 && (this.hash = l.substr(p), l = l.slice(0, p));
+    let b = l.indexOf("?");
+    return b !== -1 && (this.search = l.substr(b), l = l.slice(0, b)), l && (this.pathname = l), gs[i] && this.hostname && !this.pathname && (this.pathname = ""), this
+};
+Vr.prototype.parseHost = function(e) {
+    let r = vd.exec(e);
+    r && (r = r[0], r !== ":" && (this.port = r.substr(1)), e = e.substr(0, e.length - r.length)), e && (this.hostname = e)
+};
+var Z0 = Td;
+var _u = {};
+wr(_u, {
+    Any: () => jr,
+    Cc: () => Wr,
+    Cf: () => xs,
+    P: () => S0,
+    S: () => Yr,
+    Z: () => Zr
+});
+var jr = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
+var Wr = /[\0-\x1F\x7F-\x9F]/;
+var xs = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
+var S0 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
+var Yr = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;
+var Zr = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
+var ys = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(e => e.charCodeAt(0)));
+var vs = new Uint16Array("\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(e => e.charCodeAt(0)));
+var Cu, Dd = new Map([
+        [0, 65533],
+        [128, 8364],
+        [130, 8218],
+        [131, 402],
+        [132, 8222],
+        [133, 8230],
+        [134, 8224],
+        [135, 8225],
+        [136, 710],
+        [137, 8240],
+        [138, 352],
+        [139, 8249],
+        [140, 338],
+        [142, 381],
+        [145, 8216],
+        [146, 8217],
+        [147, 8220],
+        [148, 8221],
+        [149, 8226],
+        [150, 8211],
+        [151, 8212],
+        [152, 732],
+        [153, 8482],
+        [154, 353],
+        [155, 8250],
+        [156, 339],
+        [158, 382],
+        [159, 376]
+    ]),
+    Su = (Cu = String.fromCodePoint) !== null && Cu !== void 0 ? Cu : function(e) {
+        let r = "";
+        return e > 65535 && (e -= 65536, r += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), r += String.fromCharCode(e), r
+    };
+
+function Au(e) {
+    var r;
+    return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (r = Dd.get(e)) !== null && r !== void 0 ? r : e
+}
+var Ke;
+(function(e) {
+    e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z"
+})(Ke || (Ke = {}));
+var Ed = 32,
+    r0;
+(function(e) {
+    e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE"
+})(r0 || (r0 = {}));
+
+function Tu(e) {
+    return e >= Ke.ZERO && e <= Ke.NINE
+}
+
+function Md(e) {
+    return e >= Ke.UPPER_A && e <= Ke.UPPER_F || e >= Ke.LOWER_A && e <= Ke.LOWER_F
+}
+
+function qd(e) {
+    return e >= Ke.UPPER_A && e <= Ke.UPPER_Z || e >= Ke.LOWER_A && e <= Ke.LOWER_Z || Tu(e)
+}
+
+function Fd(e) {
+    return e === Ke.EQUALS || qd(e)
+}
+var Je;
+(function(e) {
+    e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity"
+})(Je || (Je = {}));
+var At;
+(function(e) {
+    e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute"
+})(At || (At = {}));
+var Xr = class {
+    constructor(r, i, o) {
+        this.decodeTree = r, this.emitCodePoint = i, this.errors = o, this.state = Je.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = At.Strict
+    }
+    startEntity(r) {
+        this.decodeMode = r, this.state = Je.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1
+    }
+    write(r, i) {
+        switch (this.state) {
+            case Je.EntityStart:
+                return r.charCodeAt(i) === Ke.NUM ? (this.state = Je.NumericStart, this.consumed += 1, this.stateNumericStart(r, i + 1)) : (this.state = Je.NamedEntity, this.stateNamedEntity(r, i));
+            case Je.NumericStart:
+                return this.stateNumericStart(r, i);
+            case Je.NumericDecimal:
+                return this.stateNumericDecimal(r, i);
+            case Je.NumericHex:
+                return this.stateNumericHex(r, i);
+            case Je.NamedEntity:
+                return this.stateNamedEntity(r, i)
+        }
+    }
+    stateNumericStart(r, i) {
+        return i >= r.length ? -1 : (r.charCodeAt(i) | Ed) === Ke.LOWER_X ? (this.state = Je.NumericHex, this.consumed += 1, this.stateNumericHex(r, i + 1)) : (this.state = Je.NumericDecimal, this.stateNumericDecimal(r, i))
+    }
+    addToNumericResult(r, i, o, s) {
+        if (i !== o) {
+            let l = o - i;
+            this.result = this.result * Math.pow(s, l) + parseInt(r.substr(i, l), s), this.consumed += l
+        }
+    }
+    stateNumericHex(r, i) {
+        let o = i;
+        for (; i < r.length;) {
+            let s = r.charCodeAt(i);
+            if (Tu(s) || Md(s)) i += 1;
+            else return this.addToNumericResult(r, o, i, 16), this.emitNumericEntity(s, 3)
+        }
+        return this.addToNumericResult(r, o, i, 16), -1
+    }
+    stateNumericDecimal(r, i) {
+        let o = i;
+        for (; i < r.length;) {
+            let s = r.charCodeAt(i);
+            if (Tu(s)) i += 1;
+            else return this.addToNumericResult(r, o, i, 10), this.emitNumericEntity(s, 2)
+        }
+        return this.addToNumericResult(r, o, i, 10), -1
+    }
+    emitNumericEntity(r, i) {
+        var o;
+        if (this.consumed <= i) return (o = this.errors) === null || o === void 0 || o.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
+        if (r === Ke.SEMI) this.consumed += 1;
+        else if (this.decodeMode === At.Strict) return 0;
+        return this.emitCodePoint(Au(this.result), this.consumed), this.errors && (r !== Ke.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed
+    }
+    stateNamedEntity(r, i) {
+        let {
+            decodeTree: o
+        } = this, s = o[this.treeIndex], l = (s & r0.VALUE_LENGTH) >> 14;
+        for (; i < r.length; i++, this.excess++) {
+            let h = r.charCodeAt(i);
+            if (this.treeIndex = zd(o, s, this.treeIndex + Math.max(1, l), h), this.treeIndex < 0) return this.result === 0 || this.decodeMode === At.Attribute && (l === 0 || Fd(h)) ? 0 : this.emitNotTerminatedNamedEntity();
+            if (s = o[this.treeIndex], l = (s & r0.VALUE_LENGTH) >> 14, l !== 0) {
+                if (h === Ke.SEMI) return this.emitNamedEntityData(this.treeIndex, l, this.consumed + this.excess);
+                this.decodeMode !== At.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0)
+            }
+        }
+        return -1
+    }
+    emitNotTerminatedNamedEntity() {
+        var r;
+        let {
+            result: i,
+            decodeTree: o
+        } = this, s = (o[i] & r0.VALUE_LENGTH) >> 14;
+        return this.emitNamedEntityData(i, s, this.consumed), (r = this.errors) === null || r === void 0 || r.missingSemicolonAfterCharacterReference(), this.consumed
+    }
+    emitNamedEntityData(r, i, o) {
+        let {
+            decodeTree: s
+        } = this;
+        return this.emitCodePoint(i === 1 ? s[r] & ~r0.VALUE_LENGTH : s[r + 1], o), i === 3 && this.emitCodePoint(s[r + 2], o), o
+    }
+    end() {
+        var r;
+        switch (this.state) {
+            case Je.NamedEntity:
+                return this.result !== 0 && (this.decodeMode !== At.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
+            case Je.NumericDecimal:
+                return this.emitNumericEntity(0, 2);
+            case Je.NumericHex:
+                return this.emitNumericEntity(0, 3);
+            case Je.NumericStart:
+                return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
+            case Je.EntityStart:
+                return 0
+        }
+    }
+};
+
+function ws(e) {
+    let r = "",
+        i = new Xr(e, o => r += Su(o));
+    return function(s, l) {
+        let h = 0,
+            p = 0;
+        for (;
+            (p = s.indexOf("&", p)) >= 0;) {
+            r += s.slice(h, p), i.startEntity(l);
+            let x = i.write(s, p + 1);
+            if (x < 0) {
+                h = p + i.end();
+                break
+            }
+            h = p + x, p = x === 0 ? h + 1 : h
+        }
+        let b = r + s.slice(h);
+        return r = "", b
+    }
+}
+
+function zd(e, r, i, o) {
+    let s = (r & r0.BRANCH_LENGTH) >> 7,
+        l = r & r0.JUMP_TABLE;
+    if (s === 0) return l !== 0 && o === l ? i : -1;
+    if (l) {
+        let b = o - l;
+        return b < 0 || b >= s ? -1 : e[i + b] - 1
+    }
+    let h = i,
+        p = h + s - 1;
+    for (; h <= p;) {
+        let b = h + p >>> 1,
+            x = e[b];
+        if (x < o) h = b + 1;
+        else if (x > o) p = b - 1;
+        else return e[b + s]
+    }
+    return -1
+}
+var Rd = ws(ys),
+    Vf = ws(vs);
+
+function n0(e, r = At.Legacy) {
+    return Rd(e, r)
+}
+
+function Qr(e) {
+    for (let r = 1; r < e.length; r++) e[r][0] += e[r - 1][0] + 1;
+    return e
+}
+var Bd = new Map(Qr([
+    [9, "&Tab;"],
+    [0, "&NewLine;"],
+    [22, "&excl;"],
+    [0, "&quot;"],
+    [0, "&num;"],
+    [0, "&dollar;"],
+    [0, "&percnt;"],
+    [0, "&amp;"],
+    [0, "&apos;"],
+    [0, "&lpar;"],
+    [0, "&rpar;"],
+    [0, "&ast;"],
+    [0, "&plus;"],
+    [0, "&comma;"],
+    [1, "&period;"],
+    [0, "&sol;"],
+    [10, "&colon;"],
+    [0, "&semi;"],
+    [0, {
+        v: "&lt;",
+        n: 8402,
+        o: "&nvlt;"
+    }],
+    [0, {
+        v: "&equals;",
+        n: 8421,
+        o: "&bne;"
+    }],
+    [0, {
+        v: "&gt;",
+        n: 8402,
+        o: "&nvgt;"
+    }],
+    [0, "&quest;"],
+    [0, "&commat;"],
+    [26, "&lbrack;"],
+    [0, "&bsol;"],
+    [0, "&rbrack;"],
+    [0, "&Hat;"],
+    [0, "&lowbar;"],
+    [0, "&DiacriticalGrave;"],
+    [5, {
+        n: 106,
+        o: "&fjlig;"
+    }],
+    [20, "&lbrace;"],
+    [0, "&verbar;"],
+    [0, "&rbrace;"],
+    [34, "&nbsp;"],
+    [0, "&iexcl;"],
+    [0, "&cent;"],
+    [0, "&pound;"],
+    [0, "&curren;"],
+    [0, "&yen;"],
+    [0, "&brvbar;"],
+    [0, "&sect;"],
+    [0, "&die;"],
+    [0, "&copy;"],
+    [0, "&ordf;"],
+    [0, "&laquo;"],
+    [0, "&not;"],
+    [0, "&shy;"],
+    [0, "&circledR;"],
+    [0, "&macr;"],
+    [0, "&deg;"],
+    [0, "&PlusMinus;"],
+    [0, "&sup2;"],
+    [0, "&sup3;"],
+    [0, "&acute;"],
+    [0, "&micro;"],
+    [0, "&para;"],
+    [0, "&centerdot;"],
+    [0, "&cedil;"],
+    [0, "&sup1;"],
+    [0, "&ordm;"],
+    [0, "&raquo;"],
+    [0, "&frac14;"],
+    [0, "&frac12;"],
+    [0, "&frac34;"],
+    [0, "&iquest;"],
+    [0, "&Agrave;"],
+    [0, "&Aacute;"],
+    [0, "&Acirc;"],
+    [0, "&Atilde;"],
+    [0, "&Auml;"],
+    [0, "&angst;"],
+    [0, "&AElig;"],
+    [0, "&Ccedil;"],
+    [0, "&Egrave;"],
+    [0, "&Eacute;"],
+    [0, "&Ecirc;"],
+    [0, "&Euml;"],
+    [0, "&Igrave;"],
+    [0, "&Iacute;"],
+    [0, "&Icirc;"],
+    [0, "&Iuml;"],
+    [0, "&ETH;"],
+    [0, "&Ntilde;"],
+    [0, "&Ograve;"],
+    [0, "&Oacute;"],
+    [0, "&Ocirc;"],
+    [0, "&Otilde;"],
+    [0, "&Ouml;"],
+    [0, "&times;"],
+    [0, "&Oslash;"],
+    [0, "&Ugrave;"],
+    [0, "&Uacute;"],
+    [0, "&Ucirc;"],
+    [0, "&Uuml;"],
+    [0, "&Yacute;"],
+    [0, "&THORN;"],
+    [0, "&szlig;"],
+    [0, "&agrave;"],
+    [0, "&aacute;"],
+    [0, "&acirc;"],
+    [0, "&atilde;"],
+    [0, "&auml;"],
+    [0, "&aring;"],
+    [0, "&aelig;"],
+    [0, "&ccedil;"],
+    [0, "&egrave;"],
+    [0, "&eacute;"],
+    [0, "&ecirc;"],
+    [0, "&euml;"],
+    [0, "&igrave;"],
+    [0, "&iacute;"],
+    [0, "&icirc;"],
+    [0, "&iuml;"],
+    [0, "&eth;"],
+    [0, "&ntilde;"],
+    [0, "&ograve;"],
+    [0, "&oacute;"],
+    [0, "&ocirc;"],
+    [0, "&otilde;"],
+    [0, "&ouml;"],
+    [0, "&div;"],
+    [0, "&oslash;"],
+    [0, "&ugrave;"],
+    [0, "&uacute;"],
+    [0, "&ucirc;"],
+    [0, "&uuml;"],
+    [0, "&yacute;"],
+    [0, "&thorn;"],
+    [0, "&yuml;"],
+    [0, "&Amacr;"],
+    [0, "&amacr;"],
+    [0, "&Abreve;"],
+    [0, "&abreve;"],
+    [0, "&Aogon;"],
+    [0, "&aogon;"],
+    [0, "&Cacute;"],
+    [0, "&cacute;"],
+    [0, "&Ccirc;"],
+    [0, "&ccirc;"],
+    [0, "&Cdot;"],
+    [0, "&cdot;"],
+    [0, "&Ccaron;"],
+    [0, "&ccaron;"],
+    [0, "&Dcaron;"],
+    [0, "&dcaron;"],
+    [0, "&Dstrok;"],
+    [0, "&dstrok;"],
+    [0, "&Emacr;"],
+    [0, "&emacr;"],
+    [2, "&Edot;"],
+    [0, "&edot;"],
+    [0, "&Eogon;"],
+    [0, "&eogon;"],
+    [0, "&Ecaron;"],
+    [0, "&ecaron;"],
+    [0, "&Gcirc;"],
+    [0, "&gcirc;"],
+    [0, "&Gbreve;"],
+    [0, "&gbreve;"],
+    [0, "&Gdot;"],
+    [0, "&gdot;"],
+    [0, "&Gcedil;"],
+    [1, "&Hcirc;"],
+    [0, "&hcirc;"],
+    [0, "&Hstrok;"],
+    [0, "&hstrok;"],
+    [0, "&Itilde;"],
+    [0, "&itilde;"],
+    [0, "&Imacr;"],
+    [0, "&imacr;"],
+    [2, "&Iogon;"],
+    [0, "&iogon;"],
+    [0, "&Idot;"],
+    [0, "&imath;"],
+    [0, "&IJlig;"],
+    [0, "&ijlig;"],
+    [0, "&Jcirc;"],
+    [0, "&jcirc;"],
+    [0, "&Kcedil;"],
+    [0, "&kcedil;"],
+    [0, "&kgreen;"],
+    [0, "&Lacute;"],
+    [0, "&lacute;"],
+    [0, "&Lcedil;"],
+    [0, "&lcedil;"],
+    [0, "&Lcaron;"],
+    [0, "&lcaron;"],
+    [0, "&Lmidot;"],
+    [0, "&lmidot;"],
+    [0, "&Lstrok;"],
+    [0, "&lstrok;"],
+    [0, "&Nacute;"],
+    [0, "&nacute;"],
+    [0, "&Ncedil;"],
+    [0, "&ncedil;"],
+    [0, "&Ncaron;"],
+    [0, "&ncaron;"],
+    [0, "&napos;"],
+    [0, "&ENG;"],
+    [0, "&eng;"],
+    [0, "&Omacr;"],
+    [0, "&omacr;"],
+    [2, "&Odblac;"],
+    [0, "&odblac;"],
+    [0, "&OElig;"],
+    [0, "&oelig;"],
+    [0, "&Racute;"],
+    [0, "&racute;"],
+    [0, "&Rcedil;"],
+    [0, "&rcedil;"],
+    [0, "&Rcaron;"],
+    [0, "&rcaron;"],
+    [0, "&Sacute;"],
+    [0, "&sacute;"],
+    [0, "&Scirc;"],
+    [0, "&scirc;"],
+    [0, "&Scedil;"],
+    [0, "&scedil;"],
+    [0, "&Scaron;"],
+    [0, "&scaron;"],
+    [0, "&Tcedil;"],
+    [0, "&tcedil;"],
+    [0, "&Tcaron;"],
+    [0, "&tcaron;"],
+    [0, "&Tstrok;"],
+    [0, "&tstrok;"],
+    [0, "&Utilde;"],
+    [0, "&utilde;"],
+    [0, "&Umacr;"],
+    [0, "&umacr;"],
+    [0, "&Ubreve;"],
+    [0, "&ubreve;"],
+    [0, "&Uring;"],
+    [0, "&uring;"],
+    [0, "&Udblac;"],
+    [0, "&udblac;"],
+    [0, "&Uogon;"],
+    [0, "&uogon;"],
+    [0, "&Wcirc;"],
+    [0, "&wcirc;"],
+    [0, "&Ycirc;"],
+    [0, "&ycirc;"],
+    [0, "&Yuml;"],
+    [0, "&Zacute;"],
+    [0, "&zacute;"],
+    [0, "&Zdot;"],
+    [0, "&zdot;"],
+    [0, "&Zcaron;"],
+    [0, "&zcaron;"],
+    [19, "&fnof;"],
+    [34, "&imped;"],
+    [63, "&gacute;"],
+    [65, "&jmath;"],
+    [142, "&circ;"],
+    [0, "&caron;"],
+    [16, "&breve;"],
+    [0, "&DiacriticalDot;"],
+    [0, "&ring;"],
+    [0, "&ogon;"],
+    [0, "&DiacriticalTilde;"],
+    [0, "&dblac;"],
+    [51, "&DownBreve;"],
+    [127, "&Alpha;"],
+    [0, "&Beta;"],
+    [0, "&Gamma;"],
+    [0, "&Delta;"],
+    [0, "&Epsilon;"],
+    [0, "&Zeta;"],
+    [0, "&Eta;"],
+    [0, "&Theta;"],
+    [0, "&Iota;"],
+    [0, "&Kappa;"],
+    [0, "&Lambda;"],
+    [0, "&Mu;"],
+    [0, "&Nu;"],
+    [0, "&Xi;"],
+    [0, "&Omicron;"],
+    [0, "&Pi;"],
+    [0, "&Rho;"],
+    [1, "&Sigma;"],
+    [0, "&Tau;"],
+    [0, "&Upsilon;"],
+    [0, "&Phi;"],
+    [0, "&Chi;"],
+    [0, "&Psi;"],
+    [0, "&ohm;"],
+    [7, "&alpha;"],
+    [0, "&beta;"],
+    [0, "&gamma;"],
+    [0, "&delta;"],
+    [0, "&epsi;"],
+    [0, "&zeta;"],
+    [0, "&eta;"],
+    [0, "&theta;"],
+    [0, "&iota;"],
+    [0, "&kappa;"],
+    [0, "&lambda;"],
+    [0, "&mu;"],
+    [0, "&nu;"],
+    [0, "&xi;"],
+    [0, "&omicron;"],
+    [0, "&pi;"],
+    [0, "&rho;"],
+    [0, "&sigmaf;"],
+    [0, "&sigma;"],
+    [0, "&tau;"],
+    [0, "&upsi;"],
+    [0, "&phi;"],
+    [0, "&chi;"],
+    [0, "&psi;"],
+    [0, "&omega;"],
+    [7, "&thetasym;"],
+    [0, "&Upsi;"],
+    [2, "&phiv;"],
+    [0, "&piv;"],
+    [5, "&Gammad;"],
+    [0, "&digamma;"],
+    [18, "&kappav;"],
+    [0, "&rhov;"],
+    [3, "&epsiv;"],
+    [0, "&backepsilon;"],
+    [10, "&IOcy;"],
+    [0, "&DJcy;"],
+    [0, "&GJcy;"],
+    [0, "&Jukcy;"],
+    [0, "&DScy;"],
+    [0, "&Iukcy;"],
+    [0, "&YIcy;"],
+    [0, "&Jsercy;"],
+    [0, "&LJcy;"],
+    [0, "&NJcy;"],
+    [0, "&TSHcy;"],
+    [0, "&KJcy;"],
+    [1, "&Ubrcy;"],
+    [0, "&DZcy;"],
+    [0, "&Acy;"],
+    [0, "&Bcy;"],
+    [0, "&Vcy;"],
+    [0, "&Gcy;"],
+    [0, "&Dcy;"],
+    [0, "&IEcy;"],
+    [0, "&ZHcy;"],
+    [0, "&Zcy;"],
+    [0, "&Icy;"],
+    [0, "&Jcy;"],
+    [0, "&Kcy;"],
+    [0, "&Lcy;"],
+    [0, "&Mcy;"],
+    [0, "&Ncy;"],
+    [0, "&Ocy;"],
+    [0, "&Pcy;"],
+    [0, "&Rcy;"],
+    [0, "&Scy;"],
+    [0, "&Tcy;"],
+    [0, "&Ucy;"],
+    [0, "&Fcy;"],
+    [0, "&KHcy;"],
+    [0, "&TScy;"],
+    [0, "&CHcy;"],
+    [0, "&SHcy;"],
+    [0, "&SHCHcy;"],
+    [0, "&HARDcy;"],
+    [0, "&Ycy;"],
+    [0, "&SOFTcy;"],
+    [0, "&Ecy;"],
+    [0, "&YUcy;"],
+    [0, "&YAcy;"],
+    [0, "&acy;"],
+    [0, "&bcy;"],
+    [0, "&vcy;"],
+    [0, "&gcy;"],
+    [0, "&dcy;"],
+    [0, "&iecy;"],
+    [0, "&zhcy;"],
+    [0, "&zcy;"],
+    [0, "&icy;"],
+    [0, "&jcy;"],
+    [0, "&kcy;"],
+    [0, "&lcy;"],
+    [0, "&mcy;"],
+    [0, "&ncy;"],
+    [0, "&ocy;"],
+    [0, "&pcy;"],
+    [0, "&rcy;"],
+    [0, "&scy;"],
+    [0, "&tcy;"],
+    [0, "&ucy;"],
+    [0, "&fcy;"],
+    [0, "&khcy;"],
+    [0, "&tscy;"],
+    [0, "&chcy;"],
+    [0, "&shcy;"],
+    [0, "&shchcy;"],
+    [0, "&hardcy;"],
+    [0, "&ycy;"],
+    [0, "&softcy;"],
+    [0, "&ecy;"],
+    [0, "&yucy;"],
+    [0, "&yacy;"],
+    [1, "&iocy;"],
+    [0, "&djcy;"],
+    [0, "&gjcy;"],
+    [0, "&jukcy;"],
+    [0, "&dscy;"],
+    [0, "&iukcy;"],
+    [0, "&yicy;"],
+    [0, "&jsercy;"],
+    [0, "&ljcy;"],
+    [0, "&njcy;"],
+    [0, "&tshcy;"],
+    [0, "&kjcy;"],
+    [1, "&ubrcy;"],
+    [0, "&dzcy;"],
+    [7074, "&ensp;"],
+    [0, "&emsp;"],
+    [0, "&emsp13;"],
+    [0, "&emsp14;"],
+    [1, "&numsp;"],
+    [0, "&puncsp;"],
+    [0, "&ThinSpace;"],
+    [0, "&hairsp;"],
+    [0, "&NegativeMediumSpace;"],
+    [0, "&zwnj;"],
+    [0, "&zwj;"],
+    [0, "&lrm;"],
+    [0, "&rlm;"],
+    [0, "&dash;"],
+    [2, "&ndash;"],
+    [0, "&mdash;"],
+    [0, "&horbar;"],
+    [0, "&Verbar;"],
+    [1, "&lsquo;"],
+    [0, "&CloseCurlyQuote;"],
+    [0, "&lsquor;"],
+    [1, "&ldquo;"],
+    [0, "&CloseCurlyDoubleQuote;"],
+    [0, "&bdquo;"],
+    [1, "&dagger;"],
+    [0, "&Dagger;"],
+    [0, "&bull;"],
+    [2, "&nldr;"],
+    [0, "&hellip;"],
+    [9, "&permil;"],
+    [0, "&pertenk;"],
+    [0, "&prime;"],
+    [0, "&Prime;"],
+    [0, "&tprime;"],
+    [0, "&backprime;"],
+    [3, "&lsaquo;"],
+    [0, "&rsaquo;"],
+    [3, "&oline;"],
+    [2, "&caret;"],
+    [1, "&hybull;"],
+    [0, "&frasl;"],
+    [10, "&bsemi;"],
+    [7, "&qprime;"],
+    [7, {
+        v: "&MediumSpace;",
+        n: 8202,
+        o: "&ThickSpace;"
+    }],
+    [0, "&NoBreak;"],
+    [0, "&af;"],
+    [0, "&InvisibleTimes;"],
+    [0, "&ic;"],
+    [72, "&euro;"],
+    [46, "&tdot;"],
+    [0, "&DotDot;"],
+    [37, "&complexes;"],
+    [2, "&incare;"],
+    [4, "&gscr;"],
+    [0, "&hamilt;"],
+    [0, "&Hfr;"],
+    [0, "&Hopf;"],
+    [0, "&planckh;"],
+    [0, "&hbar;"],
+    [0, "&imagline;"],
+    [0, "&Ifr;"],
+    [0, "&lagran;"],
+    [0, "&ell;"],
+    [1, "&naturals;"],
+    [0, "&numero;"],
+    [0, "&copysr;"],
+    [0, "&weierp;"],
+    [0, "&Popf;"],
+    [0, "&Qopf;"],
+    [0, "&realine;"],
+    [0, "&real;"],
+    [0, "&reals;"],
+    [0, "&rx;"],
+    [3, "&trade;"],
+    [1, "&integers;"],
+    [2, "&mho;"],
+    [0, "&zeetrf;"],
+    [0, "&iiota;"],
+    [2, "&bernou;"],
+    [0, "&Cayleys;"],
+    [1, "&escr;"],
+    [0, "&Escr;"],
+    [0, "&Fouriertrf;"],
+    [1, "&Mellintrf;"],
+    [0, "&order;"],
+    [0, "&alefsym;"],
+    [0, "&beth;"],
+    [0, "&gimel;"],
+    [0, "&daleth;"],
+    [12, "&CapitalDifferentialD;"],
+    [0, "&dd;"],
+    [0, "&ee;"],
+    [0, "&ii;"],
+    [10, "&frac13;"],
+    [0, "&frac23;"],
+    [0, "&frac15;"],
+    [0, "&frac25;"],
+    [0, "&frac35;"],
+    [0, "&frac45;"],
+    [0, "&frac16;"],
+    [0, "&frac56;"],
+    [0, "&frac18;"],
+    [0, "&frac38;"],
+    [0, "&frac58;"],
+    [0, "&frac78;"],
+    [49, "&larr;"],
+    [0, "&ShortUpArrow;"],
+    [0, "&rarr;"],
+    [0, "&darr;"],
+    [0, "&harr;"],
+    [0, "&updownarrow;"],
+    [0, "&nwarr;"],
+    [0, "&nearr;"],
+    [0, "&LowerRightArrow;"],
+    [0, "&LowerLeftArrow;"],
+    [0, "&nlarr;"],
+    [0, "&nrarr;"],
+    [1, {
+        v: "&rarrw;",
+        n: 824,
+        o: "&nrarrw;"
+    }],
+    [0, "&Larr;"],
+    [0, "&Uarr;"],
+    [0, "&Rarr;"],
+    [0, "&Darr;"],
+    [0, "&larrtl;"],
+    [0, "&rarrtl;"],
+    [0, "&LeftTeeArrow;"],
+    [0, "&mapstoup;"],
+    [0, "&map;"],
+    [0, "&DownTeeArrow;"],
+    [1, "&hookleftarrow;"],
+    [0, "&hookrightarrow;"],
+    [0, "&larrlp;"],
+    [0, "&looparrowright;"],
+    [0, "&harrw;"],
+    [0, "&nharr;"],
+    [1, "&lsh;"],
+    [0, "&rsh;"],
+    [0, "&ldsh;"],
+    [0, "&rdsh;"],
+    [1, "&crarr;"],
+    [0, "&cularr;"],
+    [0, "&curarr;"],
+    [2, "&circlearrowleft;"],
+    [0, "&circlearrowright;"],
+    [0, "&leftharpoonup;"],
+    [0, "&DownLeftVector;"],
+    [0, "&RightUpVector;"],
+    [0, "&LeftUpVector;"],
+    [0, "&rharu;"],
+    [0, "&DownRightVector;"],
+    [0, "&dharr;"],
+    [0, "&dharl;"],
+    [0, "&RightArrowLeftArrow;"],
+    [0, "&udarr;"],
+    [0, "&LeftArrowRightArrow;"],
+    [0, "&leftleftarrows;"],
+    [0, "&upuparrows;"],
+    [0, "&rightrightarrows;"],
+    [0, "&ddarr;"],
+    [0, "&leftrightharpoons;"],
+    [0, "&Equilibrium;"],
+    [0, "&nlArr;"],
+    [0, "&nhArr;"],
+    [0, "&nrArr;"],
+    [0, "&DoubleLeftArrow;"],
+    [0, "&DoubleUpArrow;"],
+    [0, "&DoubleRightArrow;"],
+    [0, "&dArr;"],
+    [0, "&DoubleLeftRightArrow;"],
+    [0, "&DoubleUpDownArrow;"],
+    [0, "&nwArr;"],
+    [0, "&neArr;"],
+    [0, "&seArr;"],
+    [0, "&swArr;"],
+    [0, "&lAarr;"],
+    [0, "&rAarr;"],
+    [1, "&zigrarr;"],
+    [6, "&larrb;"],
+    [0, "&rarrb;"],
+    [15, "&DownArrowUpArrow;"],
+    [7, "&loarr;"],
+    [0, "&roarr;"],
+    [0, "&hoarr;"],
+    [0, "&forall;"],
+    [0, "&comp;"],
+    [0, {
+        v: "&part;",
+        n: 824,
+        o: "&npart;"
+    }],
+    [0, "&exist;"],
+    [0, "&nexist;"],
+    [0, "&empty;"],
+    [1, "&Del;"],
+    [0, "&Element;"],
+    [0, "&NotElement;"],
+    [1, "&ni;"],
+    [0, "&notni;"],
+    [2, "&prod;"],
+    [0, "&coprod;"],
+    [0, "&sum;"],
+    [0, "&minus;"],
+    [0, "&MinusPlus;"],
+    [0, "&dotplus;"],
+    [1, "&Backslash;"],
+    [0, "&lowast;"],
+    [0, "&compfn;"],
+    [1, "&radic;"],
+    [2, "&prop;"],
+    [0, "&infin;"],
+    [0, "&angrt;"],
+    [0, {
+        v: "&ang;",
+        n: 8402,
+        o: "&nang;"
+    }],
+    [0, "&angmsd;"],
+    [0, "&angsph;"],
+    [0, "&mid;"],
+    [0, "&nmid;"],
+    [0, "&DoubleVerticalBar;"],
+    [0, "&NotDoubleVerticalBar;"],
+    [0, "&and;"],
+    [0, "&or;"],
+    [0, {
+        v: "&cap;",
+        n: 65024,
+        o: "&caps;"
+    }],
+    [0, {
+        v: "&cup;",
+        n: 65024,
+        o: "&cups;"
+    }],
+    [0, "&int;"],
+    [0, "&Int;"],
+    [0, "&iiint;"],
+    [0, "&conint;"],
+    [0, "&Conint;"],
+    [0, "&Cconint;"],
+    [0, "&cwint;"],
+    [0, "&ClockwiseContourIntegral;"],
+    [0, "&awconint;"],
+    [0, "&there4;"],
+    [0, "&becaus;"],
+    [0, "&ratio;"],
+    [0, "&Colon;"],
+    [0, "&dotminus;"],
+    [1, "&mDDot;"],
+    [0, "&homtht;"],
+    [0, {
+        v: "&sim;",
+        n: 8402,
+        o: "&nvsim;"
+    }],
+    [0, {
+        v: "&backsim;",
+        n: 817,
+        o: "&race;"
+    }],
+    [0, {
+        v: "&ac;",
+        n: 819,
+        o: "&acE;"
+    }],
+    [0, "&acd;"],
+    [0, "&VerticalTilde;"],
+    [0, "&NotTilde;"],
+    [0, {
+        v: "&eqsim;",
+        n: 824,
+        o: "&nesim;"
+    }],
+    [0, "&sime;"],
+    [0, "&NotTildeEqual;"],
+    [0, "&cong;"],
+    [0, "&simne;"],
+    [0, "&ncong;"],
+    [0, "&ap;"],
+    [0, "&nap;"],
+    [0, "&ape;"],
+    [0, {
+        v: "&apid;",
+        n: 824,
+        o: "&napid;"
+    }],
+    [0, "&backcong;"],
+    [0, {
+        v: "&asympeq;",
+        n: 8402,
+        o: "&nvap;"
+    }],
+    [0, {
+        v: "&bump;",
+        n: 824,
+        o: "&nbump;"
+    }],
+    [0, {
+        v: "&bumpe;",
+        n: 824,
+        o: "&nbumpe;"
+    }],
+    [0, {
+        v: "&doteq;",
+        n: 824,
+        o: "&nedot;"
+    }],
+    [0, "&doteqdot;"],
+    [0, "&efDot;"],
+    [0, "&erDot;"],
+    [0, "&Assign;"],
+    [0, "&ecolon;"],
+    [0, "&ecir;"],
+    [0, "&circeq;"],
+    [1, "&wedgeq;"],
+    [0, "&veeeq;"],
+    [1, "&triangleq;"],
+    [2, "&equest;"],
+    [0, "&ne;"],
+    [0, {
+        v: "&Congruent;",
+        n: 8421,
+        o: "&bnequiv;"
+    }],
+    [0, "&nequiv;"],
+    [1, {
+        v: "&le;",
+        n: 8402,
+        o: "&nvle;"
+    }],
+    [0, {
+        v: "&ge;",
+        n: 8402,
+        o: "&nvge;"
+    }],
+    [0, {
+        v: "&lE;",
+        n: 824,
+        o: "&nlE;"
+    }],
+    [0, {
+        v: "&gE;",
+        n: 824,
+        o: "&ngE;"
+    }],
+    [0, {
+        v: "&lnE;",
+        n: 65024,
+        o: "&lvertneqq;"
+    }],
+    [0, {
+        v: "&gnE;",
+        n: 65024,
+        o: "&gvertneqq;"
+    }],
+    [0, {
+        v: "&ll;",
+        n: new Map(Qr([
+            [824, "&nLtv;"],
+            [7577, "&nLt;"]
+        ]))
+    }],
+    [0, {
+        v: "&gg;",
+        n: new Map(Qr([
+            [824, "&nGtv;"],
+            [7577, "&nGt;"]
+        ]))
+    }],
+    [0, "&between;"],
+    [0, "&NotCupCap;"],
+    [0, "&nless;"],
+    [0, "&ngt;"],
+    [0, "&nle;"],
+    [0, "&nge;"],
+    [0, "&lesssim;"],
+    [0, "&GreaterTilde;"],
+    [0, "&nlsim;"],
+    [0, "&ngsim;"],
+    [0, "&LessGreater;"],
+    [0, "&gl;"],
+    [0, "&NotLessGreater;"],
+    [0, "&NotGreaterLess;"],
+    [0, "&pr;"],
+    [0, "&sc;"],
+    [0, "&prcue;"],
+    [0, "&sccue;"],
+    [0, "&PrecedesTilde;"],
+    [0, {
+        v: "&scsim;",
+        n: 824,
+        o: "&NotSucceedsTilde;"
+    }],
+    [0, "&NotPrecedes;"],
+    [0, "&NotSucceeds;"],
+    [0, {
+        v: "&sub;",
+        n: 8402,
+        o: "&NotSubset;"
+    }],
+    [0, {
+        v: "&sup;",
+        n: 8402,
+        o: "&NotSuperset;"
+    }],
+    [0, "&nsub;"],
+    [0, "&nsup;"],
+    [0, "&sube;"],
+    [0, "&supe;"],
+    [0, "&NotSubsetEqual;"],
+    [0, "&NotSupersetEqual;"],
+    [0, {
+        v: "&subne;",
+        n: 65024,
+        o: "&varsubsetneq;"
+    }],
+    [0, {
+        v: "&supne;",
+        n: 65024,
+        o: "&varsupsetneq;"
+    }],
+    [1, "&cupdot;"],
+    [0, "&UnionPlus;"],
+    [0, {
+        v: "&sqsub;",
+        n: 824,
+        o: "&NotSquareSubset;"
+    }],
+    [0, {
+        v: "&sqsup;",
+        n: 824,
+        o: "&NotSquareSuperset;"
+    }],
+    [0, "&sqsube;"],
+    [0, "&sqsupe;"],
+    [0, {
+        v: "&sqcap;",
+        n: 65024,
+        o: "&sqcaps;"
+    }],
+    [0, {
+        v: "&sqcup;",
+        n: 65024,
+        o: "&sqcups;"
+    }],
+    [0, "&CirclePlus;"],
+    [0, "&CircleMinus;"],
+    [0, "&CircleTimes;"],
+    [0, "&osol;"],
+    [0, "&CircleDot;"],
+    [0, "&circledcirc;"],
+    [0, "&circledast;"],
+    [1, "&circleddash;"],
+    [0, "&boxplus;"],
+    [0, "&boxminus;"],
+    [0, "&boxtimes;"],
+    [0, "&dotsquare;"],
+    [0, "&RightTee;"],
+    [0, "&dashv;"],
+    [0, "&DownTee;"],
+    [0, "&bot;"],
+    [1, "&models;"],
+    [0, "&DoubleRightTee;"],
+    [0, "&Vdash;"],
+    [0, "&Vvdash;"],
+    [0, "&VDash;"],
+    [0, "&nvdash;"],
+    [0, "&nvDash;"],
+    [0, "&nVdash;"],
+    [0, "&nVDash;"],
+    [0, "&prurel;"],
+    [1, "&LeftTriangle;"],
+    [0, "&RightTriangle;"],
+    [0, {
+        v: "&LeftTriangleEqual;",
+        n: 8402,
+        o: "&nvltrie;"
+    }],
+    [0, {
+        v: "&RightTriangleEqual;",
+        n: 8402,
+        o: "&nvrtrie;"
+    }],
+    [0, "&origof;"],
+    [0, "&imof;"],
+    [0, "&multimap;"],
+    [0, "&hercon;"],
+    [0, "&intcal;"],
+    [0, "&veebar;"],
+    [1, "&barvee;"],
+    [0, "&angrtvb;"],
+    [0, "&lrtri;"],
+    [0, "&bigwedge;"],
+    [0, "&bigvee;"],
+    [0, "&bigcap;"],
+    [0, "&bigcup;"],
+    [0, "&diam;"],
+    [0, "&sdot;"],
+    [0, "&sstarf;"],
+    [0, "&divideontimes;"],
+    [0, "&bowtie;"],
+    [0, "&ltimes;"],
+    [0, "&rtimes;"],
+    [0, "&leftthreetimes;"],
+    [0, "&rightthreetimes;"],
+    [0, "&backsimeq;"],
+    [0, "&curlyvee;"],
+    [0, "&curlywedge;"],
+    [0, "&Sub;"],
+    [0, "&Sup;"],
+    [0, "&Cap;"],
+    [0, "&Cup;"],
+    [0, "&fork;"],
+    [0, "&epar;"],
+    [0, "&lessdot;"],
+    [0, "&gtdot;"],
+    [0, {
+        v: "&Ll;",
+        n: 824,
+        o: "&nLl;"
+    }],
+    [0, {
+        v: "&Gg;",
+        n: 824,
+        o: "&nGg;"
+    }],
+    [0, {
+        v: "&leg;",
+        n: 65024,
+        o: "&lesg;"
+    }],
+    [0, {
+        v: "&gel;",
+        n: 65024,
+        o: "&gesl;"
+    }],
+    [2, "&cuepr;"],
+    [0, "&cuesc;"],
+    [0, "&NotPrecedesSlantEqual;"],
+    [0, "&NotSucceedsSlantEqual;"],
+    [0, "&NotSquareSubsetEqual;"],
+    [0, "&NotSquareSupersetEqual;"],
+    [2, "&lnsim;"],
+    [0, "&gnsim;"],
+    [0, "&precnsim;"],
+    [0, "&scnsim;"],
+    [0, "&nltri;"],
+    [0, "&NotRightTriangle;"],
+    [0, "&nltrie;"],
+    [0, "&NotRightTriangleEqual;"],
+    [0, "&vellip;"],
+    [0, "&ctdot;"],
+    [0, "&utdot;"],
+    [0, "&dtdot;"],
+    [0, "&disin;"],
+    [0, "&isinsv;"],
+    [0, "&isins;"],
+    [0, {
+        v: "&isindot;",
+        n: 824,
+        o: "&notindot;"
+    }],
+    [0, "&notinvc;"],
+    [0, "&notinvb;"],
+    [1, {
+        v: "&isinE;",
+        n: 824,
+        o: "&notinE;"
+    }],
+    [0, "&nisd;"],
+    [0, "&xnis;"],
+    [0, "&nis;"],
+    [0, "&notnivc;"],
+    [0, "&notnivb;"],
+    [6, "&barwed;"],
+    [0, "&Barwed;"],
+    [1, "&lceil;"],
+    [0, "&rceil;"],
+    [0, "&LeftFloor;"],
+    [0, "&rfloor;"],
+    [0, "&drcrop;"],
+    [0, "&dlcrop;"],
+    [0, "&urcrop;"],
+    [0, "&ulcrop;"],
+    [0, "&bnot;"],
+    [1, "&profline;"],
+    [0, "&profsurf;"],
+    [1, "&telrec;"],
+    [0, "&target;"],
+    [5, "&ulcorn;"],
+    [0, "&urcorn;"],
+    [0, "&dlcorn;"],
+    [0, "&drcorn;"],
+    [2, "&frown;"],
+    [0, "&smile;"],
+    [9, "&cylcty;"],
+    [0, "&profalar;"],
+    [7, "&topbot;"],
+    [6, "&ovbar;"],
+    [1, "&solbar;"],
+    [60, "&angzarr;"],
+    [51, "&lmoustache;"],
+    [0, "&rmoustache;"],
+    [2, "&OverBracket;"],
+    [0, "&bbrk;"],
+    [0, "&bbrktbrk;"],
+    [37, "&OverParenthesis;"],
+    [0, "&UnderParenthesis;"],
+    [0, "&OverBrace;"],
+    [0, "&UnderBrace;"],
+    [2, "&trpezium;"],
+    [4, "&elinters;"],
+    [59, "&blank;"],
+    [164, "&circledS;"],
+    [55, "&boxh;"],
+    [1, "&boxv;"],
+    [9, "&boxdr;"],
+    [3, "&boxdl;"],
+    [3, "&boxur;"],
+    [3, "&boxul;"],
+    [3, "&boxvr;"],
+    [7, "&boxvl;"],
+    [7, "&boxhd;"],
+    [7, "&boxhu;"],
+    [7, "&boxvh;"],
+    [19, "&boxH;"],
+    [0, "&boxV;"],
+    [0, "&boxdR;"],
+    [0, "&boxDr;"],
+    [0, "&boxDR;"],
+    [0, "&boxdL;"],
+    [0, "&boxDl;"],
+    [0, "&boxDL;"],
+    [0, "&boxuR;"],
+    [0, "&boxUr;"],
+    [0, "&boxUR;"],
+    [0, "&boxuL;"],
+    [0, "&boxUl;"],
+    [0, "&boxUL;"],
+    [0, "&boxvR;"],
+    [0, "&boxVr;"],
+    [0, "&boxVR;"],
+    [0, "&boxvL;"],
+    [0, "&boxVl;"],
+    [0, "&boxVL;"],
+    [0, "&boxHd;"],
+    [0, "&boxhD;"],
+    [0, "&boxHD;"],
+    [0, "&boxHu;"],
+    [0, "&boxhU;"],
+    [0, "&boxHU;"],
+    [0, "&boxvH;"],
+    [0, "&boxVh;"],
+    [0, "&boxVH;"],
+    [19, "&uhblk;"],
+    [3, "&lhblk;"],
+    [3, "&block;"],
+    [8, "&blk14;"],
+    [0, "&blk12;"],
+    [0, "&blk34;"],
+    [13, "&square;"],
+    [8, "&blacksquare;"],
+    [0, "&EmptyVerySmallSquare;"],
+    [1, "&rect;"],
+    [0, "&marker;"],
+    [2, "&fltns;"],
+    [1, "&bigtriangleup;"],
+    [0, "&blacktriangle;"],
+    [0, "&triangle;"],
+    [2, "&blacktriangleright;"],
+    [0, "&rtri;"],
+    [3, "&bigtriangledown;"],
+    [0, "&blacktriangledown;"],
+    [0, "&dtri;"],
+    [2, "&blacktriangleleft;"],
+    [0, "&ltri;"],
+    [6, "&loz;"],
+    [0, "&cir;"],
+    [32, "&tridot;"],
+    [2, "&bigcirc;"],
+    [8, "&ultri;"],
+    [0, "&urtri;"],
+    [0, "&lltri;"],
+    [0, "&EmptySmallSquare;"],
+    [0, "&FilledSmallSquare;"],
+    [8, "&bigstar;"],
+    [0, "&star;"],
+    [7, "&phone;"],
+    [49, "&female;"],
+    [1, "&male;"],
+    [29, "&spades;"],
+    [2, "&clubs;"],
+    [1, "&hearts;"],
+    [0, "&diamondsuit;"],
+    [3, "&sung;"],
+    [2, "&flat;"],
+    [0, "&natural;"],
+    [0, "&sharp;"],
+    [163, "&check;"],
+    [3, "&cross;"],
+    [8, "&malt;"],
+    [21, "&sext;"],
+    [33, "&VerticalSeparator;"],
+    [25, "&lbbrk;"],
+    [0, "&rbbrk;"],
+    [84, "&bsolhsub;"],
+    [0, "&suphsol;"],
+    [28, "&LeftDoubleBracket;"],
+    [0, "&RightDoubleBracket;"],
+    [0, "&lang;"],
+    [0, "&rang;"],
+    [0, "&Lang;"],
+    [0, "&Rang;"],
+    [0, "&loang;"],
+    [0, "&roang;"],
+    [7, "&longleftarrow;"],
+    [0, "&longrightarrow;"],
+    [0, "&longleftrightarrow;"],
+    [0, "&DoubleLongLeftArrow;"],
+    [0, "&DoubleLongRightArrow;"],
+    [0, "&DoubleLongLeftRightArrow;"],
+    [1, "&longmapsto;"],
+    [2, "&dzigrarr;"],
+    [258, "&nvlArr;"],
+    [0, "&nvrArr;"],
+    [0, "&nvHarr;"],
+    [0, "&Map;"],
+    [6, "&lbarr;"],
+    [0, "&bkarow;"],
+    [0, "&lBarr;"],
+    [0, "&dbkarow;"],
+    [0, "&drbkarow;"],
+    [0, "&DDotrahd;"],
+    [0, "&UpArrowBar;"],
+    [0, "&DownArrowBar;"],
+    [2, "&Rarrtl;"],
+    [2, "&latail;"],
+    [0, "&ratail;"],
+    [0, "&lAtail;"],
+    [0, "&rAtail;"],
+    [0, "&larrfs;"],
+    [0, "&rarrfs;"],
+    [0, "&larrbfs;"],
+    [0, "&rarrbfs;"],
+    [2, "&nwarhk;"],
+    [0, "&nearhk;"],
+    [0, "&hksearow;"],
+    [0, "&hkswarow;"],
+    [0, "&nwnear;"],
+    [0, "&nesear;"],
+    [0, "&seswar;"],
+    [0, "&swnwar;"],
+    [8, {
+        v: "&rarrc;",
+        n: 824,
+        o: "&nrarrc;"
+    }],
+    [1, "&cudarrr;"],
+    [0, "&ldca;"],
+    [0, "&rdca;"],
+    [0, "&cudarrl;"],
+    [0, "&larrpl;"],
+    [2, "&curarrm;"],
+    [0, "&cularrp;"],
+    [7, "&rarrpl;"],
+    [2, "&harrcir;"],
+    [0, "&Uarrocir;"],
+    [0, "&lurdshar;"],
+    [0, "&ldrushar;"],
+    [2, "&LeftRightVector;"],
+    [0, "&RightUpDownVector;"],
+    [0, "&DownLeftRightVector;"],
+    [0, "&LeftUpDownVector;"],
+    [0, "&LeftVectorBar;"],
+    [0, "&RightVectorBar;"],
+    [0, "&RightUpVectorBar;"],
+    [0, "&RightDownVectorBar;"],
+    [0, "&DownLeftVectorBar;"],
+    [0, "&DownRightVectorBar;"],
+    [0, "&LeftUpVectorBar;"],
+    [0, "&LeftDownVectorBar;"],
+    [0, "&LeftTeeVector;"],
+    [0, "&RightTeeVector;"],
+    [0, "&RightUpTeeVector;"],
+    [0, "&RightDownTeeVector;"],
+    [0, "&DownLeftTeeVector;"],
+    [0, "&DownRightTeeVector;"],
+    [0, "&LeftUpTeeVector;"],
+    [0, "&LeftDownTeeVector;"],
+    [0, "&lHar;"],
+    [0, "&uHar;"],
+    [0, "&rHar;"],
+    [0, "&dHar;"],
+    [0, "&luruhar;"],
+    [0, "&ldrdhar;"],
+    [0, "&ruluhar;"],
+    [0, "&rdldhar;"],
+    [0, "&lharul;"],
+    [0, "&llhard;"],
+    [0, "&rharul;"],
+    [0, "&lrhard;"],
+    [0, "&udhar;"],
+    [0, "&duhar;"],
+    [0, "&RoundImplies;"],
+    [0, "&erarr;"],
+    [0, "&simrarr;"],
+    [0, "&larrsim;"],
+    [0, "&rarrsim;"],
+    [0, "&rarrap;"],
+    [0, "&ltlarr;"],
+    [1, "&gtrarr;"],
+    [0, "&subrarr;"],
+    [1, "&suplarr;"],
+    [0, "&lfisht;"],
+    [0, "&rfisht;"],
+    [0, "&ufisht;"],
+    [0, "&dfisht;"],
+    [5, "&lopar;"],
+    [0, "&ropar;"],
+    [4, "&lbrke;"],
+    [0, "&rbrke;"],
+    [0, "&lbrkslu;"],
+    [0, "&rbrksld;"],
+    [0, "&lbrksld;"],
+    [0, "&rbrkslu;"],
+    [0, "&langd;"],
+    [0, "&rangd;"],
+    [0, "&lparlt;"],
+    [0, "&rpargt;"],
+    [0, "&gtlPar;"],
+    [0, "&ltrPar;"],
+    [3, "&vzigzag;"],
+    [1, "&vangrt;"],
+    [0, "&angrtvbd;"],
+    [6, "&ange;"],
+    [0, "&range;"],
+    [0, "&dwangle;"],
+    [0, "&uwangle;"],
+    [0, "&angmsdaa;"],
+    [0, "&angmsdab;"],
+    [0, "&angmsdac;"],
+    [0, "&angmsdad;"],
+    [0, "&angmsdae;"],
+    [0, "&angmsdaf;"],
+    [0, "&angmsdag;"],
+    [0, "&angmsdah;"],
+    [0, "&bemptyv;"],
+    [0, "&demptyv;"],
+    [0, "&cemptyv;"],
+    [0, "&raemptyv;"],
+    [0, "&laemptyv;"],
+    [0, "&ohbar;"],
+    [0, "&omid;"],
+    [0, "&opar;"],
+    [1, "&operp;"],
+    [1, "&olcross;"],
+    [0, "&odsold;"],
+    [1, "&olcir;"],
+    [0, "&ofcir;"],
+    [0, "&olt;"],
+    [0, "&ogt;"],
+    [0, "&cirscir;"],
+    [0, "&cirE;"],
+    [0, "&solb;"],
+    [0, "&bsolb;"],
+    [3, "&boxbox;"],
+    [3, "&trisb;"],
+    [0, "&rtriltri;"],
+    [0, {
+        v: "&LeftTriangleBar;",
+        n: 824,
+        o: "&NotLeftTriangleBar;"
+    }],
+    [0, {
+        v: "&RightTriangleBar;",
+        n: 824,
+        o: "&NotRightTriangleBar;"
+    }],
+    [11, "&iinfin;"],
+    [0, "&infintie;"],
+    [0, "&nvinfin;"],
+    [4, "&eparsl;"],
+    [0, "&smeparsl;"],
+    [0, "&eqvparsl;"],
+    [5, "&blacklozenge;"],
+    [8, "&RuleDelayed;"],
+    [1, "&dsol;"],
+    [9, "&bigodot;"],
+    [0, "&bigoplus;"],
+    [0, "&bigotimes;"],
+    [1, "&biguplus;"],
+    [1, "&bigsqcup;"],
+    [5, "&iiiint;"],
+    [0, "&fpartint;"],
+    [2, "&cirfnint;"],
+    [0, "&awint;"],
+    [0, "&rppolint;"],
+    [0, "&scpolint;"],
+    [0, "&npolint;"],
+    [0, "&pointint;"],
+    [0, "&quatint;"],
+    [0, "&intlarhk;"],
+    [10, "&pluscir;"],
+    [0, "&plusacir;"],
+    [0, "&simplus;"],
+    [0, "&plusdu;"],
+    [0, "&plussim;"],
+    [0, "&plustwo;"],
+    [1, "&mcomma;"],
+    [0, "&minusdu;"],
+    [2, "&loplus;"],
+    [0, "&roplus;"],
+    [0, "&Cross;"],
+    [0, "&timesd;"],
+    [0, "&timesbar;"],
+    [1, "&smashp;"],
+    [0, "&lotimes;"],
+    [0, "&rotimes;"],
+    [0, "&otimesas;"],
+    [0, "&Otimes;"],
+    [0, "&odiv;"],
+    [0, "&triplus;"],
+    [0, "&triminus;"],
+    [0, "&tritime;"],
+    [0, "&intprod;"],
+    [2, "&amalg;"],
+    [0, "&capdot;"],
+    [1, "&ncup;"],
+    [0, "&ncap;"],
+    [0, "&capand;"],
+    [0, "&cupor;"],
+    [0, "&cupcap;"],
+    [0, "&capcup;"],
+    [0, "&cupbrcap;"],
+    [0, "&capbrcup;"],
+    [0, "&cupcup;"],
+    [0, "&capcap;"],
+    [0, "&ccups;"],
+    [0, "&ccaps;"],
+    [2, "&ccupssm;"],
+    [2, "&And;"],
+    [0, "&Or;"],
+    [0, "&andand;"],
+    [0, "&oror;"],
+    [0, "&orslope;"],
+    [0, "&andslope;"],
+    [1, "&andv;"],
+    [0, "&orv;"],
+    [0, "&andd;"],
+    [0, "&ord;"],
+    [1, "&wedbar;"],
+    [6, "&sdote;"],
+    [3, "&simdot;"],
+    [2, {
+        v: "&congdot;",
+        n: 824,
+        o: "&ncongdot;"
+    }],
+    [0, "&easter;"],
+    [0, "&apacir;"],
+    [0, {
+        v: "&apE;",
+        n: 824,
+        o: "&napE;"
+    }],
+    [0, "&eplus;"],
+    [0, "&pluse;"],
+    [0, "&Esim;"],
+    [0, "&Colone;"],
+    [0, "&Equal;"],
+    [1, "&ddotseq;"],
+    [0, "&equivDD;"],
+    [0, "&ltcir;"],
+    [0, "&gtcir;"],
+    [0, "&ltquest;"],
+    [0, "&gtquest;"],
+    [0, {
+        v: "&leqslant;",
+        n: 824,
+        o: "&nleqslant;"
+    }],
+    [0, {
+        v: "&geqslant;",
+        n: 824,
+        o: "&ngeqslant;"
+    }],
+    [0, "&lesdot;"],
+    [0, "&gesdot;"],
+    [0, "&lesdoto;"],
+    [0, "&gesdoto;"],
+    [0, "&lesdotor;"],
+    [0, "&gesdotol;"],
+    [0, "&lap;"],
+    [0, "&gap;"],
+    [0, "&lne;"],
+    [0, "&gne;"],
+    [0, "&lnap;"],
+    [0, "&gnap;"],
+    [0, "&lEg;"],
+    [0, "&gEl;"],
+    [0, "&lsime;"],
+    [0, "&gsime;"],
+    [0, "&lsimg;"],
+    [0, "&gsiml;"],
+    [0, "&lgE;"],
+    [0, "&glE;"],
+    [0, "&lesges;"],
+    [0, "&gesles;"],
+    [0, "&els;"],
+    [0, "&egs;"],
+    [0, "&elsdot;"],
+    [0, "&egsdot;"],
+    [0, "&el;"],
+    [0, "&eg;"],
+    [2, "&siml;"],
+    [0, "&simg;"],
+    [0, "&simlE;"],
+    [0, "&simgE;"],
+    [0, {
+        v: "&LessLess;",
+        n: 824,
+        o: "&NotNestedLessLess;"
+    }],
+    [0, {
+        v: "&GreaterGreater;",
+        n: 824,
+        o: "&NotNestedGreaterGreater;"
+    }],
+    [1, "&glj;"],
+    [0, "&gla;"],
+    [0, "&ltcc;"],
+    [0, "&gtcc;"],
+    [0, "&lescc;"],
+    [0, "&gescc;"],
+    [0, "&smt;"],
+    [0, "&lat;"],
+    [0, {
+        v: "&smte;",
+        n: 65024,
+        o: "&smtes;"
+    }],
+    [0, {
+        v: "&late;",
+        n: 65024,
+        o: "&lates;"
+    }],
+    [0, "&bumpE;"],
+    [0, {
+        v: "&PrecedesEqual;",
+        n: 824,
+        o: "&NotPrecedesEqual;"
+    }],
+    [0, {
+        v: "&sce;",
+        n: 824,
+        o: "&NotSucceedsEqual;"
+    }],
+    [2, "&prE;"],
+    [0, "&scE;"],
+    [0, "&precneqq;"],
+    [0, "&scnE;"],
+    [0, "&prap;"],
+    [0, "&scap;"],
+    [0, "&precnapprox;"],
+    [0, "&scnap;"],
+    [0, "&Pr;"],
+    [0, "&Sc;"],
+    [0, "&subdot;"],
+    [0, "&supdot;"],
+    [0, "&subplus;"],
+    [0, "&supplus;"],
+    [0, "&submult;"],
+    [0, "&supmult;"],
+    [0, "&subedot;"],
+    [0, "&supedot;"],
+    [0, {
+        v: "&subE;",
+        n: 824,
+        o: "&nsubE;"
+    }],
+    [0, {
+        v: "&supE;",
+        n: 824,
+        o: "&nsupE;"
+    }],
+    [0, "&subsim;"],
+    [0, "&supsim;"],
+    [2, {
+        v: "&subnE;",
+        n: 65024,
+        o: "&varsubsetneqq;"
+    }],
+    [0, {
+        v: "&supnE;",
+        n: 65024,
+        o: "&varsupsetneqq;"
+    }],
+    [2, "&csub;"],
+    [0, "&csup;"],
+    [0, "&csube;"],
+    [0, "&csupe;"],
+    [0, "&subsup;"],
+    [0, "&supsub;"],
+    [0, "&subsub;"],
+    [0, "&supsup;"],
+    [0, "&suphsub;"],
+    [0, "&supdsub;"],
+    [0, "&forkv;"],
+    [0, "&topfork;"],
+    [0, "&mlcp;"],
+    [8, "&Dashv;"],
+    [1, "&Vdashl;"],
+    [0, "&Barv;"],
+    [0, "&vBar;"],
+    [0, "&vBarv;"],
+    [1, "&Vbar;"],
+    [0, "&Not;"],
+    [0, "&bNot;"],
+    [0, "&rnmid;"],
+    [0, "&cirmid;"],
+    [0, "&midcir;"],
+    [0, "&topcir;"],
+    [0, "&nhpar;"],
+    [0, "&parsim;"],
+    [9, {
+        v: "&parsl;",
+        n: 8421,
+        o: "&nparsl;"
+    }],
+    [44343, {
+        n: new Map(Qr([
+            [56476, "&Ascr;"],
+            [1, "&Cscr;"],
+            [0, "&Dscr;"],
+            [2, "&Gscr;"],
+            [2, "&Jscr;"],
+            [0, "&Kscr;"],
+            [2, "&Nscr;"],
+            [0, "&Oscr;"],
+            [0, "&Pscr;"],
+            [0, "&Qscr;"],
+            [1, "&Sscr;"],
+            [0, "&Tscr;"],
+            [0, "&Uscr;"],
+            [0, "&Vscr;"],
+            [0, "&Wscr;"],
+            [0, "&Xscr;"],
+            [0, "&Yscr;"],
+            [0, "&Zscr;"],
+            [0, "&ascr;"],
+            [0, "&bscr;"],
+            [0, "&cscr;"],
+            [0, "&dscr;"],
+            [1, "&fscr;"],
+            [1, "&hscr;"],
+            [0, "&iscr;"],
+            [0, "&jscr;"],
+            [0, "&kscr;"],
+            [0, "&lscr;"],
+            [0, "&mscr;"],
+            [0, "&nscr;"],
+            [1, "&pscr;"],
+            [0, "&qscr;"],
+            [0, "&rscr;"],
+            [0, "&sscr;"],
+            [0, "&tscr;"],
+            [0, "&uscr;"],
+            [0, "&vscr;"],
+            [0, "&wscr;"],
+            [0, "&xscr;"],
+            [0, "&yscr;"],
+            [0, "&zscr;"],
+            [52, "&Afr;"],
+            [0, "&Bfr;"],
+            [1, "&Dfr;"],
+            [0, "&Efr;"],
+            [0, "&Ffr;"],
+            [0, "&Gfr;"],
+            [2, "&Jfr;"],
+            [0, "&Kfr;"],
+            [0, "&Lfr;"],
+            [0, "&Mfr;"],
+            [0, "&Nfr;"],
+            [0, "&Ofr;"],
+            [0, "&Pfr;"],
+            [0, "&Qfr;"],
+            [1, "&Sfr;"],
+            [0, "&Tfr;"],
+            [0, "&Ufr;"],
+            [0, "&Vfr;"],
+            [0, "&Wfr;"],
+            [0, "&Xfr;"],
+            [0, "&Yfr;"],
+            [1, "&afr;"],
+            [0, "&bfr;"],
+            [0, "&cfr;"],
+            [0, "&dfr;"],
+            [0, "&efr;"],
+            [0, "&ffr;"],
+            [0, "&gfr;"],
+            [0, "&hfr;"],
+            [0, "&ifr;"],
+            [0, "&jfr;"],
+            [0, "&kfr;"],
+            [0, "&lfr;"],
+            [0, "&mfr;"],
+            [0, "&nfr;"],
+            [0, "&ofr;"],
+            [0, "&pfr;"],
+            [0, "&qfr;"],
+            [0, "&rfr;"],
+            [0, "&sfr;"],
+            [0, "&tfr;"],
+            [0, "&ufr;"],
+            [0, "&vfr;"],
+            [0, "&wfr;"],
+            [0, "&xfr;"],
+            [0, "&yfr;"],
+            [0, "&zfr;"],
+            [0, "&Aopf;"],
+            [0, "&Bopf;"],
+            [1, "&Dopf;"],
+            [0, "&Eopf;"],
+            [0, "&Fopf;"],
+            [0, "&Gopf;"],
+            [1, "&Iopf;"],
+            [0, "&Jopf;"],
+            [0, "&Kopf;"],
+            [0, "&Lopf;"],
+            [0, "&Mopf;"],
+            [1, "&Oopf;"],
+            [3, "&Sopf;"],
+            [0, "&Topf;"],
+            [0, "&Uopf;"],
+            [0, "&Vopf;"],
+            [0, "&Wopf;"],
+            [0, "&Xopf;"],
+            [0, "&Yopf;"],
+            [1, "&aopf;"],
+            [0, "&bopf;"],
+            [0, "&copf;"],
+            [0, "&dopf;"],
+            [0, "&eopf;"],
+            [0, "&fopf;"],
+            [0, "&gopf;"],
+            [0, "&hopf;"],
+            [0, "&iopf;"],
+            [0, "&jopf;"],
+            [0, "&kopf;"],
+            [0, "&lopf;"],
+            [0, "&mopf;"],
+            [0, "&nopf;"],
+            [0, "&oopf;"],
+            [0, "&popf;"],
+            [0, "&qopf;"],
+            [0, "&ropf;"],
+            [0, "&sopf;"],
+            [0, "&topf;"],
+            [0, "&uopf;"],
+            [0, "&vopf;"],
+            [0, "&wopf;"],
+            [0, "&xopf;"],
+            [0, "&yopf;"],
+            [0, "&zopf;"]
+        ]))
+    }],
+    [8906, "&fflig;"],
+    [0, "&filig;"],
+    [0, "&fllig;"],
+    [0, "&ffilig;"],
+    [0, "&ffllig;"]
+]));
+var Nd = new Map([
+        [34, "&quot;"],
+        [38, "&amp;"],
+        [39, "&apos;"],
+        [60, "&lt;"],
+        [62, "&gt;"]
+    ]),
+    Ld = String.prototype.codePointAt != null ? (e, r) => e.codePointAt(r) : (e, r) => (e.charCodeAt(r) & 64512) === 55296 ? (e.charCodeAt(r) - 55296) * 1024 + e.charCodeAt(r + 1) - 56320 + 65536 : e.charCodeAt(r);
+
+function Du(e, r) {
+    return function(o) {
+        let s, l = 0,
+            h = "";
+        for (; s = e.exec(o);) l !== s.index && (h += o.substring(l, s.index)), h += r.get(s[0].charCodeAt(0)), l = s.index + 1;
+        return h + o.substring(l)
+    }
+}
+var ks = Du(/[&<>'"]/g, Nd),
+    _s = Du(/["&\u00A0]/g, new Map([
+        [34, "&quot;"],
+        [38, "&amp;"],
+        [160, "&nbsp;"]
+    ])),
+    Cs = Du(/[&<>\u00A0]/g, new Map([
+        [38, "&amp;"],
+        [60, "&lt;"],
+        [62, "&gt;"],
+        [160, "&nbsp;"]
+    ]));
+var Ss;
+(function(e) {
+    e[e.XML = 0] = "XML", e[e.HTML = 1] = "HTML"
+})(Ss || (Ss = {}));
+var As;
+(function(e) {
+    e[e.UTF8 = 0] = "UTF8", e[e.ASCII = 1] = "ASCII", e[e.Extensive = 2] = "Extensive", e[e.Attribute = 3] = "Attribute", e[e.Text = 4] = "Text"
+})(As || (As = {}));
+
+function Od(e) {
+    return Object.prototype.toString.call(e)
+}
+
+function Jr(e) {
+    return Od(e) === "[object String]"
+}
+var Hd = Object.prototype.hasOwnProperty;
+
+function $d(e, r) {
+    return Hd.call(e, r)
+}
+
+function A0(e) {
+    return Array.prototype.slice.call(arguments, 1).forEach(function(i) {
+        if (i) {
+            if (typeof i != "object") throw new TypeError(i + "must be object");
+            Object.keys(i).forEach(function(o) {
+                e[o] = i[o]
+            })
+        }
+    }), e
+}
+
+function Mu(e, r, i) {
+    return [].concat(e.slice(0, r), i, e.slice(r + 1))
+}
+
+function Kr(e) {
+    return !(e >= 55296 && e <= 57343 || e >= 64976 && e <= 65007 || (e & 65535) === 65535 || (e & 65535) === 65534 || e >= 0 && e <= 8 || e === 11 || e >= 14 && e <= 31 || e >= 127 && e <= 159 || e > 1114111)
+}
+
+function X0(e) {
+    if (e > 65535) {
+        e -= 65536;
+        let r = 55296 + (e >> 10),
+            i = 56320 + (e & 1023);
+        return String.fromCharCode(r, i)
+    }
+    return String.fromCharCode(e)
+}
+var Es = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g,
+    Gd = /&([a-z#][a-z0-9]{1,31});/gi,
+    Vd = new RegExp(Es.source + "|" + Gd.source, "gi"),
+    Ud = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
+
+function jd(e, r) {
+    if (r.charCodeAt(0) === 35 && Ud.test(r)) {
+        let o = r[1].toLowerCase() === "x" ? parseInt(r.slice(2), 16) : parseInt(r.slice(1), 10);
+        return Kr(o) ? X0(o) : e
+    }
+    let i = n0(e);
+    return i !== e ? i : e
+}
+
+function Wd(e) {
+    return e.indexOf("\\") < 0 ? e : e.replace(Es, "$1")
+}
+
+function Ot(e) {
+    return e.indexOf("\\") < 0 && e.indexOf("&") < 0 ? e : e.replace(Vd, function(r, i, o) {
+        return i || jd(r, o)
+    })
+}
+var Yd = /[&<>"]/,
+    Zd = /[&<>"]/g,
+    Xd = {
+        "&": "&amp;",
+        "<": "&lt;",
+        ">": "&gt;",
+        '"': "&quot;"
+    };
+
+function Qd(e) {
+    return Xd[e]
+}
+
+function Ht(e) {
+    return Yd.test(e) ? e.replace(Zd, Qd) : e
+}
+var Jd = /[.?*+^$[\]\\(){}|-]/g;
+
+function Kd(e) {
+    return e.replace(Jd, "\\$&")
+}
+
+function me(e) {
+    switch (e) {
+        case 9:
+        case 32:
+            return !0
+    }
+    return !1
+}
+
+function h0(e) {
+    if (e >= 8192 && e <= 8202) return !0;
+    switch (e) {
+        case 9:
+        case 10:
+        case 11:
+        case 12:
+        case 13:
+        case 32:
+        case 160:
+        case 5760:
+        case 8239:
+        case 8287:
+        case 12288:
+            return !0
+    }
+    return !1
+}
+
+function f0(e) {
+    return S0.test(e) || Yr.test(e)
+}
+
+function m0(e) {
+    switch (e) {
+        case 33:
+        case 34:
+        case 35:
+        case 36:
+        case 37:
+        case 38:
+        case 39:
+        case 40:
+        case 41:
+        case 42:
+        case 43:
+        case 44:
+        case 45:
+        case 46:
+        case 47:
+        case 58:
+        case 59:
+        case 60:
+        case 61:
+        case 62:
+        case 63:
+        case 64:
+        case 91:
+        case 92:
+        case 93:
+        case 94:
+        case 95:
+        case 96:
+        case 123:
+        case 124:
+        case 125:
+        case 126:
+            return !0;
+        default:
+            return !1
+    }
+}
+
+function p0(e) {
+    return e = e.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (e = e.replace(/ẞ/g, "\xDF")), e.toLowerCase().toUpperCase()
+}
+var eh = {
+    mdurl: Ur,
+    ucmicro: _u
+};
+var Bu = {};
+wr(Bu, {
+    parseLinkDestination: () => zu,
+    parseLinkLabel: () => Fu,
+    parseLinkTitle: () => Ru
+});
+
+function Fu(e, r, i) {
+    let o, s, l, h, p = e.posMax,
+        b = e.pos;
+    for (e.pos = r + 1, o = 1; e.pos < p;) {
+        if (l = e.src.charCodeAt(e.pos), l === 93 && (o--, o === 0)) {
+            s = !0;
+            break
+        }
+        if (h = e.pos, e.md.inline.skipToken(e), l === 91) {
+            if (h === e.pos - 1) o++;
+            else if (i) return e.pos = b, -1
+        }
+    }
+    let x = -1;
+    return s && (x = e.pos), e.pos = b, x
+}
+
+function zu(e, r, i) {
+    let o, s = r,
+        l = {
+            ok: !1,
+            pos: 0,
+            str: ""
+        };
+    if (e.charCodeAt(s) === 60) {
+        for (s++; s < i;) {
+            if (o = e.charCodeAt(s), o === 10 || o === 60) return l;
+            if (o === 62) return l.pos = s + 1, l.str = Ot(e.slice(r + 1, s)), l.ok = !0, l;
+            if (o === 92 && s + 1 < i) {
+                s += 2;
+                continue
+            }
+            s++
+        }
+        return l
+    }
+    let h = 0;
+    for (; s < i && (o = e.charCodeAt(s), !(o === 32 || o < 32 || o === 127));) {
+        if (o === 92 && s + 1 < i) {
+            if (e.charCodeAt(s + 1) === 32) break;
+            s += 2;
+            continue
+        }
+        if (o === 40 && (h++, h > 32)) return l;
+        if (o === 41) {
+            if (h === 0) break;
+            h--
+        }
+        s++
+    }
+    return r === s || h !== 0 || (l.str = Ot(e.slice(r, s)), l.pos = s, l.ok = !0), l
+}
+
+function Ru(e, r, i, o) {
+    let s, l = r,
+        h = {
+            ok: !1,
+            can_continue: !1,
+            pos: 0,
+            str: "",
+            marker: 0
+        };
+    if (o) h.str = o.str, h.marker = o.marker;
+    else {
+        if (l >= i) return h;
+        let p = e.charCodeAt(l);
+        if (p !== 34 && p !== 39 && p !== 40) return h;
+        r++, l++, p === 40 && (p = 41), h.marker = p
+    }
+    for (; l < i;) {
+        if (s = e.charCodeAt(l), s === h.marker) return h.pos = l + 1, h.str += Ot(e.slice(r, l)), h.ok = !0, h;
+        if (s === 40 && h.marker === 41) return h;
+        s === 92 && l + 1 < i && l++, l++
+    }
+    return h.can_continue = !0, h.str += Ot(e.slice(r, l)), h
+}
+var Tt = {};
+Tt.code_inline = function(e, r, i, o, s) {
+    let l = e[r];
+    return "<code" + s.renderAttrs(l) + ">" + Ht(l.content) + "</code>"
+};
+Tt.code_block = function(e, r, i, o, s) {
+    let l = e[r];
+    return "<pre" + s.renderAttrs(l) + "><code>" + Ht(e[r].content) + `</code></pre>
+`
+};
+Tt.fence = function(e, r, i, o, s) {
+    let l = e[r],
+        h = l.info ? Ot(l.info).trim() : "",
+        p = "",
+        b = "";
+    if (h) {
+        let C = h.split(/(\s+)/g);
+        p = C[0], b = C.slice(2).join("")
+    }
+    let x;
+    if (i.highlight ? x = i.highlight(l.content, p, b) || Ht(l.content) : x = Ht(l.content), x.indexOf("<pre") === 0) return x + `
+`;
+    if (h) {
+        let C = l.attrIndex("class"),
+            k = l.attrs ? l.attrs.slice() : [];
+        C < 0 ? k.push(["class", i.langPrefix + p]) : (k[C] = k[C].slice(), k[C][1] += " " + i.langPrefix + p);
+        let F = {
+            attrs: k
+        };
+        return `<pre><code${s.renderAttrs(F)}>${x}</code></pre>
+`
+    }
+    return `<pre><code${s.renderAttrs(l)}>${x}</code></pre>
+`
+};
+Tt.image = function(e, r, i, o, s) {
+    let l = e[r];
+    return l.attrs[l.attrIndex("alt")][1] = s.renderInlineAsText(l.children, i, o), s.renderToken(e, r, i)
+};
+Tt.hardbreak = function(e, r, i) {
+    return i.xhtmlOut ? `<br />
+` : `<br>
+`
+};
+Tt.softbreak = function(e, r, i) {
+    return i.breaks ? i.xhtmlOut ? `<br />
+` : `<br>
+` : `
+`
+};
+Tt.text = function(e, r) {
+    return Ht(e[r].content)
+};
+Tt.html_block = function(e, r) {
+    return e[r].content
+};
+Tt.html_inline = function(e, r) {
+    return e[r].content
+};
+
+function T0() {
+    this.rules = A0({}, Tt)
+}
+T0.prototype.renderAttrs = function(r) {
+    let i, o, s;
+    if (!r.attrs) return "";
+    for (s = "", i = 0, o = r.attrs.length; i < o; i++) s += " " + Ht(r.attrs[i][0]) + '="' + Ht(r.attrs[i][1]) + '"';
+    return s
+};
+T0.prototype.renderToken = function(r, i, o) {
+    let s = r[i],
+        l = "";
+    if (s.hidden) return "";
+    s.block && s.nesting !== -1 && i && r[i - 1].hidden && (l += `
+`), l += (s.nesting === -1 ? "</" : "<") + s.tag, l += this.renderAttrs(s), s.nesting === 0 && o.xhtmlOut && (l += " /");
+    let h = !1;
+    if (s.block && (h = !0, s.nesting === 1 && i + 1 < r.length)) {
+        let p = r[i + 1];
+        (p.type === "inline" || p.hidden || p.nesting === -1 && p.tag === s.tag) && (h = !1)
+    }
+    return l += h ? `>
+` : ">", l
+};
+T0.prototype.renderInline = function(e, r, i) {
+    let o = "",
+        s = this.rules;
+    for (let l = 0, h = e.length; l < h; l++) {
+        let p = e[l].type;
+        typeof s[p] < "u" ? o += s[p](e, l, r, i, this) : o += this.renderToken(e, l, r)
+    }
+    return o
+};
+T0.prototype.renderInlineAsText = function(e, r, i) {
+    let o = "";
+    for (let s = 0, l = e.length; s < l; s++) switch (e[s].type) {
+        case "text":
+            o += e[s].content;
+            break;
+        case "image":
+            o += this.renderInlineAsText(e[s].children, r, i);
+            break;
+        case "html_inline":
+        case "html_block":
+            o += e[s].content;
+            break;
+        case "softbreak":
+        case "hardbreak":
+            o += `
+`;
+            break;
+        default:
+    }
+    return o
+};
+T0.prototype.render = function(e, r, i) {
+    let o = "",
+        s = this.rules;
+    for (let l = 0, h = e.length; l < h; l++) {
+        let p = e[l].type;
+        p === "inline" ? o += this.renderInline(e[l].children, r, i) : typeof s[p] < "u" ? o += s[p](e, l, r, i, this) : o += this.renderToken(e, l, r, i)
+    }
+    return o
+};
+var Ms = T0;
+
+function vt() {
+    this.__rules__ = [], this.__cache__ = null
+}
+vt.prototype.__find__ = function(e) {
+    for (let r = 0; r < this.__rules__.length; r++)
+        if (this.__rules__[r].name === e) return r;
+    return -1
+};
+vt.prototype.__compile__ = function() {
+    let e = this,
+        r = [""];
+    e.__rules__.forEach(function(i) {
+        i.enabled && i.alt.forEach(function(o) {
+            r.indexOf(o) < 0 && r.push(o)
+        })
+    }), e.__cache__ = {}, r.forEach(function(i) {
+        e.__cache__[i] = [], e.__rules__.forEach(function(o) {
+            o.enabled && (i && o.alt.indexOf(i) < 0 || e.__cache__[i].push(o.fn))
+        })
+    })
+};
+vt.prototype.at = function(e, r, i) {
+    let o = this.__find__(e),
+        s = i || {};
+    if (o === -1) throw new Error("Parser rule not found: " + e);
+    this.__rules__[o].fn = r, this.__rules__[o].alt = s.alt || [], this.__cache__ = null
+};
+vt.prototype.before = function(e, r, i, o) {
+    let s = this.__find__(e),
+        l = o || {};
+    if (s === -1) throw new Error("Parser rule not found: " + e);
+    this.__rules__.splice(s, 0, {
+        name: r,
+        enabled: !0,
+        fn: i,
+        alt: l.alt || []
+    }), this.__cache__ = null
+};
+vt.prototype.after = function(e, r, i, o) {
+    let s = this.__find__(e),
+        l = o || {};
+    if (s === -1) throw new Error("Parser rule not found: " + e);
+    this.__rules__.splice(s + 1, 0, {
+        name: r,
+        enabled: !0,
+        fn: i,
+        alt: l.alt || []
+    }), this.__cache__ = null
+};
+vt.prototype.push = function(e, r, i) {
+    let o = i || {};
+    this.__rules__.push({
+        name: e,
+        enabled: !0,
+        fn: r,
+        alt: o.alt || []
+    }), this.__cache__ = null
+};
+vt.prototype.enable = function(e, r) {
+    Array.isArray(e) || (e = [e]);
+    let i = [];
+    return e.forEach(function(o) {
+        let s = this.__find__(o);
+        if (s < 0) {
+            if (r) return;
+            throw new Error("Rules manager: invalid rule name " + o)
+        }
+        this.__rules__[s].enabled = !0, i.push(o)
+    }, this), this.__cache__ = null, i
+};
+vt.prototype.enableOnly = function(e, r) {
+    Array.isArray(e) || (e = [e]), this.__rules__.forEach(function(i) {
+        i.enabled = !1
+    }), this.enable(e, r)
+};
+vt.prototype.disable = function(e, r) {
+    Array.isArray(e) || (e = [e]);
+    let i = [];
+    return e.forEach(function(o) {
+        let s = this.__find__(o);
+        if (s < 0) {
+            if (r) return;
+            throw new Error("Rules manager: invalid rule name " + o)
+        }
+        this.__rules__[s].enabled = !1, i.push(o)
+    }, this), this.__cache__ = null, i
+};
+vt.prototype.getRules = function(e) {
+    return this.__cache__ === null && this.__compile__(), this.__cache__[e] || []
+};
+var b0 = vt;
+
+function D0(e, r, i) {
+    this.type = e, this.tag = r, this.attrs = null, this.map = null, this.nesting = i, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1
+}
+D0.prototype.attrIndex = function(r) {
+    if (!this.attrs) return -1;
+    let i = this.attrs;
+    for (let o = 0, s = i.length; o < s; o++)
+        if (i[o][0] === r) return o;
+    return -1
+};
+D0.prototype.attrPush = function(r) {
+    this.attrs ? this.attrs.push(r) : this.attrs = [r]
+};
+D0.prototype.attrSet = function(r, i) {
+    let o = this.attrIndex(r),
+        s = [r, i];
+    o < 0 ? this.attrPush(s) : this.attrs[o] = s
+};
+D0.prototype.attrGet = function(r) {
+    let i = this.attrIndex(r),
+        o = null;
+    return i >= 0 && (o = this.attrs[i][1]), o
+};
+D0.prototype.attrJoin = function(r, i) {
+    let o = this.attrIndex(r);
+    o < 0 ? this.attrPush([r, i]) : this.attrs[o][1] = this.attrs[o][1] + " " + i
+};
+var $t = D0;
+
+function qs(e, r, i) {
+    this.src = e, this.env = i, this.tokens = [], this.inlineMode = !1, this.md = r
+}
+qs.prototype.Token = $t;
+var Fs = qs;
+var th = /\r\n?|\n/g,
+    rh = /\0/g;
+
+function Nu(e) {
+    let r;
+    r = e.src.replace(th, `
+`), r = r.replace(rh, "\uFFFD"), e.src = r
+}
+
+function Lu(e) {
+    let r;
+    e.inlineMode ? (r = new e.Token("inline", "", 0), r.content = e.src, r.map = [0, 1], r.children = [], e.tokens.push(r)) : e.md.block.parse(e.src, e.md, e.env, e.tokens)
+}
+
+function Pu(e) {
+    let r = e.tokens;
+    for (let i = 0, o = r.length; i < o; i++) {
+        let s = r[i];
+        s.type === "inline" && e.md.inline.parse(s.content, e.md, e.env, s.children)
+    }
+}
+
+function nh(e) {
+    return /^<a[>\s]/i.test(e)
+}
+
+function uh(e) {
+    return /^<\/a\s*>/i.test(e)
+}
+
+function Iu(e) {
+    let r = e.tokens;
+    if (e.md.options.linkify)
+        for (let i = 0, o = r.length; i < o; i++) {
+            if (r[i].type !== "inline" || !e.md.linkify.pretest(r[i].content)) continue;
+            let s = r[i].children,
+                l = 0;
+            for (let h = s.length - 1; h >= 0; h--) {
+                let p = s[h];
+                if (p.type === "link_close") {
+                    for (h--; s[h].level !== p.level && s[h].type !== "link_open";) h--;
+                    continue
+                }
+                if (p.type === "html_inline" && (nh(p.content) && l > 0 && l--, uh(p.content) && l++), !(l > 0) && p.type === "text" && e.md.linkify.test(p.content)) {
+                    let b = p.content,
+                        x = e.md.linkify.match(b),
+                        C = [],
+                        k = p.level,
+                        F = 0;
+                    x.length > 0 && x[0].index === 0 && h > 0 && s[h - 1].type === "text_special" && (x = x.slice(1));
+                    for (let E = 0; E < x.length; E++) {
+                        let M = x[E].url,
+                            N = e.md.normalizeLink(M);
+                        if (!e.md.validateLink(N)) continue;
+                        let G = x[E].text;
+                        x[E].schema ? x[E].schema === "mailto:" && !/^mailto:/i.test(G) ? G = e.md.normalizeLinkText("mailto:" + G).replace(/^mailto:/, "") : G = e.md.normalizeLinkText(G) : G = e.md.normalizeLinkText("http://" + G).replace(/^http:\/\//, "");
+                        let U = x[E].index;
+                        if (U > F) {
+                            let X = new e.Token("text", "", 0);
+                            X.content = b.slice(F, U), X.level = k, C.push(X)
+                        }
+                        let $ = new e.Token("link_open", "a", 1);
+                        $.attrs = [
+                            ["href", N]
+                        ], $.level = k++, $.markup = "linkify", $.info = "auto", C.push($);
+                        let V = new e.Token("text", "", 0);
+                        V.content = G, V.level = k, C.push(V);
+                        let Y = new e.Token("link_close", "a", -1);
+                        Y.level = --k, Y.markup = "linkify", Y.info = "auto", C.push(Y), F = x[E].lastIndex
+                    }
+                    if (F < b.length) {
+                        let E = new e.Token("text", "", 0);
+                        E.content = b.slice(F), E.level = k, C.push(E)
+                    }
+                    r[i].children = s = Mu(s, h, C)
+                }
+            }
+        }
+}
+var zs = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/,
+    ih = /\((c|tm|r)\)/i,
+    oh = /\((c|tm|r)\)/ig,
+    ah = {
+        c: "\xA9",
+        r: "\xAE",
+        tm: "\u2122"
+    };
+
+function sh(e, r) {
+    return ah[r.toLowerCase()]
+}
+
+function lh(e) {
+    let r = 0;
+    for (let i = e.length - 1; i >= 0; i--) {
+        let o = e[i];
+        o.type === "text" && !r && (o.content = o.content.replace(oh, sh)), o.type === "link_open" && o.info === "auto" && r--, o.type === "link_close" && o.info === "auto" && r++
+    }
+}
+
+function ch(e) {
+    let r = 0;
+    for (let i = e.length - 1; i >= 0; i--) {
+        let o = e[i];
+        o.type === "text" && !r && zs.test(o.content) && (o.content = o.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), o.type === "link_open" && o.info === "auto" && r--, o.type === "link_close" && o.info === "auto" && r++
+    }
+}
+
+function Ou(e) {
+    let r;
+    if (e.md.options.typographer)
+        for (r = e.tokens.length - 1; r >= 0; r--) e.tokens[r].type === "inline" && (ih.test(e.tokens[r].content) && lh(e.tokens[r].children), zs.test(e.tokens[r].content) && ch(e.tokens[r].children))
+}
+var dh = /['"]/,
+    Rs = /['"]/g,
+    Bs = "\u2019";
+
+function en(e, r, i) {
+    return e.slice(0, r) + i + e.slice(r + 1)
+}
+
+function hh(e, r) {
+    let i, o = [];
+    for (let s = 0; s < e.length; s++) {
+        let l = e[s],
+            h = e[s].level;
+        for (i = o.length - 1; i >= 0 && !(o[i].level <= h); i--);
+        if (o.length = i + 1, l.type !== "text") continue;
+        let p = l.content,
+            b = 0,
+            x = p.length;
+        e: for (; b < x;) {
+            Rs.lastIndex = b;
+            let C = Rs.exec(p);
+            if (!C) break;
+            let k = !0,
+                F = !0;
+            b = C.index + 1;
+            let E = C[0] === "'",
+                M = 32;
+            if (C.index - 1 >= 0) M = p.charCodeAt(C.index - 1);
+            else
+                for (i = s - 1; i >= 0 && !(e[i].type === "softbreak" || e[i].type === "hardbreak"); i--)
+                    if (e[i].content) {
+                        M = e[i].content.charCodeAt(e[i].content.length - 1);
+                        break
+                    } let N = 32;
+            if (b < x) N = p.charCodeAt(b);
+            else
+                for (i = s + 1; i < e.length && !(e[i].type === "softbreak" || e[i].type === "hardbreak"); i++)
+                    if (e[i].content) {
+                        N = e[i].content.charCodeAt(0);
+                        break
+                    } let G = m0(M) || f0(String.fromCharCode(M)),
+                U = m0(N) || f0(String.fromCharCode(N)),
+                $ = h0(M),
+                V = h0(N);
+            if (V ? k = !1 : U && ($ || G || (k = !1)), $ ? F = !1 : G && (V || U || (F = !1)), N === 34 && C[0] === '"' && M >= 48 && M <= 57 && (F = k = !1), k && F && (k = G, F = U), !k && !F) {
+                E && (l.content = en(l.content, C.index, Bs));
+                continue
+            }
+            if (F)
+                for (i = o.length - 1; i >= 0; i--) {
+                    let Y = o[i];
+                    if (o[i].level < h) break;
+                    if (Y.single === E && o[i].level === h) {
+                        Y = o[i];
+                        let X, te;
+                        E ? (X = r.md.options.quotes[2], te = r.md.options.quotes[3]) : (X = r.md.options.quotes[0], te = r.md.options.quotes[1]), l.content = en(l.content, C.index, te), e[Y.token].content = en(e[Y.token].content, Y.pos, X), b += te.length - 1, Y.token === s && (b += X.length - 1), p = l.content, x = p.length, o.length = i;
+                        continue e
+                    }
+                }
+            k ? o.push({
+                token: s,
+                pos: C.index,
+                single: E,
+                level: h
+            }) : F && E && (l.content = en(l.content, C.index, Bs))
+        }
+    }
+}
+
+function Hu(e) {
+    if (e.md.options.typographer)
+        for (let r = e.tokens.length - 1; r >= 0; r--) e.tokens[r].type !== "inline" || !dh.test(e.tokens[r].content) || hh(e.tokens[r].children, e)
+}
+
+function $u(e) {
+    let r, i, o = e.tokens,
+        s = o.length;
+    for (let l = 0; l < s; l++) {
+        if (o[l].type !== "inline") continue;
+        let h = o[l].children,
+            p = h.length;
+        for (r = 0; r < p; r++) h[r].type === "text_special" && (h[r].type = "text");
+        for (r = i = 0; r < p; r++) h[r].type === "text" && r + 1 < p && h[r + 1].type === "text" ? h[r + 1].content = h[r].content + h[r + 1].content : (r !== i && (h[i] = h[r]), i++);
+        r !== i && (h.length = i)
+    }
+}
+var Gu = [
+    ["normalize", Nu],
+    ["block", Lu],
+    ["inline", Pu],
+    ["linkify", Iu],
+    ["replacements", Ou],
+    ["smartquotes", Hu],
+    ["text_join", $u]
+];
+
+function Vu() {
+    this.ruler = new b0;
+    for (let e = 0; e < Gu.length; e++) this.ruler.push(Gu[e][0], Gu[e][1])
+}
+Vu.prototype.process = function(e) {
+    let r = this.ruler.getRules("");
+    for (let i = 0, o = r.length; i < o; i++) r[i](e)
+};
+Vu.prototype.State = Fs;
+var Ns = Vu;
+
+function Dt(e, r, i, o) {
+    this.src = e, this.md = r, this.env = i, this.tokens = o, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
+    let s = this.src;
+    for (let l = 0, h = 0, p = 0, b = 0, x = s.length, C = !1; h < x; h++) {
+        let k = s.charCodeAt(h);
+        if (!C)
+            if (me(k)) {
+                p++, k === 9 ? b += 4 - b % 4 : b++;
+                continue
+            } else C = !0;
+        (k === 10 || h === x - 1) && (k !== 10 && h++, this.bMarks.push(l), this.eMarks.push(h), this.tShift.push(p), this.sCount.push(b), this.bsCount.push(0), C = !1, p = 0, b = 0, l = h + 1)
+    }
+    this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1
+}
+Dt.prototype.push = function(e, r, i) {
+    let o = new $t(e, r, i);
+    return o.block = !0, i < 0 && this.level--, o.level = this.level, i > 0 && this.level++, this.tokens.push(o), o
+};
+Dt.prototype.isEmpty = function(r) {
+    return this.bMarks[r] + this.tShift[r] >= this.eMarks[r]
+};
+Dt.prototype.skipEmptyLines = function(r) {
+    for (let i = this.lineMax; r < i && !(this.bMarks[r] + this.tShift[r] < this.eMarks[r]); r++);
+    return r
+};
+Dt.prototype.skipSpaces = function(r) {
+    for (let i = this.src.length; r < i; r++) {
+        let o = this.src.charCodeAt(r);
+        if (!me(o)) break
+    }
+    return r
+};
+Dt.prototype.skipSpacesBack = function(r, i) {
+    if (r <= i) return r;
+    for (; r > i;)
+        if (!me(this.src.charCodeAt(--r))) return r + 1;
+    return r
+};
+Dt.prototype.skipChars = function(r, i) {
+    for (let o = this.src.length; r < o && this.src.charCodeAt(r) === i; r++);
+    return r
+};
+Dt.prototype.skipCharsBack = function(r, i, o) {
+    if (r <= o) return r;
+    for (; r > o;)
+        if (i !== this.src.charCodeAt(--r)) return r + 1;
+    return r
+};
+Dt.prototype.getLines = function(r, i, o, s) {
+    if (r >= i) return "";
+    let l = new Array(i - r);
+    for (let h = 0, p = r; p < i; p++, h++) {
+        let b = 0,
+            x = this.bMarks[p],
+            C = x,
+            k;
+        for (p + 1 < i || s ? k = this.eMarks[p] + 1 : k = this.eMarks[p]; C < k && b < o;) {
+            let F = this.src.charCodeAt(C);
+            if (me(F)) F === 9 ? b += 4 - (b + this.bsCount[p]) % 4 : b++;
+            else if (C - x < this.tShift[p]) b++;
+            else break;
+            C++
+        }
+        b > o ? l[h] = new Array(b - o + 1).join(" ") + this.src.slice(C, k) : l[h] = this.src.slice(C, k)
+    }
+    return l.join("")
+};
+Dt.prototype.Token = $t;
+var Ls = Dt;
+var fh = 65536;
+
+function Uu(e, r) {
+    let i = e.bMarks[r] + e.tShift[r],
+        o = e.eMarks[r];
+    return e.src.slice(i, o)
+}
+
+function Ps(e) {
+    let r = [],
+        i = e.length,
+        o = 0,
+        s = e.charCodeAt(o),
+        l = !1,
+        h = 0,
+        p = "";
+    for (; o < i;) s === 124 && (l ? (p += e.substring(h, o - 1), h = o) : (r.push(p + e.substring(h, o)), p = "", h = o + 1)), l = s === 92, o++, s = e.charCodeAt(o);
+    return r.push(p + e.substring(h)), r
+}
+
+function ju(e, r, i, o) {
+    if (r + 2 > i) return !1;
+    let s = r + 1;
+    if (e.sCount[s] < e.blkIndent || e.sCount[s] - e.blkIndent >= 4) return !1;
+    let l = e.bMarks[s] + e.tShift[s];
+    if (l >= e.eMarks[s]) return !1;
+    let h = e.src.charCodeAt(l++);
+    if (h !== 124 && h !== 45 && h !== 58 || l >= e.eMarks[s]) return !1;
+    let p = e.src.charCodeAt(l++);
+    if (p !== 124 && p !== 45 && p !== 58 && !me(p) || h === 45 && me(p)) return !1;
+    for (; l < e.eMarks[s];) {
+        let Y = e.src.charCodeAt(l);
+        if (Y !== 124 && Y !== 45 && Y !== 58 && !me(Y)) return !1;
+        l++
+    }
+    let b = Uu(e, r + 1),
+        x = b.split("|"),
+        C = [];
+    for (let Y = 0; Y < x.length; Y++) {
+        let X = x[Y].trim();
+        if (!X) {
+            if (Y === 0 || Y === x.length - 1) continue;
+            return !1
+        }
+        if (!/^:?-+:?$/.test(X)) return !1;
+        X.charCodeAt(X.length - 1) === 58 ? C.push(X.charCodeAt(0) === 58 ? "center" : "right") : X.charCodeAt(0) === 58 ? C.push("left") : C.push("")
+    }
+    if (b = Uu(e, r).trim(), b.indexOf("|") === -1 || e.sCount[r] - e.blkIndent >= 4) return !1;
+    x = Ps(b), x.length && x[0] === "" && x.shift(), x.length && x[x.length - 1] === "" && x.pop();
+    let k = x.length;
+    if (k === 0 || k !== C.length) return !1;
+    if (o) return !0;
+    let F = e.parentType;
+    e.parentType = "table";
+    let E = e.md.block.ruler.getRules("blockquote"),
+        M = e.push("table_open", "table", 1),
+        N = [r, 0];
+    M.map = N;
+    let G = e.push("thead_open", "thead", 1);
+    G.map = [r, r + 1];
+    let U = e.push("tr_open", "tr", 1);
+    U.map = [r, r + 1];
+    for (let Y = 0; Y < x.length; Y++) {
+        let X = e.push("th_open", "th", 1);
+        C[Y] && (X.attrs = [
+            ["style", "text-align:" + C[Y]]
+        ]);
+        let te = e.push("inline", "", 0);
+        te.content = x[Y].trim(), te.children = [], e.push("th_close", "th", -1)
+    }
+    e.push("tr_close", "tr", -1), e.push("thead_close", "thead", -1);
+    let $, V = 0;
+    for (s = r + 2; s < i && !(e.sCount[s] < e.blkIndent); s++) {
+        let Y = !1;
+        for (let te = 0, ie = E.length; te < ie; te++)
+            if (E[te](e, s, i, !0)) {
+                Y = !0;
+                break
+            } if (Y || (b = Uu(e, s).trim(), !b) || e.sCount[s] - e.blkIndent >= 4 || (x = Ps(b), x.length && x[0] === "" && x.shift(), x.length && x[x.length - 1] === "" && x.pop(), V += k - x.length, V > fh)) break;
+        if (s === r + 2) {
+            let te = e.push("tbody_open", "tbody", 1);
+            te.map = $ = [r + 2, 0]
+        }
+        let X = e.push("tr_open", "tr", 1);
+        X.map = [s, s + 1];
+        for (let te = 0; te < k; te++) {
+            let ie = e.push("td_open", "td", 1);
+            C[te] && (ie.attrs = [
+                ["style", "text-align:" + C[te]]
+            ]);
+            let ge = e.push("inline", "", 0);
+            ge.content = x[te] ? x[te].trim() : "", ge.children = [], e.push("td_close", "td", -1)
+        }
+        e.push("tr_close", "tr", -1)
+    }
+    return $ && (e.push("tbody_close", "tbody", -1), $[1] = s), e.push("table_close", "table", -1), N[1] = s, e.parentType = F, e.line = s, !0
+}
+
+function Wu(e, r, i) {
+    if (e.sCount[r] - e.blkIndent < 4) return !1;
+    let o = r + 1,
+        s = o;
+    for (; o < i;) {
+        if (e.isEmpty(o)) {
+            o++;
+            continue
+        }
+        if (e.sCount[o] - e.blkIndent >= 4) {
+            o++, s = o;
+            continue
+        }
+        break
+    }
+    e.line = s;
+    let l = e.push("code_block", "code", 0);
+    return l.content = e.getLines(r, s, 4 + e.blkIndent, !1) + `
+`, l.map = [r, e.line], !0
+}
+
+function Yu(e, r, i, o) {
+    let s = e.bMarks[r] + e.tShift[r],
+        l = e.eMarks[r];
+    if (e.sCount[r] - e.blkIndent >= 4 || s + 3 > l) return !1;
+    let h = e.src.charCodeAt(s);
+    if (h !== 126 && h !== 96) return !1;
+    let p = s;
+    s = e.skipChars(s, h);
+    let b = s - p;
+    if (b < 3) return !1;
+    let x = e.src.slice(p, s),
+        C = e.src.slice(s, l);
+    if (h === 96 && C.indexOf(String.fromCharCode(h)) >= 0) return !1;
+    if (o) return !0;
+    let k = r,
+        F = !1;
+    for (; k++, !(k >= i || (s = p = e.bMarks[k] + e.tShift[k], l = e.eMarks[k], s < l && e.sCount[k] < e.blkIndent));)
+        if (e.src.charCodeAt(s) === h && !(e.sCount[k] - e.blkIndent >= 4) && (s = e.skipChars(s, h), !(s - p < b) && (s = e.skipSpaces(s), !(s < l)))) {
+            F = !0;
+            break
+        } b = e.sCount[r], e.line = k + (F ? 1 : 0);
+    let E = e.push("fence", "code", 0);
+    return E.info = C, E.content = e.getLines(r + 1, k, b, !0), E.markup = x, E.map = [r, e.line], !0
+}
+
+function Zu(e, r, i, o) {
+    let s = e.bMarks[r] + e.tShift[r],
+        l = e.eMarks[r],
+        h = e.lineMax;
+    if (e.sCount[r] - e.blkIndent >= 4 || e.src.charCodeAt(s) !== 62) return !1;
+    if (o) return !0;
+    let p = [],
+        b = [],
+        x = [],
+        C = [],
+        k = e.md.block.ruler.getRules("blockquote"),
+        F = e.parentType;
+    e.parentType = "blockquote";
+    let E = !1,
+        M;
+    for (M = r; M < i; M++) {
+        let V = e.sCount[M] < e.blkIndent;
+        if (s = e.bMarks[M] + e.tShift[M], l = e.eMarks[M], s >= l) break;
+        if (e.src.charCodeAt(s++) === 62 && !V) {
+            let X = e.sCount[M] + 1,
+                te, ie;
+            e.src.charCodeAt(s) === 32 ? (s++, X++, ie = !1, te = !0) : e.src.charCodeAt(s) === 9 ? (te = !0, (e.bsCount[M] + X) % 4 === 3 ? (s++, X++, ie = !1) : ie = !0) : te = !1;
+            let ge = X;
+            for (p.push(e.bMarks[M]), e.bMarks[M] = s; s < l;) {
+                let ae = e.src.charCodeAt(s);
+                if (me(ae)) ae === 9 ? ge += 4 - (ge + e.bsCount[M] + (ie ? 1 : 0)) % 4 : ge++;
+                else break;
+                s++
+            }
+            E = s >= l, b.push(e.bsCount[M]), e.bsCount[M] = e.sCount[M] + 1 + (te ? 1 : 0), x.push(e.sCount[M]), e.sCount[M] = ge - X, C.push(e.tShift[M]), e.tShift[M] = s - e.bMarks[M];
+            continue
+        }
+        if (E) break;
+        let Y = !1;
+        for (let X = 0, te = k.length; X < te; X++)
+            if (k[X](e, M, i, !0)) {
+                Y = !0;
+                break
+            } if (Y) {
+            e.lineMax = M, e.blkIndent !== 0 && (p.push(e.bMarks[M]), b.push(e.bsCount[M]), C.push(e.tShift[M]), x.push(e.sCount[M]), e.sCount[M] -= e.blkIndent);
+            break
+        }
+        p.push(e.bMarks[M]), b.push(e.bsCount[M]), C.push(e.tShift[M]), x.push(e.sCount[M]), e.sCount[M] = -1
+    }
+    let N = e.blkIndent;
+    e.blkIndent = 0;
+    let G = e.push("blockquote_open", "blockquote", 1);
+    G.markup = ">";
+    let U = [r, 0];
+    G.map = U, e.md.block.tokenize(e, r, M);
+    let $ = e.push("blockquote_close", "blockquote", -1);
+    $.markup = ">", e.lineMax = h, e.parentType = F, U[1] = e.line;
+    for (let V = 0; V < C.length; V++) e.bMarks[V + r] = p[V], e.tShift[V + r] = C[V], e.sCount[V + r] = x[V], e.bsCount[V + r] = b[V];
+    return e.blkIndent = N, !0
+}
+
+function Xu(e, r, i, o) {
+    let s = e.eMarks[r];
+    if (e.sCount[r] - e.blkIndent >= 4) return !1;
+    let l = e.bMarks[r] + e.tShift[r],
+        h = e.src.charCodeAt(l++);
+    if (h !== 42 && h !== 45 && h !== 95) return !1;
+    let p = 1;
+    for (; l < s;) {
+        let x = e.src.charCodeAt(l++);
+        if (x !== h && !me(x)) return !1;
+        x === h && p++
+    }
+    if (p < 3) return !1;
+    if (o) return !0;
+    e.line = r + 1;
+    let b = e.push("hr", "hr", 0);
+    return b.map = [r, e.line], b.markup = Array(p + 1).join(String.fromCharCode(h)), !0
+}
+
+function Is(e, r) {
+    let i = e.eMarks[r],
+        o = e.bMarks[r] + e.tShift[r],
+        s = e.src.charCodeAt(o++);
+    if (s !== 42 && s !== 45 && s !== 43) return -1;
+    if (o < i) {
+        let l = e.src.charCodeAt(o);
+        if (!me(l)) return -1
+    }
+    return o
+}
+
+function Os(e, r) {
+    let i = e.bMarks[r] + e.tShift[r],
+        o = e.eMarks[r],
+        s = i;
+    if (s + 1 >= o) return -1;
+    let l = e.src.charCodeAt(s++);
+    if (l < 48 || l > 57) return -1;
+    for (;;) {
+        if (s >= o) return -1;
+        if (l = e.src.charCodeAt(s++), l >= 48 && l <= 57) {
+            if (s - i >= 10) return -1;
+            continue
+        }
+        if (l === 41 || l === 46) break;
+        return -1
+    }
+    return s < o && (l = e.src.charCodeAt(s), !me(l)) ? -1 : s
+}
+
+function mh(e, r) {
+    let i = e.level + 2;
+    for (let o = r + 2, s = e.tokens.length - 2; o < s; o++) e.tokens[o].level === i && e.tokens[o].type === "paragraph_open" && (e.tokens[o + 2].hidden = !0, e.tokens[o].hidden = !0, o += 2)
+}
+
+function Qu(e, r, i, o) {
+    let s, l, h, p, b = r,
+        x = !0;
+    if (e.sCount[b] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[b] - e.listIndent >= 4 && e.sCount[b] < e.blkIndent) return !1;
+    let C = !1;
+    o && e.parentType === "paragraph" && e.sCount[b] >= e.blkIndent && (C = !0);
+    let k, F, E;
+    if ((E = Os(e, b)) >= 0) {
+        if (k = !0, h = e.bMarks[b] + e.tShift[b], F = Number(e.src.slice(h, E - 1)), C && F !== 1) return !1
+    } else if ((E = Is(e, b)) >= 0) k = !1;
+    else return !1;
+    if (C && e.skipSpaces(E) >= e.eMarks[b]) return !1;
+    if (o) return !0;
+    let M = e.src.charCodeAt(E - 1),
+        N = e.tokens.length;
+    k ? (p = e.push("ordered_list_open", "ol", 1), F !== 1 && (p.attrs = [
+        ["start", F]
+    ])) : p = e.push("bullet_list_open", "ul", 1);
+    let G = [b, 0];
+    p.map = G, p.markup = String.fromCharCode(M);
+    let U = !1,
+        $ = e.md.block.ruler.getRules("list"),
+        V = e.parentType;
+    for (e.parentType = "list"; b < i;) {
+        l = E, s = e.eMarks[b];
+        let Y = e.sCount[b] + E - (e.bMarks[b] + e.tShift[b]),
+            X = Y;
+        for (; l < s;) {
+            let fe = e.src.charCodeAt(l);
+            if (fe === 9) X += 4 - (X + e.bsCount[b]) % 4;
+            else if (fe === 32) X++;
+            else break;
+            l++
+        }
+        let te = l,
+            ie;
+        te >= s ? ie = 1 : ie = X - Y, ie > 4 && (ie = 1);
+        let ge = Y + ie;
+        p = e.push("list_item_open", "li", 1), p.markup = String.fromCharCode(M);
+        let ae = [b, 0];
+        p.map = ae, k && (p.info = e.src.slice(h, E - 1));
+        let qe = e.tight,
+            Ee = e.tShift[b],
+            Ne = e.sCount[b],
+            W = e.listIndent;
+        if (e.listIndent = e.blkIndent, e.blkIndent = ge, e.tight = !0, e.tShift[b] = te - e.bMarks[b], e.sCount[b] = X, te >= s && e.isEmpty(b + 1) ? e.line = Math.min(e.line + 2, i) : e.md.block.tokenize(e, b, i, !0), (!e.tight || U) && (x = !1), U = e.line - b > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = W, e.tShift[b] = Ee, e.sCount[b] = Ne, e.tight = qe, p = e.push("list_item_close", "li", -1), p.markup = String.fromCharCode(M), b = e.line, ae[1] = b, b >= i || e.sCount[b] < e.blkIndent || e.sCount[b] - e.blkIndent >= 4) break;
+        let Q = !1;
+        for (let fe = 0, Qe = $.length; fe < Qe; fe++)
+            if ($[fe](e, b, i, !0)) {
+                Q = !0;
+                break
+            } if (Q) break;
+        if (k) {
+            if (E = Os(e, b), E < 0) break;
+            h = e.bMarks[b] + e.tShift[b]
+        } else if (E = Is(e, b), E < 0) break;
+        if (M !== e.src.charCodeAt(E - 1)) break
+    }
+    return k ? p = e.push("ordered_list_close", "ol", -1) : p = e.push("bullet_list_close", "ul", -1), p.markup = String.fromCharCode(M), G[1] = b, e.line = b, e.parentType = V, x && mh(e, N), !0
+}
+
+function Ju(e, r, i, o) {
+    let s = e.bMarks[r] + e.tShift[r],
+        l = e.eMarks[r],
+        h = r + 1;
+    if (e.sCount[r] - e.blkIndent >= 4 || e.src.charCodeAt(s) !== 91) return !1;
+
+    function p($) {
+        let V = e.lineMax;
+        if ($ >= V || e.isEmpty($)) return null;
+        let Y = !1;
+        if (e.sCount[$] - e.blkIndent > 3 && (Y = !0), e.sCount[$] < 0 && (Y = !0), !Y) {
+            let ie = e.md.block.ruler.getRules("reference"),
+                ge = e.parentType;
+            e.parentType = "reference";
+            let ae = !1;
+            for (let qe = 0, Ee = ie.length; qe < Ee; qe++)
+                if (ie[qe](e, $, V, !0)) {
+                    ae = !0;
+                    break
+                } if (e.parentType = ge, ae) return null
+        }
+        let X = e.bMarks[$] + e.tShift[$],
+            te = e.eMarks[$];
+        return e.src.slice(X, te + 1)
+    }
+    let b = e.src.slice(s, l + 1);
+    l = b.length;
+    let x = -1;
+    for (s = 1; s < l; s++) {
+        let $ = b.charCodeAt(s);
+        if ($ === 91) return !1;
+        if ($ === 93) {
+            x = s;
+            break
+        } else if ($ === 10) {
+            let V = p(h);
+            V !== null && (b += V, l = b.length, h++)
+        } else if ($ === 92 && (s++, s < l && b.charCodeAt(s) === 10)) {
+            let V = p(h);
+            V !== null && (b += V, l = b.length, h++)
+        }
+    }
+    if (x < 0 || b.charCodeAt(x + 1) !== 58) return !1;
+    for (s = x + 2; s < l; s++) {
+        let $ = b.charCodeAt(s);
+        if ($ === 10) {
+            let V = p(h);
+            V !== null && (b += V, l = b.length, h++)
+        } else if (!me($)) break
+    }
+    let C = e.md.helpers.parseLinkDestination(b, s, l);
+    if (!C.ok) return !1;
+    let k = e.md.normalizeLink(C.str);
+    if (!e.md.validateLink(k)) return !1;
+    s = C.pos;
+    let F = s,
+        E = h,
+        M = s;
+    for (; s < l; s++) {
+        let $ = b.charCodeAt(s);
+        if ($ === 10) {
+            let V = p(h);
+            V !== null && (b += V, l = b.length, h++)
+        } else if (!me($)) break
+    }
+    let N = e.md.helpers.parseLinkTitle(b, s, l);
+    for (; N.can_continue;) {
+        let $ = p(h);
+        if ($ === null) break;
+        b += $, s = l, l = b.length, h++, N = e.md.helpers.parseLinkTitle(b, s, l, N)
+    }
+    let G;
+    for (s < l && M !== s && N.ok ? (G = N.str, s = N.pos) : (G = "", s = F, h = E); s < l;) {
+        let $ = b.charCodeAt(s);
+        if (!me($)) break;
+        s++
+    }
+    if (s < l && b.charCodeAt(s) !== 10 && G)
+        for (G = "", s = F, h = E; s < l;) {
+            let $ = b.charCodeAt(s);
+            if (!me($)) break;
+            s++
+        }
+    if (s < l && b.charCodeAt(s) !== 10) return !1;
+    let U = p0(b.slice(1, x));
+    return U ? (o || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[U] > "u" && (e.env.references[U] = {
+        title: G,
+        href: k
+    }), e.line = h), !0) : !1
+}
+var Hs = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"];
+var ph = "[a-zA-Z_:][a-zA-Z0-9:._-]*",
+    bh = "[^\"'=<>`\\x00-\\x20]+",
+    gh = "'[^']*'",
+    xh = '"[^"]*"',
+    yh = "(?:" + bh + "|" + gh + "|" + xh + ")",
+    vh = "(?:\\s+" + ph + "(?:\\s*=\\s*" + yh + ")?)",
+    $s = "<[A-Za-z][A-Za-z0-9\\-]*" + vh + "*\\s*\\/?>",
+    Gs = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>",
+    wh = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->",
+    kh = "<[?][\\s\\S]*?[?]>",
+    _h = "<![A-Za-z][^>]*>",
+    Ch = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
+    Vs = new RegExp("^(?:" + $s + "|" + Gs + "|" + wh + "|" + kh + "|" + _h + "|" + Ch + ")"),
+    Us = new RegExp("^(?:" + $s + "|" + Gs + ")");
+var E0 = [
+    [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
+    [/^<!--/, /-->/, !0],
+    [/^<\?/, /\?>/, !0],
+    [/^<![A-Z]/, />/, !0],
+    [/^<!\[CDATA\[/, /\]\]>/, !0],
+    [new RegExp("^</?(" + Hs.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
+    [new RegExp(Us.source + "\\s*$"), /^$/, !1]
+];
+
+function Ku(e, r, i, o) {
+    let s = e.bMarks[r] + e.tShift[r],
+        l = e.eMarks[r];
+    if (e.sCount[r] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(s) !== 60) return !1;
+    let h = e.src.slice(s, l),
+        p = 0;
+    for (; p < E0.length && !E0[p][0].test(h); p++);
+    if (p === E0.length) return !1;
+    if (o) return E0[p][2];
+    let b = r + 1;
+    if (!E0[p][1].test(h)) {
+        for (; b < i && !(e.sCount[b] < e.blkIndent); b++)
+            if (s = e.bMarks[b] + e.tShift[b], l = e.eMarks[b], h = e.src.slice(s, l), E0[p][1].test(h)) {
+                h.length !== 0 && b++;
+                break
+            }
+    }
+    e.line = b;
+    let x = e.push("html_block", "", 0);
+    return x.map = [r, b], x.content = e.getLines(r, b, e.blkIndent, !0), !0
+}
+
+function ei(e, r, i, o) {
+    let s = e.bMarks[r] + e.tShift[r],
+        l = e.eMarks[r];
+    if (e.sCount[r] - e.blkIndent >= 4) return !1;
+    let h = e.src.charCodeAt(s);
+    if (h !== 35 || s >= l) return !1;
+    let p = 1;
+    for (h = e.src.charCodeAt(++s); h === 35 && s < l && p <= 6;) p++, h = e.src.charCodeAt(++s);
+    if (p > 6 || s < l && !me(h)) return !1;
+    if (o) return !0;
+    l = e.skipSpacesBack(l, s);
+    let b = e.skipCharsBack(l, 35, s);
+    b > s && me(e.src.charCodeAt(b - 1)) && (l = b), e.line = r + 1;
+    let x = e.push("heading_open", "h" + String(p), 1);
+    x.markup = "########".slice(0, p), x.map = [r, e.line];
+    let C = e.push("inline", "", 0);
+    C.content = e.src.slice(s, l).trim(), C.map = [r, e.line], C.children = [];
+    let k = e.push("heading_close", "h" + String(p), -1);
+    return k.markup = "########".slice(0, p), !0
+}
+
+function ti(e, r, i) {
+    let o = e.md.block.ruler.getRules("paragraph");
+    if (e.sCount[r] - e.blkIndent >= 4) return !1;
+    let s = e.parentType;
+    e.parentType = "paragraph";
+    let l = 0,
+        h, p = r + 1;
+    for (; p < i && !e.isEmpty(p); p++) {
+        if (e.sCount[p] - e.blkIndent > 3) continue;
+        if (e.sCount[p] >= e.blkIndent) {
+            let E = e.bMarks[p] + e.tShift[p],
+                M = e.eMarks[p];
+            if (E < M && (h = e.src.charCodeAt(E), (h === 45 || h === 61) && (E = e.skipChars(E, h), E = e.skipSpaces(E), E >= M))) {
+                l = h === 61 ? 1 : 2;
+                break
+            }
+        }
+        if (e.sCount[p] < 0) continue;
+        let F = !1;
+        for (let E = 0, M = o.length; E < M; E++)
+            if (o[E](e, p, i, !0)) {
+                F = !0;
+                break
+            } if (F) break
+    }
+    if (!l) return !1;
+    let b = e.getLines(r, p, e.blkIndent, !1).trim();
+    e.line = p + 1;
+    let x = e.push("heading_open", "h" + String(l), 1);
+    x.markup = String.fromCharCode(h), x.map = [r, e.line];
+    let C = e.push("inline", "", 0);
+    C.content = b, C.map = [r, e.line - 1], C.children = [];
+    let k = e.push("heading_close", "h" + String(l), -1);
+    return k.markup = String.fromCharCode(h), e.parentType = s, !0
+}
+
+function ri(e, r, i) {
+    let o = e.md.block.ruler.getRules("paragraph"),
+        s = e.parentType,
+        l = r + 1;
+    for (e.parentType = "paragraph"; l < i && !e.isEmpty(l); l++) {
+        if (e.sCount[l] - e.blkIndent > 3 || e.sCount[l] < 0) continue;
+        let x = !1;
+        for (let C = 0, k = o.length; C < k; C++)
+            if (o[C](e, l, i, !0)) {
+                x = !0;
+                break
+            } if (x) break
+    }
+    let h = e.getLines(r, l, e.blkIndent, !1).trim();
+    e.line = l;
+    let p = e.push("paragraph_open", "p", 1);
+    p.map = [r, e.line];
+    let b = e.push("inline", "", 0);
+    return b.content = h, b.map = [r, e.line], b.children = [], e.push("paragraph_close", "p", -1), e.parentType = s, !0
+}
+var tn = [
+    ["table", ju, ["paragraph", "reference"]],
+    ["code", Wu],
+    ["fence", Yu, ["paragraph", "reference", "blockquote", "list"]],
+    ["blockquote", Zu, ["paragraph", "reference", "blockquote", "list"]],
+    ["hr", Xu, ["paragraph", "reference", "blockquote", "list"]],
+    ["list", Qu, ["paragraph", "reference", "blockquote"]],
+    ["reference", Ju],
+    ["html_block", Ku, ["paragraph", "reference", "blockquote"]],
+    ["heading", ei, ["paragraph", "reference", "blockquote"]],
+    ["lheading", ti],
+    ["paragraph", ri]
+];
+
+function rn() {
+    this.ruler = new b0;
+    for (let e = 0; e < tn.length; e++) this.ruler.push(tn[e][0], tn[e][1], {
+        alt: (tn[e][2] || []).slice()
+    })
+}
+rn.prototype.tokenize = function(e, r, i) {
+    let o = this.ruler.getRules(""),
+        s = o.length,
+        l = e.md.options.maxNesting,
+        h = r,
+        p = !1;
+    for (; h < i && (e.line = h = e.skipEmptyLines(h), !(h >= i || e.sCount[h] < e.blkIndent));) {
+        if (e.level >= l) {
+            e.line = i;
+            break
+        }
+        let b = e.line,
+            x = !1;
+        for (let C = 0; C < s; C++)
+            if (x = o[C](e, h, i, !1), x) {
+                if (b >= e.line) throw new Error("block rule didn't increment state.line");
+                break
+            } if (!x) throw new Error("none of the block rules matched");
+        e.tight = !p, e.isEmpty(e.line - 1) && (p = !0), h = e.line, h < i && e.isEmpty(h) && (p = !0, h++, e.line = h)
+    }
+};
+rn.prototype.parse = function(e, r, i, o) {
+    if (!e) return;
+    let s = new this.State(e, r, i, o);
+    this.tokenize(s, s.line, s.lineMax)
+};
+rn.prototype.State = Ls;
+var js = rn;
+
+function Q0(e, r, i, o) {
+    this.src = e, this.env = i, this.md = r, this.tokens = o, this.tokens_meta = Array(o.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0
+}
+Q0.prototype.pushPending = function() {
+    let e = new $t("text", "", 0);
+    return e.content = this.pending, e.level = this.pendingLevel, this.tokens.push(e), this.pending = "", e
+};
+Q0.prototype.push = function(e, r, i) {
+    this.pending && this.pushPending();
+    let o = new $t(e, r, i),
+        s = null;
+    return i < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), o.level = this.level, i > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], s = {
+        delimiters: this.delimiters
+    }), this.pendingLevel = this.level, this.tokens.push(o), this.tokens_meta.push(s), o
+};
+Q0.prototype.scanDelims = function(e, r) {
+    let i = this.posMax,
+        o = this.src.charCodeAt(e),
+        s = e > 0 ? this.src.charCodeAt(e - 1) : 32,
+        l = e;
+    for (; l < i && this.src.charCodeAt(l) === o;) l++;
+    let h = l - e,
+        p = l < i ? this.src.charCodeAt(l) : 32,
+        b = m0(s) || f0(String.fromCharCode(s)),
+        x = m0(p) || f0(String.fromCharCode(p)),
+        C = h0(s),
+        k = h0(p),
+        F = !k && (!x || C || b),
+        E = !C && (!b || k || x);
+    return {
+        can_open: F && (r || !E || b),
+        can_close: E && (r || !F || x),
+        length: h
+    }
+};
+Q0.prototype.Token = $t;
+var Ws = Q0;
+
+function Sh(e) {
+    switch (e) {
+        case 10:
+        case 33:
+        case 35:
+        case 36:
+        case 37:
+        case 38:
+        case 42:
+        case 43:
+        case 45:
+        case 58:
+        case 60:
+        case 61:
+        case 62:
+        case 64:
+        case 91:
+        case 92:
+        case 93:
+        case 94:
+        case 95:
+        case 96:
+        case 123:
+        case 125:
+        case 126:
+            return !0;
+        default:
+            return !1
+    }
+}
+
+function ni(e, r) {
+    let i = e.pos;
+    for (; i < e.posMax && !Sh(e.src.charCodeAt(i));) i++;
+    return i === e.pos ? !1 : (r || (e.pending += e.src.slice(e.pos, i)), e.pos = i, !0)
+}
+var Ah = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
+
+function ui(e, r) {
+    if (!e.md.options.linkify || e.linkLevel > 0) return !1;
+    let i = e.pos,
+        o = e.posMax;
+    if (i + 3 > o || e.src.charCodeAt(i) !== 58 || e.src.charCodeAt(i + 1) !== 47 || e.src.charCodeAt(i + 2) !== 47) return !1;
+    let s = e.pending.match(Ah);
+    if (!s) return !1;
+    let l = s[1],
+        h = e.md.linkify.matchAtStart(e.src.slice(i - l.length));
+    if (!h) return !1;
+    let p = h.url;
+    if (p.length <= l.length) return !1;
+    p = p.replace(/\*+$/, "");
+    let b = e.md.normalizeLink(p);
+    if (!e.md.validateLink(b)) return !1;
+    if (!r) {
+        e.pending = e.pending.slice(0, -l.length);
+        let x = e.push("link_open", "a", 1);
+        x.attrs = [
+            ["href", b]
+        ], x.markup = "linkify", x.info = "auto";
+        let C = e.push("text", "", 0);
+        C.content = e.md.normalizeLinkText(p);
+        let k = e.push("link_close", "a", -1);
+        k.markup = "linkify", k.info = "auto"
+    }
+    return e.pos += p.length - l.length, !0
+}
+
+function ii(e, r) {
+    let i = e.pos;
+    if (e.src.charCodeAt(i) !== 10) return !1;
+    let o = e.pending.length - 1,
+        s = e.posMax;
+    if (!r)
+        if (o >= 0 && e.pending.charCodeAt(o) === 32)
+            if (o >= 1 && e.pending.charCodeAt(o - 1) === 32) {
+                let l = o - 1;
+                for (; l >= 1 && e.pending.charCodeAt(l - 1) === 32;) l--;
+                e.pending = e.pending.slice(0, l), e.push("hardbreak", "br", 0)
+            } else e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
+    else e.push("softbreak", "br", 0);
+    for (i++; i < s && me(e.src.charCodeAt(i));) i++;
+    return e.pos = i, !0
+}
+var oi = [];
+for (let e = 0; e < 256; e++) oi.push(0);
+"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(e) {
+    oi[e.charCodeAt(0)] = 1
+});
+
+function ai(e, r) {
+    let i = e.pos,
+        o = e.posMax;
+    if (e.src.charCodeAt(i) !== 92 || (i++, i >= o)) return !1;
+    let s = e.src.charCodeAt(i);
+    if (s === 10) {
+        for (r || e.push("hardbreak", "br", 0), i++; i < o && (s = e.src.charCodeAt(i), !!me(s));) i++;
+        return e.pos = i, !0
+    }
+    let l = e.src[i];
+    if (s >= 55296 && s <= 56319 && i + 1 < o) {
+        let p = e.src.charCodeAt(i + 1);
+        p >= 56320 && p <= 57343 && (l += e.src[i + 1], i++)
+    }
+    let h = "\\" + l;
+    if (!r) {
+        let p = e.push("text_special", "", 0);
+        s < 256 && oi[s] !== 0 ? p.content = l : p.content = h, p.markup = h, p.info = "escape"
+    }
+    return e.pos = i + 1, !0
+}
+
+function si(e, r) {
+    let i = e.pos;
+    if (e.src.charCodeAt(i) !== 96) return !1;
+    let s = i;
+    i++;
+    let l = e.posMax;
+    for (; i < l && e.src.charCodeAt(i) === 96;) i++;
+    let h = e.src.slice(s, i),
+        p = h.length;
+    if (e.backticksScanned && (e.backticks[p] || 0) <= s) return r || (e.pending += h), e.pos += p, !0;
+    let b = i,
+        x;
+    for (;
+        (x = e.src.indexOf("`", b)) !== -1;) {
+        for (b = x + 1; b < l && e.src.charCodeAt(b) === 96;) b++;
+        let C = b - x;
+        if (C === p) {
+            if (!r) {
+                let k = e.push("code_inline", "code", 0);
+                k.markup = h, k.content = e.src.slice(i, x).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")
+            }
+            return e.pos = b, !0
+        }
+        e.backticks[C] = x
+    }
+    return e.backticksScanned = !0, r || (e.pending += h), e.pos += p, !0
+}
+
+function Th(e, r) {
+    let i = e.pos,
+        o = e.src.charCodeAt(i);
+    if (r || o !== 126) return !1;
+    let s = e.scanDelims(e.pos, !0),
+        l = s.length,
+        h = String.fromCharCode(o);
+    if (l < 2) return !1;
+    let p;
+    l % 2 && (p = e.push("text", "", 0), p.content = h, l--);
+    for (let b = 0; b < l; b += 2) p = e.push("text", "", 0), p.content = h + h, e.delimiters.push({
+        marker: o,
+        length: 0,
+        token: e.tokens.length - 1,
+        end: -1,
+        open: s.can_open,
+        close: s.can_close
+    });
+    return e.pos += s.length, !0
+}
+
+function Ys(e, r) {
+    let i, o = [],
+        s = r.length;
+    for (let l = 0; l < s; l++) {
+        let h = r[l];
+        if (h.marker !== 126 || h.end === -1) continue;
+        let p = r[h.end];
+        i = e.tokens[h.token], i.type = "s_open", i.tag = "s", i.nesting = 1, i.markup = "~~", i.content = "", i = e.tokens[p.token], i.type = "s_close", i.tag = "s", i.nesting = -1, i.markup = "~~", i.content = "", e.tokens[p.token - 1].type === "text" && e.tokens[p.token - 1].content === "~" && o.push(p.token - 1)
+    }
+    for (; o.length;) {
+        let l = o.pop(),
+            h = l + 1;
+        for (; h < e.tokens.length && e.tokens[h].type === "s_close";) h++;
+        h--, l !== h && (i = e.tokens[h], e.tokens[h] = e.tokens[l], e.tokens[l] = i)
+    }
+}
+
+function Dh(e) {
+    let r = e.tokens_meta,
+        i = e.tokens_meta.length;
+    Ys(e, e.delimiters);
+    for (let o = 0; o < i; o++) r[o] && r[o].delimiters && Ys(e, r[o].delimiters)
+}
+var li = {
+    tokenize: Th,
+    postProcess: Dh
+};
+
+function Eh(e, r) {
+    let i = e.pos,
+        o = e.src.charCodeAt(i);
+    if (r || o !== 95 && o !== 42) return !1;
+    let s = e.scanDelims(e.pos, o === 42);
+    for (let l = 0; l < s.length; l++) {
+        let h = e.push("text", "", 0);
+        h.content = String.fromCharCode(o), e.delimiters.push({
+            marker: o,
+            length: s.length,
+            token: e.tokens.length - 1,
+            end: -1,
+            open: s.can_open,
+            close: s.can_close
+        })
+    }
+    return e.pos += s.length, !0
+}
+
+function Zs(e, r) {
+    let i = r.length;
+    for (let o = i - 1; o >= 0; o--) {
+        let s = r[o];
+        if (s.marker !== 95 && s.marker !== 42 || s.end === -1) continue;
+        let l = r[s.end],
+            h = o > 0 && r[o - 1].end === s.end + 1 && r[o - 1].marker === s.marker && r[o - 1].token === s.token - 1 && r[s.end + 1].token === l.token + 1,
+            p = String.fromCharCode(s.marker),
+            b = e.tokens[s.token];
+        b.type = h ? "strong_open" : "em_open", b.tag = h ? "strong" : "em", b.nesting = 1, b.markup = h ? p + p : p, b.content = "";
+        let x = e.tokens[l.token];
+        x.type = h ? "strong_close" : "em_close", x.tag = h ? "strong" : "em", x.nesting = -1, x.markup = h ? p + p : p, x.content = "", h && (e.tokens[r[o - 1].token].content = "", e.tokens[r[s.end + 1].token].content = "", o--)
+    }
+}
+
+function Mh(e) {
+    let r = e.tokens_meta,
+        i = e.tokens_meta.length;
+    Zs(e, e.delimiters);
+    for (let o = 0; o < i; o++) r[o] && r[o].delimiters && Zs(e, r[o].delimiters)
+}
+var ci = {
+    tokenize: Eh,
+    postProcess: Mh
+};
+
+function di(e, r) {
+    let i, o, s, l, h = "",
+        p = "",
+        b = e.pos,
+        x = !0;
+    if (e.src.charCodeAt(e.pos) !== 91) return !1;
+    let C = e.pos,
+        k = e.posMax,
+        F = e.pos + 1,
+        E = e.md.helpers.parseLinkLabel(e, e.pos, !0);
+    if (E < 0) return !1;
+    let M = E + 1;
+    if (M < k && e.src.charCodeAt(M) === 40) {
+        for (x = !1, M++; M < k && (i = e.src.charCodeAt(M), !(!me(i) && i !== 10)); M++);
+        if (M >= k) return !1;
+        if (b = M, s = e.md.helpers.parseLinkDestination(e.src, M, e.posMax), s.ok) {
+            for (h = e.md.normalizeLink(s.str), e.md.validateLink(h) ? M = s.pos : h = "", b = M; M < k && (i = e.src.charCodeAt(M), !(!me(i) && i !== 10)); M++);
+            if (s = e.md.helpers.parseLinkTitle(e.src, M, e.posMax), M < k && b !== M && s.ok)
+                for (p = s.str, M = s.pos; M < k && (i = e.src.charCodeAt(M), !(!me(i) && i !== 10)); M++);
+        }(M >= k || e.src.charCodeAt(M) !== 41) && (x = !0), M++
+    }
+    if (x) {
+        if (typeof e.env.references > "u") return !1;
+        if (M < k && e.src.charCodeAt(M) === 91 ? (b = M + 1, M = e.md.helpers.parseLinkLabel(e, M), M >= 0 ? o = e.src.slice(b, M++) : M = E + 1) : M = E + 1, o || (o = e.src.slice(F, E)), l = e.env.references[p0(o)], !l) return e.pos = C, !1;
+        h = l.href, p = l.title
+    }
+    if (!r) {
+        e.pos = F, e.posMax = E;
+        let N = e.push("link_open", "a", 1),
+            G = [
+                ["href", h]
+            ];
+        N.attrs = G, p && G.push(["title", p]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, e.push("link_close", "a", -1)
+    }
+    return e.pos = M, e.posMax = k, !0
+}
+
+function hi(e, r) {
+    let i, o, s, l, h, p, b, x, C = "",
+        k = e.pos,
+        F = e.posMax;
+    if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91) return !1;
+    let E = e.pos + 2,
+        M = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1);
+    if (M < 0) return !1;
+    if (l = M + 1, l < F && e.src.charCodeAt(l) === 40) {
+        for (l++; l < F && (i = e.src.charCodeAt(l), !(!me(i) && i !== 10)); l++);
+        if (l >= F) return !1;
+        for (x = l, p = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), p.ok && (C = e.md.normalizeLink(p.str), e.md.validateLink(C) ? l = p.pos : C = ""), x = l; l < F && (i = e.src.charCodeAt(l), !(!me(i) && i !== 10)); l++);
+        if (p = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < F && x !== l && p.ok)
+            for (b = p.str, l = p.pos; l < F && (i = e.src.charCodeAt(l), !(!me(i) && i !== 10)); l++);
+        else b = "";
+        if (l >= F || e.src.charCodeAt(l) !== 41) return e.pos = k, !1;
+        l++
+    } else {
+        if (typeof e.env.references > "u") return !1;
+        if (l < F && e.src.charCodeAt(l) === 91 ? (x = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? s = e.src.slice(x, l++) : l = M + 1) : l = M + 1, s || (s = e.src.slice(E, M)), h = e.env.references[p0(s)], !h) return e.pos = k, !1;
+        C = h.href, b = h.title
+    }
+    if (!r) {
+        o = e.src.slice(E, M);
+        let N = [];
+        e.md.inline.parse(o, e.md, e.env, N);
+        let G = e.push("image", "img", 0),
+            U = [
+                ["src", C],
+                ["alt", ""]
+            ];
+        G.attrs = U, G.children = N, G.content = o, b && U.push(["title", b])
+    }
+    return e.pos = l, e.posMax = F, !0
+}
+var qh = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/,
+    Fh = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
+
+function fi(e, r) {
+    let i = e.pos;
+    if (e.src.charCodeAt(i) !== 60) return !1;
+    let o = e.pos,
+        s = e.posMax;
+    for (;;) {
+        if (++i >= s) return !1;
+        let h = e.src.charCodeAt(i);
+        if (h === 60) return !1;
+        if (h === 62) break
+    }
+    let l = e.src.slice(o + 1, i);
+    if (Fh.test(l)) {
+        let h = e.md.normalizeLink(l);
+        if (!e.md.validateLink(h)) return !1;
+        if (!r) {
+            let p = e.push("link_open", "a", 1);
+            p.attrs = [
+                ["href", h]
+            ], p.markup = "autolink", p.info = "auto";
+            let b = e.push("text", "", 0);
+            b.content = e.md.normalizeLinkText(l);
+            let x = e.push("link_close", "a", -1);
+            x.markup = "autolink", x.info = "auto"
+        }
+        return e.pos += l.length + 2, !0
+    }
+    if (qh.test(l)) {
+        let h = e.md.normalizeLink("mailto:" + l);
+        if (!e.md.validateLink(h)) return !1;
+        if (!r) {
+            let p = e.push("link_open", "a", 1);
+            p.attrs = [
+                ["href", h]
+            ], p.markup = "autolink", p.info = "auto";
+            let b = e.push("text", "", 0);
+            b.content = e.md.normalizeLinkText(l);
+            let x = e.push("link_close", "a", -1);
+            x.markup = "autolink", x.info = "auto"
+        }
+        return e.pos += l.length + 2, !0
+    }
+    return !1
+}
+
+function zh(e) {
+    return /^<a[>\s]/i.test(e)
+}
+
+function Rh(e) {
+    return /^<\/a\s*>/i.test(e)
+}
+
+function Bh(e) {
+    let r = e | 32;
+    return r >= 97 && r <= 122
+}
+
+function mi(e, r) {
+    if (!e.md.options.html) return !1;
+    let i = e.posMax,
+        o = e.pos;
+    if (e.src.charCodeAt(o) !== 60 || o + 2 >= i) return !1;
+    let s = e.src.charCodeAt(o + 1);
+    if (s !== 33 && s !== 63 && s !== 47 && !Bh(s)) return !1;
+    let l = e.src.slice(o).match(Vs);
+    if (!l) return !1;
+    if (!r) {
+        let h = e.push("html_inline", "", 0);
+        h.content = l[0], zh(h.content) && e.linkLevel++, Rh(h.content) && e.linkLevel--
+    }
+    return e.pos += l[0].length, !0
+}
+var Nh = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i,
+    Lh = /^&([a-z][a-z0-9]{1,31});/i;
+
+function pi(e, r) {
+    let i = e.pos,
+        o = e.posMax;
+    if (e.src.charCodeAt(i) !== 38 || i + 1 >= o) return !1;
+    if (e.src.charCodeAt(i + 1) === 35) {
+        let l = e.src.slice(i).match(Nh);
+        if (l) {
+            if (!r) {
+                let h = l[1][0].toLowerCase() === "x" ? parseInt(l[1].slice(1), 16) : parseInt(l[1], 10),
+                    p = e.push("text_special", "", 0);
+                p.content = Kr(h) ? X0(h) : X0(65533), p.markup = l[0], p.info = "entity"
+            }
+            return e.pos += l[0].length, !0
+        }
+    } else {
+        let l = e.src.slice(i).match(Lh);
+        if (l) {
+            let h = n0(l[0]);
+            if (h !== l[0]) {
+                if (!r) {
+                    let p = e.push("text_special", "", 0);
+                    p.content = h, p.markup = l[0], p.info = "entity"
+                }
+                return e.pos += l[0].length, !0
+            }
+        }
+    }
+    return !1
+}
+
+function Xs(e) {
+    let r = {},
+        i = e.length;
+    if (!i) return;
+    let o = 0,
+        s = -2,
+        l = [];
+    for (let h = 0; h < i; h++) {
+        let p = e[h];
+        if (l.push(0), (e[o].marker !== p.marker || s !== p.token - 1) && (o = h), s = p.token, p.length = p.length || 0, !p.close) continue;
+        r.hasOwnProperty(p.marker) || (r[p.marker] = [-1, -1, -1, -1, -1, -1]);
+        let b = r[p.marker][(p.open ? 3 : 0) + p.length % 3],
+            x = o - l[o] - 1,
+            C = x;
+        for (; x > b; x -= l[x] + 1) {
+            let k = e[x];
+            if (k.marker === p.marker && k.open && k.end < 0) {
+                let F = !1;
+                if ((k.close || p.open) && (k.length + p.length) % 3 === 0 && (k.length % 3 !== 0 || p.length % 3 !== 0) && (F = !0), !F) {
+                    let E = x > 0 && !e[x - 1].open ? l[x - 1] + 1 : 0;
+                    l[h] = h - x + E, l[x] = E, p.open = !1, k.end = h, k.close = !1, C = -1, s = -2;
+                    break
+                }
+            }
+        }
+        C !== -1 && (r[p.marker][(p.open ? 3 : 0) + (p.length || 0) % 3] = C)
+    }
+}
+
+function bi(e) {
+    let r = e.tokens_meta,
+        i = e.tokens_meta.length;
+    Xs(e.delimiters);
+    for (let o = 0; o < i; o++) r[o] && r[o].delimiters && Xs(r[o].delimiters)
+}
+
+function gi(e) {
+    let r, i, o = 0,
+        s = e.tokens,
+        l = e.tokens.length;
+    for (r = i = 0; r < l; r++) s[r].nesting < 0 && o--, s[r].level = o, s[r].nesting > 0 && o++, s[r].type === "text" && r + 1 < l && s[r + 1].type === "text" ? s[r + 1].content = s[r].content + s[r + 1].content : (r !== i && (s[i] = s[r]), i++);
+    r !== i && (s.length = i)
+}
+var xi = [
+        ["text", ni],
+        ["linkify", ui],
+        ["newline", ii],
+        ["escape", ai],
+        ["backticks", si],
+        ["strikethrough", li.tokenize],
+        ["emphasis", ci.tokenize],
+        ["link", di],
+        ["image", hi],
+        ["autolink", fi],
+        ["html_inline", mi],
+        ["entity", pi]
+    ],
+    yi = [
+        ["balance_pairs", bi],
+        ["strikethrough", li.postProcess],
+        ["emphasis", ci.postProcess],
+        ["fragments_join", gi]
+    ];
+
+function J0() {
+    this.ruler = new b0;
+    for (let e = 0; e < xi.length; e++) this.ruler.push(xi[e][0], xi[e][1]);
+    this.ruler2 = new b0;
+    for (let e = 0; e < yi.length; e++) this.ruler2.push(yi[e][0], yi[e][1])
+}
+J0.prototype.skipToken = function(e) {
+    let r = e.pos,
+        i = this.ruler.getRules(""),
+        o = i.length,
+        s = e.md.options.maxNesting,
+        l = e.cache;
+    if (typeof l[r] < "u") {
+        e.pos = l[r];
+        return
+    }
+    let h = !1;
+    if (e.level < s) {
+        for (let p = 0; p < o; p++)
+            if (e.level++, h = i[p](e, !0), e.level--, h) {
+                if (r >= e.pos) throw new Error("inline rule didn't increment state.pos");
+                break
+            }
+    } else e.pos = e.posMax;
+    h || e.pos++, l[r] = e.pos
+};
+J0.prototype.tokenize = function(e) {
+    let r = this.ruler.getRules(""),
+        i = r.length,
+        o = e.posMax,
+        s = e.md.options.maxNesting;
+    for (; e.pos < o;) {
+        let l = e.pos,
+            h = !1;
+        if (e.level < s) {
+            for (let p = 0; p < i; p++)
+                if (h = r[p](e, !1), h) {
+                    if (l >= e.pos) throw new Error("inline rule didn't increment state.pos");
+                    break
+                }
+        }
+        if (h) {
+            if (e.pos >= o) break;
+            continue
+        }
+        e.pending += e.src[e.pos++]
+    }
+    e.pending && e.pushPending()
+};
+J0.prototype.parse = function(e, r, i, o) {
+    let s = new this.State(e, r, i, o);
+    this.tokenize(s);
+    let l = this.ruler2.getRules(""),
+        h = l.length;
+    for (let p = 0; p < h; p++) l[p](s)
+};
+J0.prototype.State = Ws;
+var Qs = J0;
+
+function Js(e) {
+    let r = {};
+    e = e || {}, r.src_Any = jr.source, r.src_Cc = Wr.source, r.src_Z = Zr.source, r.src_P = S0.source, r.src_ZPCc = [r.src_Z, r.src_P, r.src_Cc].join("|"), r.src_ZCc = [r.src_Z, r.src_Cc].join("|");
+    let i = "[><\uFF5C]";
+    return r.src_pseudo_letter = "(?:(?!" + i + "|" + r.src_ZPCc + ")" + r.src_Any + ")", r.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", r.src_auth = "(?:(?:(?!" + r.src_ZCc + "|[@/\\[\\]()]).)+@)?", r.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", r.src_host_terminator = "(?=$|" + i + "|" + r.src_ZPCc + ")(?!" + (e["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + r.src_ZPCc + "))", r.src_path = "(?:[/?#](?:(?!" + r.src_ZCc + "|" + i + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + r.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + r.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + r.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + r.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + r.src_ZCc + "|[']).)+\\'|\\'(?=" + r.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + r.src_ZCc + "|[.]|$)|" + (e["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + r.src_ZCc + "|$)|;(?!" + r.src_ZCc + "|$)|\\!+(?!" + r.src_ZCc + "|[!]|$)|\\?(?!" + r.src_ZCc + "|[?]|$))+|\\/)?", r.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', r.src_xn = "xn--[a-z0-9\\-]{1,59}", r.src_domain_root = "(?:" + r.src_xn + "|" + r.src_pseudo_letter + "{1,63})", r.src_domain = "(?:" + r.src_xn + "|(?:" + r.src_pseudo_letter + ")|(?:" + r.src_pseudo_letter + "(?:-|" + r.src_pseudo_letter + "){0,61}" + r.src_pseudo_letter + "))", r.src_host = "(?:(?:(?:(?:" + r.src_domain + ")\\.)*" + r.src_domain + "))", r.tpl_host_fuzzy = "(?:" + r.src_ip4 + "|(?:(?:(?:" + r.src_domain + ")\\.)+(?:%TLDS%)))", r.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + r.src_domain + ")\\.)+(?:%TLDS%))", r.src_host_strict = r.src_host + r.src_host_terminator, r.tpl_host_fuzzy_strict = r.tpl_host_fuzzy + r.src_host_terminator, r.src_host_port_strict = r.src_host + r.src_port + r.src_host_terminator, r.tpl_host_port_fuzzy_strict = r.tpl_host_fuzzy + r.src_port + r.src_host_terminator, r.tpl_host_port_no_ip_fuzzy_strict = r.tpl_host_no_ip_fuzzy + r.src_port + r.src_host_terminator, r.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + r.src_ZPCc + "|>|$))", r.tpl_email_fuzzy = "(^|" + i + '|"|\\(|' + r.src_ZCc + ")(" + r.src_email_name + "@" + r.tpl_host_fuzzy_strict + ")", r.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + r.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + r.tpl_host_port_fuzzy_strict + r.src_path + ")", r.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + r.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + r.tpl_host_port_no_ip_fuzzy_strict + r.src_path + ")", r
+}
+
+function vi(e) {
+    return Array.prototype.slice.call(arguments, 1).forEach(function(i) {
+        i && Object.keys(i).forEach(function(o) {
+            e[o] = i[o]
+        })
+    }), e
+}
+
+function un(e) {
+    return Object.prototype.toString.call(e)
+}
+
+function Ph(e) {
+    return un(e) === "[object String]"
+}
+
+function Ih(e) {
+    return un(e) === "[object Object]"
+}
+
+function Oh(e) {
+    return un(e) === "[object RegExp]"
+}
+
+function Ks(e) {
+    return un(e) === "[object Function]"
+}
+
+function Hh(e) {
+    return e.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
+}
+var tl = {
+    fuzzyLink: !0,
+    fuzzyEmail: !0,
+    fuzzyIP: !1
+};
+
+function $h(e) {
+    return Object.keys(e || {}).reduce(function(r, i) {
+        return r || tl.hasOwnProperty(i)
+    }, !1)
+}
+var Gh = {
+        "http:": {
+            validate: function(e, r, i) {
+                let o = e.slice(r);
+                return i.re.http || (i.re.http = new RegExp("^\\/\\/" + i.re.src_auth + i.re.src_host_port_strict + i.re.src_path, "i")), i.re.http.test(o) ? o.match(i.re.http)[0].length : 0
+            }
+        },
+        "https:": "http:",
+        "ftp:": "http:",
+        "//": {
+            validate: function(e, r, i) {
+                let o = e.slice(r);
+                return i.re.no_http || (i.re.no_http = new RegExp("^" + i.re.src_auth + "(?:localhost|(?:(?:" + i.re.src_domain + ")\\.)+" + i.re.src_domain_root + ")" + i.re.src_port + i.re.src_host_terminator + i.re.src_path, "i")), i.re.no_http.test(o) ? r >= 3 && e[r - 3] === ":" || r >= 3 && e[r - 3] === "/" ? 0 : o.match(i.re.no_http)[0].length : 0
+            }
+        },
+        "mailto:": {
+            validate: function(e, r, i) {
+                let o = e.slice(r);
+                return i.re.mailto || (i.re.mailto = new RegExp("^" + i.re.src_email_name + "@" + i.re.src_host_strict, "i")), i.re.mailto.test(o) ? o.match(i.re.mailto)[0].length : 0
+            }
+        }
+    },
+    Vh = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",
+    Uh = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
+
+function jh(e) {
+    e.__index__ = -1, e.__text_cache__ = ""
+}
+
+function Wh(e) {
+    return function(r, i) {
+        let o = r.slice(i);
+        return e.test(o) ? o.match(e)[0].length : 0
+    }
+}
+
+function el() {
+    return function(e, r) {
+        r.normalize(e)
+    }
+}
+
+function nn(e) {
+    let r = e.re = Js(e.__opts__),
+        i = e.__tlds__.slice();
+    e.onCompile(), e.__tlds_replaced__ || i.push(Vh), i.push(r.src_xn), r.src_tlds = i.join("|");
+
+    function o(p) {
+        return p.replace("%TLDS%", r.src_tlds)
+    }
+    r.email_fuzzy = RegExp(o(r.tpl_email_fuzzy), "i"), r.link_fuzzy = RegExp(o(r.tpl_link_fuzzy), "i"), r.link_no_ip_fuzzy = RegExp(o(r.tpl_link_no_ip_fuzzy), "i"), r.host_fuzzy_test = RegExp(o(r.tpl_host_fuzzy_test), "i");
+    let s = [];
+    e.__compiled__ = {};
+
+    function l(p, b) {
+        throw new Error('(LinkifyIt) Invalid schema "' + p + '": ' + b)
+    }
+    Object.keys(e.__schemas__).forEach(function(p) {
+        let b = e.__schemas__[p];
+        if (b === null) return;
+        let x = {
+            validate: null,
+            link: null
+        };
+        if (e.__compiled__[p] = x, Ih(b)) {
+            Oh(b.validate) ? x.validate = Wh(b.validate) : Ks(b.validate) ? x.validate = b.validate : l(p, b), Ks(b.normalize) ? x.normalize = b.normalize : b.normalize ? l(p, b) : x.normalize = el();
+            return
+        }
+        if (Ph(b)) {
+            s.push(p);
+            return
+        }
+        l(p, b)
+    }), s.forEach(function(p) {
+        e.__compiled__[e.__schemas__[p]] && (e.__compiled__[p].validate = e.__compiled__[e.__schemas__[p]].validate, e.__compiled__[p].normalize = e.__compiled__[e.__schemas__[p]].normalize)
+    }), e.__compiled__[""] = {
+        validate: null,
+        normalize: el()
+    };
+    let h = Object.keys(e.__compiled__).filter(function(p) {
+        return p.length > 0 && e.__compiled__[p]
+    }).map(Hh).join("|");
+    e.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + r.src_ZPCc + "))(" + h + ")", "i"), e.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + r.src_ZPCc + "))(" + h + ")", "ig"), e.re.schema_at_start = RegExp("^" + e.re.schema_search.source, "i"), e.re.pretest = RegExp("(" + e.re.schema_test.source + ")|(" + e.re.host_fuzzy_test.source + ")|@", "i"), jh(e)
+}
+
+function Yh(e, r) {
+    let i = e.__index__,
+        o = e.__last_index__,
+        s = e.__text_cache__.slice(i, o);
+    this.schema = e.__schema__.toLowerCase(), this.index = i + r, this.lastIndex = o + r, this.raw = s, this.text = s, this.url = s
+}
+
+function wi(e, r) {
+    let i = new Yh(e, r);
+    return e.__compiled__[i.schema].normalize(i, e), i
+}
+
+function lt(e, r) {
+    if (!(this instanceof lt)) return new lt(e, r);
+    r || $h(e) && (r = e, e = {}), this.__opts__ = vi({}, tl, r), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = vi({}, Gh, e), this.__compiled__ = {}, this.__tlds__ = Uh, this.__tlds_replaced__ = !1, this.re = {}, nn(this)
+}
+lt.prototype.add = function(r, i) {
+    return this.__schemas__[r] = i, nn(this), this
+};
+lt.prototype.set = function(r) {
+    return this.__opts__ = vi(this.__opts__, r), this
+};
+lt.prototype.test = function(r) {
+    if (this.__text_cache__ = r, this.__index__ = -1, !r.length) return !1;
+    let i, o, s, l, h, p, b, x, C;
+    if (this.re.schema_test.test(r)) {
+        for (b = this.re.schema_search, b.lastIndex = 0;
+            (i = b.exec(r)) !== null;)
+            if (l = this.testSchemaAt(r, i[2], b.lastIndex), l) {
+                this.__schema__ = i[2], this.__index__ = i.index + i[1].length, this.__last_index__ = i.index + i[0].length + l;
+                break
+            }
+    }
+    return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (x = r.search(this.re.host_fuzzy_test), x >= 0 && (this.__index__ < 0 || x < this.__index__) && (o = r.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (h = o.index + o[1].length, (this.__index__ < 0 || h < this.__index__) && (this.__schema__ = "", this.__index__ = h, this.__last_index__ = o.index + o[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (C = r.indexOf("@"), C >= 0 && (s = r.match(this.re.email_fuzzy)) !== null && (h = s.index + s[1].length, p = s.index + s[0].length, (this.__index__ < 0 || h < this.__index__ || h === this.__index__ && p > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = h, this.__last_index__ = p))), this.__index__ >= 0
+};
+lt.prototype.pretest = function(r) {
+    return this.re.pretest.test(r)
+};
+lt.prototype.testSchemaAt = function(r, i, o) {
+    return this.__compiled__[i.toLowerCase()] ? this.__compiled__[i.toLowerCase()].validate(r, o, this) : 0
+};
+lt.prototype.match = function(r) {
+    let i = [],
+        o = 0;
+    this.__index__ >= 0 && this.__text_cache__ === r && (i.push(wi(this, o)), o = this.__last_index__);
+    let s = o ? r.slice(o) : r;
+    for (; this.test(s);) i.push(wi(this, o)), s = s.slice(this.__last_index__), o += this.__last_index__;
+    return i.length ? i : null
+};
+lt.prototype.matchAtStart = function(r) {
+    if (this.__text_cache__ = r, this.__index__ = -1, !r.length) return null;
+    let i = this.re.schema_at_start.exec(r);
+    if (!i) return null;
+    let o = this.testSchemaAt(r, i[2], i[0].length);
+    return o ? (this.__schema__ = i[2], this.__index__ = i.index + i[1].length, this.__last_index__ = i.index + i[0].length + o, wi(this, 0)) : null
+};
+lt.prototype.tlds = function(r, i) {
+    return r = Array.isArray(r) ? r : [r], i ? (this.__tlds__ = this.__tlds__.concat(r).sort().filter(function(o, s, l) {
+        return o !== l[s - 1]
+    }).reverse(), nn(this), this) : (this.__tlds__ = r.slice(), this.__tlds_replaced__ = !0, nn(this), this)
+};
+lt.prototype.normalize = function(r) {
+    r.schema || (r.url = "http://" + r.url), r.schema === "mailto:" && !/^mailto:/i.test(r.url) && (r.url = "mailto:" + r.url)
+};
+lt.prototype.onCompile = function() {};
+var rl = lt;
+var ul = "-",
+    Zh = /^xn--/,
+    Xh = /[^\0-\x7F]/,
+    Qh = /[\x2E\u3002\uFF0E\uFF61]/g,
+    Jh = {
+        overflow: "Overflow: input needs wider integers to process",
+        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
+        "invalid-input": "Invalid input"
+    },
+    ki = 35,
+    Et = Math.floor,
+    _i = String.fromCharCode;
+
+function u0(e) {
+    throw new RangeError(Jh[e])
+}
+
+function Kh(e, r) {
+    let i = [],
+        o = e.length;
+    for (; o--;) i[o] = r(e[o]);
+    return i
+}
+
+function il(e, r) {
+    let i = e.split("@"),
+        o = "";
+    i.length > 1 && (o = i[0] + "@", e = i[1]), e = e.replace(Qh, ".");
+    let s = e.split("."),
+        l = Kh(s, r).join(".");
+    return o + l
+}
+
+function ol(e) {
+    let r = [],
+        i = 0,
+        o = e.length;
+    for (; i < o;) {
+        let s = e.charCodeAt(i++);
+        if (s >= 55296 && s <= 56319 && i < o) {
+            let l = e.charCodeAt(i++);
+            (l & 64512) == 56320 ? r.push(((s & 1023) << 10) + (l & 1023) + 65536) : (r.push(s), i--)
+        } else r.push(s)
+    }
+    return r
+}
+var e2 = e => String.fromCodePoint(...e),
+    t2 = function(e) {
+        return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : 36
+    },
+    nl = function(e, r) {
+        return e + 22 + 75 * (e < 26) - ((r != 0) << 5)
+    },
+    al = function(e, r, i) {
+        let o = 0;
+        for (e = i ? Et(e / 700) : e >> 1, e += Et(e / r); e > ki * 26 >> 1; o += 36) e = Et(e / ki);
+        return Et(o + (ki + 1) * e / (e + 38))
+    },
+    sl = function(e) {
+        let r = [],
+            i = e.length,
+            o = 0,
+            s = 128,
+            l = 72,
+            h = e.lastIndexOf(ul);
+        h < 0 && (h = 0);
+        for (let p = 0; p < h; ++p) e.charCodeAt(p) >= 128 && u0("not-basic"), r.push(e.charCodeAt(p));
+        for (let p = h > 0 ? h + 1 : 0; p < i;) {
+            let b = o;
+            for (let C = 1, k = 36;; k += 36) {
+                p >= i && u0("invalid-input");
+                let F = t2(e.charCodeAt(p++));
+                F >= 36 && u0("invalid-input"), F > Et((2147483647 - o) / C) && u0("overflow"), o += F * C;
+                let E = k <= l ? 1 : k >= l + 26 ? 26 : k - l;
+                if (F < E) break;
+                let M = 36 - E;
+                C > Et(2147483647 / M) && u0("overflow"), C *= M
+            }
+            let x = r.length + 1;
+            l = al(o - b, x, b == 0), Et(o / x) > 2147483647 - s && u0("overflow"), s += Et(o / x), o %= x, r.splice(o++, 0, s)
+        }
+        return String.fromCodePoint(...r)
+    },
+    ll = function(e) {
+        let r = [];
+        e = ol(e);
+        let i = e.length,
+            o = 128,
+            s = 0,
+            l = 72;
+        for (let b of e) b < 128 && r.push(_i(b));
+        let h = r.length,
+            p = h;
+        for (h && r.push(ul); p < i;) {
+            let b = 2147483647;
+            for (let C of e) C >= o && C < b && (b = C);
+            let x = p + 1;
+            b - o > Et((2147483647 - s) / x) && u0("overflow"), s += (b - o) * x, o = b;
+            for (let C of e)
+                if (C < o && ++s > 2147483647 && u0("overflow"), C === o) {
+                    let k = s;
+                    for (let F = 36;; F += 36) {
+                        let E = F <= l ? 1 : F >= l + 26 ? 26 : F - l;
+                        if (k < E) break;
+                        let M = k - E,
+                            N = 36 - E;
+                        r.push(_i(nl(E + M % N, 0))), k = Et(M / N)
+                    }
+                    r.push(_i(nl(k, 0))), l = al(s, x, p === h), s = 0, ++p
+                }++ s, ++o
+        }
+        return r.join("")
+    },
+    r2 = function(e) {
+        return il(e, function(r) {
+            return Zh.test(r) ? sl(r.slice(4).toLowerCase()) : r
+        })
+    },
+    n2 = function(e) {
+        return il(e, function(r) {
+            return Xh.test(r) ? "xn--" + ll(r) : r
+        })
+    },
+    u2 = {
+        version: "2.3.1",
+        ucs2: {
+            decode: ol,
+            encode: e2
+        },
+        decode: sl,
+        encode: ll,
+        toASCII: n2,
+        toUnicode: r2
+    };
+var Ci = u2;
+var cl = {
+    options: {
+        html: !1,
+        xhtmlOut: !1,
+        breaks: !1,
+        langPrefix: "language-",
+        linkify: !1,
+        typographer: !1,
+        quotes: "\u201C\u201D\u2018\u2019",
+        highlight: null,
+        maxNesting: 100
+    },
+    components: {
+        core: {},
+        block: {},
+        inline: {}
+    }
+};
+var dl = {
+    options: {
+        html: !1,
+        xhtmlOut: !1,
+        breaks: !1,
+        langPrefix: "language-",
+        linkify: !1,
+        typographer: !1,
+        quotes: "\u201C\u201D\u2018\u2019",
+        highlight: null,
+        maxNesting: 20
+    },
+    components: {
+        core: {
+            rules: ["normalize", "block", "inline", "text_join"]
+        },
+        block: {
+            rules: ["paragraph"]
+        },
+        inline: {
+            rules: ["text"],
+            rules2: ["balance_pairs", "fragments_join"]
+        }
+    }
+};
+var hl = {
+    options: {
+        html: !0,
+        xhtmlOut: !0,
+        breaks: !1,
+        langPrefix: "language-",
+        linkify: !1,
+        typographer: !1,
+        quotes: "\u201C\u201D\u2018\u2019",
+        highlight: null,
+        maxNesting: 20
+    },
+    components: {
+        core: {
+            rules: ["normalize", "block", "inline", "text_join"]
+        },
+        block: {
+            rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"]
+        },
+        inline: {
+            rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"],
+            rules2: ["balance_pairs", "emphasis", "fragments_join"]
+        }
+    }
+};
+var i2 = {
+        default: cl,
+        zero: dl,
+        commonmark: hl
+    },
+    o2 = /^(vbscript|javascript|file|data):/,
+    a2 = /^data:image\/(gif|png|jpeg|webp);/;
+
+function s2(e) {
+    let r = e.trim().toLowerCase();
+    return o2.test(r) ? a2.test(r) : !0
+}
+var fl = ["http:", "https:", "mailto:"];
+
+function l2(e) {
+    let r = Z0(e, !0);
+    if (r.hostname && (!r.protocol || fl.indexOf(r.protocol) >= 0)) try {
+        r.hostname = Ci.toASCII(r.hostname)
+    } catch {}
+    return Gr(C0(r))
+}
+
+function c2(e) {
+    let r = Z0(e, !0);
+    if (r.hostname && (!r.protocol || fl.indexOf(r.protocol) >= 0)) try {
+        r.hostname = Ci.toUnicode(r.hostname)
+    } catch {}
+    return Y0(C0(r), Y0.defaultChars + "%")
+}
+
+function xt(e, r) {
+    if (!(this instanceof xt)) return new xt(e, r);
+    r || Jr(e) || (r = e || {}, e = "default"), this.inline = new Qs, this.block = new js, this.core = new Ns, this.renderer = new Ms, this.linkify = new rl, this.validateLink = s2, this.normalizeLink = l2, this.normalizeLinkText = c2, this.utils = qu, this.helpers = A0({}, Bu), this.options = {}, this.configure(e), r && this.set(r)
+}
+xt.prototype.set = function(e) {
+    return A0(this.options, e), this
+};
+xt.prototype.configure = function(e) {
+    let r = this;
+    if (Jr(e)) {
+        let i = e;
+        if (e = i2[i], !e) throw new Error('Wrong `markdown-it` preset "' + i + '", check name')
+    }
+    if (!e) throw new Error("Wrong `markdown-it` preset, can't be empty");
+    return e.options && r.set(e.options), e.components && Object.keys(e.components).forEach(function(i) {
+        e.components[i].rules && r[i].ruler.enableOnly(e.components[i].rules), e.components[i].rules2 && r[i].ruler2.enableOnly(e.components[i].rules2)
+    }), this
+};
+xt.prototype.enable = function(e, r) {
+    let i = [];
+    Array.isArray(e) || (e = [e]), ["core", "block", "inline"].forEach(function(s) {
+        i = i.concat(this[s].ruler.enable(e, !0))
+    }, this), i = i.concat(this.inline.ruler2.enable(e, !0));
+    let o = e.filter(function(s) {
+        return i.indexOf(s) < 0
+    });
+    if (o.length && !r) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + o);
+    return this
+};
+xt.prototype.disable = function(e, r) {
+    let i = [];
+    Array.isArray(e) || (e = [e]), ["core", "block", "inline"].forEach(function(s) {
+        i = i.concat(this[s].ruler.disable(e, !0))
+    }, this), i = i.concat(this.inline.ruler2.disable(e, !0));
+    let o = e.filter(function(s) {
+        return i.indexOf(s) < 0
+    });
+    if (o.length && !r) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + o);
+    return this
+};
+xt.prototype.use = function(e) {
+    let r = [this].concat(Array.prototype.slice.call(arguments, 1));
+    return e.apply(e, r), this
+};
+xt.prototype.parse = function(e, r) {
+    if (typeof e != "string") throw new Error("Input data should be a String");
+    let i = new this.core.State(e, this, r);
+    return this.core.process(i), i.tokens
+};
+xt.prototype.render = function(e, r) {
+    return r = r || {}, this.renderer.render(this.parse(e, r), this.options, r)
+};
+xt.prototype.parseInline = function(e, r) {
+    let i = new this.core.State(e, this, r);
+    return i.inlineMode = !0, this.core.process(i), i.tokens
+};
+xt.prototype.renderInline = function(e, r) {
+    return r = r || {}, this.renderer.render(this.parseInline(e, r), this.options, r)
+};
+var Si = xt;
+var kl = ea(wl());
+var _l = Si();
+_l.use(kl.default);
+
+function Cl(e) {
+    return _l.render(e.replace(/\\\\/g, "\\"))
 }
 
-function u5({
-    model: r,
-    el: e
+function P6({
+    model: e,
+    el: r
 }) {
-    let i = r.get("comp");
+    let i = e.get("comp");
     switch (i) {
         case "SpaceChart":
-            Wp({
-                model: r,
-                el: e
+            y2({
+                model: e,
+                el: r
             });
             break;
         case "EstimatesOverview":
-            Yp({
-                model: r,
-                el: e
+            v2({
+                model: e,
+                el: r
             });
             break;
         case "EstimateDetails":
-            Up({
-                model: r,
-                el: e
+            x2({
+                model: e,
+                el: r
             });
             break;
         case "Histogram":
-            Qp({
-                model: r,
-                el: e
+            k2({
+                model: e,
+                el: r
             });
             break;
         case "EstimatesPanel":
-            Zp({
-                model: r,
-                el: e
+            w2({
+                model: e,
+                el: r
             });
             break;
         case "Circuit":
-            Xp({
-                model: r,
-                el: e
+            _2({
+                model: e,
+                el: r
             });
             break;
         default:
             throw new Error(`Unknown component type ${i}`)
     }
 }
 
-function Up({
-    model: r,
-    el: e
+function x2({
+    model: e,
+    el: r
 }) {
     let i = () => {
-        let a = r.get("estimates"),
-            l = r.get("index"),
-            c = jt(a, l);
-        rr(M(qr, {
-            estimatesData: c,
-            mdRenderer: zu
-        }), e)
+        let o = e.get("estimates"),
+            s = e.get("index"),
+            l = Xt(o, s);
+        l0(T(O0, {
+            estimatesData: l,
+            mdRenderer: Cl
+        }), r)
     };
-    i(), r.on("change:estimates", i), r.on("change:index", i)
+    i(), e.on("change:estimates", i), e.on("change:index", i)
 }
 
-function Wp({
-    model: r,
-    el: e
+function y2({
+    model: e,
+    el: r
 }) {
     let i = () => {
-        let a = r.get("estimates"),
-            l = r.get("index"),
-            c = jt(a, l);
-        rr(M(Mr, {
-            estimatesData: c
-        }), e)
+        let o = e.get("estimates"),
+            s = e.get("index"),
+            l = Xt(o, s);
+        l0(T(H0, {
+            estimatesData: l
+        }), r)
     };
-    i(), r.on("change:estimates", i), r.on("change:index", i)
+    i(), e.on("change:estimates", i), e.on("change:index", i)
 }
 
-function Yp({
-    model: r,
-    el: e
+function v2({
+    model: e,
+    el: r
 }) {
     let i = () => {
-        let a = r.get("estimates"),
-            l = r.get("colors"),
-            c = r.get("runNames"),
-            d = [];
-        if (a[0] == null) d.push(a);
+        let o = e.get("estimates"),
+            s = e.get("colors"),
+            l = e.get("runNames"),
+            h = [];
+        if (o[0] == null) h.push(o);
         else
-            for (let g of Object.values(a)) d.push(g);
-        let f = Ru(d, g => {
-            d = g, r.set("estimates", d)
+            for (let b of Object.values(o)) h.push(b);
+        let p = Sl(h, b => {
+            h = b, e.set("estimates", h)
         });
-        rr(M(Er, {
-            estimatesData: d,
-            runNames: c,
-            colors: l,
+        l0(T($0, {
+            estimatesData: h,
+            runNames: l,
+            colors: s,
             isSimplifiedView: !0,
-            onRowDeleted: f,
+            onRowDeleted: p,
             setEstimate: () => {}
-        }), e)
+        }), r)
     };
-    i(), r.on("change:estimates", i), r.on("change:colors", i), r.on("change:runNames", i)
+    i(), e.on("change:estimates", i), e.on("change:colors", i), e.on("change:runNames", i)
 }
 
-function Zp({
-    model: r,
-    el: e
+function w2({
+    model: e,
+    el: r
 }) {
     let i = () => {
-        let a = r.get("estimates"),
-            l = r.get("colors"),
-            c = r.get("runNames"),
-            d = [];
-        if (a[0] == null) d.push(a);
+        let o = e.get("estimates"),
+            s = e.get("colors"),
+            l = e.get("runNames"),
+            h = [];
+        if (o[0] == null) h.push(o);
         else
-            for (let g of Object.values(a)) d.push(g);
-        let f = Ru(d, g => {
-            d = g, r.set("estimates", d)
+            for (let b of Object.values(o)) h.push(b);
+        let p = Sl(h, b => {
+            h = b, e.set("estimates", h)
         });
-        rr(M(Gn, {
-            estimatesData: d,
-            runNames: c,
-            colors: l,
-            renderer: zu,
+        l0(T(au, {
+            estimatesData: h,
+            runNames: l,
+            colors: s,
+            renderer: Cl,
             calculating: !1,
-            onRowDeleted: f
-        }), e)
+            onRowDeleted: p
+        }), r)
     };
-    i(), r.on("change:estimates", i), r.on("change:colors", i), r.on("change:runNames", i)
+    i(), e.on("change:estimates", i), e.on("change:colors", i), e.on("change:runNames", i)
 }
 
-function Ru(r, e) {
+function Sl(e, r) {
     return i => {
-        let a = JSON.parse(JSON.stringify(r)),
-            l = a.findIndex(c => c.jobParams.runName === i);
-        l >= 0 && a.splice(l, 1), e(a)
+        let o = JSON.parse(JSON.stringify(e)),
+            s = o.findIndex(l => l.jobParams.runName === i);
+        s >= 0 && o.splice(s, 1), r(o)
     }
 }
 
-function Qp({
-    model: r,
-    el: e
+function k2({
+    model: e,
+    el: r
 }) {
     let i = () => {
-        let a = r.get("buckets"),
-            l = new Map(Object.entries(a)),
-            c = r.get("shot_count");
-        rr(M(On, {
-            data: l,
-            shotCount: c,
+        let o = e.get("buckets"),
+            s = new Map(Object.entries(o)),
+            l = e.get("shot_count");
+        l0(T(uu, {
+            data: s,
+            shotCount: l,
             filter: "",
             onFilter: () => {},
             shotsHeader: !0
-        }), e)
+        }), r)
     };
-    i(), r.on("change:buckets", i), r.on("change:shot_count", i)
+    i(), e.on("change:buckets", i), e.on("change:shot_count", i)
 }
 
-function Xp({
-    model: r,
-    el: e
+function _2({
+    model: e,
+    el: r
 }) {
     let i = () => {
-        let a = r.get("circuit_json");
-        rr(M(ii, {
-            circuit: JSON.parse(a)
-        }), e)
+        let o = e.get("circuit_json");
+        l0(T(ku, {
+            circuit: JSON.parse(o)
+        }), r)
     };
-    i(), r.on("change:circuit_json", i)
+    i(), e.on("change:circuit_json", i)
 }
 export {
-    zu as mdRenderer, u5 as render
+    Cl as mdRenderer, P6 as render
 };
```

